(self.webpackChunkpwb_website_base = self.webpackChunkpwb_website_base || []).push([[240], {
    8792: e => {
        "use strict";
        e.exports = function e(t, n) {
            if (t === n)
                return !0;
            if (t && n && "object" == typeof t && "object" == typeof n) {
                if (t.constructor !== n.constructor)
                    return !1;
                var i, r, s;
                if (Array.isArray(t)) {
                    if ((i = t.length) != n.length)
                        return !1;
                    for (r = i; 0 != r--; )
                        if (!e(t[r], n[r]))
                            return !1;
                    return !0
                }
                if (t.constructor === RegExp)
                    return t.source === n.source && t.flags === n.flags;
                if (t.valueOf !== Object.prototype.valueOf)
                    return t.valueOf() === n.valueOf();
                if (t.toString !== Object.prototype.toString)
                    return t.toString() === n.toString();
                if ((i = (s = Object.keys(t)).length) !== Object.keys(n).length)
                    return !1;
                for (r = i; 0 != r--; )
                    if (!Object.prototype.hasOwnProperty.call(n, s[r]))
                        return !1;
                for (r = i; 0 != r--; ) {
                    var a = s[r];
                    if (!e(t[a], n[a]))
                        return !1
                }
                return !0
            }
            return t != t && n != n
        }
    }
    ,
    7629: (e, t, n) => {
        "use strict";
        function i(e) {
            if (void 0 === e)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return e
        }
        function r(e, t) {
            e.prototype = Object.create(t.prototype),
            e.prototype.constructor = e,
            e.__proto__ = t
        }
        n.d(t, {
            Ay: () => Yi
        });
        var s, a, o, l, c, u, h, d, p, f, A, g, m, v, y, x = {
            autoSleep: 120,
            force3D: "auto",
            nullTargetWarn: 1,
            units: {
                lineHeight: ""
            }
        }, _ = {
            duration: .5,
            overwrite: !1,
            delay: 0
        }, b = 1e8, E = 1e-8, w = 2 * Math.PI, C = w / 4, I = 0, S = Math.sqrt, M = Math.cos, T = Math.sin, B = function(e) {
            return "string" == typeof e
        }, R = function(e) {
            return "function" == typeof e
        }, D = function(e) {
            return "number" == typeof e
        }, P = function(e) {
            return void 0 === e
        }, L = function(e) {
            return "object" == typeof e
        }, U = function(e) {
            return !1 !== e
        }, F = function() {
            return "undefined" != typeof window
        }, N = function(e) {
            return R(e) || B(e)
        }, O = "function" == typeof ArrayBuffer && ArrayBuffer.isView || function() {}
        , Q = Array.isArray, k = /(?:-?\.?\d|\.)+/gi, G = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g, H = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g, z = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi, V = /[+-]=-?[.\d]+/, W = /[^,'"\[\]\s]+/gi, j = /^[+\-=e\s\d]*\d+[.\d]*([a-z]*|%)\s*$/i, q = {}, Y = {}, X = function(e) {
            return (Y = we(e, q)) && In
        }, K = function(e, t) {
            return console.warn("Invalid property", e, "set to", t, "Missing plugin? gsap.registerPlugin()")
        }, J = function(e, t) {
            return !t && console.warn(e)
        }, Z = function(e, t) {
            return e && (q[e] = t) && Y && (Y[e] = t) || q
        }, $ = function() {
            return 0
        }, ee = {
            suppressEvents: !0,
            isStart: !0,
            kill: !1
        }, te = {
            suppressEvents: !0,
            kill: !1
        }, ne = {
            suppressEvents: !0
        }, ie = {}, re = [], se = {}, ae = {}, oe = {}, le = 30, ce = [], ue = "", he = function(e) {
            var t, n, i = e[0];
            if (L(i) || R(i) || (e = [e]),
            !(t = (i._gsap || {}).harness)) {
                for (n = ce.length; n-- && !ce[n].targetTest(i); )
                    ;
                t = ce[n]
            }
            for (n = e.length; n--; )
                e[n] && (e[n]._gsap || (e[n]._gsap = new Qt(e[n],t))) || e.splice(n, 1);
            return e
        }, de = function(e) {
            return e._gsap || he(nt(e))[0]._gsap
        }, pe = function(e, t, n) {
            return (n = e[t]) && R(n) ? e[t]() : P(n) && e.getAttribute && e.getAttribute(t) || n
        }, fe = function(e, t) {
            return (e = e.split(",")).forEach(t) || e
        }, Ae = function(e) {
            return Math.round(1e5 * e) / 1e5 || 0
        }, ge = function(e) {
            return Math.round(1e7 * e) / 1e7 || 0
        }, me = function(e, t) {
            var n = t.charAt(0)
              , i = parseFloat(t.substr(2));
            return e = parseFloat(e),
            "+" === n ? e + i : "-" === n ? e - i : "*" === n ? e * i : e / i
        }, ve = function(e, t) {
            for (var n = t.length, i = 0; e.indexOf(t[i]) < 0 && ++i < n; )
                ;
            return i < n
        }, ye = function() {
            var e, t, n = re.length, i = re.slice(0);
            for (se = {},
            re.length = 0,
            e = 0; e < n; e++)
                (t = i[e]) && t._lazy && (t.render(t._lazy[0], t._lazy[1], !0)._lazy = 0)
        }, xe = function(e, t, n, i) {
            re.length && !a && ye(),
            e.render(t, n, i || a && t < 0 && (e._initted || e._startAt)),
            re.length && !a && ye()
        }, _e = function(e) {
            var t = parseFloat(e);
            return (t || 0 === t) && (e + "").match(W).length < 2 ? t : B(e) ? e.trim() : e
        }, be = function(e) {
            return e
        }, Ee = function(e, t) {
            for (var n in t)
                n in e || (e[n] = t[n]);
            return e
        }, we = function(e, t) {
            for (var n in t)
                e[n] = t[n];
            return e
        }, Ce = function e(t, n) {
            for (var i in n)
                "__proto__" !== i && "constructor" !== i && "prototype" !== i && (t[i] = L(n[i]) ? e(t[i] || (t[i] = {}), n[i]) : n[i]);
            return t
        }, Ie = function(e, t) {
            var n, i = {};
            for (n in e)
                n in t || (i[n] = e[n]);
            return i
        }, Se = function(e) {
            var t, n = e.parent || l, i = e.keyframes ? (t = Q(e.keyframes),
            function(e, n) {
                for (var i in n)
                    i in e || "duration" === i && t || "ease" === i || (e[i] = n[i])
            }
            ) : Ee;
            if (U(e.inherit))
                for (; n; )
                    i(e, n.vars.defaults),
                    n = n.parent || n._dp;
            return e
        }, Me = function(e, t, n, i, r) {
            void 0 === n && (n = "_first"),
            void 0 === i && (i = "_last");
            var s, a = e[i];
            if (r)
                for (s = t[r]; a && a[r] > s; )
                    a = a._prev;
            return a ? (t._next = a._next,
            a._next = t) : (t._next = e[n],
            e[n] = t),
            t._next ? t._next._prev = t : e[i] = t,
            t._prev = a,
            t.parent = t._dp = e,
            t
        }, Te = function(e, t, n, i) {
            void 0 === n && (n = "_first"),
            void 0 === i && (i = "_last");
            var r = t._prev
              , s = t._next;
            r ? r._next = s : e[n] === t && (e[n] = s),
            s ? s._prev = r : e[i] === t && (e[i] = r),
            t._next = t._prev = t.parent = null
        }, Be = function(e, t) {
            e.parent && (!t || e.parent.autoRemoveChildren) && e.parent.remove && e.parent.remove(e),
            e._act = 0
        }, Re = function(e, t) {
            if (e && (!t || t._end > e._dur || t._start < 0))
                for (var n = e; n; )
                    n._dirty = 1,
                    n = n.parent;
            return e
        }, De = function(e, t, n, i) {
            return e._startAt && (a ? e._startAt.revert(te) : e.vars.immediateRender && !e.vars.autoRevert || e._startAt.render(t, !0, i))
        }, Pe = function e(t) {
            return !t || t._ts && e(t.parent)
        }, Le = function(e) {
            return e._repeat ? Ue(e._tTime, e = e.duration() + e._rDelay) * e : 0
        }, Ue = function(e, t) {
            var n = Math.floor(e /= t);
            return e && n === e ? n - 1 : n
        }, Fe = function(e, t) {
            return (e - t._start) * t._ts + (t._ts >= 0 ? 0 : t._dirty ? t.totalDuration() : t._tDur)
        }, Ne = function(e) {
            return e._end = ge(e._start + (e._tDur / Math.abs(e._ts || e._rts || E) || 0))
        }, Oe = function(e, t) {
            var n = e._dp;
            return n && n.smoothChildTiming && e._ts && (e._start = ge(n._time - (e._ts > 0 ? t / e._ts : ((e._dirty ? e.totalDuration() : e._tDur) - t) / -e._ts)),
            Ne(e),
            n._dirty || Re(n, e)),
            e
        }, Qe = function(e, t) {
            var n;
            if ((t._time || !t._dur && t._initted || t._start < e._time && (t._dur || !t.add)) && (n = Fe(e.rawTime(), t),
            (!t._dur || Je(0, t.totalDuration(), n) - t._tTime > E) && t.render(n, !0)),
            Re(e, t)._dp && e._initted && e._time >= e._dur && e._ts) {
                if (e._dur < e.duration())
                    for (n = e; n._dp; )
                        n.rawTime() >= 0 && n.totalTime(n._tTime),
                        n = n._dp;
                e._zTime = -1e-8
            }
        }, ke = function(e, t, n, i) {
            return t.parent && Be(t),
            t._start = ge((D(n) ? n : n || e !== l ? Ye(e, n, t) : e._time) + t._delay),
            t._end = ge(t._start + (t.totalDuration() / Math.abs(t.timeScale()) || 0)),
            Me(e, t, "_first", "_last", e._sort ? "_start" : 0),
            Ve(t) || (e._recent = t),
            i || Qe(e, t),
            e._ts < 0 && Oe(e, e._tTime),
            e
        }, Ge = function(e, t) {
            return (q.ScrollTrigger || K("scrollTrigger", t)) && q.ScrollTrigger.create(t, e)
        }, He = function(e, t, n, i, r) {
            return qt(e, t, r),
            e._initted ? !n && e._pt && !a && (e._dur && !1 !== e.vars.lazy || !e._dur && e.vars.lazy) && p !== It.frame ? (re.push(e),
            e._lazy = [r, i],
            1) : void 0 : 1
        }, ze = function e(t) {
            var n = t.parent;
            return n && n._ts && n._initted && !n._lock && (n.rawTime() < 0 || e(n))
        }, Ve = function(e) {
            var t = e.data;
            return "isFromStart" === t || "isStart" === t
        }, We = function(e, t, n, i) {
            var r = e._repeat
              , s = ge(t) || 0
              , a = e._tTime / e._tDur;
            return a && !i && (e._time *= s / e._dur),
            e._dur = s,
            e._tDur = r ? r < 0 ? 1e10 : ge(s * (r + 1) + e._rDelay * r) : s,
            a > 0 && !i && Oe(e, e._tTime = e._tDur * a),
            e.parent && Ne(e),
            n || Re(e.parent, e),
            e
        }, je = function(e) {
            return e instanceof Gt ? Re(e) : We(e, e._dur)
        }, qe = {
            _start: 0,
            endTime: $,
            totalDuration: $
        }, Ye = function e(t, n, i) {
            var r, s, a, o = t.labels, l = t._recent || qe, c = t.duration() >= b ? l.endTime(!1) : t._dur;
            return B(n) && (isNaN(n) || n in o) ? (s = n.charAt(0),
            a = "%" === n.substr(-1),
            r = n.indexOf("="),
            "<" === s || ">" === s ? (r >= 0 && (n = n.replace(/=/, "")),
            ("<" === s ? l._start : l.endTime(l._repeat >= 0)) + (parseFloat(n.substr(1)) || 0) * (a ? (r < 0 ? l : i).totalDuration() / 100 : 1)) : r < 0 ? (n in o || (o[n] = c),
            o[n]) : (s = parseFloat(n.charAt(r - 1) + n.substr(r + 1)),
            a && i && (s = s / 100 * (Q(i) ? i[0] : i).totalDuration()),
            r > 1 ? e(t, n.substr(0, r - 1), i) + s : c + s)) : null == n ? c : +n
        }, Xe = function(e, t, n) {
            var i, r, s = D(t[1]), a = (s ? 2 : 1) + (e < 2 ? 0 : 1), o = t[a];
            if (s && (o.duration = t[1]),
            o.parent = n,
            e) {
                for (i = o,
                r = n; r && !("immediateRender"in i); )
                    i = r.vars.defaults || {},
                    r = U(r.vars.inherit) && r.parent;
                o.immediateRender = U(i.immediateRender),
                e < 2 ? o.runBackwards = 1 : o.startAt = t[a - 1]
            }
            return new Zt(t[0],o,t[a + 1])
        }, Ke = function(e, t) {
            return e || 0 === e ? t(e) : t
        }, Je = function(e, t, n) {
            return n < e ? e : n > t ? t : n
        }, Ze = function(e, t) {
            return B(e) && (t = j.exec(e)) ? t[1] : ""
        }, $e = [].slice, et = function(e, t) {
            return e && L(e) && "length"in e && (!t && !e.length || e.length - 1 in e && L(e[0])) && !e.nodeType && e !== c
        }, tt = function(e, t, n) {
            return void 0 === n && (n = []),
            e.forEach((function(e) {
                var i;
                return B(e) && !t || et(e, 1) ? (i = n).push.apply(i, nt(e)) : n.push(e)
            }
            )) || n
        }, nt = function(e, t, n) {
            return o && !t && o.selector ? o.selector(e) : !B(e) || n || !u && St() ? Q(e) ? tt(e, n) : et(e) ? $e.call(e, 0) : e ? [e] : [] : $e.call((t || h).querySelectorAll(e), 0)
        }, it = function(e) {
            return e = nt(e)[0] || J("Invalid scope") || {},
            function(t) {
                var n = e.current || e.nativeElement || e;
                return nt(t, n.querySelectorAll ? n : n === e ? J("Invalid scope") || h.createElement("div") : e)
            }
        }, rt = function(e) {
            return e.sort((function() {
                return .5 - Math.random()
            }
            ))
        }, st = function(e) {
            if (R(e))
                return e;
            var t = L(e) ? e : {
                each: e
            }
              , n = Lt(t.ease)
              , i = t.from || 0
              , r = parseFloat(t.base) || 0
              , s = {}
              , a = i > 0 && i < 1
              , o = isNaN(i) || a
              , l = t.axis
              , c = i
              , u = i;
            return B(i) ? c = u = {
                center: .5,
                edges: .5,
                end: 1
            }[i] || 0 : !a && o && (c = i[0],
            u = i[1]),
            function(e, a, h) {
                var d, p, f, A, g, m, v, y, x, _ = (h || t).length, E = s[_];
                if (!E) {
                    if (!(x = "auto" === t.grid ? 0 : (t.grid || [1, b])[1])) {
                        for (v = -b; v < (v = h[x++].getBoundingClientRect().left) && x < _; )
                            ;
                        x < _ && x--
                    }
                    for (E = s[_] = [],
                    d = o ? Math.min(x, _) * c - .5 : i % x,
                    p = x === b ? 0 : o ? _ * u / x - .5 : i / x | 0,
                    v = 0,
                    y = b,
                    m = 0; m < _; m++)
                        f = m % x - d,
                        A = p - (m / x | 0),
                        E[m] = g = l ? Math.abs("y" === l ? A : f) : S(f * f + A * A),
                        g > v && (v = g),
                        g < y && (y = g);
                    "random" === i && rt(E),
                    E.max = v - y,
                    E.min = y,
                    E.v = _ = (parseFloat(t.amount) || parseFloat(t.each) * (x > _ ? _ - 1 : l ? "y" === l ? _ / x : x : Math.max(x, _ / x)) || 0) * ("edges" === i ? -1 : 1),
                    E.b = _ < 0 ? r - _ : r,
                    E.u = Ze(t.amount || t.each) || 0,
                    n = n && _ < 0 ? Dt(n) : n
                }
                return _ = (E[e] - E.min) / E.max || 0,
                ge(E.b + (n ? n(_) : _) * E.v) + E.u
            }
        }, at = function(e) {
            var t = Math.pow(10, ((e + "").split(".")[1] || "").length);
            return function(n) {
                var i = ge(Math.round(parseFloat(n) / e) * e * t);
                return (i - i % 1) / t + (D(n) ? 0 : Ze(n))
            }
        }, ot = function(e, t) {
            var n, i, r = Q(e);
            return !r && L(e) && (n = r = e.radius || b,
            e.values ? (e = nt(e.values),
            (i = !D(e[0])) && (n *= n)) : e = at(e.increment)),
            Ke(t, r ? R(e) ? function(t) {
                return i = e(t),
                Math.abs(i - t) <= n ? i : t
            }
            : function(t) {
                for (var r, s, a = parseFloat(i ? t.x : t), o = parseFloat(i ? t.y : 0), l = b, c = 0, u = e.length; u--; )
                    (r = i ? (r = e[u].x - a) * r + (s = e[u].y - o) * s : Math.abs(e[u] - a)) < l && (l = r,
                    c = u);
                return c = !n || l <= n ? e[c] : t,
                i || c === t || D(t) ? c : c + Ze(t)
            }
            : at(e))
        }, lt = function(e, t, n, i) {
            return Ke(Q(e) ? !t : !0 === n ? !!(n = 0) : !i, (function() {
                return Q(e) ? e[~~(Math.random() * e.length)] : (n = n || 1e-5) && (i = n < 1 ? Math.pow(10, (n + "").length - 2) : 1) && Math.floor(Math.round((e - n / 2 + Math.random() * (t - e + .99 * n)) / n) * n * i) / i
            }
            ))
        }, ct = function(e, t, n) {
            return Ke(n, (function(n) {
                return e[~~t(n)]
            }
            ))
        }, ut = function(e) {
            for (var t, n, i, r, s = 0, a = ""; ~(t = e.indexOf("random(", s)); )
                i = e.indexOf(")", t),
                r = "[" === e.charAt(t + 7),
                n = e.substr(t + 7, i - t - 7).match(r ? W : k),
                a += e.substr(s, t - s) + lt(r ? n : +n[0], r ? 0 : +n[1], +n[2] || 1e-5),
                s = i + 1;
            return a + e.substr(s, e.length - s)
        }, ht = function(e, t, n, i, r) {
            var s = t - e
              , a = i - n;
            return Ke(r, (function(t) {
                return n + ((t - e) / s * a || 0)
            }
            ))
        }, dt = function(e, t, n) {
            var i, r, s, a = e.labels, o = b;
            for (i in a)
                (r = a[i] - t) < 0 == !!n && r && o > (r = Math.abs(r)) && (s = i,
                o = r);
            return s
        }, pt = function(e, t, n) {
            var i, r, s, a = e.vars, l = a[t], c = o, u = e._ctx;
            if (l)
                return i = a[t + "Params"],
                r = a.callbackScope || e,
                n && re.length && ye(),
                u && (o = u),
                s = i ? l.apply(r, i) : l.call(r),
                o = c,
                s
        }, ft = function(e) {
            return Be(e),
            e.scrollTrigger && e.scrollTrigger.kill(!!a),
            e.progress() < 1 && pt(e, "onInterrupt"),
            e
        }, At = [], gt = function(e) {
            if (e)
                if (e = !e.name && e.default || e,
                F() || e.headless) {
                    var t = e.name
                      , n = R(e)
                      , i = t && !n && e.init ? function() {
                        this._props = []
                    }
                    : e
                      , r = {
                        init: $,
                        render: ln,
                        add: Wt,
                        kill: un,
                        modifier: cn,
                        rawVars: 0
                    }
                      , s = {
                        targetTest: 0,
                        get: 0,
                        getSetter: rn,
                        aliases: {},
                        register: 0
                    };
                    if (St(),
                    e !== i) {
                        if (ae[t])
                            return;
                        Ee(i, Ee(Ie(e, r), s)),
                        we(i.prototype, we(r, Ie(e, s))),
                        ae[i.prop = t] = i,
                        e.targetTest && (ce.push(i),
                        ie[t] = 1),
                        t = ("css" === t ? "CSS" : t.charAt(0).toUpperCase() + t.substr(1)) + "Plugin"
                    }
                    Z(t, i),
                    e.register && e.register(In, i, pn)
                } else
                    At.push(e)
        }, mt = 255, vt = {
            aqua: [0, mt, mt],
            lime: [0, mt, 0],
            silver: [192, 192, 192],
            black: [0, 0, 0],
            maroon: [128, 0, 0],
            teal: [0, 128, 128],
            blue: [0, 0, mt],
            navy: [0, 0, 128],
            white: [mt, mt, mt],
            olive: [128, 128, 0],
            yellow: [mt, mt, 0],
            orange: [mt, 165, 0],
            gray: [128, 128, 128],
            purple: [128, 0, 128],
            green: [0, 128, 0],
            red: [mt, 0, 0],
            pink: [mt, 192, 203],
            cyan: [0, mt, mt],
            transparent: [mt, mt, mt, 0]
        }, yt = function(e, t, n) {
            return (6 * (e += e < 0 ? 1 : e > 1 ? -1 : 0) < 1 ? t + (n - t) * e * 6 : e < .5 ? n : 3 * e < 2 ? t + (n - t) * (2 / 3 - e) * 6 : t) * mt + .5 | 0
        }, xt = function(e, t, n) {
            var i, r, s, a, o, l, c, u, h, d, p = e ? D(e) ? [e >> 16, e >> 8 & mt, e & mt] : 0 : vt.black;
            if (!p) {
                if ("," === e.substr(-1) && (e = e.substr(0, e.length - 1)),
                vt[e])
                    p = vt[e];
                else if ("#" === e.charAt(0)) {
                    if (e.length < 6 && (i = e.charAt(1),
                    r = e.charAt(2),
                    s = e.charAt(3),
                    e = "#" + i + i + r + r + s + s + (5 === e.length ? e.charAt(4) + e.charAt(4) : "")),
                    9 === e.length)
                        return [(p = parseInt(e.substr(1, 6), 16)) >> 16, p >> 8 & mt, p & mt, parseInt(e.substr(7), 16) / 255];
                    p = [(e = parseInt(e.substr(1), 16)) >> 16, e >> 8 & mt, e & mt]
                } else if ("hsl" === e.substr(0, 3))
                    if (p = d = e.match(k),
                    t) {
                        if (~e.indexOf("="))
                            return p = e.match(G),
                            n && p.length < 4 && (p[3] = 1),
                            p
                    } else
                        a = +p[0] % 360 / 360,
                        o = +p[1] / 100,
                        i = 2 * (l = +p[2] / 100) - (r = l <= .5 ? l * (o + 1) : l + o - l * o),
                        p.length > 3 && (p[3] *= 1),
                        p[0] = yt(a + 1 / 3, i, r),
                        p[1] = yt(a, i, r),
                        p[2] = yt(a - 1 / 3, i, r);
                else
                    p = e.match(k) || vt.transparent;
                p = p.map(Number)
            }
            return t && !d && (i = p[0] / mt,
            r = p[1] / mt,
            s = p[2] / mt,
            l = ((c = Math.max(i, r, s)) + (u = Math.min(i, r, s))) / 2,
            c === u ? a = o = 0 : (h = c - u,
            o = l > .5 ? h / (2 - c - u) : h / (c + u),
            a = c === i ? (r - s) / h + (r < s ? 6 : 0) : c === r ? (s - i) / h + 2 : (i - r) / h + 4,
            a *= 60),
            p[0] = ~~(a + .5),
            p[1] = ~~(100 * o + .5),
            p[2] = ~~(100 * l + .5)),
            n && p.length < 4 && (p[3] = 1),
            p
        }, _t = function(e) {
            var t = []
              , n = []
              , i = -1;
            return e.split(Et).forEach((function(e) {
                var r = e.match(H) || [];
                t.push.apply(t, r),
                n.push(i += r.length + 1)
            }
            )),
            t.c = n,
            t
        }, bt = function(e, t, n) {
            var i, r, s, a, o = "", l = (e + o).match(Et), c = t ? "hsla(" : "rgba(", u = 0;
            if (!l)
                return e;
            if (l = l.map((function(e) {
                return (e = xt(e, t, 1)) && c + (t ? e[0] + "," + e[1] + "%," + e[2] + "%," + e[3] : e.join(",")) + ")"
            }
            )),
            n && (s = _t(e),
            (i = n.c).join(o) !== s.c.join(o)))
                for (a = (r = e.replace(Et, "1").split(H)).length - 1; u < a; u++)
                    o += r[u] + (~i.indexOf(u) ? l.shift() || c + "0,0,0,0)" : (s.length ? s : l.length ? l : n).shift());
            if (!r)
                for (a = (r = e.split(Et)).length - 1; u < a; u++)
                    o += r[u] + l[u];
            return o + r[a]
        }, Et = function() {
            var e, t = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b";
            for (e in vt)
                t += "|" + e + "\\b";
            return new RegExp(t + ")","gi")
        }(), wt = /hsl[a]?\(/, Ct = function(e) {
            var t, n = e.join(" ");
            if (Et.lastIndex = 0,
            Et.test(n))
                return t = wt.test(n),
                e[1] = bt(e[1], t),
                e[0] = bt(e[0], t, _t(e[1])),
                !0
        }, It = function() {
            var e, t, n, i, r, s, a = Date.now, o = 500, l = 33, p = a(), f = p, g = 1e3 / 240, m = g, v = [], y = function n(c) {
                var u, h, d, A, y = a() - f, x = !0 === c;
                if ((y > o || y < 0) && (p += y - l),
                ((u = (d = (f += y) - p) - m) > 0 || x) && (A = ++i.frame,
                r = d - 1e3 * i.time,
                i.time = d /= 1e3,
                m += u + (u >= g ? 4 : g - u),
                h = 1),
                x || (e = t(n)),
                h)
                    for (s = 0; s < v.length; s++)
                        v[s](d, r, A, c)
            };
            return i = {
                time: 0,
                frame: 0,
                tick: function() {
                    y(!0)
                },
                deltaRatio: function(e) {
                    return r / (1e3 / (e || 60))
                },
                wake: function() {
                    d && (!u && F() && (c = u = window,
                    h = c.document || {},
                    q.gsap = In,
                    (c.gsapVersions || (c.gsapVersions = [])).push(In.version),
                    X(Y || c.GreenSockGlobals || !c.gsap && c || {}),
                    At.forEach(gt)),
                    n = "undefined" != typeof requestAnimationFrame && requestAnimationFrame,
                    e && i.sleep(),
                    t = n || function(e) {
                        return setTimeout(e, m - 1e3 * i.time + 1 | 0)
                    }
                    ,
                    A = 1,
                    y(2))
                },
                sleep: function() {
                    (n ? cancelAnimationFrame : clearTimeout)(e),
                    A = 0,
                    t = $
                },
                lagSmoothing: function(e, t) {
                    o = e || 1 / 0,
                    l = Math.min(t || 33, o)
                },
                fps: function(e) {
                    g = 1e3 / (e || 240),
                    m = 1e3 * i.time + g
                },
                add: function(e, t, n) {
                    var r = t ? function(t, n, s, a) {
                        e(t, n, s, a),
                        i.remove(r)
                    }
                    : e;
                    return i.remove(e),
                    v[n ? "unshift" : "push"](r),
                    St(),
                    r
                },
                remove: function(e, t) {
                    ~(t = v.indexOf(e)) && v.splice(t, 1) && s >= t && s--
                },
                _listeners: v
            }
        }(), St = function() {
            return !A && It.wake()
        }, Mt = {}, Tt = /^[\d.\-M][\d.\-,\s]/, Bt = /["']/g, Rt = function(e) {
            for (var t, n, i, r = {}, s = e.substr(1, e.length - 3).split(":"), a = s[0], o = 1, l = s.length; o < l; o++)
                n = s[o],
                t = o !== l - 1 ? n.lastIndexOf(",") : n.length,
                i = n.substr(0, t),
                r[a] = isNaN(i) ? i.replace(Bt, "").trim() : +i,
                a = n.substr(t + 1).trim();
            return r
        }, Dt = function(e) {
            return function(t) {
                return 1 - e(1 - t)
            }
        }, Pt = function e(t, n) {
            for (var i, r = t._first; r; )
                r instanceof Gt ? e(r, n) : !r.vars.yoyoEase || r._yoyo && r._repeat || r._yoyo === n || (r.timeline ? e(r.timeline, n) : (i = r._ease,
                r._ease = r._yEase,
                r._yEase = i,
                r._yoyo = n)),
                r = r._next
        }, Lt = function(e, t) {
            return e && (R(e) ? e : Mt[e] || function(e) {
                var t, n, i, r, s = (e + "").split("("), a = Mt[s[0]];
                return a && s.length > 1 && a.config ? a.config.apply(null, ~e.indexOf("{") ? [Rt(s[1])] : (t = e,
                n = t.indexOf("(") + 1,
                i = t.indexOf(")"),
                r = t.indexOf("(", n),
                t.substring(n, ~r && r < i ? t.indexOf(")", i + 1) : i)).split(",").map(_e)) : Mt._CE && Tt.test(e) ? Mt._CE("", e) : a
            }(e)) || t
        }, Ut = function(e, t, n, i) {
            void 0 === n && (n = function(e) {
                return 1 - t(1 - e)
            }
            ),
            void 0 === i && (i = function(e) {
                return e < .5 ? t(2 * e) / 2 : 1 - t(2 * (1 - e)) / 2
            }
            );
            var r, s = {
                easeIn: t,
                easeOut: n,
                easeInOut: i
            };
            return fe(e, (function(e) {
                for (var t in Mt[e] = q[e] = s,
                Mt[r = e.toLowerCase()] = n,
                s)
                    Mt[r + ("easeIn" === t ? ".in" : "easeOut" === t ? ".out" : ".inOut")] = Mt[e + "." + t] = s[t]
            }
            )),
            s
        }, Ft = function(e) {
            return function(t) {
                return t < .5 ? (1 - e(1 - 2 * t)) / 2 : .5 + e(2 * (t - .5)) / 2
            }
        }, Nt = function e(t, n, i) {
            var r = n >= 1 ? n : 1
              , s = (i || (t ? .3 : .45)) / (n < 1 ? n : 1)
              , a = s / w * (Math.asin(1 / r) || 0)
              , o = function(e) {
                return 1 === e ? 1 : r * Math.pow(2, -10 * e) * T((e - a) * s) + 1
            }
              , l = "out" === t ? o : "in" === t ? function(e) {
                return 1 - o(1 - e)
            }
            : Ft(o);
            return s = w / s,
            l.config = function(n, i) {
                return e(t, n, i)
            }
            ,
            l
        }, Ot = function e(t, n) {
            void 0 === n && (n = 1.70158);
            var i = function(e) {
                return e ? --e * e * ((n + 1) * e + n) + 1 : 0
            }
              , r = "out" === t ? i : "in" === t ? function(e) {
                return 1 - i(1 - e)
            }
            : Ft(i);
            return r.config = function(n) {
                return e(t, n)
            }
            ,
            r
        };
        fe("Linear,Quad,Cubic,Quart,Quint,Strong", (function(e, t) {
            var n = t < 5 ? t + 1 : t;
            Ut(e + ",Power" + (n - 1), t ? function(e) {
                return Math.pow(e, n)
            }
            : function(e) {
                return e
            }
            , (function(e) {
                return 1 - Math.pow(1 - e, n)
            }
            ), (function(e) {
                return e < .5 ? Math.pow(2 * e, n) / 2 : 1 - Math.pow(2 * (1 - e), n) / 2
            }
            ))
        }
        )),
        Mt.Linear.easeNone = Mt.none = Mt.Linear.easeIn,
        Ut("Elastic", Nt("in"), Nt("out"), Nt()),
        g = 7.5625,
        v = 1 / (m = 2.75),
        Ut("Bounce", (function(e) {
            return 1 - y(1 - e)
        }
        ), y = function(e) {
            return e < v ? g * e * e : e < .7272727272727273 ? g * Math.pow(e - 1.5 / m, 2) + .75 : e < .9090909090909092 ? g * (e -= 2.25 / m) * e + .9375 : g * Math.pow(e - 2.625 / m, 2) + .984375
        }
        ),
        Ut("Expo", (function(e) {
            return e ? Math.pow(2, 10 * (e - 1)) : 0
        }
        )),
        Ut("Circ", (function(e) {
            return -(S(1 - e * e) - 1)
        }
        )),
        Ut("Sine", (function(e) {
            return 1 === e ? 1 : 1 - M(e * C)
        }
        )),
        Ut("Back", Ot("in"), Ot("out"), Ot()),
        Mt.SteppedEase = Mt.steps = q.SteppedEase = {
            config: function(e, t) {
                void 0 === e && (e = 1);
                var n = 1 / e
                  , i = e + (t ? 0 : 1)
                  , r = t ? 1 : 0;
                return function(e) {
                    return ((i * Je(0, .99999999, e) | 0) + r) * n
                }
            }
        },
        _.ease = Mt["quad.out"],
        fe("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", (function(e) {
            return ue += e + "," + e + "Params,"
        }
        ));
        var Qt = function(e, t) {
            this.id = I++,
            e._gsap = this,
            this.target = e,
            this.harness = t,
            this.get = t ? t.get : pe,
            this.set = t ? t.getSetter : rn
        }
          , kt = function() {
            function e(e) {
                this.vars = e,
                this._delay = +e.delay || 0,
                (this._repeat = e.repeat === 1 / 0 ? -2 : e.repeat || 0) && (this._rDelay = e.repeatDelay || 0,
                this._yoyo = !!e.yoyo || !!e.yoyoEase),
                this._ts = 1,
                We(this, +e.duration, 1, 1),
                this.data = e.data,
                o && (this._ctx = o,
                o.data.push(this)),
                A || It.wake()
            }
            var t = e.prototype;
            return t.delay = function(e) {
                return e || 0 === e ? (this.parent && this.parent.smoothChildTiming && this.startTime(this._start + e - this._delay),
                this._delay = e,
                this) : this._delay
            }
            ,
            t.duration = function(e) {
                return arguments.length ? this.totalDuration(this._repeat > 0 ? e + (e + this._rDelay) * this._repeat : e) : this.totalDuration() && this._dur
            }
            ,
            t.totalDuration = function(e) {
                return arguments.length ? (this._dirty = 0,
                We(this, this._repeat < 0 ? e : (e - this._repeat * this._rDelay) / (this._repeat + 1))) : this._tDur
            }
            ,
            t.totalTime = function(e, t) {
                if (St(),
                !arguments.length)
                    return this._tTime;
                var n = this._dp;
                if (n && n.smoothChildTiming && this._ts) {
                    for (Oe(this, e),
                    !n._dp || n.parent || Qe(n, this); n && n.parent; )
                        n.parent._time !== n._start + (n._ts >= 0 ? n._tTime / n._ts : (n.totalDuration() - n._tTime) / -n._ts) && n.totalTime(n._tTime, !0),
                        n = n.parent;
                    !this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && e < this._tDur || this._ts < 0 && e > 0 || !this._tDur && !e) && ke(this._dp, this, this._start - this._delay)
                }
                return (this._tTime !== e || !this._dur && !t || this._initted && Math.abs(this._zTime) === E || !e && !this._initted && (this.add || this._ptLookup)) && (this._ts || (this._pTime = e),
                xe(this, e, t)),
                this
            }
            ,
            t.time = function(e, t) {
                return arguments.length ? this.totalTime(Math.min(this.totalDuration(), e + Le(this)) % (this._dur + this._rDelay) || (e ? this._dur : 0), t) : this._time
            }
            ,
            t.totalProgress = function(e, t) {
                return arguments.length ? this.totalTime(this.totalDuration() * e, t) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.rawTime() > 0 ? 1 : 0
            }
            ,
            t.progress = function(e, t) {
                return arguments.length ? this.totalTime(this.duration() * (!this._yoyo || 1 & this.iteration() ? e : 1 - e) + Le(this), t) : this.duration() ? Math.min(1, this._time / this._dur) : this.rawTime() > 0 ? 1 : 0
            }
            ,
            t.iteration = function(e, t) {
                var n = this.duration() + this._rDelay;
                return arguments.length ? this.totalTime(this._time + (e - 1) * n, t) : this._repeat ? Ue(this._tTime, n) + 1 : 1
            }
            ,
            t.timeScale = function(e, t) {
                if (!arguments.length)
                    return -1e-8 === this._rts ? 0 : this._rts;
                if (this._rts === e)
                    return this;
                var n = this.parent && this._ts ? Fe(this.parent._time, this) : this._tTime;
                return this._rts = +e || 0,
                this._ts = this._ps || -1e-8 === e ? 0 : this._rts,
                this.totalTime(Je(-Math.abs(this._delay), this._tDur, n), !1 !== t),
                Ne(this),
                function(e) {
                    for (var t = e.parent; t && t.parent; )
                        t._dirty = 1,
                        t.totalDuration(),
                        t = t.parent;
                    return e
                }(this)
            }
            ,
            t.paused = function(e) {
                return arguments.length ? (this._ps !== e && (this._ps = e,
                e ? (this._pTime = this._tTime || Math.max(-this._delay, this.rawTime()),
                this._ts = this._act = 0) : (St(),
                this._ts = this._rts,
                this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, 1 === this.progress() && Math.abs(this._zTime) !== E && (this._tTime -= E)))),
                this) : this._ps
            }
            ,
            t.startTime = function(e) {
                if (arguments.length) {
                    this._start = e;
                    var t = this.parent || this._dp;
                    return t && (t._sort || !this.parent) && ke(t, this, e - this._delay),
                    this
                }
                return this._start
            }
            ,
            t.endTime = function(e) {
                return this._start + (U(e) ? this.totalDuration() : this.duration()) / Math.abs(this._ts || 1)
            }
            ,
            t.rawTime = function(e) {
                var t = this.parent || this._dp;
                return t ? e && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : this._ts ? Fe(t.rawTime(e), this) : this._tTime : this._tTime
            }
            ,
            t.revert = function(e) {
                void 0 === e && (e = ne);
                var t = a;
                return a = e,
                (this._initted || this._startAt) && (this.timeline && this.timeline.revert(e),
                this.totalTime(-.01, e.suppressEvents)),
                "nested" !== this.data && !1 !== e.kill && this.kill(),
                a = t,
                this
            }
            ,
            t.globalTime = function(e) {
                for (var t = this, n = arguments.length ? e : t.rawTime(); t; )
                    n = t._start + n / (Math.abs(t._ts) || 1),
                    t = t._dp;
                return !this.parent && this._sat ? this._sat.globalTime(e) : n
            }
            ,
            t.repeat = function(e) {
                return arguments.length ? (this._repeat = e === 1 / 0 ? -2 : e,
                je(this)) : -2 === this._repeat ? 1 / 0 : this._repeat
            }
            ,
            t.repeatDelay = function(e) {
                if (arguments.length) {
                    var t = this._time;
                    return this._rDelay = e,
                    je(this),
                    t ? this.time(t) : this
                }
                return this._rDelay
            }
            ,
            t.yoyo = function(e) {
                return arguments.length ? (this._yoyo = e,
                this) : this._yoyo
            }
            ,
            t.seek = function(e, t) {
                return this.totalTime(Ye(this, e), U(t))
            }
            ,
            t.restart = function(e, t) {
                return this.play().totalTime(e ? -this._delay : 0, U(t))
            }
            ,
            t.play = function(e, t) {
                return null != e && this.seek(e, t),
                this.reversed(!1).paused(!1)
            }
            ,
            t.reverse = function(e, t) {
                return null != e && this.seek(e || this.totalDuration(), t),
                this.reversed(!0).paused(!1)
            }
            ,
            t.pause = function(e, t) {
                return null != e && this.seek(e, t),
                this.paused(!0)
            }
            ,
            t.resume = function() {
                return this.paused(!1)
            }
            ,
            t.reversed = function(e) {
                return arguments.length ? (!!e !== this.reversed() && this.timeScale(-this._rts || (e ? -1e-8 : 0)),
                this) : this._rts < 0
            }
            ,
            t.invalidate = function() {
                return this._initted = this._act = 0,
                this._zTime = -1e-8,
                this
            }
            ,
            t.isActive = function() {
                var e, t = this.parent || this._dp, n = this._start;
                return !(t && !(this._ts && this._initted && t.isActive() && (e = t.rawTime(!0)) >= n && e < this.endTime(!0) - E))
            }
            ,
            t.eventCallback = function(e, t, n) {
                var i = this.vars;
                return arguments.length > 1 ? (t ? (i[e] = t,
                n && (i[e + "Params"] = n),
                "onUpdate" === e && (this._onUpdate = t)) : delete i[e],
                this) : i[e]
            }
            ,
            t.then = function(e) {
                var t = this;
                return new Promise((function(n) {
                    var i = R(e) ? e : be
                      , r = function() {
                        var e = t.then;
                        t.then = null,
                        R(i) && (i = i(t)) && (i.then || i === t) && (t.then = e),
                        n(i),
                        t.then = e
                    };
                    t._initted && 1 === t.totalProgress() && t._ts >= 0 || !t._tTime && t._ts < 0 ? r() : t._prom = r
                }
                ))
            }
            ,
            t.kill = function() {
                ft(this)
            }
            ,
            e
        }();
        Ee(kt.prototype, {
            _time: 0,
            _start: 0,
            _end: 0,
            _tTime: 0,
            _tDur: 0,
            _dirty: 0,
            _repeat: 0,
            _yoyo: !1,
            parent: null,
            _initted: !1,
            _rDelay: 0,
            _ts: 1,
            _dp: 0,
            ratio: 0,
            _zTime: -1e-8,
            _prom: 0,
            _ps: !1,
            _rts: 1
        });
        var Gt = function(e) {
            function t(t, n) {
                var r;
                return void 0 === t && (t = {}),
                (r = e.call(this, t) || this).labels = {},
                r.smoothChildTiming = !!t.smoothChildTiming,
                r.autoRemoveChildren = !!t.autoRemoveChildren,
                r._sort = U(t.sortChildren),
                l && ke(t.parent || l, i(r), n),
                t.reversed && r.reverse(),
                t.paused && r.paused(!0),
                t.scrollTrigger && Ge(i(r), t.scrollTrigger),
                r
            }
            r(t, e);
            var n = t.prototype;
            return n.to = function(e, t, n) {
                return Xe(0, arguments, this),
                this
            }
            ,
            n.from = function(e, t, n) {
                return Xe(1, arguments, this),
                this
            }
            ,
            n.fromTo = function(e, t, n, i) {
                return Xe(2, arguments, this),
                this
            }
            ,
            n.set = function(e, t, n) {
                return t.duration = 0,
                t.parent = this,
                Se(t).repeatDelay || (t.repeat = 0),
                t.immediateRender = !!t.immediateRender,
                new Zt(e,t,Ye(this, n),1),
                this
            }
            ,
            n.call = function(e, t, n) {
                return ke(this, Zt.delayedCall(0, e, t), n)
            }
            ,
            n.staggerTo = function(e, t, n, i, r, s, a) {
                return n.duration = t,
                n.stagger = n.stagger || i,
                n.onComplete = s,
                n.onCompleteParams = a,
                n.parent = this,
                new Zt(e,n,Ye(this, r)),
                this
            }
            ,
            n.staggerFrom = function(e, t, n, i, r, s, a) {
                return n.runBackwards = 1,
                Se(n).immediateRender = U(n.immediateRender),
                this.staggerTo(e, t, n, i, r, s, a)
            }
            ,
            n.staggerFromTo = function(e, t, n, i, r, s, a, o) {
                return i.startAt = n,
                Se(i).immediateRender = U(i.immediateRender),
                this.staggerTo(e, t, i, r, s, a, o)
            }
            ,
            n.render = function(e, t, n) {
                var i, r, s, o, c, u, h, d, p, f, A, g, m = this._time, v = this._dirty ? this.totalDuration() : this._tDur, y = this._dur, x = e <= 0 ? 0 : ge(e), _ = this._zTime < 0 != e < 0 && (this._initted || !y);
                if (this !== l && x > v && e >= 0 && (x = v),
                x !== this._tTime || n || _) {
                    if (m !== this._time && y && (x += this._time - m,
                    e += this._time - m),
                    i = x,
                    p = this._start,
                    u = !(d = this._ts),
                    _ && (y || (m = this._zTime),
                    (e || !t) && (this._zTime = e)),
                    this._repeat) {
                        if (A = this._yoyo,
                        c = y + this._rDelay,
                        this._repeat < -1 && e < 0)
                            return this.totalTime(100 * c + e, t, n);
                        if (i = ge(x % c),
                        x === v ? (o = this._repeat,
                        i = y) : ((o = ~~(x / c)) && o === x / c && (i = y,
                        o--),
                        i > y && (i = y)),
                        f = Ue(this._tTime, c),
                        !m && this._tTime && f !== o && this._tTime - f * c - this._dur <= 0 && (f = o),
                        A && 1 & o && (i = y - i,
                        g = 1),
                        o !== f && !this._lock) {
                            var b = A && 1 & f
                              , w = b === (A && 1 & o);
                            if (o < f && (b = !b),
                            m = b ? 0 : x % y ? y : x,
                            this._lock = 1,
                            this.render(m || (g ? 0 : ge(o * c)), t, !y)._lock = 0,
                            this._tTime = x,
                            !t && this.parent && pt(this, "onRepeat"),
                            this.vars.repeatRefresh && !g && (this.invalidate()._lock = 1),
                            m && m !== this._time || u !== !this._ts || this.vars.onRepeat && !this.parent && !this._act)
                                return this;
                            if (y = this._dur,
                            v = this._tDur,
                            w && (this._lock = 2,
                            m = b ? y : -1e-4,
                            this.render(m, !0),
                            this.vars.repeatRefresh && !g && this.invalidate()),
                            this._lock = 0,
                            !this._ts && !u)
                                return this;
                            Pt(this, g)
                        }
                    }
                    if (this._hasPause && !this._forcing && this._lock < 2 && (h = function(e, t, n) {
                        var i;
                        if (n > t)
                            for (i = e._first; i && i._start <= n; ) {
                                if ("isPause" === i.data && i._start > t)
                                    return i;
                                i = i._next
                            }
                        else
                            for (i = e._last; i && i._start >= n; ) {
                                if ("isPause" === i.data && i._start < t)
                                    return i;
                                i = i._prev
                            }
                    }(this, ge(m), ge(i)),
                    h && (x -= i - (i = h._start))),
                    this._tTime = x,
                    this._time = i,
                    this._act = !d,
                    this._initted || (this._onUpdate = this.vars.onUpdate,
                    this._initted = 1,
                    this._zTime = e,
                    m = 0),
                    !m && i && !t && !o && (pt(this, "onStart"),
                    this._tTime !== x))
                        return this;
                    if (i >= m && e >= 0)
                        for (r = this._first; r; ) {
                            if (s = r._next,
                            (r._act || i >= r._start) && r._ts && h !== r) {
                                if (r.parent !== this)
                                    return this.render(e, t, n);
                                if (r.render(r._ts > 0 ? (i - r._start) * r._ts : (r._dirty ? r.totalDuration() : r._tDur) + (i - r._start) * r._ts, t, n),
                                i !== this._time || !this._ts && !u) {
                                    h = 0,
                                    s && (x += this._zTime = -1e-8);
                                    break
                                }
                            }
                            r = s
                        }
                    else {
                        r = this._last;
                        for (var C = e < 0 ? e : i; r; ) {
                            if (s = r._prev,
                            (r._act || C <= r._end) && r._ts && h !== r) {
                                if (r.parent !== this)
                                    return this.render(e, t, n);
                                if (r.render(r._ts > 0 ? (C - r._start) * r._ts : (r._dirty ? r.totalDuration() : r._tDur) + (C - r._start) * r._ts, t, n || a && (r._initted || r._startAt)),
                                i !== this._time || !this._ts && !u) {
                                    h = 0,
                                    s && (x += this._zTime = C ? -1e-8 : E);
                                    break
                                }
                            }
                            r = s
                        }
                    }
                    if (h && !t && (this.pause(),
                    h.render(i >= m ? 0 : -1e-8)._zTime = i >= m ? 1 : -1,
                    this._ts))
                        return this._start = p,
                        Ne(this),
                        this.render(e, t, n);
                    this._onUpdate && !t && pt(this, "onUpdate", !0),
                    (x === v && this._tTime >= this.totalDuration() || !x && m) && (p !== this._start && Math.abs(d) === Math.abs(this._ts) || this._lock || ((e || !y) && (x === v && this._ts > 0 || !x && this._ts < 0) && Be(this, 1),
                    t || e < 0 && !m || !x && !m && v || (pt(this, x === v && e >= 0 ? "onComplete" : "onReverseComplete", !0),
                    this._prom && !(x < v && this.timeScale() > 0) && this._prom())))
                }
                return this
            }
            ,
            n.add = function(e, t) {
                var n = this;
                if (D(t) || (t = Ye(this, t, e)),
                !(e instanceof kt)) {
                    if (Q(e))
                        return e.forEach((function(e) {
                            return n.add(e, t)
                        }
                        )),
                        this;
                    if (B(e))
                        return this.addLabel(e, t);
                    if (!R(e))
                        return this;
                    e = Zt.delayedCall(0, e)
                }
                return this !== e ? ke(this, e, t) : this
            }
            ,
            n.getChildren = function(e, t, n, i) {
                void 0 === e && (e = !0),
                void 0 === t && (t = !0),
                void 0 === n && (n = !0),
                void 0 === i && (i = -b);
                for (var r = [], s = this._first; s; )
                    s._start >= i && (s instanceof Zt ? t && r.push(s) : (n && r.push(s),
                    e && r.push.apply(r, s.getChildren(!0, t, n)))),
                    s = s._next;
                return r
            }
            ,
            n.getById = function(e) {
                for (var t = this.getChildren(1, 1, 1), n = t.length; n--; )
                    if (t[n].vars.id === e)
                        return t[n]
            }
            ,
            n.remove = function(e) {
                return B(e) ? this.removeLabel(e) : R(e) ? this.killTweensOf(e) : (Te(this, e),
                e === this._recent && (this._recent = this._last),
                Re(this))
            }
            ,
            n.totalTime = function(t, n) {
                return arguments.length ? (this._forcing = 1,
                !this._dp && this._ts && (this._start = ge(It.time - (this._ts > 0 ? t / this._ts : (this.totalDuration() - t) / -this._ts))),
                e.prototype.totalTime.call(this, t, n),
                this._forcing = 0,
                this) : this._tTime
            }
            ,
            n.addLabel = function(e, t) {
                return this.labels[e] = Ye(this, t),
                this
            }
            ,
            n.removeLabel = function(e) {
                return delete this.labels[e],
                this
            }
            ,
            n.addPause = function(e, t, n) {
                var i = Zt.delayedCall(0, t || $, n);
                return i.data = "isPause",
                this._hasPause = 1,
                ke(this, i, Ye(this, e))
            }
            ,
            n.removePause = function(e) {
                var t = this._first;
                for (e = Ye(this, e); t; )
                    t._start === e && "isPause" === t.data && Be(t),
                    t = t._next
            }
            ,
            n.killTweensOf = function(e, t, n) {
                for (var i = this.getTweensOf(e, n), r = i.length; r--; )
                    Ht !== i[r] && i[r].kill(e, t);
                return this
            }
            ,
            n.getTweensOf = function(e, t) {
                for (var n, i = [], r = nt(e), s = this._first, a = D(t); s; )
                    s instanceof Zt ? ve(s._targets, r) && (a ? (!Ht || s._initted && s._ts) && s.globalTime(0) <= t && s.globalTime(s.totalDuration()) > t : !t || s.isActive()) && i.push(s) : (n = s.getTweensOf(r, t)).length && i.push.apply(i, n),
                    s = s._next;
                return i
            }
            ,
            n.tweenTo = function(e, t) {
                t = t || {};
                var n, i = this, r = Ye(i, e), s = t, a = s.startAt, o = s.onStart, l = s.onStartParams, c = s.immediateRender, u = Zt.to(i, Ee({
                    ease: t.ease || "none",
                    lazy: !1,
                    immediateRender: !1,
                    time: r,
                    overwrite: "auto",
                    duration: t.duration || Math.abs((r - (a && "time"in a ? a.time : i._time)) / i.timeScale()) || E,
                    onStart: function() {
                        if (i.pause(),
                        !n) {
                            var e = t.duration || Math.abs((r - (a && "time"in a ? a.time : i._time)) / i.timeScale());
                            u._dur !== e && We(u, e, 0, 1).render(u._time, !0, !0),
                            n = 1
                        }
                        o && o.apply(u, l || [])
                    }
                }, t));
                return c ? u.render(0) : u
            }
            ,
            n.tweenFromTo = function(e, t, n) {
                return this.tweenTo(t, Ee({
                    startAt: {
                        time: Ye(this, e)
                    }
                }, n))
            }
            ,
            n.recent = function() {
                return this._recent
            }
            ,
            n.nextLabel = function(e) {
                return void 0 === e && (e = this._time),
                dt(this, Ye(this, e))
            }
            ,
            n.previousLabel = function(e) {
                return void 0 === e && (e = this._time),
                dt(this, Ye(this, e), 1)
            }
            ,
            n.currentLabel = function(e) {
                return arguments.length ? this.seek(e, !0) : this.previousLabel(this._time + E)
            }
            ,
            n.shiftChildren = function(e, t, n) {
                void 0 === n && (n = 0);
                for (var i, r = this._first, s = this.labels; r; )
                    r._start >= n && (r._start += e,
                    r._end += e),
                    r = r._next;
                if (t)
                    for (i in s)
                        s[i] >= n && (s[i] += e);
                return Re(this)
            }
            ,
            n.invalidate = function(t) {
                var n = this._first;
                for (this._lock = 0; n; )
                    n.invalidate(t),
                    n = n._next;
                return e.prototype.invalidate.call(this, t)
            }
            ,
            n.clear = function(e) {
                void 0 === e && (e = !0);
                for (var t, n = this._first; n; )
                    t = n._next,
                    this.remove(n),
                    n = t;
                return this._dp && (this._time = this._tTime = this._pTime = 0),
                e && (this.labels = {}),
                Re(this)
            }
            ,
            n.totalDuration = function(e) {
                var t, n, i, r = 0, s = this, a = s._last, o = b;
                if (arguments.length)
                    return s.timeScale((s._repeat < 0 ? s.duration() : s.totalDuration()) / (s.reversed() ? -e : e));
                if (s._dirty) {
                    for (i = s.parent; a; )
                        t = a._prev,
                        a._dirty && a.totalDuration(),
                        (n = a._start) > o && s._sort && a._ts && !s._lock ? (s._lock = 1,
                        ke(s, a, n - a._delay, 1)._lock = 0) : o = n,
                        n < 0 && a._ts && (r -= n,
                        (!i && !s._dp || i && i.smoothChildTiming) && (s._start += n / s._ts,
                        s._time -= n,
                        s._tTime -= n),
                        s.shiftChildren(-n, !1, -Infinity),
                        o = 0),
                        a._end > r && a._ts && (r = a._end),
                        a = t;
                    We(s, s === l && s._time > r ? s._time : r, 1, 1),
                    s._dirty = 0
                }
                return s._tDur
            }
            ,
            t.updateRoot = function(e) {
                if (l._ts && (xe(l, Fe(e, l)),
                p = It.frame),
                It.frame >= le) {
                    le += x.autoSleep || 120;
                    var t = l._first;
                    if ((!t || !t._ts) && x.autoSleep && It._listeners.length < 2) {
                        for (; t && !t._ts; )
                            t = t._next;
                        t || It.sleep()
                    }
                }
            }
            ,
            t
        }(kt);
        Ee(Gt.prototype, {
            _lock: 0,
            _hasPause: 0,
            _forcing: 0
        });
        var Ht, zt, Vt = function(e, t, n, i, r, s, a) {
            var o, l, c, u, h, d, p, f, A = new pn(this._pt,e,t,0,1,on,null,r), g = 0, m = 0;
            for (A.b = n,
            A.e = i,
            n += "",
            (p = ~(i += "").indexOf("random(")) && (i = ut(i)),
            s && (s(f = [n, i], e, t),
            n = f[0],
            i = f[1]),
            l = n.match(z) || []; o = z.exec(i); )
                u = o[0],
                h = i.substring(g, o.index),
                c ? c = (c + 1) % 5 : "rgba(" === h.substr(-5) && (c = 1),
                u !== l[m++] && (d = parseFloat(l[m - 1]) || 0,
                A._pt = {
                    _next: A._pt,
                    p: h || 1 === m ? h : ",",
                    s: d,
                    c: "=" === u.charAt(1) ? me(d, u) - d : parseFloat(u) - d,
                    m: c && c < 4 ? Math.round : 0
                },
                g = z.lastIndex);
            return A.c = g < i.length ? i.substring(g, i.length) : "",
            A.fp = a,
            (V.test(i) || p) && (A.e = 0),
            this._pt = A,
            A
        }, Wt = function(e, t, n, i, r, s, a, o, l, c) {
            R(i) && (i = i(r || 0, e, s));
            var u, h = e[t], d = "get" !== n ? n : R(h) ? l ? e[t.indexOf("set") || !R(e["get" + t.substr(3)]) ? t : "get" + t.substr(3)](l) : e[t]() : h, p = R(h) ? l ? tn : en : $t;
            if (B(i) && (~i.indexOf("random(") && (i = ut(i)),
            "=" === i.charAt(1) && ((u = me(d, i) + (Ze(d) || 0)) || 0 === u) && (i = u)),
            !c || d !== i || zt)
                return isNaN(d * i) || "" === i ? (!h && !(t in e) && K(t, i),
                Vt.call(this, e, t, d, i, p, o || x.stringFilter, l)) : (u = new pn(this._pt,e,t,+d || 0,i - (d || 0),"boolean" == typeof h ? an : sn,0,p),
                l && (u.fp = l),
                a && u.modifier(a, this, e),
                this._pt = u)
        }, jt = function(e, t, n, i, r, s) {
            var a, o, l, c;
            if (ae[e] && !1 !== (a = new ae[e]).init(r, a.rawVars ? t[e] : function(e, t, n, i, r) {
                if (R(e) && (e = Xt(e, r, t, n, i)),
                !L(e) || e.style && e.nodeType || Q(e) || O(e))
                    return B(e) ? Xt(e, r, t, n, i) : e;
                var s, a = {};
                for (s in e)
                    a[s] = Xt(e[s], r, t, n, i);
                return a
            }(t[e], i, r, s, n), n, i, s) && (n._pt = o = new pn(n._pt,r,e,0,1,a.render,a,0,a.priority),
            n !== f))
                for (l = n._ptLookup[n._targets.indexOf(r)],
                c = a._props.length; c--; )
                    l[a._props[c]] = o;
            return a
        }, qt = function e(t, n, i) {
            var r, o, c, u, h, d, p, f, A, g, m, v, y, x = t.vars, w = x.ease, C = x.startAt, I = x.immediateRender, S = x.lazy, M = x.onUpdate, T = x.runBackwards, B = x.yoyoEase, R = x.keyframes, D = x.autoRevert, P = t._dur, L = t._startAt, F = t._targets, N = t.parent, O = N && "nested" === N.data ? N.vars.targets : F, Q = "auto" === t._overwrite && !s, k = t.timeline;
            if (k && (!R || !w) && (w = "none"),
            t._ease = Lt(w, _.ease),
            t._yEase = B ? Dt(Lt(!0 === B ? w : B, _.ease)) : 0,
            B && t._yoyo && !t._repeat && (B = t._yEase,
            t._yEase = t._ease,
            t._ease = B),
            t._from = !k && !!x.runBackwards,
            !k || R && !x.stagger) {
                if (v = (f = F[0] ? de(F[0]).harness : 0) && x[f.prop],
                r = Ie(x, ie),
                L && (L._zTime < 0 && L.progress(1),
                n < 0 && T && I && !D ? L.render(-1, !0) : L.revert(T && P ? te : ee),
                L._lazy = 0),
                C) {
                    if (Be(t._startAt = Zt.set(F, Ee({
                        data: "isStart",
                        overwrite: !1,
                        parent: N,
                        immediateRender: !0,
                        lazy: !L && U(S),
                        startAt: null,
                        delay: 0,
                        onUpdate: M && function() {
                            return pt(t, "onUpdate")
                        }
                        ,
                        stagger: 0
                    }, C))),
                    t._startAt._dp = 0,
                    t._startAt._sat = t,
                    n < 0 && (a || !I && !D) && t._startAt.revert(te),
                    I && P && n <= 0 && i <= 0)
                        return void (n && (t._zTime = n))
                } else if (T && P && !L)
                    if (n && (I = !1),
                    c = Ee({
                        overwrite: !1,
                        data: "isFromStart",
                        lazy: I && !L && U(S),
                        immediateRender: I,
                        stagger: 0,
                        parent: N
                    }, r),
                    v && (c[f.prop] = v),
                    Be(t._startAt = Zt.set(F, c)),
                    t._startAt._dp = 0,
                    t._startAt._sat = t,
                    n < 0 && (a ? t._startAt.revert(te) : t._startAt.render(-1, !0)),
                    t._zTime = n,
                    I) {
                        if (!n)
                            return
                    } else
                        e(t._startAt, E, E);
                for (t._pt = t._ptCache = 0,
                S = P && U(S) || S && !P,
                o = 0; o < F.length; o++) {
                    if (p = (h = F[o])._gsap || he(F)[o]._gsap,
                    t._ptLookup[o] = g = {},
                    se[p.id] && re.length && ye(),
                    m = O === F ? o : O.indexOf(h),
                    f && !1 !== (A = new f).init(h, v || r, t, m, O) && (t._pt = u = new pn(t._pt,h,A.name,0,1,A.render,A,0,A.priority),
                    A._props.forEach((function(e) {
                        g[e] = u
                    }
                    )),
                    A.priority && (d = 1)),
                    !f || v)
                        for (c in r)
                            ae[c] && (A = jt(c, r, t, m, h, O)) ? A.priority && (d = 1) : g[c] = u = Wt.call(t, h, c, "get", r[c], m, O, 0, x.stringFilter);
                    t._op && t._op[o] && t.kill(h, t._op[o]),
                    Q && t._pt && (Ht = t,
                    l.killTweensOf(h, g, t.globalTime(n)),
                    y = !t.parent,
                    Ht = 0),
                    t._pt && S && (se[p.id] = 1)
                }
                d && dn(t),
                t._onInit && t._onInit(t)
            }
            t._onUpdate = M,
            t._initted = (!t._op || t._pt) && !y,
            R && n <= 0 && k.render(b, !0, !0)
        }, Yt = function(e, t, n, i) {
            var r, s, a = t.ease || i || "power1.inOut";
            if (Q(t))
                s = n[e] || (n[e] = []),
                t.forEach((function(e, n) {
                    return s.push({
                        t: n / (t.length - 1) * 100,
                        v: e,
                        e: a
                    })
                }
                ));
            else
                for (r in t)
                    s = n[r] || (n[r] = []),
                    "ease" === r || s.push({
                        t: parseFloat(e),
                        v: t[r],
                        e: a
                    })
        }, Xt = function(e, t, n, i, r) {
            return R(e) ? e.call(t, n, i, r) : B(e) && ~e.indexOf("random(") ? ut(e) : e
        }, Kt = ue + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert", Jt = {};
        fe(Kt + ",id,stagger,delay,duration,paused,scrollTrigger", (function(e) {
            return Jt[e] = 1
        }
        ));
        var Zt = function(e) {
            function t(t, n, r, a) {
                var o;
                "number" == typeof n && (r.duration = n,
                n = r,
                r = null);
                var c, u, h, d, p, f, A, g, m = (o = e.call(this, a ? n : Se(n)) || this).vars, v = m.duration, y = m.delay, _ = m.immediateRender, b = m.stagger, E = m.overwrite, w = m.keyframes, C = m.defaults, I = m.scrollTrigger, S = m.yoyoEase, M = n.parent || l, T = (Q(t) || O(t) ? D(t[0]) : "length"in n) ? [t] : nt(t);
                if (o._targets = T.length ? he(T) : J("GSAP target " + t + " not found. https://gsap.com", !x.nullTargetWarn) || [],
                o._ptLookup = [],
                o._overwrite = E,
                w || b || N(v) || N(y)) {
                    if (n = o.vars,
                    (c = o.timeline = new Gt({
                        data: "nested",
                        defaults: C || {},
                        targets: M && "nested" === M.data ? M.vars.targets : T
                    })).kill(),
                    c.parent = c._dp = i(o),
                    c._start = 0,
                    b || N(v) || N(y)) {
                        if (d = T.length,
                        A = b && st(b),
                        L(b))
                            for (p in b)
                                ~Kt.indexOf(p) && (g || (g = {}),
                                g[p] = b[p]);
                        for (u = 0; u < d; u++)
                            (h = Ie(n, Jt)).stagger = 0,
                            S && (h.yoyoEase = S),
                            g && we(h, g),
                            f = T[u],
                            h.duration = +Xt(v, i(o), u, f, T),
                            h.delay = (+Xt(y, i(o), u, f, T) || 0) - o._delay,
                            !b && 1 === d && h.delay && (o._delay = y = h.delay,
                            o._start += y,
                            h.delay = 0),
                            c.to(f, h, A ? A(u, f, T) : 0),
                            c._ease = Mt.none;
                        c.duration() ? v = y = 0 : o.timeline = 0
                    } else if (w) {
                        Se(Ee(c.vars.defaults, {
                            ease: "none"
                        })),
                        c._ease = Lt(w.ease || n.ease || "none");
                        var B, R, P, F = 0;
                        if (Q(w))
                            w.forEach((function(e) {
                                return c.to(T, e, ">")
                            }
                            )),
                            c.duration();
                        else {
                            for (p in h = {},
                            w)
                                "ease" === p || "easeEach" === p || Yt(p, w[p], h, w.easeEach);
                            for (p in h)
                                for (B = h[p].sort((function(e, t) {
                                    return e.t - t.t
                                }
                                )),
                                F = 0,
                                u = 0; u < B.length; u++)
                                    (P = {
                                        ease: (R = B[u]).e,
                                        duration: (R.t - (u ? B[u - 1].t : 0)) / 100 * v
                                    })[p] = R.v,
                                    c.to(T, P, F),
                                    F += P.duration;
                            c.duration() < v && c.to({}, {
                                duration: v - c.duration()
                            })
                        }
                    }
                    v || o.duration(v = c.duration())
                } else
                    o.timeline = 0;
                return !0 !== E || s || (Ht = i(o),
                l.killTweensOf(T),
                Ht = 0),
                ke(M, i(o), r),
                n.reversed && o.reverse(),
                n.paused && o.paused(!0),
                (_ || !v && !w && o._start === ge(M._time) && U(_) && Pe(i(o)) && "nested" !== M.data) && (o._tTime = -1e-8,
                o.render(Math.max(0, -y) || 0)),
                I && Ge(i(o), I),
                o
            }
            r(t, e);
            var n = t.prototype;
            return n.render = function(e, t, n) {
                var i, r, s, o, l, c, u, h, d, p = this._time, f = this._tDur, A = this._dur, g = e < 0, m = e > f - E && !g ? f : e < E ? 0 : e;
                if (A) {
                    if (m !== this._tTime || !e || n || !this._initted && this._tTime || this._startAt && this._zTime < 0 !== g) {
                        if (i = m,
                        h = this.timeline,
                        this._repeat) {
                            if (o = A + this._rDelay,
                            this._repeat < -1 && g)
                                return this.totalTime(100 * o + e, t, n);
                            if (i = ge(m % o),
                            m === f ? (s = this._repeat,
                            i = A) : ((s = ~~(m / o)) && s === ge(m / o) && (i = A,
                            s--),
                            i > A && (i = A)),
                            (c = this._yoyo && 1 & s) && (d = this._yEase,
                            i = A - i),
                            l = Ue(this._tTime, o),
                            i === p && !n && this._initted && s === l)
                                return this._tTime = m,
                                this;
                            s !== l && (h && this._yEase && Pt(h, c),
                            this.vars.repeatRefresh && !c && !this._lock && this._time !== o && this._initted && (this._lock = n = 1,
                            this.render(ge(o * s), !0).invalidate()._lock = 0))
                        }
                        if (!this._initted) {
                            if (He(this, g ? e : i, n, t, m))
                                return this._tTime = 0,
                                this;
                            if (!(p === this._time || n && this.vars.repeatRefresh && s !== l))
                                return this;
                            if (A !== this._dur)
                                return this.render(e, t, n)
                        }
                        if (this._tTime = m,
                        this._time = i,
                        !this._act && this._ts && (this._act = 1,
                        this._lazy = 0),
                        this.ratio = u = (d || this._ease)(i / A),
                        this._from && (this.ratio = u = 1 - u),
                        i && !p && !t && !s && (pt(this, "onStart"),
                        this._tTime !== m))
                            return this;
                        for (r = this._pt; r; )
                            r.r(u, r.d),
                            r = r._next;
                        h && h.render(e < 0 ? e : h._dur * h._ease(i / this._dur), t, n) || this._startAt && (this._zTime = e),
                        this._onUpdate && !t && (g && De(this, e, 0, n),
                        pt(this, "onUpdate")),
                        this._repeat && s !== l && this.vars.onRepeat && !t && this.parent && pt(this, "onRepeat"),
                        m !== this._tDur && m || this._tTime !== m || (g && !this._onUpdate && De(this, e, 0, !0),
                        (e || !A) && (m === this._tDur && this._ts > 0 || !m && this._ts < 0) && Be(this, 1),
                        t || g && !p || !(m || p || c) || (pt(this, m === f ? "onComplete" : "onReverseComplete", !0),
                        this._prom && !(m < f && this.timeScale() > 0) && this._prom()))
                    }
                } else
                    !function(e, t, n, i) {
                        var r, s, o, l = e.ratio, c = t < 0 || !t && (!e._start && ze(e) && (e._initted || !Ve(e)) || (e._ts < 0 || e._dp._ts < 0) && !Ve(e)) ? 0 : 1, u = e._rDelay, h = 0;
                        if (u && e._repeat && (h = Je(0, e._tDur, t),
                        s = Ue(h, u),
                        e._yoyo && 1 & s && (c = 1 - c),
                        s !== Ue(e._tTime, u) && (l = 1 - c,
                        e.vars.repeatRefresh && e._initted && e.invalidate())),
                        c !== l || a || i || e._zTime === E || !t && e._zTime) {
                            if (!e._initted && He(e, t, i, n, h))
                                return;
                            for (o = e._zTime,
                            e._zTime = t || (n ? E : 0),
                            n || (n = t && !o),
                            e.ratio = c,
                            e._from && (c = 1 - c),
                            e._time = 0,
                            e._tTime = h,
                            r = e._pt; r; )
                                r.r(c, r.d),
                                r = r._next;
                            t < 0 && De(e, t, 0, !0),
                            e._onUpdate && !n && pt(e, "onUpdate"),
                            h && e._repeat && !n && e.parent && pt(e, "onRepeat"),
                            (t >= e._tDur || t < 0) && e.ratio === c && (c && Be(e, 1),
                            n || a || (pt(e, c ? "onComplete" : "onReverseComplete", !0),
                            e._prom && e._prom()))
                        } else
                            e._zTime || (e._zTime = t)
                    }(this, e, t, n);
                return this
            }
            ,
            n.targets = function() {
                return this._targets
            }
            ,
            n.invalidate = function(t) {
                return (!t || !this.vars.runBackwards) && (this._startAt = 0),
                this._pt = this._op = this._onUpdate = this._lazy = this.ratio = 0,
                this._ptLookup = [],
                this.timeline && this.timeline.invalidate(t),
                e.prototype.invalidate.call(this, t)
            }
            ,
            n.resetTo = function(e, t, n, i, r) {
                A || It.wake(),
                this._ts || this.play();
                var s = Math.min(this._dur, (this._dp._time - this._start) * this._ts);
                return this._initted || qt(this, s),
                function(e, t, n, i, r, s, a, o) {
                    var l, c, u, h, d = (e._pt && e._ptCache || (e._ptCache = {}))[t];
                    if (!d)
                        for (d = e._ptCache[t] = [],
                        u = e._ptLookup,
                        h = e._targets.length; h--; ) {
                            if ((l = u[h][t]) && l.d && l.d._pt)
                                for (l = l.d._pt; l && l.p !== t && l.fp !== t; )
                                    l = l._next;
                            if (!l)
                                return zt = 1,
                                e.vars[t] = "+=0",
                                qt(e, a),
                                zt = 0,
                                o ? J(t + " not eligible for reset") : 1;
                            d.push(l)
                        }
                    for (h = d.length; h--; )
                        (l = (c = d[h])._pt || c).s = !i && 0 !== i || r ? l.s + (i || 0) + s * l.c : i,
                        l.c = n - l.s,
                        c.e && (c.e = Ae(n) + Ze(c.e)),
                        c.b && (c.b = l.s + Ze(c.b))
                }(this, e, t, n, i, this._ease(s / this._dur), s, r) ? this.resetTo(e, t, n, i, 1) : (Oe(this, 0),
                this.parent || Me(this._dp, this, "_first", "_last", this._dp._sort ? "_start" : 0),
                this.render(0))
            }
            ,
            n.kill = function(e, t) {
                if (void 0 === t && (t = "all"),
                !(e || t && "all" !== t))
                    return this._lazy = this._pt = 0,
                    this.parent ? ft(this) : this;
                if (this.timeline) {
                    var n = this.timeline.totalDuration();
                    return this.timeline.killTweensOf(e, t, Ht && !0 !== Ht.vars.overwrite)._first || ft(this),
                    this.parent && n !== this.timeline.totalDuration() && We(this, this._dur * this.timeline._tDur / n, 0, 1),
                    this
                }
                var i, r, s, a, o, l, c, u = this._targets, h = e ? nt(e) : u, d = this._ptLookup, p = this._pt;
                if ((!t || "all" === t) && function(e, t) {
                    for (var n = e.length, i = n === t.length; i && n-- && e[n] === t[n]; )
                        ;
                    return n < 0
                }(u, h))
                    return "all" === t && (this._pt = 0),
                    ft(this);
                for (i = this._op = this._op || [],
                "all" !== t && (B(t) && (o = {},
                fe(t, (function(e) {
                    return o[e] = 1
                }
                )),
                t = o),
                t = function(e, t) {
                    var n, i, r, s, a = e[0] ? de(e[0]).harness : 0, o = a && a.aliases;
                    if (!o)
                        return t;
                    for (i in n = we({}, t),
                    o)
                        if (i in n)
                            for (r = (s = o[i].split(",")).length; r--; )
                                n[s[r]] = n[i];
                    return n
                }(u, t)),
                c = u.length; c--; )
                    if (~h.indexOf(u[c]))
                        for (o in r = d[c],
                        "all" === t ? (i[c] = t,
                        a = r,
                        s = {}) : (s = i[c] = i[c] || {},
                        a = t),
                        a)
                            (l = r && r[o]) && ("kill"in l.d && !0 !== l.d.kill(o) || Te(this, l, "_pt"),
                            delete r[o]),
                            "all" !== s && (s[o] = 1);
                return this._initted && !this._pt && p && ft(this),
                this
            }
            ,
            t.to = function(e, n) {
                return new t(e,n,arguments[2])
            }
            ,
            t.from = function(e, t) {
                return Xe(1, arguments)
            }
            ,
            t.delayedCall = function(e, n, i, r) {
                return new t(n,0,{
                    immediateRender: !1,
                    lazy: !1,
                    overwrite: !1,
                    delay: e,
                    onComplete: n,
                    onReverseComplete: n,
                    onCompleteParams: i,
                    onReverseCompleteParams: i,
                    callbackScope: r
                })
            }
            ,
            t.fromTo = function(e, t, n) {
                return Xe(2, arguments)
            }
            ,
            t.set = function(e, n) {
                return n.duration = 0,
                n.repeatDelay || (n.repeat = 0),
                new t(e,n)
            }
            ,
            t.killTweensOf = function(e, t, n) {
                return l.killTweensOf(e, t, n)
            }
            ,
            t
        }(kt);
        Ee(Zt.prototype, {
            _targets: [],
            _lazy: 0,
            _startAt: 0,
            _op: 0,
            _onInit: 0
        }),
        fe("staggerTo,staggerFrom,staggerFromTo", (function(e) {
            Zt[e] = function() {
                var t = new Gt
                  , n = $e.call(arguments, 0);
                return n.splice("staggerFromTo" === e ? 5 : 4, 0, 0),
                t[e].apply(t, n)
            }
        }
        ));
        var $t = function(e, t, n) {
            return e[t] = n
        }
          , en = function(e, t, n) {
            return e[t](n)
        }
          , tn = function(e, t, n, i) {
            return e[t](i.fp, n)
        }
          , nn = function(e, t, n) {
            return e.setAttribute(t, n)
        }
          , rn = function(e, t) {
            return R(e[t]) ? en : P(e[t]) && e.setAttribute ? nn : $t
        }
          , sn = function(e, t) {
            return t.set(t.t, t.p, Math.round(1e6 * (t.s + t.c * e)) / 1e6, t)
        }
          , an = function(e, t) {
            return t.set(t.t, t.p, !!(t.s + t.c * e), t)
        }
          , on = function(e, t) {
            var n = t._pt
              , i = "";
            if (!e && t.b)
                i = t.b;
            else if (1 === e && t.e)
                i = t.e;
            else {
                for (; n; )
                    i = n.p + (n.m ? n.m(n.s + n.c * e) : Math.round(1e4 * (n.s + n.c * e)) / 1e4) + i,
                    n = n._next;
                i += t.c
            }
            t.set(t.t, t.p, i, t)
        }
          , ln = function(e, t) {
            for (var n = t._pt; n; )
                n.r(e, n.d),
                n = n._next
        }
          , cn = function(e, t, n, i) {
            for (var r, s = this._pt; s; )
                r = s._next,
                s.p === i && s.modifier(e, t, n),
                s = r
        }
          , un = function(e) {
            for (var t, n, i = this._pt; i; )
                n = i._next,
                i.p === e && !i.op || i.op === e ? Te(this, i, "_pt") : i.dep || (t = 1),
                i = n;
            return !t
        }
          , hn = function(e, t, n, i) {
            i.mSet(e, t, i.m.call(i.tween, n, i.mt), i)
        }
          , dn = function(e) {
            for (var t, n, i, r, s = e._pt; s; ) {
                for (t = s._next,
                n = i; n && n.pr > s.pr; )
                    n = n._next;
                (s._prev = n ? n._prev : r) ? s._prev._next = s : i = s,
                (s._next = n) ? n._prev = s : r = s,
                s = t
            }
            e._pt = i
        }
          , pn = function() {
            function e(e, t, n, i, r, s, a, o, l) {
                this.t = t,
                this.s = i,
                this.c = r,
                this.p = n,
                this.r = s || sn,
                this.d = a || this,
                this.set = o || $t,
                this.pr = l || 0,
                this._next = e,
                e && (e._prev = this)
            }
            return e.prototype.modifier = function(e, t, n) {
                this.mSet = this.mSet || this.set,
                this.set = hn,
                this.m = e,
                this.mt = n,
                this.tween = t
            }
            ,
            e
        }();
        fe(ue + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", (function(e) {
            return ie[e] = 1
        }
        )),
        q.TweenMax = q.TweenLite = Zt,
        q.TimelineLite = q.TimelineMax = Gt,
        l = new Gt({
            sortChildren: !1,
            defaults: _,
            autoRemoveChildren: !0,
            id: "root",
            smoothChildTiming: !0
        }),
        x.stringFilter = Ct;
        var fn = []
          , An = {}
          , gn = []
          , mn = 0
          , vn = 0
          , yn = function(e) {
            return (An[e] || gn).map((function(e) {
                return e()
            }
            ))
        }
          , xn = function() {
            var e = Date.now()
              , t = [];
            e - mn > 2 && (yn("matchMediaInit"),
            fn.forEach((function(e) {
                var n, i, r, s, a = e.queries, o = e.conditions;
                for (i in a)
                    (n = c.matchMedia(a[i]).matches) && (r = 1),
                    n !== o[i] && (o[i] = n,
                    s = 1);
                s && (e.revert(),
                r && t.push(e))
            }
            )),
            yn("matchMediaRevert"),
            t.forEach((function(e) {
                return e.onMatch(e, (function(t) {
                    return e.add(null, t)
                }
                ))
            }
            )),
            mn = e,
            yn("matchMedia"))
        }
          , _n = function() {
            function e(e, t) {
                this.selector = t && it(t),
                this.data = [],
                this._r = [],
                this.isReverted = !1,
                this.id = vn++,
                e && this.add(e)
            }
            var t = e.prototype;
            return t.add = function(e, t, n) {
                R(e) && (n = t,
                t = e,
                e = R);
                var i = this
                  , r = function() {
                    var e, r = o, s = i.selector;
                    return r && r !== i && r.data.push(i),
                    n && (i.selector = it(n)),
                    o = i,
                    e = t.apply(i, arguments),
                    R(e) && i._r.push(e),
                    o = r,
                    i.selector = s,
                    i.isReverted = !1,
                    e
                };
                return i.last = r,
                e === R ? r(i, (function(e) {
                    return i.add(null, e)
                }
                )) : e ? i[e] = r : r
            }
            ,
            t.ignore = function(e) {
                var t = o;
                o = null,
                e(this),
                o = t
            }
            ,
            t.getTweens = function() {
                var t = [];
                return this.data.forEach((function(n) {
                    return n instanceof e ? t.push.apply(t, n.getTweens()) : n instanceof Zt && !(n.parent && "nested" === n.parent.data) && t.push(n)
                }
                )),
                t
            }
            ,
            t.clear = function() {
                this._r.length = this.data.length = 0
            }
            ,
            t.kill = function(e, t) {
                var n = this;
                if (e ? function() {
                    for (var t, i = n.getTweens(), r = n.data.length; r--; )
                        "isFlip" === (t = n.data[r]).data && (t.revert(),
                        t.getChildren(!0, !0, !1).forEach((function(e) {
                            return i.splice(i.indexOf(e), 1)
                        }
                        )));
                    for (i.map((function(e) {
                        return {
                            g: e._dur || e._delay || e._sat && !e._sat.vars.immediateRender ? e.globalTime(0) : -1 / 0,
                            t: e
                        }
                    }
                    )).sort((function(e, t) {
                        return t.g - e.g || -1 / 0
                    }
                    )).forEach((function(t) {
                        return t.t.revert(e)
                    }
                    )),
                    r = n.data.length; r--; )
                        (t = n.data[r])instanceof Gt ? "nested" !== t.data && (t.scrollTrigger && t.scrollTrigger.revert(),
                        t.kill()) : !(t instanceof Zt) && t.revert && t.revert(e);
                    n._r.forEach((function(t) {
                        return t(e, n)
                    }
                    )),
                    n.isReverted = !0
                }() : this.data.forEach((function(e) {
                    return e.kill && e.kill()
                }
                )),
                this.clear(),
                t)
                    for (var i = fn.length; i--; )
                        fn[i].id === this.id && fn.splice(i, 1)
            }
            ,
            t.revert = function(e) {
                this.kill(e || {})
            }
            ,
            e
        }()
          , bn = function() {
            function e(e) {
                this.contexts = [],
                this.scope = e,
                o && o.data.push(this)
            }
            var t = e.prototype;
            return t.add = function(e, t, n) {
                L(e) || (e = {
                    matches: e
                });
                var i, r, s, a = new _n(0,n || this.scope), l = a.conditions = {};
                for (r in o && !a.selector && (a.selector = o.selector),
                this.contexts.push(a),
                t = a.add("onMatch", t),
                a.queries = e,
                e)
                    "all" === r ? s = 1 : (i = c.matchMedia(e[r])) && (fn.indexOf(a) < 0 && fn.push(a),
                    (l[r] = i.matches) && (s = 1),
                    i.addListener ? i.addListener(xn) : i.addEventListener("change", xn));
                return s && t(a, (function(e) {
                    return a.add(null, e)
                }
                )),
                this
            }
            ,
            t.revert = function(e) {
                this.kill(e || {})
            }
            ,
            t.kill = function(e) {
                this.contexts.forEach((function(t) {
                    return t.kill(e, !0)
                }
                ))
            }
            ,
            e
        }()
          , En = {
            registerPlugin: function() {
                for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
                    t[n] = arguments[n];
                t.forEach((function(e) {
                    return gt(e)
                }
                ))
            },
            timeline: function(e) {
                return new Gt(e)
            },
            getTweensOf: function(e, t) {
                return l.getTweensOf(e, t)
            },
            getProperty: function(e, t, n, i) {
                B(e) && (e = nt(e)[0]);
                var r = de(e || {}).get
                  , s = n ? be : _e;
                return "native" === n && (n = ""),
                e ? t ? s((ae[t] && ae[t].get || r)(e, t, n, i)) : function(t, n, i) {
                    return s((ae[t] && ae[t].get || r)(e, t, n, i))
                }
                : e
            },
            quickSetter: function(e, t, n) {
                if ((e = nt(e)).length > 1) {
                    var i = e.map((function(e) {
                        return In.quickSetter(e, t, n)
                    }
                    ))
                      , r = i.length;
                    return function(e) {
                        for (var t = r; t--; )
                            i[t](e)
                    }
                }
                e = e[0] || {};
                var s = ae[t]
                  , a = de(e)
                  , o = a.harness && (a.harness.aliases || {})[t] || t
                  , l = s ? function(t) {
                    var i = new s;
                    f._pt = 0,
                    i.init(e, n ? t + n : t, f, 0, [e]),
                    i.render(1, i),
                    f._pt && ln(1, f)
                }
                : a.set(e, o);
                return s ? l : function(t) {
                    return l(e, o, n ? t + n : t, a, 1)
                }
            },
            quickTo: function(e, t, n) {
                var i, r = In.to(e, we(((i = {})[t] = "+=0.1",
                i.paused = !0,
                i), n || {})), s = function(e, n, i) {
                    return r.resetTo(t, e, n, i)
                };
                return s.tween = r,
                s
            },
            isTweening: function(e) {
                return l.getTweensOf(e, !0).length > 0
            },
            defaults: function(e) {
                return e && e.ease && (e.ease = Lt(e.ease, _.ease)),
                Ce(_, e || {})
            },
            config: function(e) {
                return Ce(x, e || {})
            },
            registerEffect: function(e) {
                var t = e.name
                  , n = e.effect
                  , i = e.plugins
                  , r = e.defaults
                  , s = e.extendTimeline;
                (i || "").split(",").forEach((function(e) {
                    return e && !ae[e] && !q[e] && J(t + " effect requires " + e + " plugin.")
                }
                )),
                oe[t] = function(e, t, i) {
                    return n(nt(e), Ee(t || {}, r), i)
                }
                ,
                s && (Gt.prototype[t] = function(e, n, i) {
                    return this.add(oe[t](e, L(n) ? n : (i = n) && {}, this), i)
                }
                )
            },
            registerEase: function(e, t) {
                Mt[e] = Lt(t)
            },
            parseEase: function(e, t) {
                return arguments.length ? Lt(e, t) : Mt
            },
            getById: function(e) {
                return l.getById(e)
            },
            exportRoot: function(e, t) {
                void 0 === e && (e = {});
                var n, i, r = new Gt(e);
                for (r.smoothChildTiming = U(e.smoothChildTiming),
                l.remove(r),
                r._dp = 0,
                r._time = r._tTime = l._time,
                n = l._first; n; )
                    i = n._next,
                    !t && !n._dur && n instanceof Zt && n.vars.onComplete === n._targets[0] || ke(r, n, n._start - n._delay),
                    n = i;
                return ke(l, r, 0),
                r
            },
            context: function(e, t) {
                return e ? new _n(e,t) : o
            },
            matchMedia: function(e) {
                return new bn(e)
            },
            matchMediaRefresh: function() {
                return fn.forEach((function(e) {
                    var t, n, i = e.conditions;
                    for (n in i)
                        i[n] && (i[n] = !1,
                        t = 1);
                    t && e.revert()
                }
                )) || xn()
            },
            addEventListener: function(e, t) {
                var n = An[e] || (An[e] = []);
                ~n.indexOf(t) || n.push(t)
            },
            removeEventListener: function(e, t) {
                var n = An[e]
                  , i = n && n.indexOf(t);
                i >= 0 && n.splice(i, 1)
            },
            utils: {
                wrap: function e(t, n, i) {
                    var r = n - t;
                    return Q(t) ? ct(t, e(0, t.length), n) : Ke(i, (function(e) {
                        return (r + (e - t) % r) % r + t
                    }
                    ))
                },
                wrapYoyo: function e(t, n, i) {
                    var r = n - t
                      , s = 2 * r;
                    return Q(t) ? ct(t, e(0, t.length - 1), n) : Ke(i, (function(e) {
                        return t + ((e = (s + (e - t) % s) % s || 0) > r ? s - e : e)
                    }
                    ))
                },
                distribute: st,
                random: lt,
                snap: ot,
                normalize: function(e, t, n) {
                    return ht(e, t, 0, 1, n)
                },
                getUnit: Ze,
                clamp: function(e, t, n) {
                    return Ke(n, (function(n) {
                        return Je(e, t, n)
                    }
                    ))
                },
                splitColor: xt,
                toArray: nt,
                selector: it,
                mapRange: ht,
                pipe: function() {
                    for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
                        t[n] = arguments[n];
                    return function(e) {
                        return t.reduce((function(e, t) {
                            return t(e)
                        }
                        ), e)
                    }
                },
                unitize: function(e, t) {
                    return function(n) {
                        return e(parseFloat(n)) + (t || Ze(n))
                    }
                },
                interpolate: function e(t, n, i, r) {
                    var s = isNaN(t + n) ? 0 : function(e) {
                        return (1 - e) * t + e * n
                    }
                    ;
                    if (!s) {
                        var a, o, l, c, u, h = B(t), d = {};
                        if (!0 === i && (r = 1) && (i = null),
                        h)
                            t = {
                                p: t
                            },
                            n = {
                                p: n
                            };
                        else if (Q(t) && !Q(n)) {
                            for (l = [],
                            c = t.length,
                            u = c - 2,
                            o = 1; o < c; o++)
                                l.push(e(t[o - 1], t[o]));
                            c--,
                            s = function(e) {
                                e *= c;
                                var t = Math.min(u, ~~e);
                                return l[t](e - t)
                            }
                            ,
                            i = n
                        } else
                            r || (t = we(Q(t) ? [] : {}, t));
                        if (!l) {
                            for (a in n)
                                Wt.call(d, t, a, "get", n[a]);
                            s = function(e) {
                                return ln(e, d) || (h ? t.p : t)
                            }
                        }
                    }
                    return Ke(i, s)
                },
                shuffle: rt
            },
            install: X,
            effects: oe,
            ticker: It,
            updateRoot: Gt.updateRoot,
            plugins: ae,
            globalTimeline: l,
            core: {
                PropTween: pn,
                globals: Z,
                Tween: Zt,
                Timeline: Gt,
                Animation: kt,
                getCache: de,
                _removeLinkedListItem: Te,
                reverting: function() {
                    return a
                },
                context: function(e) {
                    return e && o && (o.data.push(e),
                    e._ctx = o),
                    o
                },
                suppressOverwrites: function(e) {
                    return s = e
                }
            }
        };
        fe("to,from,fromTo,delayedCall,set,killTweensOf", (function(e) {
            return En[e] = Zt[e]
        }
        )),
        It.add(Gt.updateRoot),
        f = En.to({}, {
            duration: 0
        });
        var wn = function(e, t) {
            for (var n = e._pt; n && n.p !== t && n.op !== t && n.fp !== t; )
                n = n._next;
            return n
        }
          , Cn = function(e, t) {
            return {
                name: e,
                rawVars: 1,
                init: function(e, n, i) {
                    i._onInit = function(e) {
                        var i, r;
                        if (B(n) && (i = {},
                        fe(n, (function(e) {
                            return i[e] = 1
                        }
                        )),
                        n = i),
                        t) {
                            for (r in i = {},
                            n)
                                i[r] = t(n[r]);
                            n = i
                        }
                        !function(e, t) {
                            var n, i, r, s = e._targets;
                            for (n in t)
                                for (i = s.length; i--; )
                                    (r = e._ptLookup[i][n]) && (r = r.d) && (r._pt && (r = wn(r, n)),
                                    r && r.modifier && r.modifier(t[n], e, s[i], n))
                        }(e, n)
                    }
                }
            }
        }
          , In = En.registerPlugin({
            name: "attr",
            init: function(e, t, n, i, r) {
                var s, a, o;
                for (s in this.tween = n,
                t)
                    o = e.getAttribute(s) || "",
                    (a = this.add(e, "setAttribute", (o || 0) + "", t[s], i, r, 0, 0, s)).op = s,
                    a.b = o,
                    this._props.push(s)
            },
            render: function(e, t) {
                for (var n = t._pt; n; )
                    a ? n.set(n.t, n.p, n.b, n) : n.r(e, n.d),
                    n = n._next
            }
        }, {
            name: "endArray",
            init: function(e, t) {
                for (var n = t.length; n--; )
                    this.add(e, n, e[n] || 0, t[n], 0, 0, 0, 0, 0, 1)
            }
        }, Cn("roundProps", at), Cn("modifiers"), Cn("snap", ot)) || En;
        Zt.version = Gt.version = In.version = "3.12.5",
        d = 1,
        F() && St();
        Mt.Power0,
        Mt.Power1,
        Mt.Power2,
        Mt.Power3,
        Mt.Power4,
        Mt.Linear,
        Mt.Quad,
        Mt.Cubic,
        Mt.Quart,
        Mt.Quint,
        Mt.Strong,
        Mt.Elastic,
        Mt.Back,
        Mt.SteppedEase,
        Mt.Bounce,
        Mt.Sine,
        Mt.Expo,
        Mt.Circ;
        var Sn, Mn, Tn, Bn, Rn, Dn, Pn, Ln, Un = {}, Fn = 180 / Math.PI, Nn = Math.PI / 180, On = Math.atan2, Qn = /([A-Z])/g, kn = /(left|right|width|margin|padding|x)/i, Gn = /[\s,\(]\S/, Hn = {
            autoAlpha: "opacity,visibility",
            scale: "scaleX,scaleY",
            alpha: "opacity"
        }, zn = function(e, t) {
            return t.set(t.t, t.p, Math.round(1e4 * (t.s + t.c * e)) / 1e4 + t.u, t)
        }, Vn = function(e, t) {
            return t.set(t.t, t.p, 1 === e ? t.e : Math.round(1e4 * (t.s + t.c * e)) / 1e4 + t.u, t)
        }, Wn = function(e, t) {
            return t.set(t.t, t.p, e ? Math.round(1e4 * (t.s + t.c * e)) / 1e4 + t.u : t.b, t)
        }, jn = function(e, t) {
            var n = t.s + t.c * e;
            t.set(t.t, t.p, ~~(n + (n < 0 ? -.5 : .5)) + t.u, t)
        }, qn = function(e, t) {
            return t.set(t.t, t.p, e ? t.e : t.b, t)
        }, Yn = function(e, t) {
            return t.set(t.t, t.p, 1 !== e ? t.b : t.e, t)
        }, Xn = function(e, t, n) {
            return e.style[t] = n
        }, Kn = function(e, t, n) {
            return e.style.setProperty(t, n)
        }, Jn = function(e, t, n) {
            return e._gsap[t] = n
        }, Zn = function(e, t, n) {
            return e._gsap.scaleX = e._gsap.scaleY = n
        }, $n = function(e, t, n, i, r) {
            var s = e._gsap;
            s.scaleX = s.scaleY = n,
            s.renderTransform(r, s)
        }, ei = function(e, t, n, i, r) {
            var s = e._gsap;
            s[t] = n,
            s.renderTransform(r, s)
        }, ti = "transform", ni = ti + "Origin", ii = function e(t, n) {
            var i = this
              , r = this.target
              , s = r.style
              , a = r._gsap;
            if (t in Un && s) {
                if (this.tfm = this.tfm || {},
                "transform" === t)
                    return Hn.transform.split(",").forEach((function(t) {
                        return e.call(i, t, n)
                    }
                    ));
                if (~(t = Hn[t] || t).indexOf(",") ? t.split(",").forEach((function(e) {
                    return i.tfm[e] = _i(r, e)
                }
                )) : this.tfm[t] = a.x ? a[t] : _i(r, t),
                t === ni && (this.tfm.zOrigin = a.zOrigin),
                this.props.indexOf(ti) >= 0)
                    return;
                a.svg && (this.svgo = r.getAttribute("data-svg-origin"),
                this.props.push(ni, n, "")),
                t = ti
            }
            (s || n) && this.props.push(t, n, s[t])
        }, ri = function(e) {
            e.translate && (e.removeProperty("translate"),
            e.removeProperty("scale"),
            e.removeProperty("rotate"))
        }, si = function() {
            var e, t, n = this.props, i = this.target, r = i.style, s = i._gsap;
            for (e = 0; e < n.length; e += 3)
                n[e + 1] ? i[n[e]] = n[e + 2] : n[e + 2] ? r[n[e]] = n[e + 2] : r.removeProperty("--" === n[e].substr(0, 2) ? n[e] : n[e].replace(Qn, "-$1").toLowerCase());
            if (this.tfm) {
                for (t in this.tfm)
                    s[t] = this.tfm[t];
                s.svg && (s.renderTransform(),
                i.setAttribute("data-svg-origin", this.svgo || "")),
                (e = Pn()) && e.isStart || r[ti] || (ri(r),
                s.zOrigin && r[ni] && (r[ni] += " " + s.zOrigin + "px",
                s.zOrigin = 0,
                s.renderTransform()),
                s.uncache = 1)
            }
        }, ai = function(e, t) {
            var n = {
                target: e,
                props: [],
                revert: si,
                save: ii
            };
            return e._gsap || In.core.getCache(e),
            t && t.split(",").forEach((function(e) {
                return n.save(e)
            }
            )),
            n
        }, oi = function(e, t) {
            var n = Mn.createElementNS ? Mn.createElementNS((t || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), e) : Mn.createElement(e);
            return n && n.style ? n : Mn.createElement(e)
        }, li = function e(t, n, i) {
            var r = getComputedStyle(t);
            return r[n] || r.getPropertyValue(n.replace(Qn, "-$1").toLowerCase()) || r.getPropertyValue(n) || !i && e(t, ui(n) || n, 1) || ""
        }, ci = "O,Moz,ms,Ms,Webkit".split(","), ui = function(e, t, n) {
            var i = (t || Rn).style
              , r = 5;
            if (e in i && !n)
                return e;
            for (e = e.charAt(0).toUpperCase() + e.substr(1); r-- && !(ci[r] + e in i); )
                ;
            return r < 0 ? null : (3 === r ? "ms" : r >= 0 ? ci[r] : "") + e
        }, hi = function() {
            "undefined" != typeof window && window.document && (Sn = window,
            Mn = Sn.document,
            Tn = Mn.documentElement,
            Rn = oi("div") || {
                style: {}
            },
            oi("div"),
            ti = ui(ti),
            ni = ti + "Origin",
            Rn.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0",
            Ln = !!ui("perspective"),
            Pn = In.core.reverting,
            Bn = 1)
        }, di = function e(t) {
            var n, i = oi("svg", this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"), r = this.parentNode, s = this.nextSibling, a = this.style.cssText;
            if (Tn.appendChild(i),
            i.appendChild(this),
            this.style.display = "block",
            t)
                try {
                    n = this.getBBox(),
                    this._gsapBBox = this.getBBox,
                    this.getBBox = e
                } catch (e) {}
            else
                this._gsapBBox && (n = this._gsapBBox());
            return r && (s ? r.insertBefore(this, s) : r.appendChild(this)),
            Tn.removeChild(i),
            this.style.cssText = a,
            n
        }, pi = function(e, t) {
            for (var n = t.length; n--; )
                if (e.hasAttribute(t[n]))
                    return e.getAttribute(t[n])
        }, fi = function(e) {
            var t;
            try {
                t = e.getBBox()
            } catch (n) {
                t = di.call(e, !0)
            }
            return t && (t.width || t.height) || e.getBBox === di || (t = di.call(e, !0)),
            !t || t.width || t.x || t.y ? t : {
                x: +pi(e, ["x", "cx", "x1"]) || 0,
                y: +pi(e, ["y", "cy", "y1"]) || 0,
                width: 0,
                height: 0
            }
        }, Ai = function(e) {
            return !(!e.getCTM || e.parentNode && !e.ownerSVGElement || !fi(e))
        }, gi = function(e, t) {
            if (t) {
                var n, i = e.style;
                t in Un && t !== ni && (t = ti),
                i.removeProperty ? ("ms" !== (n = t.substr(0, 2)) && "webkit" !== t.substr(0, 6) || (t = "-" + t),
                i.removeProperty("--" === n ? t : t.replace(Qn, "-$1").toLowerCase())) : i.removeAttribute(t)
            }
        }, mi = function(e, t, n, i, r, s) {
            var a = new pn(e._pt,t,n,0,1,s ? Yn : qn);
            return e._pt = a,
            a.b = i,
            a.e = r,
            e._props.push(n),
            a
        }, vi = {
            deg: 1,
            rad: 1,
            turn: 1
        }, yi = {
            grid: 1,
            flex: 1
        }, xi = function e(t, n, i, r) {
            var s, a, o, l, c = parseFloat(i) || 0, u = (i + "").trim().substr((c + "").length) || "px", h = Rn.style, d = kn.test(n), p = "svg" === t.tagName.toLowerCase(), f = (p ? "client" : "offset") + (d ? "Width" : "Height"), A = 100, g = "px" === r, m = "%" === r;
            if (r === u || !c || vi[r] || vi[u])
                return c;
            if ("px" !== u && !g && (c = e(t, n, i, "px")),
            l = t.getCTM && Ai(t),
            (m || "%" === u) && (Un[n] || ~n.indexOf("adius")))
                return s = l ? t.getBBox()[d ? "width" : "height"] : t[f],
                Ae(m ? c / s * A : c / 100 * s);
            if (h[d ? "width" : "height"] = A + (g ? u : r),
            a = ~n.indexOf("adius") || "em" === r && t.appendChild && !p ? t : t.parentNode,
            l && (a = (t.ownerSVGElement || {}).parentNode),
            a && a !== Mn && a.appendChild || (a = Mn.body),
            (o = a._gsap) && m && o.width && d && o.time === It.time && !o.uncache)
                return Ae(c / o.width * A);
            if (!m || "height" !== n && "width" !== n)
                (m || "%" === u) && !yi[li(a, "display")] && (h.position = li(t, "position")),
                a === t && (h.position = "static"),
                a.appendChild(Rn),
                s = Rn[f],
                a.removeChild(Rn),
                h.position = "absolute";
            else {
                var v = t.style[n];
                t.style[n] = A + r,
                s = t[f],
                v ? t.style[n] = v : gi(t, n)
            }
            return d && m && ((o = de(a)).time = It.time,
            o.width = a[f]),
            Ae(g ? s * c / A : s && c ? A / s * c : 0)
        }, _i = function(e, t, n, i) {
            var r;
            return Bn || hi(),
            t in Hn && "transform" !== t && ~(t = Hn[t]).indexOf(",") && (t = t.split(",")[0]),
            Un[t] && "transform" !== t ? (r = Di(e, i),
            r = "transformOrigin" !== t ? r[t] : r.svg ? r.origin : Pi(li(e, ni)) + " " + r.zOrigin + "px") : (!(r = e.style[t]) || "auto" === r || i || ~(r + "").indexOf("calc(")) && (r = Ci[t] && Ci[t](e, t, n) || li(e, t) || pe(e, t) || ("opacity" === t ? 1 : 0)),
            n && !~(r + "").trim().indexOf(" ") ? xi(e, t, r, n) + n : r
        }, bi = function(e, t, n, i) {
            if (!n || "none" === n) {
                var r = ui(t, e, 1)
                  , s = r && li(e, r, 1);
                s && s !== n ? (t = r,
                n = s) : "borderColor" === t && (n = li(e, "borderTopColor"))
            }
            var a, o, l, c, u, h, d, p, f, A, g, m = new pn(this._pt,e.style,t,0,1,on), v = 0, y = 0;
            if (m.b = n,
            m.e = i,
            n += "",
            "auto" === (i += "") && (h = e.style[t],
            e.style[t] = i,
            i = li(e, t) || i,
            h ? e.style[t] = h : gi(e, t)),
            Ct(a = [n, i]),
            i = a[1],
            l = (n = a[0]).match(H) || [],
            (i.match(H) || []).length) {
                for (; o = H.exec(i); )
                    d = o[0],
                    f = i.substring(v, o.index),
                    u ? u = (u + 1) % 5 : "rgba(" !== f.substr(-5) && "hsla(" !== f.substr(-5) || (u = 1),
                    d !== (h = l[y++] || "") && (c = parseFloat(h) || 0,
                    g = h.substr((c + "").length),
                    "=" === d.charAt(1) && (d = me(c, d) + g),
                    p = parseFloat(d),
                    A = d.substr((p + "").length),
                    v = H.lastIndex - A.length,
                    A || (A = A || x.units[t] || g,
                    v === i.length && (i += A,
                    m.e += A)),
                    g !== A && (c = xi(e, t, h, A) || 0),
                    m._pt = {
                        _next: m._pt,
                        p: f || 1 === y ? f : ",",
                        s: c,
                        c: p - c,
                        m: u && u < 4 || "zIndex" === t ? Math.round : 0
                    });
                m.c = v < i.length ? i.substring(v, i.length) : ""
            } else
                m.r = "display" === t && "none" === i ? Yn : qn;
            return V.test(i) && (m.e = 0),
            this._pt = m,
            m
        }, Ei = {
            top: "0%",
            bottom: "100%",
            left: "0%",
            right: "100%",
            center: "50%"
        }, wi = function(e, t) {
            if (t.tween && t.tween._time === t.tween._dur) {
                var n, i, r, s = t.t, a = s.style, o = t.u, l = s._gsap;
                if ("all" === o || !0 === o)
                    a.cssText = "",
                    i = 1;
                else
                    for (r = (o = o.split(",")).length; --r > -1; )
                        n = o[r],
                        Un[n] && (i = 1,
                        n = "transformOrigin" === n ? ni : ti),
                        gi(s, n);
                i && (gi(s, ti),
                l && (l.svg && s.removeAttribute("transform"),
                Di(s, 1),
                l.uncache = 1,
                ri(a)))
            }
        }, Ci = {
            clearProps: function(e, t, n, i, r) {
                if ("isFromStart" !== r.data) {
                    var s = e._pt = new pn(e._pt,t,n,0,0,wi);
                    return s.u = i,
                    s.pr = -10,
                    s.tween = r,
                    e._props.push(n),
                    1
                }
            }
        }, Ii = [1, 0, 0, 1, 0, 0], Si = {}, Mi = function(e) {
            return "matrix(1, 0, 0, 1, 0, 0)" === e || "none" === e || !e
        }, Ti = function(e) {
            var t = li(e, ti);
            return Mi(t) ? Ii : t.substr(7).match(G).map(Ae)
        }, Bi = function(e, t) {
            var n, i, r, s, a = e._gsap || de(e), o = e.style, l = Ti(e);
            return a.svg && e.getAttribute("transform") ? "1,0,0,1,0,0" === (l = [(r = e.transform.baseVal.consolidate().matrix).a, r.b, r.c, r.d, r.e, r.f]).join(",") ? Ii : l : (l !== Ii || e.offsetParent || e === Tn || a.svg || (r = o.display,
            o.display = "block",
            (n = e.parentNode) && e.offsetParent || (s = 1,
            i = e.nextElementSibling,
            Tn.appendChild(e)),
            l = Ti(e),
            r ? o.display = r : gi(e, "display"),
            s && (i ? n.insertBefore(e, i) : n ? n.appendChild(e) : Tn.removeChild(e))),
            t && l.length > 6 ? [l[0], l[1], l[4], l[5], l[12], l[13]] : l)
        }, Ri = function(e, t, n, i, r, s) {
            var a, o, l, c = e._gsap, u = r || Bi(e, !0), h = c.xOrigin || 0, d = c.yOrigin || 0, p = c.xOffset || 0, f = c.yOffset || 0, A = u[0], g = u[1], m = u[2], v = u[3], y = u[4], x = u[5], _ = t.split(" "), b = parseFloat(_[0]) || 0, E = parseFloat(_[1]) || 0;
            n ? u !== Ii && (o = A * v - g * m) && (l = b * (-g / o) + E * (A / o) - (A * x - g * y) / o,
            b = b * (v / o) + E * (-m / o) + (m * x - v * y) / o,
            E = l) : (b = (a = fi(e)).x + (~_[0].indexOf("%") ? b / 100 * a.width : b),
            E = a.y + (~(_[1] || _[0]).indexOf("%") ? E / 100 * a.height : E)),
            i || !1 !== i && c.smooth ? (y = b - h,
            x = E - d,
            c.xOffset = p + (y * A + x * m) - y,
            c.yOffset = f + (y * g + x * v) - x) : c.xOffset = c.yOffset = 0,
            c.xOrigin = b,
            c.yOrigin = E,
            c.smooth = !!i,
            c.origin = t,
            c.originIsAbsolute = !!n,
            e.style[ni] = "0px 0px",
            s && (mi(s, c, "xOrigin", h, b),
            mi(s, c, "yOrigin", d, E),
            mi(s, c, "xOffset", p, c.xOffset),
            mi(s, c, "yOffset", f, c.yOffset)),
            e.setAttribute("data-svg-origin", b + " " + E)
        }, Di = function(e, t) {
            var n = e._gsap || new Qt(e);
            if ("x"in n && !t && !n.uncache)
                return n;
            var i, r, s, a, o, l, c, u, h, d, p, f, A, g, m, v, y, _, b, E, w, C, I, S, M, T, B, R, D, P, L, U, F = e.style, N = n.scaleX < 0, O = "px", Q = "deg", k = getComputedStyle(e), G = li(e, ni) || "0";
            return i = r = s = l = c = u = h = d = p = 0,
            a = o = 1,
            n.svg = !(!e.getCTM || !Ai(e)),
            k.translate && ("none" === k.translate && "none" === k.scale && "none" === k.rotate || (F[ti] = ("none" !== k.translate ? "translate3d(" + (k.translate + " 0 0").split(" ").slice(0, 3).join(", ") + ") " : "") + ("none" !== k.rotate ? "rotate(" + k.rotate + ") " : "") + ("none" !== k.scale ? "scale(" + k.scale.split(" ").join(",") + ") " : "") + ("none" !== k[ti] ? k[ti] : "")),
            F.scale = F.rotate = F.translate = "none"),
            g = Bi(e, n.svg),
            n.svg && (n.uncache ? (M = e.getBBox(),
            G = n.xOrigin - M.x + "px " + (n.yOrigin - M.y) + "px",
            S = "") : S = !t && e.getAttribute("data-svg-origin"),
            Ri(e, S || G, !!S || n.originIsAbsolute, !1 !== n.smooth, g)),
            f = n.xOrigin || 0,
            A = n.yOrigin || 0,
            g !== Ii && (_ = g[0],
            b = g[1],
            E = g[2],
            w = g[3],
            i = C = g[4],
            r = I = g[5],
            6 === g.length ? (a = Math.sqrt(_ * _ + b * b),
            o = Math.sqrt(w * w + E * E),
            l = _ || b ? On(b, _) * Fn : 0,
            (h = E || w ? On(E, w) * Fn + l : 0) && (o *= Math.abs(Math.cos(h * Nn))),
            n.svg && (i -= f - (f * _ + A * E),
            r -= A - (f * b + A * w))) : (U = g[6],
            P = g[7],
            B = g[8],
            R = g[9],
            D = g[10],
            L = g[11],
            i = g[12],
            r = g[13],
            s = g[14],
            c = (m = On(U, D)) * Fn,
            m && (S = C * (v = Math.cos(-m)) + B * (y = Math.sin(-m)),
            M = I * v + R * y,
            T = U * v + D * y,
            B = C * -y + B * v,
            R = I * -y + R * v,
            D = U * -y + D * v,
            L = P * -y + L * v,
            C = S,
            I = M,
            U = T),
            u = (m = On(-E, D)) * Fn,
            m && (v = Math.cos(-m),
            L = w * (y = Math.sin(-m)) + L * v,
            _ = S = _ * v - B * y,
            b = M = b * v - R * y,
            E = T = E * v - D * y),
            l = (m = On(b, _)) * Fn,
            m && (S = _ * (v = Math.cos(m)) + b * (y = Math.sin(m)),
            M = C * v + I * y,
            b = b * v - _ * y,
            I = I * v - C * y,
            _ = S,
            C = M),
            c && Math.abs(c) + Math.abs(l) > 359.9 && (c = l = 0,
            u = 180 - u),
            a = Ae(Math.sqrt(_ * _ + b * b + E * E)),
            o = Ae(Math.sqrt(I * I + U * U)),
            m = On(C, I),
            h = Math.abs(m) > 2e-4 ? m * Fn : 0,
            p = L ? 1 / (L < 0 ? -L : L) : 0),
            n.svg && (S = e.getAttribute("transform"),
            n.forceCSS = e.setAttribute("transform", "") || !Mi(li(e, ti)),
            S && e.setAttribute("transform", S))),
            Math.abs(h) > 90 && Math.abs(h) < 270 && (N ? (a *= -1,
            h += l <= 0 ? 180 : -180,
            l += l <= 0 ? 180 : -180) : (o *= -1,
            h += h <= 0 ? 180 : -180)),
            t = t || n.uncache,
            n.x = i - ((n.xPercent = i && (!t && n.xPercent || (Math.round(e.offsetWidth / 2) === Math.round(-i) ? -50 : 0))) ? e.offsetWidth * n.xPercent / 100 : 0) + O,
            n.y = r - ((n.yPercent = r && (!t && n.yPercent || (Math.round(e.offsetHeight / 2) === Math.round(-r) ? -50 : 0))) ? e.offsetHeight * n.yPercent / 100 : 0) + O,
            n.z = s + O,
            n.scaleX = Ae(a),
            n.scaleY = Ae(o),
            n.rotation = Ae(l) + Q,
            n.rotationX = Ae(c) + Q,
            n.rotationY = Ae(u) + Q,
            n.skewX = h + Q,
            n.skewY = d + Q,
            n.transformPerspective = p + O,
            (n.zOrigin = parseFloat(G.split(" ")[2]) || !t && n.zOrigin || 0) && (F[ni] = Pi(G)),
            n.xOffset = n.yOffset = 0,
            n.force3D = x.force3D,
            n.renderTransform = n.svg ? ki : Ln ? Qi : Ui,
            n.uncache = 0,
            n
        }, Pi = function(e) {
            return (e = e.split(" "))[0] + " " + e[1]
        }, Li = function(e, t, n) {
            var i = Ze(t);
            return Ae(parseFloat(t) + parseFloat(xi(e, "x", n + "px", i))) + i
        }, Ui = function(e, t) {
            t.z = "0px",
            t.rotationY = t.rotationX = "0deg",
            t.force3D = 0,
            Qi(e, t)
        }, Fi = "0deg", Ni = "0px", Oi = ") ", Qi = function(e, t) {
            var n = t || this
              , i = n.xPercent
              , r = n.yPercent
              , s = n.x
              , a = n.y
              , o = n.z
              , l = n.rotation
              , c = n.rotationY
              , u = n.rotationX
              , h = n.skewX
              , d = n.skewY
              , p = n.scaleX
              , f = n.scaleY
              , A = n.transformPerspective
              , g = n.force3D
              , m = n.target
              , v = n.zOrigin
              , y = ""
              , x = "auto" === g && e && 1 !== e || !0 === g;
            if (v && (u !== Fi || c !== Fi)) {
                var _, b = parseFloat(c) * Nn, E = Math.sin(b), w = Math.cos(b);
                b = parseFloat(u) * Nn,
                _ = Math.cos(b),
                s = Li(m, s, E * _ * -v),
                a = Li(m, a, -Math.sin(b) * -v),
                o = Li(m, o, w * _ * -v + v)
            }
            A !== Ni && (y += "perspective(" + A + Oi),
            (i || r) && (y += "translate(" + i + "%, " + r + "%) "),
            (x || s !== Ni || a !== Ni || o !== Ni) && (y += o !== Ni || x ? "translate3d(" + s + ", " + a + ", " + o + ") " : "translate(" + s + ", " + a + Oi),
            l !== Fi && (y += "rotate(" + l + Oi),
            c !== Fi && (y += "rotateY(" + c + Oi),
            u !== Fi && (y += "rotateX(" + u + Oi),
            h === Fi && d === Fi || (y += "skew(" + h + ", " + d + Oi),
            1 === p && 1 === f || (y += "scale(" + p + ", " + f + Oi),
            m.style[ti] = y || "translate(0, 0)"
        }, ki = function(e, t) {
            var n, i, r, s, a, o = t || this, l = o.xPercent, c = o.yPercent, u = o.x, h = o.y, d = o.rotation, p = o.skewX, f = o.skewY, A = o.scaleX, g = o.scaleY, m = o.target, v = o.xOrigin, y = o.yOrigin, x = o.xOffset, _ = o.yOffset, b = o.forceCSS, E = parseFloat(u), w = parseFloat(h);
            d = parseFloat(d),
            p = parseFloat(p),
            (f = parseFloat(f)) && (p += f = parseFloat(f),
            d += f),
            d || p ? (d *= Nn,
            p *= Nn,
            n = Math.cos(d) * A,
            i = Math.sin(d) * A,
            r = Math.sin(d - p) * -g,
            s = Math.cos(d - p) * g,
            p && (f *= Nn,
            a = Math.tan(p - f),
            r *= a = Math.sqrt(1 + a * a),
            s *= a,
            f && (a = Math.tan(f),
            n *= a = Math.sqrt(1 + a * a),
            i *= a)),
            n = Ae(n),
            i = Ae(i),
            r = Ae(r),
            s = Ae(s)) : (n = A,
            s = g,
            i = r = 0),
            (E && !~(u + "").indexOf("px") || w && !~(h + "").indexOf("px")) && (E = xi(m, "x", u, "px"),
            w = xi(m, "y", h, "px")),
            (v || y || x || _) && (E = Ae(E + v - (v * n + y * r) + x),
            w = Ae(w + y - (v * i + y * s) + _)),
            (l || c) && (a = m.getBBox(),
            E = Ae(E + l / 100 * a.width),
            w = Ae(w + c / 100 * a.height)),
            a = "matrix(" + n + "," + i + "," + r + "," + s + "," + E + "," + w + ")",
            m.setAttribute("transform", a),
            b && (m.style[ti] = a)
        }, Gi = function(e, t, n, i, r) {
            var s, a, o = 360, l = B(r), c = parseFloat(r) * (l && ~r.indexOf("rad") ? Fn : 1) - i, u = i + c + "deg";
            return l && ("short" === (s = r.split("_")[1]) && (c %= o) !== c % 180 && (c += c < 0 ? o : -360),
            "cw" === s && c < 0 ? c = (c + 36e9) % o - ~~(c / o) * o : "ccw" === s && c > 0 && (c = (c - 36e9) % o - ~~(c / o) * o)),
            e._pt = a = new pn(e._pt,t,n,i,c,Vn),
            a.e = u,
            a.u = "deg",
            e._props.push(n),
            a
        }, Hi = function(e, t) {
            for (var n in t)
                e[n] = t[n];
            return e
        }, zi = function(e, t, n) {
            var i, r, s, a, o, l, c, u = Hi({}, n._gsap), h = n.style;
            for (r in u.svg ? (s = n.getAttribute("transform"),
            n.setAttribute("transform", ""),
            h[ti] = t,
            i = Di(n, 1),
            gi(n, ti),
            n.setAttribute("transform", s)) : (s = getComputedStyle(n)[ti],
            h[ti] = t,
            i = Di(n, 1),
            h[ti] = s),
            Un)
                (s = u[r]) !== (a = i[r]) && "perspective,force3D,transformOrigin,svgOrigin".indexOf(r) < 0 && (o = Ze(s) !== (c = Ze(a)) ? xi(n, r, s, c) : parseFloat(s),
                l = parseFloat(a),
                e._pt = new pn(e._pt,i,r,o,l - o,zn),
                e._pt.u = c || 0,
                e._props.push(r));
            Hi(i, u)
        };
        fe("padding,margin,Width,Radius", (function(e, t) {
            var n = "Top"
              , i = "Right"
              , r = "Bottom"
              , s = "Left"
              , a = (t < 3 ? [n, i, r, s] : [n + s, n + i, r + i, r + s]).map((function(n) {
                return t < 2 ? e + n : "border" + n + e
            }
            ));
            Ci[t > 1 ? "border" + e : e] = function(e, t, n, i, r) {
                var s, o;
                if (arguments.length < 4)
                    return s = a.map((function(t) {
                        return _i(e, t, n)
                    }
                    )),
                    5 === (o = s.join(" ")).split(s[0]).length ? s[0] : o;
                s = (i + "").split(" "),
                o = {},
                a.forEach((function(e, t) {
                    return o[e] = s[t] = s[t] || s[(t - 1) / 2 | 0]
                }
                )),
                e.init(t, o, r)
            }
        }
        ));
        var Vi, Wi, ji, qi = {
            name: "css",
            register: hi,
            targetTest: function(e) {
                return e.style && e.nodeType
            },
            init: function(e, t, n, i, r) {
                var s, a, o, l, c, u, h, d, p, f, A, g, m, v, y, _, b, E, w, C, I = this._props, S = e.style, M = n.vars.startAt;
                for (h in Bn || hi(),
                this.styles = this.styles || ai(e),
                _ = this.styles.props,
                this.tween = n,
                t)
                    if ("autoRound" !== h && (a = t[h],
                    !ae[h] || !jt(h, t, n, i, e, r)))
                        if (c = typeof a,
                        u = Ci[h],
                        "function" === c && (c = typeof (a = a.call(n, i, e, r))),
                        "string" === c && ~a.indexOf("random(") && (a = ut(a)),
                        u)
                            u(this, e, h, a, n) && (y = 1);
                        else if ("--" === h.substr(0, 2))
                            s = (getComputedStyle(e).getPropertyValue(h) + "").trim(),
                            a += "",
                            Et.lastIndex = 0,
                            Et.test(s) || (d = Ze(s),
                            p = Ze(a)),
                            p ? d !== p && (s = xi(e, h, s, p) + p) : d && (a += d),
                            this.add(S, "setProperty", s, a, i, r, 0, 0, h),
                            I.push(h),
                            _.push(h, 0, S[h]);
                        else if ("undefined" !== c) {
                            if (M && h in M ? (s = "function" == typeof M[h] ? M[h].call(n, i, e, r) : M[h],
                            B(s) && ~s.indexOf("random(") && (s = ut(s)),
                            Ze(s + "") || "auto" === s || (s += x.units[h] || Ze(_i(e, h)) || ""),
                            "=" === (s + "").charAt(1) && (s = _i(e, h))) : s = _i(e, h),
                            l = parseFloat(s),
                            (f = "string" === c && "=" === a.charAt(1) && a.substr(0, 2)) && (a = a.substr(2)),
                            o = parseFloat(a),
                            h in Hn && ("autoAlpha" === h && (1 === l && "hidden" === _i(e, "visibility") && o && (l = 0),
                            _.push("visibility", 0, S.visibility),
                            mi(this, S, "visibility", l ? "inherit" : "hidden", o ? "inherit" : "hidden", !o)),
                            "scale" !== h && "transform" !== h && ~(h = Hn[h]).indexOf(",") && (h = h.split(",")[0])),
                            A = h in Un)
                                if (this.styles.save(h),
                                g || ((m = e._gsap).renderTransform && !t.parseTransform || Di(e, t.parseTransform),
                                v = !1 !== t.smoothOrigin && m.smooth,
                                (g = this._pt = new pn(this._pt,S,ti,0,1,m.renderTransform,m,0,-1)).dep = 1),
                                "scale" === h)
                                    this._pt = new pn(this._pt,m,"scaleY",m.scaleY,(f ? me(m.scaleY, f + o) : o) - m.scaleY || 0,zn),
                                    this._pt.u = 0,
                                    I.push("scaleY", h),
                                    h += "X";
                                else {
                                    if ("transformOrigin" === h) {
                                        _.push(ni, 0, S[ni]),
                                        E = void 0,
                                        w = void 0,
                                        C = void 0,
                                        E = (b = a).split(" "),
                                        w = E[0],
                                        C = E[1] || "50%",
                                        "top" !== w && "bottom" !== w && "left" !== C && "right" !== C || (b = w,
                                        w = C,
                                        C = b),
                                        E[0] = Ei[w] || w,
                                        E[1] = Ei[C] || C,
                                        a = E.join(" "),
                                        m.svg ? Ri(e, a, 0, v, 0, this) : ((p = parseFloat(a.split(" ")[2]) || 0) !== m.zOrigin && mi(this, m, "zOrigin", m.zOrigin, p),
                                        mi(this, S, h, Pi(s), Pi(a)));
                                        continue
                                    }
                                    if ("svgOrigin" === h) {
                                        Ri(e, a, 1, v, 0, this);
                                        continue
                                    }
                                    if (h in Si) {
                                        Gi(this, m, h, l, f ? me(l, f + a) : a);
                                        continue
                                    }
                                    if ("smoothOrigin" === h) {
                                        mi(this, m, "smooth", m.smooth, a);
                                        continue
                                    }
                                    if ("force3D" === h) {
                                        m[h] = a;
                                        continue
                                    }
                                    if ("transform" === h) {
                                        zi(this, a, e);
                                        continue
                                    }
                                }
                            else
                                h in S || (h = ui(h) || h);
                            if (A || (o || 0 === o) && (l || 0 === l) && !Gn.test(a) && h in S)
                                o || (o = 0),
                                (d = (s + "").substr((l + "").length)) !== (p = Ze(a) || (h in x.units ? x.units[h] : d)) && (l = xi(e, h, s, p)),
                                this._pt = new pn(this._pt,A ? m : S,h,l,(f ? me(l, f + o) : o) - l,A || "px" !== p && "zIndex" !== h || !1 === t.autoRound ? zn : jn),
                                this._pt.u = p || 0,
                                d !== p && "%" !== p && (this._pt.b = s,
                                this._pt.r = Wn);
                            else if (h in S)
                                bi.call(this, e, h, s, f ? f + a : a);
                            else if (h in e)
                                this.add(e, h, s || e[h], f ? f + a : a, i, r);
                            else if ("parseTransform" !== h) {
                                K(h, a);
                                continue
                            }
                            A || (h in S ? _.push(h, 0, S[h]) : _.push(h, 1, s || e[h])),
                            I.push(h)
                        }
                y && dn(this)
            },
            render: function(e, t) {
                if (t.tween._time || !Pn())
                    for (var n = t._pt; n; )
                        n.r(e, n.d),
                        n = n._next;
                else
                    t.styles.revert()
            },
            get: _i,
            aliases: Hn,
            getSetter: function(e, t, n) {
                var i = Hn[t];
                return i && i.indexOf(",") < 0 && (t = i),
                t in Un && t !== ni && (e._gsap.x || _i(e, "x")) ? n && Dn === n ? "scale" === t ? Zn : Jn : (Dn = n || {}) && ("scale" === t ? $n : ei) : e.style && !P(e.style[t]) ? Xn : ~t.indexOf("-") ? Kn : rn(e, t)
            },
            core: {
                _removeProperty: gi,
                _getMatrix: Bi
            }
        };
        In.utils.checkPrefix = ui,
        In.core.getStyleSaver = ai,
        ji = fe((Vi = "x,y,z,scale,scaleX,scaleY,xPercent,yPercent") + "," + (Wi = "rotation,rotationX,rotationY,skewX,skewY") + ",transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", (function(e) {
            Un[e] = 1
        }
        )),
        fe(Wi, (function(e) {
            x.units[e] = "deg",
            Si[e] = 1
        }
        )),
        Hn[ji[13]] = Vi + "," + Wi,
        fe("0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY", (function(e) {
            var t = e.split(":");
            Hn[t[1]] = ji[t[0]]
        }
        )),
        fe("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", (function(e) {
            x.units[e] = "px"
        }
        )),
        In.registerPlugin(qi);
        var Yi = In.registerPlugin(qi) || In;
        Yi.core.Tween
    }
    ,
    8683: (e, t, n) => {
        var i;
        !function() {
            "use strict";
            var r = function() {
                this.init()
            };
            r.prototype = {
                init: function() {
                    var e = this || s;
                    return e._counter = 1e3,
                    e._html5AudioPool = [],
                    e.html5PoolSize = 10,
                    e._codecs = {},
                    e._howls = [],
                    e._muted = !1,
                    e._volume = 1,
                    e._canPlayEvent = "canplaythrough",
                    e._navigator = "undefined" != typeof window && window.navigator ? window.navigator : null,
                    e.masterGain = null,
                    e.noAudio = !1,
                    e.usingWebAudio = !0,
                    e.autoSuspend = !0,
                    e.ctx = null,
                    e.autoUnlock = !0,
                    e._setup(),
                    e
                },
                volume: function(e) {
                    var t = this || s;
                    if (e = parseFloat(e),
                    t.ctx || p(),
                    void 0 !== e && e >= 0 && e <= 1) {
                        if (t._volume = e,
                        t._muted)
                            return t;
                        t.usingWebAudio && t.masterGain.gain.setValueAtTime(e, s.ctx.currentTime);
                        for (var n = 0; n < t._howls.length; n++)
                            if (!t._howls[n]._webAudio)
                                for (var i = t._howls[n]._getSoundIds(), r = 0; r < i.length; r++) {
                                    var a = t._howls[n]._soundById(i[r]);
                                    a && a._node && (a._node.volume = a._volume * e)
                                }
                        return t
                    }
                    return t._volume
                },
                mute: function(e) {
                    var t = this || s;
                    t.ctx || p(),
                    t._muted = e,
                    t.usingWebAudio && t.masterGain.gain.setValueAtTime(e ? 0 : t._volume, s.ctx.currentTime);
                    for (var n = 0; n < t._howls.length; n++)
                        if (!t._howls[n]._webAudio)
                            for (var i = t._howls[n]._getSoundIds(), r = 0; r < i.length; r++) {
                                var a = t._howls[n]._soundById(i[r]);
                                a && a._node && (a._node.muted = !!e || a._muted)
                            }
                    return t
                },
                stop: function() {
                    for (var e = this || s, t = 0; t < e._howls.length; t++)
                        e._howls[t].stop();
                    return e
                },
                unload: function() {
                    for (var e = this || s, t = e._howls.length - 1; t >= 0; t--)
                        e._howls[t].unload();
                    return e.usingWebAudio && e.ctx && void 0 !== e.ctx.close && (e.ctx.close(),
                    e.ctx = null,
                    p()),
                    e
                },
                codecs: function(e) {
                    return (this || s)._codecs[e.replace(/^x-/, "")]
                },
                _setup: function() {
                    var e = this || s;
                    if (e.state = e.ctx && e.ctx.state || "suspended",
                    e._autoSuspend(),
                    !e.usingWebAudio)
                        if ("undefined" != typeof Audio)
                            try {
                                void 0 === (new Audio).oncanplaythrough && (e._canPlayEvent = "canplay")
                            } catch (t) {
                                e.noAudio = !0
                            }
                        else
                            e.noAudio = !0;
                    try {
                        (new Audio).muted && (e.noAudio = !0)
                    } catch (e) {}
                    return e.noAudio || e._setupCodecs(),
                    e
                },
                _setupCodecs: function() {
                    var e = this || s
                      , t = null;
                    try {
                        t = "undefined" != typeof Audio ? new Audio : null
                    } catch (t) {
                        return e
                    }
                    if (!t || "function" != typeof t.canPlayType)
                        return e;
                    var n = t.canPlayType("audio/mpeg;").replace(/^no$/, "")
                      , i = e._navigator ? e._navigator.userAgent : ""
                      , r = i.match(/OPR\/(\d+)/g)
                      , a = r && parseInt(r[0].split("/")[1], 10) < 33
                      , o = -1 !== i.indexOf("Safari") && -1 === i.indexOf("Chrome")
                      , l = i.match(/Version\/(.*?) /)
                      , c = o && l && parseInt(l[1], 10) < 15;
                    return e._codecs = {
                        mp3: !(a || !n && !t.canPlayType("audio/mp3;").replace(/^no$/, "")),
                        mpeg: !!n,
                        opus: !!t.canPlayType('audio/ogg; codecs="opus"').replace(/^no$/, ""),
                        ogg: !!t.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ""),
                        oga: !!t.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ""),
                        wav: !!(t.canPlayType('audio/wav; codecs="1"') || t.canPlayType("audio/wav")).replace(/^no$/, ""),
                        aac: !!t.canPlayType("audio/aac;").replace(/^no$/, ""),
                        caf: !!t.canPlayType("audio/x-caf;").replace(/^no$/, ""),
                        m4a: !!(t.canPlayType("audio/x-m4a;") || t.canPlayType("audio/m4a;") || t.canPlayType("audio/aac;")).replace(/^no$/, ""),
                        m4b: !!(t.canPlayType("audio/x-m4b;") || t.canPlayType("audio/m4b;") || t.canPlayType("audio/aac;")).replace(/^no$/, ""),
                        mp4: !!(t.canPlayType("audio/x-mp4;") || t.canPlayType("audio/mp4;") || t.canPlayType("audio/aac;")).replace(/^no$/, ""),
                        weba: !(c || !t.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, "")),
                        webm: !(c || !t.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, "")),
                        dolby: !!t.canPlayType('audio/mp4; codecs="ec-3"').replace(/^no$/, ""),
                        flac: !!(t.canPlayType("audio/x-flac;") || t.canPlayType("audio/flac;")).replace(/^no$/, "")
                    },
                    e
                },
                _unlockAudio: function() {
                    var e = this || s;
                    if (!e._audioUnlocked && e.ctx) {
                        e._audioUnlocked = !1,
                        e.autoUnlock = !1,
                        e._mobileUnloaded || 44100 === e.ctx.sampleRate || (e._mobileUnloaded = !0,
                        e.unload()),
                        e._scratchBuffer = e.ctx.createBuffer(1, 1, 22050);
                        var t = function(n) {
                            for (; e._html5AudioPool.length < e.html5PoolSize; )
                                try {
                                    var i = new Audio;
                                    i._unlocked = !0,
                                    e._releaseHtml5Audio(i)
                                } catch (n) {
                                    e.noAudio = !0;
                                    break
                                }
                            for (var r = 0; r < e._howls.length; r++)
                                if (!e._howls[r]._webAudio)
                                    for (var s = e._howls[r]._getSoundIds(), a = 0; a < s.length; a++) {
                                        var o = e._howls[r]._soundById(s[a]);
                                        o && o._node && !o._node._unlocked && (o._node._unlocked = !0,
                                        o._node.load())
                                    }
                            e._autoResume();
                            var l = e.ctx.createBufferSource();
                            l.buffer = e._scratchBuffer,
                            l.connect(e.ctx.destination),
                            void 0 === l.start ? l.noteOn(0) : l.start(0),
                            "function" == typeof e.ctx.resume && e.ctx.resume(),
                            l.onended = function() {
                                l.disconnect(0),
                                e._audioUnlocked = !0,
                                document.removeEventListener("touchstart", t, !0),
                                document.removeEventListener("touchend", t, !0),
                                document.removeEventListener("click", t, !0),
                                document.removeEventListener("keydown", t, !0);
                                for (var n = 0; n < e._howls.length; n++)
                                    e._howls[n]._emit("unlock")
                            }
                        };
                        return document.addEventListener("touchstart", t, !0),
                        document.addEventListener("touchend", t, !0),
                        document.addEventListener("click", t, !0),
                        document.addEventListener("keydown", t, !0),
                        e
                    }
                },
                _obtainHtml5Audio: function() {
                    var e = this || s;
                    if (e._html5AudioPool.length)
                        return e._html5AudioPool.pop();
                    var t = (new Audio).play();
                    return t && "undefined" != typeof Promise && (t instanceof Promise || "function" == typeof t.then) && t.catch((function() {
                        console.warn("HTML5 Audio pool exhausted, returning potentially locked audio object.")
                    }
                    )),
                    new Audio
                },
                _releaseHtml5Audio: function(e) {
                    var t = this || s;
                    return e._unlocked && t._html5AudioPool.push(e),
                    t
                },
                _autoSuspend: function() {
                    var e = this;
                    if (e.autoSuspend && e.ctx && void 0 !== e.ctx.suspend && s.usingWebAudio) {
                        for (var t = 0; t < e._howls.length; t++)
                            if (e._howls[t]._webAudio)
                                for (var n = 0; n < e._howls[t]._sounds.length; n++)
                                    if (!e._howls[t]._sounds[n]._paused)
                                        return e;
                        return e._suspendTimer && clearTimeout(e._suspendTimer),
                        e._suspendTimer = setTimeout((function() {
                            if (e.autoSuspend) {
                                e._suspendTimer = null,
                                e.state = "suspending";
                                var t = function() {
                                    e.state = "suspended",
                                    e._resumeAfterSuspend && (delete e._resumeAfterSuspend,
                                    e._autoResume())
                                };
                                e.ctx.suspend().then(t, t)
                            }
                        }
                        ), 3e4),
                        e
                    }
                },
                _autoResume: function() {
                    var e = this;
                    if (e.ctx && void 0 !== e.ctx.resume && s.usingWebAudio)
                        return "running" === e.state && "interrupted" !== e.ctx.state && e._suspendTimer ? (clearTimeout(e._suspendTimer),
                        e._suspendTimer = null) : "suspended" === e.state || "running" === e.state && "interrupted" === e.ctx.state ? (e.ctx.resume().then((function() {
                            e.state = "running";
                            for (var t = 0; t < e._howls.length; t++)
                                e._howls[t]._emit("resume")
                        }
                        )),
                        e._suspendTimer && (clearTimeout(e._suspendTimer),
                        e._suspendTimer = null)) : "suspending" === e.state && (e._resumeAfterSuspend = !0),
                        e
                }
            };
            var s = new r
              , a = function(e) {
                e.src && 0 !== e.src.length ? this.init(e) : console.error("An array of source files must be passed with any new Howl.")
            };
            a.prototype = {
                init: function(e) {
                    var t = this;
                    return s.ctx || p(),
                    t._autoplay = e.autoplay || !1,
                    t._format = "string" != typeof e.format ? e.format : [e.format],
                    t._html5 = e.html5 || !1,
                    t._muted = e.mute || !1,
                    t._loop = e.loop || !1,
                    t._pool = e.pool || 5,
                    t._preload = "boolean" != typeof e.preload && "metadata" !== e.preload || e.preload,
                    t._rate = e.rate || 1,
                    t._sprite = e.sprite || {},
                    t._src = "string" != typeof e.src ? e.src : [e.src],
                    t._volume = void 0 !== e.volume ? e.volume : 1,
                    t._xhr = {
                        method: e.xhr && e.xhr.method ? e.xhr.method : "GET",
                        headers: e.xhr && e.xhr.headers ? e.xhr.headers : null,
                        withCredentials: !(!e.xhr || !e.xhr.withCredentials) && e.xhr.withCredentials
                    },
                    t._duration = 0,
                    t._state = "unloaded",
                    t._sounds = [],
                    t._endTimers = {},
                    t._queue = [],
                    t._playLock = !1,
                    t._onend = e.onend ? [{
                        fn: e.onend
                    }] : [],
                    t._onfade = e.onfade ? [{
                        fn: e.onfade
                    }] : [],
                    t._onload = e.onload ? [{
                        fn: e.onload
                    }] : [],
                    t._onloaderror = e.onloaderror ? [{
                        fn: e.onloaderror
                    }] : [],
                    t._onplayerror = e.onplayerror ? [{
                        fn: e.onplayerror
                    }] : [],
                    t._onpause = e.onpause ? [{
                        fn: e.onpause
                    }] : [],
                    t._onplay = e.onplay ? [{
                        fn: e.onplay
                    }] : [],
                    t._onstop = e.onstop ? [{
                        fn: e.onstop
                    }] : [],
                    t._onmute = e.onmute ? [{
                        fn: e.onmute
                    }] : [],
                    t._onvolume = e.onvolume ? [{
                        fn: e.onvolume
                    }] : [],
                    t._onrate = e.onrate ? [{
                        fn: e.onrate
                    }] : [],
                    t._onseek = e.onseek ? [{
                        fn: e.onseek
                    }] : [],
                    t._onunlock = e.onunlock ? [{
                        fn: e.onunlock
                    }] : [],
                    t._onresume = [],
                    t._webAudio = s.usingWebAudio && !t._html5,
                    void 0 !== s.ctx && s.ctx && s.autoUnlock && s._unlockAudio(),
                    s._howls.push(t),
                    t._autoplay && t._queue.push({
                        event: "play",
                        action: function() {
                            t.play()
                        }
                    }),
                    t._preload && "none" !== t._preload && t.load(),
                    t
                },
                load: function() {
                    var e = this
                      , t = null;
                    if (s.noAudio)
                        e._emit("loaderror", null, "No audio support.");
                    else {
                        "string" == typeof e._src && (e._src = [e._src]);
                        for (var n = 0; n < e._src.length; n++) {
                            var i, r;
                            if (e._format && e._format[n])
                                i = e._format[n];
                            else {
                                if ("string" != typeof (r = e._src[n])) {
                                    e._emit("loaderror", null, "Non-string found in selected audio sources - ignoring.");
                                    continue
                                }
                                (i = /^data:audio\/([^;,]+);/i.exec(r)) || (i = /\.([^.]+)$/.exec(r.split("?", 1)[0])),
                                i && (i = i[1].toLowerCase())
                            }
                            if (i || console.warn('No file extension was found. Consider using the "format" property or specify an extension.'),
                            i && s.codecs(i)) {
                                t = e._src[n];
                                break
                            }
                        }
                        if (t)
                            return e._src = t,
                            e._state = "loading",
                            "https:" === window.location.protocol && "http:" === t.slice(0, 5) && (e._html5 = !0,
                            e._webAudio = !1),
                            new o(e),
                            e._webAudio && c(e),
                            e;
                        e._emit("loaderror", null, "No codec support for selected audio sources.")
                    }
                },
                play: function(e, t) {
                    var n = this
                      , i = null;
                    if ("number" == typeof e)
                        i = e,
                        e = null;
                    else {
                        if ("string" == typeof e && "loaded" === n._state && !n._sprite[e])
                            return null;
                        if (void 0 === e && (e = "__default",
                        !n._playLock)) {
                            for (var r = 0, a = 0; a < n._sounds.length; a++)
                                n._sounds[a]._paused && !n._sounds[a]._ended && (r++,
                                i = n._sounds[a]._id);
                            1 === r ? e = null : i = null
                        }
                    }
                    var o = i ? n._soundById(i) : n._inactiveSound();
                    if (!o)
                        return null;
                    if (i && !e && (e = o._sprite || "__default"),
                    "loaded" !== n._state) {
                        o._sprite = e,
                        o._ended = !1;
                        var l = o._id;
                        return n._queue.push({
                            event: "play",
                            action: function() {
                                n.play(l)
                            }
                        }),
                        l
                    }
                    if (i && !o._paused)
                        return t || n._loadQueue("play"),
                        o._id;
                    n._webAudio && s._autoResume();
                    var c = Math.max(0, o._seek > 0 ? o._seek : n._sprite[e][0] / 1e3)
                      , u = Math.max(0, (n._sprite[e][0] + n._sprite[e][1]) / 1e3 - c)
                      , h = 1e3 * u / Math.abs(o._rate)
                      , d = n._sprite[e][0] / 1e3
                      , p = (n._sprite[e][0] + n._sprite[e][1]) / 1e3;
                    o._sprite = e,
                    o._ended = !1;
                    var f = function() {
                        o._paused = !1,
                        o._seek = c,
                        o._start = d,
                        o._stop = p,
                        o._loop = !(!o._loop && !n._sprite[e][2])
                    };
                    if (!(c >= p)) {
                        var A = o._node;
                        if (n._webAudio) {
                            var g = function() {
                                n._playLock = !1,
                                f(),
                                n._refreshBuffer(o);
                                var e = o._muted || n._muted ? 0 : o._volume;
                                A.gain.setValueAtTime(e, s.ctx.currentTime),
                                o._playStart = s.ctx.currentTime,
                                void 0 === A.bufferSource.start ? o._loop ? A.bufferSource.noteGrainOn(0, c, 86400) : A.bufferSource.noteGrainOn(0, c, u) : o._loop ? A.bufferSource.start(0, c, 86400) : A.bufferSource.start(0, c, u),
                                h !== 1 / 0 && (n._endTimers[o._id] = setTimeout(n._ended.bind(n, o), h)),
                                t || setTimeout((function() {
                                    n._emit("play", o._id),
                                    n._loadQueue()
                                }
                                ), 0)
                            };
                            "running" === s.state && "interrupted" !== s.ctx.state ? g() : (n._playLock = !0,
                            n.once("resume", g),
                            n._clearTimer(o._id))
                        } else {
                            var m = function() {
                                A.currentTime = c,
                                A.muted = o._muted || n._muted || s._muted || A.muted,
                                A.volume = o._volume * s.volume(),
                                A.playbackRate = o._rate;
                                try {
                                    var i = A.play();
                                    if (i && "undefined" != typeof Promise && (i instanceof Promise || "function" == typeof i.then) ? (n._playLock = !0,
                                    f(),
                                    i.then((function() {
                                        n._playLock = !1,
                                        A._unlocked = !0,
                                        t ? n._loadQueue() : n._emit("play", o._id)
                                    }
                                    )).catch((function() {
                                        n._playLock = !1,
                                        n._emit("playerror", o._id, "Playback was unable to start. This is most commonly an issue on mobile devices and Chrome where playback was not within a user interaction."),
                                        o._ended = !0,
                                        o._paused = !0
                                    }
                                    ))) : t || (n._playLock = !1,
                                    f(),
                                    n._emit("play", o._id)),
                                    A.playbackRate = o._rate,
                                    A.paused)
                                        return void n._emit("playerror", o._id, "Playback was unable to start. This is most commonly an issue on mobile devices and Chrome where playback was not within a user interaction.");
                                    "__default" !== e || o._loop ? n._endTimers[o._id] = setTimeout(n._ended.bind(n, o), h) : (n._endTimers[o._id] = function() {
                                        n._ended(o),
                                        A.removeEventListener("ended", n._endTimers[o._id], !1)
                                    }
                                    ,
                                    A.addEventListener("ended", n._endTimers[o._id], !1))
                                } catch (e) {
                                    n._emit("playerror", o._id, e)
                                }
                            };
                            "data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA" === A.src && (A.src = n._src,
                            A.load());
                            var v = window && window.ejecta || !A.readyState && s._navigator.isCocoonJS;
                            if (A.readyState >= 3 || v)
                                m();
                            else {
                                n._playLock = !0,
                                n._state = "loading";
                                var y = function() {
                                    n._state = "loaded",
                                    m(),
                                    A.removeEventListener(s._canPlayEvent, y, !1)
                                };
                                A.addEventListener(s._canPlayEvent, y, !1),
                                n._clearTimer(o._id)
                            }
                        }
                        return o._id
                    }
                    n._ended(o)
                },
                pause: function(e) {
                    var t = this;
                    if ("loaded" !== t._state || t._playLock)
                        return t._queue.push({
                            event: "pause",
                            action: function() {
                                t.pause(e)
                            }
                        }),
                        t;
                    for (var n = t._getSoundIds(e), i = 0; i < n.length; i++) {
                        t._clearTimer(n[i]);
                        var r = t._soundById(n[i]);
                        if (r && !r._paused && (r._seek = t.seek(n[i]),
                        r._rateSeek = 0,
                        r._paused = !0,
                        t._stopFade(n[i]),
                        r._node))
                            if (t._webAudio) {
                                if (!r._node.bufferSource)
                                    continue;
                                void 0 === r._node.bufferSource.stop ? r._node.bufferSource.noteOff(0) : r._node.bufferSource.stop(0),
                                t._cleanBuffer(r._node)
                            } else
                                isNaN(r._node.duration) && r._node.duration !== 1 / 0 || r._node.pause();
                        arguments[1] || t._emit("pause", r ? r._id : null)
                    }
                    return t
                },
                stop: function(e, t) {
                    var n = this;
                    if ("loaded" !== n._state || n._playLock)
                        return n._queue.push({
                            event: "stop",
                            action: function() {
                                n.stop(e)
                            }
                        }),
                        n;
                    for (var i = n._getSoundIds(e), r = 0; r < i.length; r++) {
                        n._clearTimer(i[r]);
                        var s = n._soundById(i[r]);
                        s && (s._seek = s._start || 0,
                        s._rateSeek = 0,
                        s._paused = !0,
                        s._ended = !0,
                        n._stopFade(i[r]),
                        s._node && (n._webAudio ? s._node.bufferSource && (void 0 === s._node.bufferSource.stop ? s._node.bufferSource.noteOff(0) : s._node.bufferSource.stop(0),
                        n._cleanBuffer(s._node)) : isNaN(s._node.duration) && s._node.duration !== 1 / 0 || (s._node.currentTime = s._start || 0,
                        s._node.pause(),
                        s._node.duration === 1 / 0 && n._clearSound(s._node))),
                        t || n._emit("stop", s._id))
                    }
                    return n
                },
                mute: function(e, t) {
                    var n = this;
                    if ("loaded" !== n._state || n._playLock)
                        return n._queue.push({
                            event: "mute",
                            action: function() {
                                n.mute(e, t)
                            }
                        }),
                        n;
                    if (void 0 === t) {
                        if ("boolean" != typeof e)
                            return n._muted;
                        n._muted = e
                    }
                    for (var i = n._getSoundIds(t), r = 0; r < i.length; r++) {
                        var a = n._soundById(i[r]);
                        a && (a._muted = e,
                        a._interval && n._stopFade(a._id),
                        n._webAudio && a._node ? a._node.gain.setValueAtTime(e ? 0 : a._volume, s.ctx.currentTime) : a._node && (a._node.muted = !!s._muted || e),
                        n._emit("mute", a._id))
                    }
                    return n
                },
                volume: function() {
                    var e, t, n, i = this, r = arguments;
                    if (0 === r.length)
                        return i._volume;
                    if (1 === r.length || 2 === r.length && void 0 === r[1] ? i._getSoundIds().indexOf(r[0]) >= 0 ? t = parseInt(r[0], 10) : e = parseFloat(r[0]) : r.length >= 2 && (e = parseFloat(r[0]),
                    t = parseInt(r[1], 10)),
                    !(void 0 !== e && e >= 0 && e <= 1))
                        return (n = t ? i._soundById(t) : i._sounds[0]) ? n._volume : 0;
                    if ("loaded" !== i._state || i._playLock)
                        return i._queue.push({
                            event: "volume",
                            action: function() {
                                i.volume.apply(i, r)
                            }
                        }),
                        i;
                    void 0 === t && (i._volume = e),
                    t = i._getSoundIds(t);
                    for (var a = 0; a < t.length; a++)
                        (n = i._soundById(t[a])) && (n._volume = e,
                        r[2] || i._stopFade(t[a]),
                        i._webAudio && n._node && !n._muted ? n._node.gain.setValueAtTime(e, s.ctx.currentTime) : n._node && !n._muted && (n._node.volume = e * s.volume()),
                        i._emit("volume", n._id));
                    return i
                },
                fade: function(e, t, n, i) {
                    var r = this;
                    if ("loaded" !== r._state || r._playLock)
                        return r._queue.push({
                            event: "fade",
                            action: function() {
                                r.fade(e, t, n, i)
                            }
                        }),
                        r;
                    e = Math.min(Math.max(0, parseFloat(e)), 1),
                    t = Math.min(Math.max(0, parseFloat(t)), 1),
                    n = parseFloat(n),
                    r.volume(e, i);
                    for (var a = r._getSoundIds(i), o = 0; o < a.length; o++) {
                        var l = r._soundById(a[o]);
                        if (l) {
                            if (i || r._stopFade(a[o]),
                            r._webAudio && !l._muted) {
                                var c = s.ctx.currentTime
                                  , u = c + n / 1e3;
                                l._volume = e,
                                l._node.gain.setValueAtTime(e, c),
                                l._node.gain.linearRampToValueAtTime(t, u)
                            }
                            r._startFadeInterval(l, e, t, n, a[o], void 0 === i)
                        }
                    }
                    return r
                },
                _startFadeInterval: function(e, t, n, i, r, s) {
                    var a = this
                      , o = t
                      , l = n - t
                      , c = Math.abs(l / .01)
                      , u = Math.max(4, c > 0 ? i / c : i)
                      , h = Date.now();
                    e._fadeTo = n,
                    e._interval = setInterval((function() {
                        var r = (Date.now() - h) / i;
                        h = Date.now(),
                        o += l * r,
                        o = Math.round(100 * o) / 100,
                        o = l < 0 ? Math.max(n, o) : Math.min(n, o),
                        a._webAudio ? e._volume = o : a.volume(o, e._id, !0),
                        s && (a._volume = o),
                        (n < t && o <= n || n > t && o >= n) && (clearInterval(e._interval),
                        e._interval = null,
                        e._fadeTo = null,
                        a.volume(n, e._id),
                        a._emit("fade", e._id))
                    }
                    ), u)
                },
                _stopFade: function(e) {
                    var t = this
                      , n = t._soundById(e);
                    return n && n._interval && (t._webAudio && n._node.gain.cancelScheduledValues(s.ctx.currentTime),
                    clearInterval(n._interval),
                    n._interval = null,
                    t.volume(n._fadeTo, e),
                    n._fadeTo = null,
                    t._emit("fade", e)),
                    t
                },
                loop: function() {
                    var e, t, n, i = this, r = arguments;
                    if (0 === r.length)
                        return i._loop;
                    if (1 === r.length) {
                        if ("boolean" != typeof r[0])
                            return !!(n = i._soundById(parseInt(r[0], 10))) && n._loop;
                        e = r[0],
                        i._loop = e
                    } else
                        2 === r.length && (e = r[0],
                        t = parseInt(r[1], 10));
                    for (var s = i._getSoundIds(t), a = 0; a < s.length; a++)
                        (n = i._soundById(s[a])) && (n._loop = e,
                        i._webAudio && n._node && n._node.bufferSource && (n._node.bufferSource.loop = e,
                        e && (n._node.bufferSource.loopStart = n._start || 0,
                        n._node.bufferSource.loopEnd = n._stop,
                        i.playing(s[a]) && (i.pause(s[a], !0),
                        i.play(s[a], !0)))));
                    return i
                },
                rate: function() {
                    var e, t, n, i = this, r = arguments;
                    if (0 === r.length)
                        t = i._sounds[0]._id;
                    else if (1 === r.length) {
                        i._getSoundIds().indexOf(r[0]) >= 0 ? t = parseInt(r[0], 10) : e = parseFloat(r[0])
                    } else
                        2 === r.length && (e = parseFloat(r[0]),
                        t = parseInt(r[1], 10));
                    if ("number" != typeof e)
                        return (n = i._soundById(t)) ? n._rate : i._rate;
                    if ("loaded" !== i._state || i._playLock)
                        return i._queue.push({
                            event: "rate",
                            action: function() {
                                i.rate.apply(i, r)
                            }
                        }),
                        i;
                    void 0 === t && (i._rate = e),
                    t = i._getSoundIds(t);
                    for (var a = 0; a < t.length; a++)
                        if (n = i._soundById(t[a])) {
                            i.playing(t[a]) && (n._rateSeek = i.seek(t[a]),
                            n._playStart = i._webAudio ? s.ctx.currentTime : n._playStart),
                            n._rate = e,
                            i._webAudio && n._node && n._node.bufferSource ? n._node.bufferSource.playbackRate.setValueAtTime(e, s.ctx.currentTime) : n._node && (n._node.playbackRate = e);
                            var o = i.seek(t[a])
                              , l = 1e3 * ((i._sprite[n._sprite][0] + i._sprite[n._sprite][1]) / 1e3 - o) / Math.abs(n._rate);
                            !i._endTimers[t[a]] && n._paused || (i._clearTimer(t[a]),
                            i._endTimers[t[a]] = setTimeout(i._ended.bind(i, n), l)),
                            i._emit("rate", n._id)
                        }
                    return i
                },
                seek: function() {
                    var e, t, n = this, i = arguments;
                    if (0 === i.length)
                        n._sounds.length && (t = n._sounds[0]._id);
                    else if (1 === i.length) {
                        n._getSoundIds().indexOf(i[0]) >= 0 ? t = parseInt(i[0], 10) : n._sounds.length && (t = n._sounds[0]._id,
                        e = parseFloat(i[0]))
                    } else
                        2 === i.length && (e = parseFloat(i[0]),
                        t = parseInt(i[1], 10));
                    if (void 0 === t)
                        return 0;
                    if ("number" == typeof e && ("loaded" !== n._state || n._playLock))
                        return n._queue.push({
                            event: "seek",
                            action: function() {
                                n.seek.apply(n, i)
                            }
                        }),
                        n;
                    var r = n._soundById(t);
                    if (r) {
                        if (!("number" == typeof e && e >= 0)) {
                            if (n._webAudio) {
                                var a = n.playing(t) ? s.ctx.currentTime - r._playStart : 0
                                  , o = r._rateSeek ? r._rateSeek - r._seek : 0;
                                return r._seek + (o + a * Math.abs(r._rate))
                            }
                            return r._node.currentTime
                        }
                        var l = n.playing(t);
                        l && n.pause(t, !0),
                        r._seek = e,
                        r._ended = !1,
                        n._clearTimer(t),
                        n._webAudio || !r._node || isNaN(r._node.duration) || (r._node.currentTime = e);
                        var c = function() {
                            l && n.play(t, !0),
                            n._emit("seek", t)
                        };
                        if (l && !n._webAudio) {
                            var u = function() {
                                n._playLock ? setTimeout(u, 0) : c()
                            };
                            setTimeout(u, 0)
                        } else
                            c()
                    }
                    return n
                },
                playing: function(e) {
                    var t = this;
                    if ("number" == typeof e) {
                        var n = t._soundById(e);
                        return !!n && !n._paused
                    }
                    for (var i = 0; i < t._sounds.length; i++)
                        if (!t._sounds[i]._paused)
                            return !0;
                    return !1
                },
                duration: function(e) {
                    var t = this
                      , n = t._duration
                      , i = t._soundById(e);
                    return i && (n = t._sprite[i._sprite][1] / 1e3),
                    n
                },
                state: function() {
                    return this._state
                },
                unload: function() {
                    for (var e = this, t = e._sounds, n = 0; n < t.length; n++)
                        t[n]._paused || e.stop(t[n]._id),
                        e._webAudio || (e._clearSound(t[n]._node),
                        t[n]._node.removeEventListener("error", t[n]._errorFn, !1),
                        t[n]._node.removeEventListener(s._canPlayEvent, t[n]._loadFn, !1),
                        t[n]._node.removeEventListener("ended", t[n]._endFn, !1),
                        s._releaseHtml5Audio(t[n]._node)),
                        delete t[n]._node,
                        e._clearTimer(t[n]._id);
                    var i = s._howls.indexOf(e);
                    i >= 0 && s._howls.splice(i, 1);
                    var r = !0;
                    for (n = 0; n < s._howls.length; n++)
                        if (s._howls[n]._src === e._src || e._src.indexOf(s._howls[n]._src) >= 0) {
                            r = !1;
                            break
                        }
                    return l && r && delete l[e._src],
                    s.noAudio = !1,
                    e._state = "unloaded",
                    e._sounds = [],
                    e = null,
                    null
                },
                on: function(e, t, n, i) {
                    var r = this["_on" + e];
                    return "function" == typeof t && r.push(i ? {
                        id: n,
                        fn: t,
                        once: i
                    } : {
                        id: n,
                        fn: t
                    }),
                    this
                },
                off: function(e, t, n) {
                    var i = this
                      , r = i["_on" + e]
                      , s = 0;
                    if ("number" == typeof t && (n = t,
                    t = null),
                    t || n)
                        for (s = 0; s < r.length; s++) {
                            var a = n === r[s].id;
                            if (t === r[s].fn && a || !t && a) {
                                r.splice(s, 1);
                                break
                            }
                        }
                    else if (e)
                        i["_on" + e] = [];
                    else {
                        var o = Object.keys(i);
                        for (s = 0; s < o.length; s++)
                            0 === o[s].indexOf("_on") && Array.isArray(i[o[s]]) && (i[o[s]] = [])
                    }
                    return i
                },
                once: function(e, t, n) {
                    return this.on(e, t, n, 1),
                    this
                },
                _emit: function(e, t, n) {
                    for (var i = this, r = i["_on" + e], s = r.length - 1; s >= 0; s--)
                        r[s].id && r[s].id !== t && "load" !== e || (setTimeout(function(e) {
                            e.call(this, t, n)
                        }
                        .bind(i, r[s].fn), 0),
                        r[s].once && i.off(e, r[s].fn, r[s].id));
                    return i._loadQueue(e),
                    i
                },
                _loadQueue: function(e) {
                    var t = this;
                    if (t._queue.length > 0) {
                        var n = t._queue[0];
                        n.event === e && (t._queue.shift(),
                        t._loadQueue()),
                        e || n.action()
                    }
                    return t
                },
                _ended: function(e) {
                    var t = this
                      , n = e._sprite;
                    if (!t._webAudio && e._node && !e._node.paused && !e._node.ended && e._node.currentTime < e._stop)
                        return setTimeout(t._ended.bind(t, e), 100),
                        t;
                    var i = !(!e._loop && !t._sprite[n][2]);
                    if (t._emit("end", e._id),
                    !t._webAudio && i && t.stop(e._id, !0).play(e._id),
                    t._webAudio && i) {
                        t._emit("play", e._id),
                        e._seek = e._start || 0,
                        e._rateSeek = 0,
                        e._playStart = s.ctx.currentTime;
                        var r = 1e3 * (e._stop - e._start) / Math.abs(e._rate);
                        t._endTimers[e._id] = setTimeout(t._ended.bind(t, e), r)
                    }
                    return t._webAudio && !i && (e._paused = !0,
                    e._ended = !0,
                    e._seek = e._start || 0,
                    e._rateSeek = 0,
                    t._clearTimer(e._id),
                    t._cleanBuffer(e._node),
                    s._autoSuspend()),
                    t._webAudio || i || t.stop(e._id, !0),
                    t
                },
                _clearTimer: function(e) {
                    var t = this;
                    if (t._endTimers[e]) {
                        if ("function" != typeof t._endTimers[e])
                            clearTimeout(t._endTimers[e]);
                        else {
                            var n = t._soundById(e);
                            n && n._node && n._node.removeEventListener("ended", t._endTimers[e], !1)
                        }
                        delete t._endTimers[e]
                    }
                    return t
                },
                _soundById: function(e) {
                    for (var t = this, n = 0; n < t._sounds.length; n++)
                        if (e === t._sounds[n]._id)
                            return t._sounds[n];
                    return null
                },
                _inactiveSound: function() {
                    var e = this;
                    e._drain();
                    for (var t = 0; t < e._sounds.length; t++)
                        if (e._sounds[t]._ended)
                            return e._sounds[t].reset();
                    return new o(e)
                },
                _drain: function() {
                    var e = this
                      , t = e._pool
                      , n = 0
                      , i = 0;
                    if (!(e._sounds.length < t)) {
                        for (i = 0; i < e._sounds.length; i++)
                            e._sounds[i]._ended && n++;
                        for (i = e._sounds.length - 1; i >= 0; i--) {
                            if (n <= t)
                                return;
                            e._sounds[i]._ended && (e._webAudio && e._sounds[i]._node && e._sounds[i]._node.disconnect(0),
                            e._sounds.splice(i, 1),
                            n--)
                        }
                    }
                },
                _getSoundIds: function(e) {
                    if (void 0 === e) {
                        for (var t = [], n = 0; n < this._sounds.length; n++)
                            t.push(this._sounds[n]._id);
                        return t
                    }
                    return [e]
                },
                _refreshBuffer: function(e) {
                    return e._node.bufferSource = s.ctx.createBufferSource(),
                    e._node.bufferSource.buffer = l[this._src],
                    e._panner ? e._node.bufferSource.connect(e._panner) : e._node.bufferSource.connect(e._node),
                    e._node.bufferSource.loop = e._loop,
                    e._loop && (e._node.bufferSource.loopStart = e._start || 0,
                    e._node.bufferSource.loopEnd = e._stop || 0),
                    e._node.bufferSource.playbackRate.setValueAtTime(e._rate, s.ctx.currentTime),
                    this
                },
                _cleanBuffer: function(e) {
                    var t = s._navigator && s._navigator.vendor.indexOf("Apple") >= 0;
                    if (!e.bufferSource)
                        return this;
                    if (s._scratchBuffer && e.bufferSource && (e.bufferSource.onended = null,
                    e.bufferSource.disconnect(0),
                    t))
                        try {
                            e.bufferSource.buffer = s._scratchBuffer
                        } catch (e) {}
                    return e.bufferSource = null,
                    this
                },
                _clearSound: function(e) {
                    /MSIE |Trident\//.test(s._navigator && s._navigator.userAgent) || (e.src = "data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA")
                }
            };
            var o = function(e) {
                this._parent = e,
                this.init()
            };
            o.prototype = {
                init: function() {
                    var e = this
                      , t = e._parent;
                    return e._muted = t._muted,
                    e._loop = t._loop,
                    e._volume = t._volume,
                    e._rate = t._rate,
                    e._seek = 0,
                    e._paused = !0,
                    e._ended = !0,
                    e._sprite = "__default",
                    e._id = ++s._counter,
                    t._sounds.push(e),
                    e.create(),
                    e
                },
                create: function() {
                    var e = this
                      , t = e._parent
                      , n = s._muted || e._muted || e._parent._muted ? 0 : e._volume;
                    return t._webAudio ? (e._node = void 0 === s.ctx.createGain ? s.ctx.createGainNode() : s.ctx.createGain(),
                    e._node.gain.setValueAtTime(n, s.ctx.currentTime),
                    e._node.paused = !0,
                    e._node.connect(s.masterGain)) : s.noAudio || (e._node = s._obtainHtml5Audio(),
                    e._errorFn = e._errorListener.bind(e),
                    e._node.addEventListener("error", e._errorFn, !1),
                    e._loadFn = e._loadListener.bind(e),
                    e._node.addEventListener(s._canPlayEvent, e._loadFn, !1),
                    e._endFn = e._endListener.bind(e),
                    e._node.addEventListener("ended", e._endFn, !1),
                    e._node.src = t._src,
                    e._node.preload = !0 === t._preload ? "auto" : t._preload,
                    e._node.volume = n * s.volume(),
                    e._node.load()),
                    e
                },
                reset: function() {
                    var e = this
                      , t = e._parent;
                    return e._muted = t._muted,
                    e._loop = t._loop,
                    e._volume = t._volume,
                    e._rate = t._rate,
                    e._seek = 0,
                    e._rateSeek = 0,
                    e._paused = !0,
                    e._ended = !0,
                    e._sprite = "__default",
                    e._id = ++s._counter,
                    e
                },
                _errorListener: function() {
                    var e = this;
                    e._parent._emit("loaderror", e._id, e._node.error ? e._node.error.code : 0),
                    e._node.removeEventListener("error", e._errorFn, !1)
                },
                _loadListener: function() {
                    var e = this
                      , t = e._parent;
                    t._duration = Math.ceil(10 * e._node.duration) / 10,
                    0 === Object.keys(t._sprite).length && (t._sprite = {
                        __default: [0, 1e3 * t._duration]
                    }),
                    "loaded" !== t._state && (t._state = "loaded",
                    t._emit("load"),
                    t._loadQueue()),
                    e._node.removeEventListener(s._canPlayEvent, e._loadFn, !1)
                },
                _endListener: function() {
                    var e = this
                      , t = e._parent;
                    t._duration === 1 / 0 && (t._duration = Math.ceil(10 * e._node.duration) / 10,
                    t._sprite.__default[1] === 1 / 0 && (t._sprite.__default[1] = 1e3 * t._duration),
                    t._ended(e)),
                    e._node.removeEventListener("ended", e._endFn, !1)
                }
            };
            var l = {}
              , c = function(e) {
                var t = e._src;
                if (l[t])
                    return e._duration = l[t].duration,
                    void d(e);
                if (/^data:[^;]+;base64,/.test(t)) {
                    for (var n = atob(t.split(",")[1]), i = new Uint8Array(n.length), r = 0; r < n.length; ++r)
                        i[r] = n.charCodeAt(r);
                    h(i.buffer, e)
                } else {
                    var s = new XMLHttpRequest;
                    s.open(e._xhr.method, t, !0),
                    s.withCredentials = e._xhr.withCredentials,
                    s.responseType = "arraybuffer",
                    e._xhr.headers && Object.keys(e._xhr.headers).forEach((function(t) {
                        s.setRequestHeader(t, e._xhr.headers[t])
                    }
                    )),
                    s.onload = function() {
                        var t = (s.status + "")[0];
                        "0" === t || "2" === t || "3" === t ? h(s.response, e) : e._emit("loaderror", null, "Failed loading audio file with status: " + s.status + ".")
                    }
                    ,
                    s.onerror = function() {
                        e._webAudio && (e._html5 = !0,
                        e._webAudio = !1,
                        e._sounds = [],
                        delete l[t],
                        e.load())
                    }
                    ,
                    u(s)
                }
            }
              , u = function(e) {
                try {
                    e.send()
                } catch (t) {
                    e.onerror()
                }
            }
              , h = function(e, t) {
                var n = function() {
                    t._emit("loaderror", null, "Decoding audio data failed.")
                }
                  , i = function(e) {
                    e && t._sounds.length > 0 ? (l[t._src] = e,
                    d(t, e)) : n()
                };
                "undefined" != typeof Promise && 1 === s.ctx.decodeAudioData.length ? s.ctx.decodeAudioData(e).then(i).catch(n) : s.ctx.decodeAudioData(e, i, n)
            }
              , d = function(e, t) {
                t && !e._duration && (e._duration = t.duration),
                0 === Object.keys(e._sprite).length && (e._sprite = {
                    __default: [0, 1e3 * e._duration]
                }),
                "loaded" !== e._state && (e._state = "loaded",
                e._emit("load"),
                e._loadQueue())
            }
              , p = function() {
                if (s.usingWebAudio) {
                    try {
                        "undefined" != typeof AudioContext ? s.ctx = new AudioContext : "undefined" != typeof webkitAudioContext ? s.ctx = new webkitAudioContext : s.usingWebAudio = !1
                    } catch (e) {
                        s.usingWebAudio = !1
                    }
                    s.ctx || (s.usingWebAudio = !1);
                    var e = /iP(hone|od|ad)/.test(s._navigator && s._navigator.platform)
                      , t = s._navigator && s._navigator.appVersion.match(/OS (\d+)_(\d+)_?(\d+)?/)
                      , n = t ? parseInt(t[1], 10) : null;
                    if (e && n && n < 9) {
                        var i = /safari/.test(s._navigator && s._navigator.userAgent.toLowerCase());
                        s._navigator && !i && (s.usingWebAudio = !1)
                    }
                    s.usingWebAudio && (s.masterGain = void 0 === s.ctx.createGain ? s.ctx.createGainNode() : s.ctx.createGain(),
                    s.masterGain.gain.setValueAtTime(s._muted ? 0 : s._volume, s.ctx.currentTime),
                    s.masterGain.connect(s.ctx.destination)),
                    s._setup()
                }
            };
            void 0 === (i = function() {
                return {
                    Howler: s,
                    Howl: a
                }
            }
            .apply(t, [])) || (e.exports = i),
            t.Howler = s,
            t.Howl = a,
            void 0 !== n.g ? (n.g.HowlerGlobal = r,
            n.g.Howler = s,
            n.g.Howl = a,
            n.g.Sound = o) : "undefined" != typeof window && (window.HowlerGlobal = r,
            window.Howler = s,
            window.Howl = a,
            window.Sound = o)
        }(),
        function() {
            "use strict";
            var e;
            HowlerGlobal.prototype._pos = [0, 0, 0],
            HowlerGlobal.prototype._orientation = [0, 0, -1, 0, 1, 0],
            HowlerGlobal.prototype.stereo = function(e) {
                var t = this;
                if (!t.ctx || !t.ctx.listener)
                    return t;
                for (var n = t._howls.length - 1; n >= 0; n--)
                    t._howls[n].stereo(e);
                return t
            }
            ,
            HowlerGlobal.prototype.pos = function(e, t, n) {
                var i = this;
                return i.ctx && i.ctx.listener ? (t = "number" != typeof t ? i._pos[1] : t,
                n = "number" != typeof n ? i._pos[2] : n,
                "number" != typeof e ? i._pos : (i._pos = [e, t, n],
                void 0 !== i.ctx.listener.positionX ? (i.ctx.listener.positionX.setTargetAtTime(i._pos[0], Howler.ctx.currentTime, .1),
                i.ctx.listener.positionY.setTargetAtTime(i._pos[1], Howler.ctx.currentTime, .1),
                i.ctx.listener.positionZ.setTargetAtTime(i._pos[2], Howler.ctx.currentTime, .1)) : i.ctx.listener.setPosition(i._pos[0], i._pos[1], i._pos[2]),
                i)) : i
            }
            ,
            HowlerGlobal.prototype.orientation = function(e, t, n, i, r, s) {
                var a = this;
                if (!a.ctx || !a.ctx.listener)
                    return a;
                var o = a._orientation;
                return t = "number" != typeof t ? o[1] : t,
                n = "number" != typeof n ? o[2] : n,
                i = "number" != typeof i ? o[3] : i,
                r = "number" != typeof r ? o[4] : r,
                s = "number" != typeof s ? o[5] : s,
                "number" != typeof e ? o : (a._orientation = [e, t, n, i, r, s],
                void 0 !== a.ctx.listener.forwardX ? (a.ctx.listener.forwardX.setTargetAtTime(e, Howler.ctx.currentTime, .1),
                a.ctx.listener.forwardY.setTargetAtTime(t, Howler.ctx.currentTime, .1),
                a.ctx.listener.forwardZ.setTargetAtTime(n, Howler.ctx.currentTime, .1),
                a.ctx.listener.upX.setTargetAtTime(i, Howler.ctx.currentTime, .1),
                a.ctx.listener.upY.setTargetAtTime(r, Howler.ctx.currentTime, .1),
                a.ctx.listener.upZ.setTargetAtTime(s, Howler.ctx.currentTime, .1)) : a.ctx.listener.setOrientation(e, t, n, i, r, s),
                a)
            }
            ,
            Howl.prototype.init = (e = Howl.prototype.init,
            function(t) {
                var n = this;
                return n._orientation = t.orientation || [1, 0, 0],
                n._stereo = t.stereo || null,
                n._pos = t.pos || null,
                n._pannerAttr = {
                    coneInnerAngle: void 0 !== t.coneInnerAngle ? t.coneInnerAngle : 360,
                    coneOuterAngle: void 0 !== t.coneOuterAngle ? t.coneOuterAngle : 360,
                    coneOuterGain: void 0 !== t.coneOuterGain ? t.coneOuterGain : 0,
                    distanceModel: void 0 !== t.distanceModel ? t.distanceModel : "inverse",
                    maxDistance: void 0 !== t.maxDistance ? t.maxDistance : 1e4,
                    panningModel: void 0 !== t.panningModel ? t.panningModel : "HRTF",
                    refDistance: void 0 !== t.refDistance ? t.refDistance : 1,
                    rolloffFactor: void 0 !== t.rolloffFactor ? t.rolloffFactor : 1
                },
                n._onstereo = t.onstereo ? [{
                    fn: t.onstereo
                }] : [],
                n._onpos = t.onpos ? [{
                    fn: t.onpos
                }] : [],
                n._onorientation = t.onorientation ? [{
                    fn: t.onorientation
                }] : [],
                e.call(this, t)
            }
            ),
            Howl.prototype.stereo = function(e, n) {
                var i = this;
                if (!i._webAudio)
                    return i;
                if ("loaded" !== i._state)
                    return i._queue.push({
                        event: "stereo",
                        action: function() {
                            i.stereo(e, n)
                        }
                    }),
                    i;
                var r = void 0 === Howler.ctx.createStereoPanner ? "spatial" : "stereo";
                if (void 0 === n) {
                    if ("number" != typeof e)
                        return i._stereo;
                    i._stereo = e,
                    i._pos = [e, 0, 0]
                }
                for (var s = i._getSoundIds(n), a = 0; a < s.length; a++) {
                    var o = i._soundById(s[a]);
                    if (o) {
                        if ("number" != typeof e)
                            return o._stereo;
                        o._stereo = e,
                        o._pos = [e, 0, 0],
                        o._node && (o._pannerAttr.panningModel = "equalpower",
                        o._panner && o._panner.pan || t(o, r),
                        "spatial" === r ? void 0 !== o._panner.positionX ? (o._panner.positionX.setValueAtTime(e, Howler.ctx.currentTime),
                        o._panner.positionY.setValueAtTime(0, Howler.ctx.currentTime),
                        o._panner.positionZ.setValueAtTime(0, Howler.ctx.currentTime)) : o._panner.setPosition(e, 0, 0) : o._panner.pan.setValueAtTime(e, Howler.ctx.currentTime)),
                        i._emit("stereo", o._id)
                    }
                }
                return i
            }
            ,
            Howl.prototype.pos = function(e, n, i, r) {
                var s = this;
                if (!s._webAudio)
                    return s;
                if ("loaded" !== s._state)
                    return s._queue.push({
                        event: "pos",
                        action: function() {
                            s.pos(e, n, i, r)
                        }
                    }),
                    s;
                if (n = "number" != typeof n ? 0 : n,
                i = "number" != typeof i ? -.5 : i,
                void 0 === r) {
                    if ("number" != typeof e)
                        return s._pos;
                    s._pos = [e, n, i]
                }
                for (var a = s._getSoundIds(r), o = 0; o < a.length; o++) {
                    var l = s._soundById(a[o]);
                    if (l) {
                        if ("number" != typeof e)
                            return l._pos;
                        l._pos = [e, n, i],
                        l._node && (l._panner && !l._panner.pan || t(l, "spatial"),
                        void 0 !== l._panner.positionX ? (l._panner.positionX.setValueAtTime(e, Howler.ctx.currentTime),
                        l._panner.positionY.setValueAtTime(n, Howler.ctx.currentTime),
                        l._panner.positionZ.setValueAtTime(i, Howler.ctx.currentTime)) : l._panner.setPosition(e, n, i)),
                        s._emit("pos", l._id)
                    }
                }
                return s
            }
            ,
            Howl.prototype.orientation = function(e, n, i, r) {
                var s = this;
                if (!s._webAudio)
                    return s;
                if ("loaded" !== s._state)
                    return s._queue.push({
                        event: "orientation",
                        action: function() {
                            s.orientation(e, n, i, r)
                        }
                    }),
                    s;
                if (n = "number" != typeof n ? s._orientation[1] : n,
                i = "number" != typeof i ? s._orientation[2] : i,
                void 0 === r) {
                    if ("number" != typeof e)
                        return s._orientation;
                    s._orientation = [e, n, i]
                }
                for (var a = s._getSoundIds(r), o = 0; o < a.length; o++) {
                    var l = s._soundById(a[o]);
                    if (l) {
                        if ("number" != typeof e)
                            return l._orientation;
                        l._orientation = [e, n, i],
                        l._node && (l._panner || (l._pos || (l._pos = s._pos || [0, 0, -.5]),
                        t(l, "spatial")),
                        void 0 !== l._panner.orientationX ? (l._panner.orientationX.setValueAtTime(e, Howler.ctx.currentTime),
                        l._panner.orientationY.setValueAtTime(n, Howler.ctx.currentTime),
                        l._panner.orientationZ.setValueAtTime(i, Howler.ctx.currentTime)) : l._panner.setOrientation(e, n, i)),
                        s._emit("orientation", l._id)
                    }
                }
                return s
            }
            ,
            Howl.prototype.pannerAttr = function() {
                var e, n, i, r = this, s = arguments;
                if (!r._webAudio)
                    return r;
                if (0 === s.length)
                    return r._pannerAttr;
                if (1 === s.length) {
                    if ("object" != typeof s[0])
                        return (i = r._soundById(parseInt(s[0], 10))) ? i._pannerAttr : r._pannerAttr;
                    e = s[0],
                    void 0 === n && (e.pannerAttr || (e.pannerAttr = {
                        coneInnerAngle: e.coneInnerAngle,
                        coneOuterAngle: e.coneOuterAngle,
                        coneOuterGain: e.coneOuterGain,
                        distanceModel: e.distanceModel,
                        maxDistance: e.maxDistance,
                        refDistance: e.refDistance,
                        rolloffFactor: e.rolloffFactor,
                        panningModel: e.panningModel
                    }),
                    r._pannerAttr = {
                        coneInnerAngle: void 0 !== e.pannerAttr.coneInnerAngle ? e.pannerAttr.coneInnerAngle : r._coneInnerAngle,
                        coneOuterAngle: void 0 !== e.pannerAttr.coneOuterAngle ? e.pannerAttr.coneOuterAngle : r._coneOuterAngle,
                        coneOuterGain: void 0 !== e.pannerAttr.coneOuterGain ? e.pannerAttr.coneOuterGain : r._coneOuterGain,
                        distanceModel: void 0 !== e.pannerAttr.distanceModel ? e.pannerAttr.distanceModel : r._distanceModel,
                        maxDistance: void 0 !== e.pannerAttr.maxDistance ? e.pannerAttr.maxDistance : r._maxDistance,
                        refDistance: void 0 !== e.pannerAttr.refDistance ? e.pannerAttr.refDistance : r._refDistance,
                        rolloffFactor: void 0 !== e.pannerAttr.rolloffFactor ? e.pannerAttr.rolloffFactor : r._rolloffFactor,
                        panningModel: void 0 !== e.pannerAttr.panningModel ? e.pannerAttr.panningModel : r._panningModel
                    })
                } else
                    2 === s.length && (e = s[0],
                    n = parseInt(s[1], 10));
                for (var a = r._getSoundIds(n), o = 0; o < a.length; o++)
                    if (i = r._soundById(a[o])) {
                        var l = i._pannerAttr;
                        l = {
                            coneInnerAngle: void 0 !== e.coneInnerAngle ? e.coneInnerAngle : l.coneInnerAngle,
                            coneOuterAngle: void 0 !== e.coneOuterAngle ? e.coneOuterAngle : l.coneOuterAngle,
                            coneOuterGain: void 0 !== e.coneOuterGain ? e.coneOuterGain : l.coneOuterGain,
                            distanceModel: void 0 !== e.distanceModel ? e.distanceModel : l.distanceModel,
                            maxDistance: void 0 !== e.maxDistance ? e.maxDistance : l.maxDistance,
                            refDistance: void 0 !== e.refDistance ? e.refDistance : l.refDistance,
                            rolloffFactor: void 0 !== e.rolloffFactor ? e.rolloffFactor : l.rolloffFactor,
                            panningModel: void 0 !== e.panningModel ? e.panningModel : l.panningModel
                        };
                        var c = i._panner;
                        c || (i._pos || (i._pos = r._pos || [0, 0, -.5]),
                        t(i, "spatial"),
                        c = i._panner),
                        c.coneInnerAngle = l.coneInnerAngle,
                        c.coneOuterAngle = l.coneOuterAngle,
                        c.coneOuterGain = l.coneOuterGain,
                        c.distanceModel = l.distanceModel,
                        c.maxDistance = l.maxDistance,
                        c.refDistance = l.refDistance,
                        c.rolloffFactor = l.rolloffFactor,
                        c.panningModel = l.panningModel
                    }
                return r
            }
            ,
            Sound.prototype.init = function(e) {
                return function() {
                    var t = this
                      , n = t._parent;
                    t._orientation = n._orientation,
                    t._stereo = n._stereo,
                    t._pos = n._pos,
                    t._pannerAttr = n._pannerAttr,
                    e.call(this),
                    t._stereo ? n.stereo(t._stereo) : t._pos && n.pos(t._pos[0], t._pos[1], t._pos[2], t._id)
                }
            }(Sound.prototype.init),
            Sound.prototype.reset = function(e) {
                return function() {
                    var t = this
                      , n = t._parent;
                    return t._orientation = n._orientation,
                    t._stereo = n._stereo,
                    t._pos = n._pos,
                    t._pannerAttr = n._pannerAttr,
                    t._stereo ? n.stereo(t._stereo) : t._pos ? n.pos(t._pos[0], t._pos[1], t._pos[2], t._id) : t._panner && (t._panner.disconnect(0),
                    t._panner = void 0,
                    n._refreshBuffer(t)),
                    e.call(this)
                }
            }(Sound.prototype.reset);
            var t = function(e, t) {
                "spatial" === (t = t || "spatial") ? (e._panner = Howler.ctx.createPanner(),
                e._panner.coneInnerAngle = e._pannerAttr.coneInnerAngle,
                e._panner.coneOuterAngle = e._pannerAttr.coneOuterAngle,
                e._panner.coneOuterGain = e._pannerAttr.coneOuterGain,
                e._panner.distanceModel = e._pannerAttr.distanceModel,
                e._panner.maxDistance = e._pannerAttr.maxDistance,
                e._panner.refDistance = e._pannerAttr.refDistance,
                e._panner.rolloffFactor = e._pannerAttr.rolloffFactor,
                e._panner.panningModel = e._pannerAttr.panningModel,
                void 0 !== e._panner.positionX ? (e._panner.positionX.setValueAtTime(e._pos[0], Howler.ctx.currentTime),
                e._panner.positionY.setValueAtTime(e._pos[1], Howler.ctx.currentTime),
                e._panner.positionZ.setValueAtTime(e._pos[2], Howler.ctx.currentTime)) : e._panner.setPosition(e._pos[0], e._pos[1], e._pos[2]),
                void 0 !== e._panner.orientationX ? (e._panner.orientationX.setValueAtTime(e._orientation[0], Howler.ctx.currentTime),
                e._panner.orientationY.setValueAtTime(e._orientation[1], Howler.ctx.currentTime),
                e._panner.orientationZ.setValueAtTime(e._orientation[2], Howler.ctx.currentTime)) : e._panner.setOrientation(e._orientation[0], e._orientation[1], e._orientation[2])) : (e._panner = Howler.ctx.createStereoPanner(),
                e._panner.pan.setValueAtTime(e._stereo, Howler.ctx.currentTime)),
                e._panner.connect(e._node),
                e._paused || e._parent.pause(e._id, !0).play(e._id, !0)
            }
        }()
    }
    ,
    8336: e => {
        var t, n;
        t = [],
        n = [],
        e.exports = function(e, i, r) {
            var s, a, o, l, c, u, h, d;
            if (e === i)
                return 0;
            if (s = e.length,
            a = i.length,
            0 === s)
                return a;
            if (0 === a)
                return s;
            for (r && (e = e.toLowerCase(),
            i = i.toLowerCase()),
            h = 0; h < s; )
                n[h] = e.charCodeAt(h),
                t[h] = ++h;
            for (d = 0; d < a; )
                for (o = i.charCodeAt(d),
                l = c = d++,
                h = -1; ++h < s; )
                    u = o === n[h] ? c : c + 1,
                    c = t[h],
                    t[h] = l = c > l ? u > l ? l + 1 : u : u > c ? c + 1 : u;
            return l
        }
    }
    ,
    2722: (e, t, n) => {
        var i = n(8336);
        e.exports = function() {
            var e, t, n, r, s, a = 0, o = arguments[0], l = arguments[1], c = l.length, u = arguments[2];
            u && (r = u.threshold,
            s = u.ignoreCase),
            void 0 === r && (r = 0);
            for (var h = 0; h < c; ++h)
                (e = (t = s ? i(o, l[h], !0) : i(o, l[h])) > o.length ? 1 - t / l[h].length : 1 - t / o.length) > a && (a = e,
                n = l[h]);
            return a >= r ? n : null
        }
    }
    ,
    2052: function(e) {
        var t;
        e.exports = ((t = function() {
            function e(e) {
                return r.appendChild(e.dom),
                e
            }
            function n(e) {
                for (var t = 0; t < r.children.length; t++)
                    r.children[t].style.display = t === e ? "block" : "none";
                i = e
            }
            var i = 0
              , r = document.createElement("div");
            r.style.cssText = "position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000",
            r.addEventListener("click", (function(e) {
                e.preventDefault(),
                n(++i % r.children.length)
            }
            ), !1);
            var s = (performance || Date).now()
              , a = s
              , o = 0
              , l = e(new t.Panel("FPS","#0ff","#002"))
              , c = e(new t.Panel("MS","#0f0","#020"));
            if (self.performance && self.performance.memory)
                var u = e(new t.Panel("MB","#f08","#201"));
            return n(0),
            {
                REVISION: 16,
                dom: r,
                addPanel: e,
                showPanel: n,
                begin: function() {
                    s = (performance || Date).now()
                },
                end: function() {
                    o++;
                    var e = (performance || Date).now();
                    if (c.update(e - s, 200),
                    e > a + 1e3 && (l.update(1e3 * o / (e - a), 100),
                    a = e,
                    o = 0,
                    u)) {
                        var t = performance.memory;
                        u.update(t.usedJSHeapSize / 1048576, t.jsHeapSizeLimit / 1048576)
                    }
                    return e
                },
                update: function() {
                    s = this.end()
                },
                domElement: r,
                setMode: n
            }
        }
        ).Panel = function(e, t, n) {
            var i = 1 / 0
              , r = 0
              , s = Math.round
              , a = s(window.devicePixelRatio || 1)
              , o = 80 * a
              , l = 48 * a
              , c = 3 * a
              , u = 2 * a
              , h = 3 * a
              , d = 15 * a
              , p = 74 * a
              , f = 30 * a
              , A = document.createElement("canvas");
            A.width = o,
            A.height = l,
            A.style.cssText = "width:80px;height:48px";
            var g = A.getContext("2d");
            return g.font = "bold " + 9 * a + "px Helvetica,Arial,sans-serif",
            g.textBaseline = "top",
            g.fillStyle = n,
            g.fillRect(0, 0, o, l),
            g.fillStyle = t,
            g.fillText(e, c, u),
            g.fillRect(h, d, p, f),
            g.fillStyle = n,
            g.globalAlpha = .9,
            g.fillRect(h, d, p, f),
            {
                dom: A,
                update: function(l, m) {
                    i = Math.min(i, l),
                    r = Math.max(r, l),
                    g.fillStyle = n,
                    g.globalAlpha = 1,
                    g.fillRect(0, 0, o, d),
                    g.fillStyle = t,
                    g.fillText(s(l) + " " + e + " (" + s(i) + "-" + s(r) + ")", c, u),
                    g.drawImage(A, h + a, d, p - a, f, h, d, p - a, f),
                    g.fillRect(h + p - a, d, a, f),
                    g.fillStyle = n,
                    g.globalAlpha = .9,
                    g.fillRect(h + p - a, d, a, s((1 - l / m) * f))
                }
            }
        }
        ,
        t)
    },
    5314: e => {
        e.exports = function() {
            function e(e, t, n, i) {
                this.set(e, t, n, i)
            }
            return e.prototype.set = function(e, t, n, i) {
                this._cx = 3 * e,
                this._bx = 3 * (n - e) - this._cx,
                this._ax = 1 - this._cx - this._bx,
                this._cy = 3 * t,
                this._by = 3 * (i - t) - this._cy,
                this._ay = 1 - this._cy - this._by
            }
            ,
            e.epsilon = 1e-6,
            e.prototype._sampleCurveX = function(e) {
                return ((this._ax * e + this._bx) * e + this._cx) * e
            }
            ,
            e.prototype._sampleCurveY = function(e) {
                return ((this._ay * e + this._by) * e + this._cy) * e
            }
            ,
            e.prototype._sampleCurveDerivativeX = function(e) {
                return (3 * this._ax * e + 2 * this._bx) * e + this._cx
            }
            ,
            e.prototype._solveCurveX = function(e, t) {
                var n, i, r, s, a, o;
                for (r = void 0,
                s = void 0,
                a = void 0,
                o = void 0,
                n = void 0,
                i = void 0,
                a = e,
                i = 0; i < 8; ) {
                    if (o = this._sampleCurveX(a) - e,
                    Math.abs(o) < t)
                        return a;
                    if (n = this._sampleCurveDerivativeX(a),
                    Math.abs(n) < t)
                        break;
                    a -= o / n,
                    i++
                }
                if ((a = e) < (r = 0))
                    return r;
                if (a > (s = 1))
                    return s;
                for (; r < s; ) {
                    if (o = this._sampleCurveX(a),
                    Math.abs(o - e) < t)
                        return a;
                    e > o ? r = a : s = a,
                    a = .5 * (s - r) + r
                }
                return a
            }
            ,
            e.prototype.solve = function(e, t) {
                return this._sampleCurveY(this._solveCurveX(e, t))
            }
            ,
            e.prototype.solveSimple = function(e) {
                return this._sampleCurveY(this._solveCurveX(e, 1e-6))
            }
            ,
            e
        }()
    }
    ,
    9314: (e, t, n) => {
        "use strict";
        n.d(t, {
            i: () => In
        });
        var i = n(1773);
        const r = new WeakMap;
        var s = n(9791)
          , a = n(2378)
          , o = n(154);
        class l {
            constructor(e) {
                this.animations = e.filter(Boolean)
            }
            then(e, t) {
                return Promise.all(this.animations).then(e).catch(t)
            }
            getAll(e) {
                return this.animations[0][e]
            }
            setAll(e, t) {
                for (let n = 0; n < this.animations.length; n++)
                    this.animations[n][e] = t
            }
            attachTimeline(e) {
                const t = this.animations.map((t => {
                    if (!(0,
                    o.J)() || !t.attachTimeline)
                        return t.pause(),
                        (0,
                        a.y)((e => {
                            t.time = t.duration * e
                        }
                        ), e);
                    t.attachTimeline(e)
                }
                ));
                return () => {
                    t.forEach(( (e, t) => {
                        e && e(),
                        this.animations[t].stop()
                    }
                    ))
                }
            }
            get time() {
                return this.getAll("time")
            }
            set time(e) {
                this.setAll("time", e)
            }
            get speed() {
                return this.getAll("speed")
            }
            set speed(e) {
                this.setAll("speed", e)
            }
            get duration() {
                let e = 0;
                for (let t = 0; t < this.animations.length; t++)
                    e = Math.max(e, this.animations[t].duration);
                return e
            }
            runAll(e) {
                this.animations.forEach((t => t[e]()))
            }
            play() {
                this.runAll("play")
            }
            pause() {
                this.runAll("pause")
            }
            stop() {
                this.runAll("stop")
            }
            cancel() {
                this.runAll("cancel")
            }
            complete() {
                this.runAll("complete")
            }
        }
        const c = ["transformPerspective", "x", "y", "z", "translateX", "translateY", "translateZ", "scale", "scaleX", "scaleY", "rotate", "rotateX", "rotateY", "rotateZ", "skew", "skewX", "skewY"]
          , u = new Set(c)
          , h = e => e.replace(/([a-z])([A-Z])/gu, "$1-$2").toLowerCase()
          , d = "data-" + h("framerAppearId")
          , p = e => 1e3 * e
          , f = e => e / 1e3
          , A = {
            type: "spring",
            stiffness: 500,
            damping: 25,
            restSpeed: 10
        }
          , g = {
            type: "keyframes",
            duration: .8
        }
          , m = {
            type: "keyframes",
            ease: [.25, .1, .35, 1],
            duration: .3
        }
          , v = (e, {keyframes: t}) => t.length > 2 ? g : u.has(e) ? e.startsWith("scale") ? {
            type: "spring",
            stiffness: 550,
            damping: 0 === t[1] ? 2 * Math.sqrt(550) : 30,
            restSpeed: 10
        } : A : m;
        function y(e, t) {
            return e[t] || e.default || e
        }
        var x = n(6021);
        const _ = !1
          , b = e => null !== e;
        function E(e, {repeat: t, repeatType: n="loop"}) {
            const i = e.filter(b);
            return i[t && "loop" !== n && t % 2 == 1 ? 0 : i.length - 1]
        }
        var w = n(4124);
        let C;
        function I() {
            C = void 0
        }
        const S = {
            now: () => (void 0 === C && S.set(w.uv.isProcessing || x.W.useManualTiming ? w.uv.timestamp : performance.now()),
            C),
            set: e => {
                C = e,
                queueMicrotask(I)
            }
        }
          , M = e => /^0[^.\s]+$/u.test(e);
        const T = e => /^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(e);
        var B = n(5813);
        const R = /^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u;
        function D(e, t, n=1) {
            (0,
            s.V)(n <= 4, `Max CSS variable fallback depth detected in property "${e}". This may indicate a circular fallback dependency.`);
            const [i,r] = function(e) {
                const t = R.exec(e);
                if (!t)
                    return [, ];
                const [,n,i,r] = t;
                return [`--${null != n ? n : i}`, r]
            }(e);
            if (!i)
                return;
            const a = window.getComputedStyle(t).getPropertyValue(i);
            if (a) {
                const e = a.trim();
                return T(e) ? parseFloat(e) : e
            }
            return (0,
            B.p)(r) ? D(r, t, n + 1) : r
        }
        var P = n(8411)
          , L = n(4238);
        const U = new Set(["width", "height", "top", "left", "right", "bottom", "x", "y", "translateX", "translateY"])
          , F = e => e === P.ai || e === L.px
          , N = (e, t) => parseFloat(e.split(", ")[t])
          , O = (e, t) => (n, {transform: i}) => {
            if ("none" === i || !i)
                return 0;
            const r = i.match(/^matrix3d\((.+)\)$/u);
            if (r)
                return N(r[1], t);
            {
                const t = i.match(/^matrix\((.+)\)$/u);
                return t ? N(t[1], e) : 0
            }
        }
          , Q = new Set(["x", "y", "z"])
          , k = c.filter((e => !Q.has(e)));
        const G = {
            width: ({x: e}, {paddingLeft: t="0", paddingRight: n="0"}) => e.max - e.min - parseFloat(t) - parseFloat(n),
            height: ({y: e}, {paddingTop: t="0", paddingBottom: n="0"}) => e.max - e.min - parseFloat(t) - parseFloat(n),
            top: (e, {top: t}) => parseFloat(t),
            left: (e, {left: t}) => parseFloat(t),
            bottom: ({y: e}, {top: t}) => parseFloat(t) + (e.max - e.min),
            right: ({x: e}, {left: t}) => parseFloat(t) + (e.max - e.min),
            x: O(4, 13),
            y: O(5, 14)
        };
        G.translateX = G.x,
        G.translateY = G.y;
        const H = e => t => t.test(e)
          , z = [P.ai, L.px, L.KN, L.uj, L.vw, L.vh, {
            test: e => "auto" === e,
            parse: e => e
        }]
          , V = e => z.find(H(e))
          , W = new Set;
        let j = !1
          , q = !1;
        function Y() {
            q && (W.forEach((e => {
                e.needsMeasurement && e.unsetTransforms()
            }
            )),
            W.forEach((e => {
                e.needsMeasurement && e.measureInitialState()
            }
            )),
            W.forEach((e => {
                e.needsMeasurement && e.renderEndStyles()
            }
            )),
            W.forEach((e => {
                e.needsMeasurement && e.measureEndState()
            }
            ))),
            q = !1,
            j = !1,
            W.forEach((e => e.complete())),
            W.clear()
        }
        function X() {
            W.forEach((e => {
                e.readKeyframes(),
                e.needsMeasurement && (q = !0)
            }
            )),
            w.Gt.resolveKeyframes(Y)
        }
        class K {
            constructor(e, t, n, i, r, s=!1) {
                this.isComplete = !1,
                this.isAsync = !1,
                this.needsMeasurement = !1,
                this.isScheduled = !1,
                this.unresolvedKeyframes = [...e],
                this.onComplete = t,
                this.name = n,
                this.motionValue = i,
                this.element = r,
                this.isAsync = s
            }
            scheduleResolve() {
                this.isScheduled = !0,
                this.isAsync ? (W.add(this),
                j || (j = !0,
                w.Gt.read(X))) : (this.readKeyframes(),
                this.complete())
            }
            readKeyframes() {
                const {unresolvedKeyframes: e, name: t, element: n, motionValue: i} = this;
                for (let r = 0; r < e.length; r++)
                    if (null === e[r])
                        if (0 === r) {
                            const r = null == i ? void 0 : i.get()
                              , s = e[e.length - 1];
                            if (void 0 !== r)
                                e[0] = r;
                            else if (n && t) {
                                const i = n.readValue(t, s);
                                null != i && (e[0] = i)
                            }
                            void 0 === e[0] && (e[0] = s),
                            i && void 0 === r && i.set(e[0])
                        } else
                            e[r] = e[r - 1]
            }
            unsetTransforms() {}
            measureInitialState() {}
            renderEndStyles() {}
            measureEndState() {}
            complete() {
                this.isComplete = !0,
                this.onComplete(this.unresolvedKeyframes),
                W.delete(this)
            }
            cancel() {
                this.isComplete || (this.isScheduled = !1,
                W.delete(this))
            }
            resume() {
                this.isComplete || this.scheduleResolve()
            }
        }
        var J = n(7865)
          , Z = n(211);
        const $ = new Set(["brightness", "contrast", "saturate", "opacity"]);
        function ee(e) {
            const [t,n] = e.slice(0, -1).split("(");
            if ("drop-shadow" === t)
                return e;
            const [i] = n.match(Z.SY) || [];
            if (!i)
                return e;
            const r = n.replace(i, "");
            let s = $.has(t) ? 1 : 0;
            return i !== n && (s *= 100),
            t + "(" + s + r + ")"
        }
        const te = /\b([a-z-]*)\(.*?\)/gu
          , ne = {
            ...J.f,
            getAnimatableNone: e => {
                const t = e.match(te);
                return t ? t.map(ee).join(" ") : e
            }
        };
        var ie = n(4984);
        const re = {
            ...P.ai,
            transform: Math.round
        }
          , se = {
            borderWidth: L.px,
            borderTopWidth: L.px,
            borderRightWidth: L.px,
            borderBottomWidth: L.px,
            borderLeftWidth: L.px,
            borderRadius: L.px,
            radius: L.px,
            borderTopLeftRadius: L.px,
            borderTopRightRadius: L.px,
            borderBottomRightRadius: L.px,
            borderBottomLeftRadius: L.px,
            width: L.px,
            maxWidth: L.px,
            height: L.px,
            maxHeight: L.px,
            size: L.px,
            top: L.px,
            right: L.px,
            bottom: L.px,
            left: L.px,
            padding: L.px,
            paddingTop: L.px,
            paddingRight: L.px,
            paddingBottom: L.px,
            paddingLeft: L.px,
            margin: L.px,
            marginTop: L.px,
            marginRight: L.px,
            marginBottom: L.px,
            marginLeft: L.px,
            rotate: L.uj,
            rotateX: L.uj,
            rotateY: L.uj,
            rotateZ: L.uj,
            scale: P.hs,
            scaleX: P.hs,
            scaleY: P.hs,
            scaleZ: P.hs,
            skew: L.uj,
            skewX: L.uj,
            skewY: L.uj,
            distance: L.px,
            translateX: L.px,
            translateY: L.px,
            translateZ: L.px,
            x: L.px,
            y: L.px,
            z: L.px,
            perspective: L.px,
            transformPerspective: L.px,
            opacity: P.X4,
            originX: L.gQ,
            originY: L.gQ,
            originZ: L.px,
            zIndex: re,
            fillOpacity: P.X4,
            strokeOpacity: P.X4,
            numOctaves: re
        }
          , ae = {
            ...se,
            color: ie.y,
            backgroundColor: ie.y,
            outlineColor: ie.y,
            fill: ie.y,
            stroke: ie.y,
            borderColor: ie.y,
            borderTopColor: ie.y,
            borderRightColor: ie.y,
            borderBottomColor: ie.y,
            borderLeftColor: ie.y,
            filter: ne,
            WebkitFilter: ne
        }
          , oe = e => ae[e];
        function le(e, t) {
            let n = oe(e);
            return n !== ne && (n = J.f),
            n.getAnimatableNone ? n.getAnimatableNone(t) : void 0
        }
        class ce extends K {
            constructor(e, t, n, i) {
                super(e, t, n, i, null == i ? void 0 : i.owner, !0)
            }
            readKeyframes() {
                const {unresolvedKeyframes: e, element: t, name: n} = this;
                if (!t.current)
                    return;
                const i = [];
                super.readKeyframes();
                for (let n = 0; n < e.length; n++) {
                    const s = e[n];
                    if ("string" == typeof s && (0,
                    B.p)(s)) {
                        const i = D(s, t.current);
                        void 0 !== i && (e[n] = i)
                    }
                    ("number" == typeof (r = e[n]) ? 0 === r : null === r || "none" === r || "0" === r || M(r)) && i.push(n)
                }
                var r;
                if (i.length && function(e, t, n) {
                    let i, r = 0;
                    for (; r < e.length && !i; )
                        "string" == typeof e[r] && "none" !== e[r] && "0" !== e[r] && (i = e[r]),
                        r++;
                    if (i && n)
                        for (const r of t)
                            e[r] = le(n, i)
                }(e, i, n),
                !U.has(n) || 2 !== e.length)
                    return;
                const [s,a] = e
                  , o = V(s)
                  , l = V(a);
                if (o && l && o !== l)
                    if (F(o) && F(l))
                        for (let t = 0; t < e.length; t++) {
                            const n = e[t];
                            "string" == typeof n && (e[t] = parseFloat(n))
                        }
                    else
                        this.needsMeasurement = !0
            }
            unsetTransforms() {
                const {element: e, name: t, unresolvedKeyframes: n} = this;
                if (!e.current)
                    return;
                this.removedTransforms = function(e) {
                    const t = [];
                    return k.forEach((n => {
                        const i = e.getValue(n);
                        void 0 !== i && (t.push([n, i.get()]),
                        i.set(n.startsWith("scale") ? 1 : 0))
                    }
                    )),
                    t.length && e.render(),
                    t
                }(e);
                const i = n[n.length - 1];
                e.getValue(t, i).jump(i, !1)
            }
            measureInitialState() {
                const {element: e, unresolvedKeyframes: t, name: n} = this;
                e.current && ("height" === n && (this.suspendedScrollY = window.pageYOffset),
                this.measuredOrigin = G[n](e.measureViewportBox(), window.getComputedStyle(e.current)),
                t[0] = this.measuredOrigin)
            }
            renderEndStyles() {
                this.element.render()
            }
            measureEndState() {
                var e;
                const {element: t, name: n, unresolvedKeyframes: i} = this;
                if (!t.current)
                    return;
                const r = t.getValue(n);
                r && r.jump(this.measuredOrigin, !1),
                i[i.length - 1] = G[n](t.measureViewportBox(), window.getComputedStyle(t.current)),
                "height" === n && void 0 !== this.suspendedScrollY && window.scrollTo(0, this.suspendedScrollY),
                (null === (e = this.removedTransforms) || void 0 === e ? void 0 : e.length) && this.removedTransforms.forEach(( ([e,n]) => {
                    t.getValue(e).set(n)
                }
                ))
            }
        }
        var ue = n(3628)
          , he = n(3146);
        const de = (e, t) => "zIndex" !== t && (!("number" != typeof e && !Array.isArray(e)) || !("string" != typeof e || !J.f.test(e) && "0" !== e || e.startsWith("url(")));
        class pe {
            constructor({autoplay: e=!0, delay: t=0, type: n="keyframes", repeat: i=0, repeatDelay: r=0, repeatType: s="loop", ...a}) {
                this.isStopped = !1,
                this.options = {
                    autoplay: e,
                    delay: t,
                    type: n,
                    repeat: i,
                    repeatDelay: r,
                    repeatType: s,
                    ...a
                },
                this.updateFinishedPromise()
            }
            get resolved() {
                return this._resolved || (X(),
                Y(),
                (0,
                w.WG)(X),
                (0,
                w.WG)(Y)),
                this._resolved
            }
            onKeyframesResolved(e) {
                const {name: t, type: n, velocity: i, delay: r, onComplete: a, onUpdate: o} = this.options;
                if (!function(e, t, n, i) {
                    const r = e[0];
                    if (null === r)
                        return !1;
                    const a = e[e.length - 1]
                      , o = de(r, t)
                      , l = de(a, t);
                    return (0,
                    s.$)(o === l, `You are trying to animate ${t} from "${r}" to "${a}". ${r} is not an animatable value - to enable this animation set ${r} to a value animatable to ${a} via the \`style\` property.`),
                    !(!o || !l) && (function(e) {
                        const t = e[0];
                        if (1 === e.length)
                            return !0;
                        for (let n = 0; n < e.length; n++)
                            if (e[n] !== t)
                                return !0
                    }(e) || "spring" === n && i)
                }(e, t, n, i)) {
                    if (_ || !r) {
                        const t = E(e, this.options);
                        return null == o || o(t),
                        null == a || a(),
                        this.resolveFinishedPromise(),
                        void this.updateFinishedPromise()
                    }
                    this.options.duration = 0
                }
                this._resolved = {
                    keyframes: e,
                    ...this.initPlayback(e)
                },
                this.onPostResolved()
            }
            onPostResolved() {}
            then(e, t) {
                return this.currentFinishedPromise.then(e, t)
            }
            updateFinishedPromise() {
                this.currentFinishedPromise = new Promise((e => {
                    this.resolveFinishedPromise = () => {
                        e(),
                        this.updateFinishedPromise()
                    }
                }
                ))
            }
        }
        var fe = n(6898);
        const Ae = 5;
        function ge(e, t, n) {
            const i = Math.max(t - Ae, 0);
            return (0,
            fe.f)(n - e(i), t - i)
        }
        var me = n(9239);
        const ve = .001
          , ye = .01
          , xe = 10
          , _e = .05
          , be = 1;
        function Ee({duration: e=800, bounce: t=.25, velocity: n=0, mass: i=1}) {
            let r, a;
            (0,
            s.$)(e <= p(xe), "Spring duration must be 10 seconds or less");
            let o = 1 - t;
            o = (0,
            me.q)(_e, be, o),
            e = (0,
            me.q)(ye, xe, f(e)),
            o < 1 ? (r = t => {
                const i = t * o
                  , r = i * e
                  , s = i - n
                  , a = Ce(t, o)
                  , l = Math.exp(-r);
                return ve - s / a * l
            }
            ,
            a = t => {
                const i = t * o * e
                  , s = i * n + n
                  , a = Math.pow(o, 2) * Math.pow(t, 2) * e
                  , l = Math.exp(-i)
                  , c = Ce(Math.pow(t, 2), o);
                return (-r(t) + ve > 0 ? -1 : 1) * ((s - a) * l) / c
            }
            ) : (r = t => Math.exp(-t * e) * ((t - n) * e + 1) - ve,
            a = t => Math.exp(-t * e) * (e * e * (n - t)));
            const l = function(e, t, n) {
                let i = n;
                for (let n = 1; n < we; n++)
                    i -= e(i) / t(i);
                return i
            }(r, a, 5 / e);
            if (e = p(e),
            isNaN(l))
                return {
                    stiffness: 100,
                    damping: 10,
                    duration: e
                };
            {
                const t = Math.pow(l, 2) * i;
                return {
                    stiffness: t,
                    damping: 2 * o * Math.sqrt(i * t),
                    duration: e
                }
            }
        }
        const we = 12;
        function Ce(e, t) {
            return e * Math.sqrt(1 - t * t)
        }
        const Ie = ["duration", "bounce"]
          , Se = ["stiffness", "damping", "mass"];
        function Me(e, t) {
            return t.some((t => void 0 !== e[t]))
        }
        function Te({keyframes: e, restDelta: t, restSpeed: n, ...i}) {
            const r = e[0]
              , s = e[e.length - 1]
              , a = {
                done: !1,
                value: r
            }
              , {stiffness: o, damping: l, mass: c, duration: u, velocity: h, isResolvedFromDuration: d} = function(e) {
                let t = {
                    velocity: 0,
                    stiffness: 100,
                    damping: 10,
                    mass: 1,
                    isResolvedFromDuration: !1,
                    ...e
                };
                if (!Me(e, Se) && Me(e, Ie)) {
                    const n = Ee(e);
                    t = {
                        ...t,
                        ...n,
                        mass: 1
                    },
                    t.isResolvedFromDuration = !0
                }
                return t
            }({
                ...i,
                velocity: -f(i.velocity || 0)
            })
              , p = h || 0
              , A = l / (2 * Math.sqrt(o * c))
              , g = s - r
              , m = f(Math.sqrt(o / c))
              , v = Math.abs(g) < 5;
            let y;
            if (n || (n = v ? .01 : 2),
            t || (t = v ? .005 : .5),
            A < 1) {
                const e = Ce(m, A);
                y = t => {
                    const n = Math.exp(-A * m * t);
                    return s - n * ((p + A * m * g) / e * Math.sin(e * t) + g * Math.cos(e * t))
                }
            } else if (1 === A)
                y = e => s - Math.exp(-m * e) * (g + (p + m * g) * e);
            else {
                const e = m * Math.sqrt(A * A - 1);
                y = t => {
                    const n = Math.exp(-A * m * t)
                      , i = Math.min(e * t, 300);
                    return s - n * ((p + A * m * g) * Math.sinh(i) + e * g * Math.cosh(i)) / e
                }
            }
            return {
                calculatedDuration: d && u || null,
                next: e => {
                    const i = y(e);
                    if (d)
                        a.done = e >= u;
                    else {
                        let r = p;
                        0 !== e && (r = A < 1 ? ge(y, e, i) : 0);
                        const o = Math.abs(r) <= n
                          , l = Math.abs(s - i) <= t;
                        a.done = o && l
                    }
                    return a.value = a.done ? s : i,
                    a
                }
            }
        }
        function Be({keyframes: e, velocity: t=0, power: n=.8, timeConstant: i=325, bounceDamping: r=10, bounceStiffness: s=500, modifyTarget: a, min: o, max: l, restDelta: c=.5, restSpeed: u}) {
            const h = e[0]
              , d = {
                done: !1,
                value: h
            }
              , p = e => void 0 === o ? l : void 0 === l || Math.abs(o - e) < Math.abs(l - e) ? o : l;
            let f = n * t;
            const A = h + f
              , g = void 0 === a ? A : a(A);
            g !== A && (f = g - h);
            const m = e => -f * Math.exp(-e / i)
              , v = e => g + m(e)
              , y = e => {
                const t = m(e)
                  , n = v(e);
                d.done = Math.abs(t) <= c,
                d.value = d.done ? g : n
            }
            ;
            let x, _;
            const b = e => {
                var t;
                (t = d.value,
                void 0 !== o && t < o || void 0 !== l && t > l) && (x = e,
                _ = Te({
                    keyframes: [d.value, p(d.value)],
                    velocity: ge(v, e, d.value),
                    damping: r,
                    stiffness: s,
                    restDelta: c,
                    restSpeed: u
                }))
            }
            ;
            return b(0),
            {
                calculatedDuration: null,
                next: e => {
                    let t = !1;
                    return _ || void 0 !== x || (t = !0,
                    y(e),
                    b(e)),
                    void 0 !== x && e >= x ? _.next(e - x) : (!t && y(e),
                    d)
                }
            }
        }
        const Re = (e, t, n) => (((1 - 3 * n + 3 * t) * e + (3 * n - 6 * t)) * e + 3 * t) * e
          , De = 1e-7
          , Pe = 12;
        function Le(e, t, n, i) {
            if (e === t && n === i)
                return he.l;
            const r = t => function(e, t, n, i, r) {
                let s, a, o = 0;
                do {
                    a = t + (n - t) / 2,
                    s = Re(a, i, r) - e,
                    s > 0 ? n = a : t = a
                } while (Math.abs(s) > De && ++o < Pe);
                return a
            }(t, 0, 1, e, n);
            return e => 0 === e || 1 === e ? e : Re(r(e), t, i)
        }
        const Ue = Le(.42, 0, 1, 1)
          , Fe = Le(0, 0, .58, 1)
          , Ne = Le(.42, 0, .58, 1)
          , Oe = e => Array.isArray(e) && "number" != typeof e[0]
          , Qe = e => t => t <= .5 ? e(2 * t) / 2 : (2 - e(2 * (1 - t))) / 2
          , ke = e => t => 1 - e(1 - t)
          , Ge = e => 1 - Math.sin(Math.acos(e))
          , He = ke(Ge)
          , ze = Qe(Ge)
          , Ve = Le(.33, 1.53, .69, .99)
          , We = ke(Ve)
          , je = Qe(We)
          , qe = {
            linear: he.l,
            easeIn: Ue,
            easeInOut: Ne,
            easeOut: Fe,
            circIn: Ge,
            circInOut: ze,
            circOut: He,
            backIn: We,
            backInOut: je,
            backOut: Ve,
            anticipate: e => (e *= 2) < 1 ? .5 * We(e) : .5 * (2 - Math.pow(2, -10 * (e - 1)))
        }
          , Ye = e => {
            if (Array.isArray(e)) {
                (0,
                s.V)(4 === e.length, "Cubic bezier arrays must contain four numerical values.");
                const [t,n,i,r] = e;
                return Le(t, n, i, r)
            }
            return "string" == typeof e ? ((0,
            s.V)(void 0 !== qe[e], `Invalid easing type '${e}'`),
            qe[e]) : e
        }
        ;
        var Xe = n(3167)
          , Ke = n(8952);
        function Je({duration: e=300, keyframes: t, times: n, ease: i="easeInOut"}) {
            const r = Oe(i) ? i.map(Ye) : Ye(i)
              , s = {
                done: !1,
                value: t[0]
            }
              , a = function(e, t) {
                return e.map((e => e * t))
            }(n && n.length === t.length ? n : (0,
            Ke.Z)(t), e)
              , o = (0,
            Xe.G)(a, t, {
                ease: Array.isArray(r) ? r : (l = t,
                c = r,
                l.map(( () => c || Ne)).splice(0, l.length - 1))
            });
            var l, c;
            return {
                calculatedDuration: e,
                next: t => (s.value = o(t),
                s.done = t >= e,
                s)
            }
        }
        var Ze = n(2302)
          , $e = n(1105);
        const et = 2e4;
        function tt(e) {
            let t = 0;
            let n = e.next(t);
            for (; !n.done && t < et; )
                t += 50,
                n = e.next(t);
            return t >= et ? 1 / 0 : t
        }
        const nt = e => {
            const t = ({timestamp: t}) => e(t);
            return {
                start: () => w.Gt.update(t, !0),
                stop: () => (0,
                w.WG)(t),
                now: () => w.uv.isProcessing ? w.uv.timestamp : S.now()
            }
        }
          , it = {
            decay: Be,
            inertia: Be,
            tween: Je,
            keyframes: Je,
            spring: Te
        }
          , rt = e => e / 100;
        class st extends pe {
            constructor({KeyframeResolver: e=K, ...t}) {
                super(t),
                this.holdTime = null,
                this.startTime = null,
                this.cancelTime = null,
                this.currentTime = 0,
                this.playbackSpeed = 1,
                this.pendingPlayState = "running",
                this.state = "idle";
                const {name: n, motionValue: i, keyframes: r} = this.options
                  , s = e => this.onKeyframesResolved(e);
                n && i && i.owner ? this.resolver = i.owner.resolveKeyframes(r, s, n, i) : this.resolver = new e(r,s,n,i),
                this.resolver.scheduleResolve()
            }
            initPlayback(e) {
                const {type: t="keyframes", repeat: n=0, repeatDelay: i=0, repeatType: r, velocity: s=0} = this.options
                  , a = it[t] || Je;
                let o, l;
                a !== Je && "number" != typeof e[0] && (o = (0,
                Ze.F)(rt, (0,
                $e.j)(e[0], e[1])),
                e = [0, 100]);
                const c = a({
                    ...this.options,
                    keyframes: e
                });
                "mirror" === r && (l = a({
                    ...this.options,
                    keyframes: [...e].reverse(),
                    velocity: -s
                })),
                null === c.calculatedDuration && (c.calculatedDuration = tt(c));
                const {calculatedDuration: u} = c
                  , h = u + i;
                return {
                    generator: c,
                    mirroredGenerator: l,
                    mapPercentToKeyframes: o,
                    calculatedDuration: u,
                    resolvedDuration: h,
                    totalDuration: h * (n + 1) - i
                }
            }
            onPostResolved() {
                const {autoplay: e=!0} = this.options;
                this.play(),
                "paused" !== this.pendingPlayState && e ? this.state = this.pendingPlayState : this.pause()
            }
            tick(e, t=!1) {
                const {generator: n, mirroredGenerator: i, mapPercentToKeyframes: r, keyframes: s, calculatedDuration: a, totalDuration: o, resolvedDuration: l} = this.resolved;
                if (null === this.startTime)
                    return n.next(0);
                const {delay: c, repeat: u, repeatType: h, repeatDelay: d, onUpdate: p} = this.options;
                this.speed > 0 ? this.startTime = Math.min(this.startTime, e) : this.speed < 0 && (this.startTime = Math.min(e - o / this.speed, this.startTime)),
                t ? this.currentTime = e : null !== this.holdTime ? this.currentTime = this.holdTime : this.currentTime = Math.round(e - this.startTime) * this.speed;
                const f = this.currentTime - c * (this.speed >= 0 ? 1 : -1)
                  , A = this.speed >= 0 ? f < 0 : f > o;
                this.currentTime = Math.max(f, 0),
                "finished" === this.state && null === this.holdTime && (this.currentTime = o);
                let g = this.currentTime
                  , m = n;
                if (u) {
                    const e = Math.min(this.currentTime, o) / l;
                    let t = Math.floor(e)
                      , n = e % 1;
                    !n && e >= 1 && (n = 1),
                    1 === n && t--,
                    t = Math.min(t, u + 1);
                    Boolean(t % 2) && ("reverse" === h ? (n = 1 - n,
                    d && (n -= d / l)) : "mirror" === h && (m = i)),
                    g = (0,
                    me.q)(0, 1, n) * l
                }
                const v = A ? {
                    done: !1,
                    value: s[0]
                } : m.next(g);
                r && (v.value = r(v.value));
                let {done: y} = v;
                A || null === a || (y = this.speed >= 0 ? this.currentTime >= o : this.currentTime <= 0);
                const x = null === this.holdTime && ("finished" === this.state || "running" === this.state && y);
                return p && p(v.value),
                x && this.finish(),
                v
            }
            get duration() {
                return f(this.resolved.calculatedDuration)
            }
            get time() {
                return f(this.currentTime)
            }
            set time(e) {
                e = p(e),
                this.currentTime = e,
                null !== this.holdTime || 0 === this.speed ? this.holdTime = e : this.driver && (this.startTime = this.driver.now() - e / this.speed)
            }
            get speed() {
                return this.playbackSpeed
            }
            set speed(e) {
                const t = this.playbackSpeed !== e;
                this.playbackSpeed = e,
                t && (this.time = f(this.currentTime))
            }
            play() {
                if (this.resolver.isScheduled || this.resolver.resume(),
                !this._resolved)
                    return void (this.pendingPlayState = "running");
                if (this.isStopped)
                    return;
                const {driver: e=nt, onPlay: t} = this.options;
                this.driver || (this.driver = e((e => this.tick(e)))),
                t && t();
                const n = this.driver.now();
                null !== this.holdTime ? this.startTime = n - this.holdTime : this.startTime && "finished" !== this.state || (this.startTime = n),
                "finished" === this.state && this.updateFinishedPromise(),
                this.cancelTime = this.startTime,
                this.holdTime = null,
                this.state = "running",
                this.driver.start()
            }
            pause() {
                var e;
                this._resolved ? (this.state = "paused",
                this.holdTime = null !== (e = this.currentTime) && void 0 !== e ? e : 0) : this.pendingPlayState = "paused"
            }
            stop() {
                if (this.isStopped = !0,
                "idle" === this.state)
                    return;
                this.state = "idle";
                const {onStop: e} = this.options;
                e && e(),
                this.teardown()
            }
            complete() {
                "running" !== this.state && this.play(),
                this.pendingPlayState = this.state = "finished",
                this.holdTime = null
            }
            finish() {
                this.teardown(),
                this.state = "finished";
                const {onComplete: e} = this.options;
                e && e()
            }
            cancel() {
                null !== this.cancelTime && this.tick(this.cancelTime),
                this.teardown()
            }
            teardown() {
                this.state = "idle",
                this.stopDriver(),
                this.resolveFinishedPromise(),
                this.updateFinishedPromise(),
                this.startTime = this.cancelTime = null,
                this.resolver.cancel()
            }
            stopDriver() {
                this.driver && (this.driver.stop(),
                this.driver = void 0)
            }
            sample(e) {
                return this.startTime = 0,
                this.tick(e, !0)
            }
        }
        const at = e => Array.isArray(e) && "number" == typeof e[0];
        function ot(e) {
            return Boolean(!e || "string" == typeof e && ct[e] || at(e) || Array.isArray(e) && e.every(ot))
        }
        const lt = ([e,t,n,i]) => `cubic-bezier(${e}, ${t}, ${n}, ${i})`
          , ct = {
            linear: "linear",
            ease: "ease",
            easeIn: "ease-in",
            easeOut: "ease-out",
            easeInOut: "ease-in-out",
            circIn: lt([0, .65, .55, 1]),
            circOut: lt([.55, 0, 1, .45]),
            backIn: lt([.31, .01, .66, -.59]),
            backOut: lt([.33, 1.53, .69, .99])
        };
        function ut(e) {
            if (e)
                return at(e) ? lt(e) : Array.isArray(e) ? e.map(ut) : ct[e]
        }
        const ht = (0,
        ue.p)(( () => Object.hasOwnProperty.call(Element.prototype, "animate")))
          , dt = new Set(["opacity", "clipPath", "filter", "transform"]);
        class pt extends pe {
            constructor(e) {
                super(e);
                const {name: t, motionValue: n, keyframes: i} = this.options;
                this.resolver = new ce(i,(e => this.onKeyframesResolved(e)),t,n),
                this.resolver.scheduleResolve()
            }
            initPlayback(e) {
                let t = this.options.duration || 300;
                if ("spring" === (n = this.options).type || "backgroundColor" === n.name || !ot(n.ease)) {
                    const {onComplete: n, onUpdate: i, motionValue: r, ...s} = this.options
                      , a = function(e, t) {
                        const n = new st({
                            ...t,
                            keyframes: e,
                            repeat: 0,
                            delay: 0
                        });
                        let i = {
                            done: !1,
                            value: e[0]
                        };
                        const r = [];
                        let s = 0;
                        for (; !i.done && s < 2e4; )
                            i = n.sample(s),
                            r.push(i.value),
                            s += 10;
                        return {
                            times: void 0,
                            keyframes: r,
                            duration: s - 10,
                            ease: "linear"
                        }
                    }(e, s);
                    e = a.keyframes,
                    t = a.duration,
                    this.options.times = a.times,
                    this.options.ease = a.ease
                }
                var n;
                const {motionValue: i, name: r} = this.options
                  , s = function(e, t, n, {delay: i=0, duration: r=300, repeat: s=0, repeatType: a="loop", ease: o, times: l}={}) {
                    const c = {
                        [t]: n
                    };
                    l && (c.offset = l);
                    const u = ut(o);
                    return Array.isArray(u) && (c.easing = u),
                    e.animate(c, {
                        delay: i,
                        duration: r,
                        easing: Array.isArray(u) ? "linear" : u,
                        fill: "both",
                        iterations: s + 1,
                        direction: "reverse" === a ? "alternate" : "normal"
                    })
                }(i.owner.current, r, e, {
                    ...this.options,
                    duration: t
                });
                return s.startTime = S.now(),
                this.pendingTimeline ? (s.timeline = this.pendingTimeline,
                this.pendingTimeline = void 0) : s.onfinish = () => {
                    const {onComplete: t} = this.options;
                    i.set(E(e, this.options)),
                    t && t(),
                    this.cancel(),
                    this.resolveFinishedPromise(),
                    this.updateFinishedPromise()
                }
                ,
                {
                    animation: s,
                    duration: t,
                    keyframes: e
                }
            }
            get duration() {
                const {duration: e} = this.resolved;
                return f(e)
            }
            get time() {
                const {animation: e} = this.resolved;
                return f(e.currentTime || 0)
            }
            set time(e) {
                const {animation: t} = this.resolved;
                t.currentTime = p(e)
            }
            get speed() {
                const {animation: e} = this.resolved;
                return e.playbackRate
            }
            set speed(e) {
                const {animation: t} = this.resolved;
                t.playbackRate = e
            }
            get state() {
                const {animation: e} = this.resolved;
                return e.playState
            }
            attachTimeline(e) {
                if (this._resolved) {
                    const {animation: t} = this.resolved;
                    t.timeline = e,
                    t.onfinish = null
                } else
                    this.pendingTimeline = e;
                return he.l
            }
            play() {
                if (this.isStopped)
                    return;
                const {animation: e} = this.resolved;
                e.play()
            }
            pause() {
                const {animation: e} = this.resolved;
                e.pause()
            }
            stop() {
                this.isStopped = !0;
                const {animation: e, keyframes: t} = this.resolved;
                if ("idle" !== e.playState && "finished" !== e.playState) {
                    if (this.time) {
                        const {motionValue: e, onUpdate: n, onComplete: i, ...r} = this.options
                          , s = new st({
                            ...r,
                            keyframes: t
                        });
                        e.setWithVelocity(s.sample(this.time - 10).value, s.sample(this.time).value, 10)
                    }
                    this.cancel()
                }
            }
            complete() {
                this.resolved.animation.finish()
            }
            cancel() {
                this.resolved.animation.cancel()
            }
            static supports(e) {
                const {motionValue: t, name: n, repeatDelay: i, repeatType: r, damping: s, type: a} = e;
                return ht() && n && dt.has(n) && t && t.owner && t.owner.current instanceof HTMLElement && !t.owner.getProps().onUpdate && !i && "mirror" !== r && 0 !== s && "inertia" !== a
            }
        }
        const ft = (e, t, n, i={}, r, s) => a => {
            const o = y(i, e) || {}
              , l = o.delay || i.delay || 0;
            let {elapsed: c=0} = i;
            c -= p(l);
            let u = {
                keyframes: Array.isArray(n) ? n : [null, n],
                ease: "easeOut",
                velocity: t.getVelocity(),
                ...o,
                delay: -c,
                onUpdate: e => {
                    t.set(e),
                    o.onUpdate && o.onUpdate(e)
                }
                ,
                onComplete: () => {
                    a(),
                    o.onComplete && o.onComplete()
                }
                ,
                name: e,
                motionValue: t,
                element: s ? void 0 : r
            };
            (function({when: e, delay: t, delayChildren: n, staggerChildren: i, staggerDirection: r, repeat: s, repeatType: a, repeatDelay: o, from: l, elapsed: c, ...u}) {
                return !!Object.keys(u).length
            }
            )(o) || (u = {
                ...u,
                ...v(e, u)
            }),
            u.duration && (u.duration = p(u.duration)),
            u.repeatDelay && (u.repeatDelay = p(u.repeatDelay)),
            void 0 !== u.from && (u.keyframes[0] = u.from);
            let h = !1;
            if (!1 === u.type && (u.duration = 0,
            0 === u.delay && (h = !0)),
            (_ || x.W.skipAnimations) && (h = !0,
            u.duration = 0,
            u.delay = 0),
            h && !s && void 0 !== t.get()) {
                const e = E(u.keyframes, o);
                if (void 0 !== e)
                    return void w.Gt.update(( () => {
                        u.onUpdate(e),
                        u.onComplete()
                    }
                    ))
            }
            return !s && pt.supports(u) ? new pt(u) : new st(u)
        }
          , At = e => Boolean(e && e.getVelocity);
        function gt(e) {
            return Boolean(At(e) && e.add)
        }
        const mt = e => (e => Array.isArray(e))(e) ? e[e.length - 1] || 0 : e;
        function vt(e, t) {
            const n = e.indexOf(t);
            n > -1 && e.splice(n, 1)
        }
        class yt {
            constructor() {
                this.subscriptions = []
            }
            add(e) {
                var t, n;
                return t = this.subscriptions,
                n = e,
                -1 === t.indexOf(n) && t.push(n),
                () => vt(this.subscriptions, e)
            }
            notify(e, t, n) {
                const i = this.subscriptions.length;
                if (i)
                    if (1 === i)
                        this.subscriptions[0](e, t, n);
                    else
                        for (let r = 0; r < i; r++) {
                            const i = this.subscriptions[r];
                            i && i(e, t, n)
                        }
            }
            getSize() {
                return this.subscriptions.length
            }
            clear() {
                this.subscriptions.length = 0
            }
        }
        const xt = {
            current: void 0
        };
        class _t {
            constructor(e, t={}) {
                var n;
                this.version = "11.0.12",
                this.canTrackVelocity = !1,
                this.events = {},
                this.updateAndNotify = (e, t=!0) => {
                    const n = S.now();
                    this.updatedAt !== n && this.setPrevFrameValue(),
                    this.prev = this.current,
                    this.setCurrent(e),
                    this.current !== this.prev && this.events.change && this.events.change.notify(this.current),
                    t && this.events.renderRequest && this.events.renderRequest.notify(this.current)
                }
                ,
                this.hasAnimated = !1,
                this.setCurrent(e),
                this.canTrackVelocity = (n = this.current,
                !isNaN(parseFloat(n))),
                this.owner = t.owner
            }
            setCurrent(e) {
                this.current = e,
                this.updatedAt = S.now()
            }
            setPrevFrameValue(e=this.current) {
                this.prevFrameValue = e,
                this.prevUpdatedAt = this.updatedAt
            }
            onChange(e) {
                return this.on("change", e)
            }
            on(e, t) {
                this.events[e] || (this.events[e] = new yt);
                const n = this.events[e].add(t);
                return "change" === e ? () => {
                    n(),
                    w.Gt.read(( () => {
                        this.events.change.getSize() || this.stop()
                    }
                    ))
                }
                : n
            }
            clearListeners() {
                for (const e in this.events)
                    this.events[e].clear()
            }
            attach(e, t) {
                this.passiveEffect = e,
                this.stopPassiveEffect = t
            }
            set(e, t=!0) {
                t && this.passiveEffect ? this.passiveEffect(e, this.updateAndNotify) : this.updateAndNotify(e, t)
            }
            setWithVelocity(e, t, n) {
                this.set(t),
                this.prev = void 0,
                this.prevFrameValue = e,
                this.prevUpdatedAt = this.updatedAt - n
            }
            jump(e, t=!0) {
                this.updateAndNotify(e),
                this.prev = e,
                this.prevUpdatedAt = this.prevFrameValue = void 0,
                t && this.stop(),
                this.stopPassiveEffect && this.stopPassiveEffect()
            }
            get() {
                return xt.current && xt.current.push(this),
                this.current
            }
            getPrevious() {
                return this.prev
            }
            getVelocity() {
                const e = S.now();
                if (!this.canTrackVelocity || void 0 === this.prevFrameValue || e - this.updatedAt > 30)
                    return 0;
                const t = Math.min(this.updatedAt - this.prevUpdatedAt, 30);
                return (0,
                fe.f)(parseFloat(this.current) - parseFloat(this.prevFrameValue), t)
            }
            start(e) {
                return this.stop(),
                new Promise((t => {
                    this.hasAnimated = !0,
                    this.animation = e(t),
                    this.events.animationStart && this.events.animationStart.notify()
                }
                )).then(( () => {
                    this.events.animationComplete && this.events.animationComplete.notify(),
                    this.clearAnimation()
                }
                ))
            }
            stop() {
                this.animation && (this.animation.stop(),
                this.events.animationCancel && this.events.animationCancel.notify()),
                this.clearAnimation()
            }
            isAnimating() {
                return !!this.animation
            }
            clearAnimation() {
                delete this.animation
            }
            destroy() {
                this.clearListeners(),
                this.stop(),
                this.stopPassiveEffect && this.stopPassiveEffect()
            }
        }
        function bt(e, t) {
            return new _t(e,t)
        }
        function Et(e, t, n, i={}, r={}) {
            return "function" == typeof t && (t = t(void 0 !== n ? n : e.custom, i, r)),
            "string" == typeof t && (t = e.variants && e.variants[t]),
            "function" == typeof t && (t = t(void 0 !== n ? n : e.custom, i, r)),
            t
        }
        function wt(e, t, n) {
            e.hasValue(t) ? e.getValue(t).set(n) : e.addValue(t, bt(n))
        }
        function Ct(e, t) {
            const n = function(e, t, n) {
                const i = e.getProps();
                return Et(i, t, void 0 !== n ? n : i.custom, function(e) {
                    const t = {};
                    return e.values.forEach(( (e, n) => t[n] = e.get())),
                    t
                }(e), function(e) {
                    const t = {};
                    return e.values.forEach(( (e, n) => t[n] = e.getVelocity())),
                    t
                }(e))
            }(e, t);
            let {transitionEnd: i={}, transition: r={}, ...s} = n || {};
            s = {
                ...s,
                ...i
            };
            for (const t in s) {
                wt(e, t, mt(s[t]))
            }
        }
        function It({protectedKeys: e, needsAnimating: t}, n) {
            const i = e.hasOwnProperty(n) && !0 !== t[n];
            return t[n] = !1,
            i
        }
        function St(e, t, {delay: n=0, transitionOverride: i, type: r}={}) {
            var s;
            let {transition: a=e.getDefaultTransition(), transitionEnd: o, ...l} = t;
            const c = e.getValue("willChange");
            i && (a = i);
            const h = []
              , p = r && e.animationState && e.animationState.getState()[r];
            for (const t in l) {
                const i = e.getValue(t, null !== (s = e.latestValues[t]) && void 0 !== s ? s : null)
                  , r = l[t];
                if (void 0 === r || p && It(p, t))
                    continue;
                const o = {
                    delay: n,
                    elapsed: 0,
                    ...y(a || {}, t)
                };
                let f = !1;
                if (window.HandoffAppearAnimations) {
                    const n = e.getProps()[d];
                    if (n) {
                        const e = window.HandoffAppearAnimations(n, t);
                        null !== e && (o.elapsed = e,
                        f = !0)
                    }
                }
                i.start(ft(t, i, r, e.shouldReduceMotion && u.has(t) ? {
                    type: !1
                } : o, e, f));
                const A = i.animation;
                A && (gt(c) && (c.add(t),
                A.then(( () => c.remove(t)))),
                h.push(A))
            }
            return o && Promise.all(h).then(( () => {
                w.Gt.update(( () => {
                    o && Ct(e, o)
                }
                ))
            }
            )),
            h
        }
        const Mt = {};
        function Tt(e, {layout: t, layoutId: n}) {
            return u.has(e) || e.startsWith("origin") || (t || void 0 !== n) && (!!Mt[e] || "opacity" === e)
        }
        function Bt(e, t) {
            const {style: n} = e
              , i = {};
            for (const r in n)
                (At(n[r]) || t.style && At(t.style[r]) || Tt(r, e)) && (i[r] = n[r]);
            return i
        }
        const Rt = "undefined" != typeof document
          , Dt = {
            current: null
        }
          , Pt = {
            current: !1
        };
        function Lt(e) {
            return "string" == typeof e || Array.isArray(e)
        }
        const Ut = ["initial", "animate", "whileInView", "whileFocus", "whileHover", "whileTap", "whileDrag", "exit"];
        function Ft(e) {
            return null !== (t = e.animate) && "object" == typeof t && "function" == typeof t.start || Ut.some((t => Lt(e[t])));
            var t
        }
        const Nt = {
            animation: ["animate", "variants", "whileHover", "whileTap", "exit", "whileInView", "whileFocus", "whileDrag"],
            exit: ["exit"],
            drag: ["drag", "dragControls"],
            focus: ["whileFocus"],
            hover: ["whileHover", "onHoverStart", "onHoverEnd"],
            tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"],
            pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"],
            inView: ["whileInView", "onViewportEnter", "onViewportLeave"],
            layout: ["layout", "layoutId"]
        }
          , Ot = {};
        for (const e in Nt)
            Ot[e] = {
                isEnabled: t => Nt[e].some((e => !!t[e]))
            };
        const Qt = [...z, ie.y, J.f]
          , kt = Object.keys(Ot)
          , Gt = kt.length
          , Ht = ["AnimationStart", "AnimationComplete", "Update", "BeforeLayoutMeasure", "LayoutMeasure", "LayoutAnimationStart", "LayoutAnimationComplete"]
          , zt = Ut.length;
        class Vt {
            constructor({parent: e, props: t, presenceContext: n, reducedMotionConfig: i, blockInitialAnimation: r, visualState: s}, a={}) {
                this.resolveKeyframes = (e, t, n, i) => new this.KeyframeResolver(e,t,n,i,this),
                this.current = null,
                this.children = new Set,
                this.isVariantNode = !1,
                this.isControllingVariants = !1,
                this.shouldReduceMotion = null,
                this.values = new Map,
                this.KeyframeResolver = K,
                this.features = {},
                this.valueSubscriptions = new Map,
                this.prevMotionValues = {},
                this.events = {},
                this.propEventSubscriptions = {},
                this.notifyUpdate = () => this.notify("Update", this.latestValues),
                this.render = () => {
                    this.current && (this.triggerBuild(),
                    this.renderInstance(this.current, this.renderState, this.props.style, this.projection))
                }
                ,
                this.scheduleRender = () => w.Gt.render(this.render, !1, !0);
                const {latestValues: o, renderState: l} = s;
                this.latestValues = o,
                this.baseTarget = {
                    ...o
                },
                this.initialValues = t.initial ? {
                    ...o
                } : {},
                this.renderState = l,
                this.parent = e,
                this.props = t,
                this.presenceContext = n,
                this.depth = e ? e.depth + 1 : 0,
                this.reducedMotionConfig = i,
                this.options = a,
                this.blockInitialAnimation = Boolean(r),
                this.isControllingVariants = Ft(t),
                this.isVariantNode = function(e) {
                    return Boolean(Ft(e) || e.variants)
                }(t),
                this.isVariantNode && (this.variantChildren = new Set),
                this.manuallyAnimateOnMount = Boolean(e && e.current);
                const {willChange: c, ...u} = this.scrapeMotionValuesFromProps(t, {});
                for (const e in u) {
                    const t = u[e];
                    void 0 !== o[e] && At(t) && (t.set(o[e], !1),
                    gt(c) && c.add(e))
                }
            }
            scrapeMotionValuesFromProps(e, t) {
                return {}
            }
            mount(e) {
                this.current = e,
                r.set(e, this),
                this.projection && !this.projection.instance && this.projection.mount(e),
                this.parent && this.isVariantNode && !this.isControllingVariants && (this.removeFromVariantTree = this.parent.addVariantChild(this)),
                this.values.forEach(( (e, t) => this.bindToMotionValue(t, e))),
                Pt.current || function() {
                    if (Pt.current = !0,
                    Rt)
                        if (window.matchMedia) {
                            const e = window.matchMedia("(prefers-reduced-motion)")
                              , t = () => Dt.current = e.matches;
                            e.addListener(t),
                            t()
                        } else
                            Dt.current = !1
                }(),
                this.shouldReduceMotion = "never" !== this.reducedMotionConfig && ("always" === this.reducedMotionConfig || Dt.current),
                this.parent && this.parent.children.add(this),
                this.update(this.props, this.presenceContext)
            }
            unmount() {
                r.delete(this.current),
                this.projection && this.projection.unmount(),
                (0,
                w.WG)(this.notifyUpdate),
                (0,
                w.WG)(this.render),
                this.valueSubscriptions.forEach((e => e())),
                this.removeFromVariantTree && this.removeFromVariantTree(),
                this.parent && this.parent.children.delete(this);
                for (const e in this.events)
                    this.events[e].clear();
                for (const e in this.features)
                    this.features[e].unmount();
                this.current = null
            }
            bindToMotionValue(e, t) {
                const n = u.has(e)
                  , i = t.on("change", (t => {
                    this.latestValues[e] = t,
                    this.props.onUpdate && w.Gt.preRender(this.notifyUpdate),
                    n && this.projection && (this.projection.isTransformDirty = !0)
                }
                ))
                  , r = t.on("renderRequest", this.scheduleRender);
                this.valueSubscriptions.set(e, ( () => {
                    i(),
                    r()
                }
                ))
            }
            sortNodePosition(e) {
                return this.current && this.sortInstanceNodePosition && this.type === e.type ? this.sortInstanceNodePosition(this.current, e.current) : 0
            }
            loadFeatures({children: e, ...t}, n, i, r) {
                let s, a;
                for (let e = 0; e < Gt; e++) {
                    const n = kt[e]
                      , {isEnabled: i, Feature: r, ProjectionNode: o, MeasureLayout: l} = Ot[n];
                    o && (s = o),
                    i(t) && (!this.features[n] && r && (this.features[n] = new r(this)),
                    l && (a = l))
                }
                if (("html" === this.type || "svg" === this.type) && !this.projection && s) {
                    this.projection = new s(this.latestValues,this.parent && this.parent.projection);
                    const {layoutId: e, layout: n, drag: i, dragConstraints: a, layoutScroll: l, layoutRoot: c} = t;
                    this.projection.setOptions({
                        layoutId: e,
                        layout: n,
                        alwaysMeasureLayout: Boolean(i) || a && (o = a,
                        o && "object" == typeof o && Object.prototype.hasOwnProperty.call(o, "current")),
                        visualElement: this,
                        scheduleRender: () => this.scheduleRender(),
                        animationType: "string" == typeof n ? n : "both",
                        initialPromotionConfig: r,
                        layoutScroll: l,
                        layoutRoot: c
                    })
                }
                var o;
                return a
            }
            updateFeatures() {
                for (const e in this.features) {
                    const t = this.features[e];
                    t.isMounted ? t.update() : (t.mount(),
                    t.isMounted = !0)
                }
            }
            triggerBuild() {
                this.build(this.renderState, this.latestValues, this.options, this.props)
            }
            measureViewportBox() {
                return this.current ? this.measureInstanceViewportBox(this.current, this.props) : {
                    x: {
                        min: 0,
                        max: 0
                    },
                    y: {
                        min: 0,
                        max: 0
                    }
                }
            }
            getStaticValue(e) {
                return this.latestValues[e]
            }
            setStaticValue(e, t) {
                this.latestValues[e] = t
            }
            update(e, t) {
                (e.transformTemplate || this.props.transformTemplate) && this.scheduleRender(),
                this.prevProps = this.props,
                this.props = e,
                this.prevPresenceContext = this.presenceContext,
                this.presenceContext = t;
                for (let t = 0; t < Ht.length; t++) {
                    const n = Ht[t];
                    this.propEventSubscriptions[n] && (this.propEventSubscriptions[n](),
                    delete this.propEventSubscriptions[n]);
                    const i = e["on" + n];
                    i && (this.propEventSubscriptions[n] = this.on(n, i))
                }
                this.prevMotionValues = function(e, t, n) {
                    const {willChange: i} = t;
                    for (const r in t) {
                        const s = t[r]
                          , a = n[r];
                        if (At(s))
                            e.addValue(r, s),
                            gt(i) && i.add(r);
                        else if (At(a))
                            e.addValue(r, bt(s, {
                                owner: e
                            })),
                            gt(i) && i.remove(r);
                        else if (a !== s)
                            if (e.hasValue(r)) {
                                const t = e.getValue(r);
                                !t.hasAnimated && t.set(s)
                            } else {
                                const t = e.getStaticValue(r);
                                e.addValue(r, bt(void 0 !== t ? t : s, {
                                    owner: e
                                }))
                            }
                    }
                    for (const i in n)
                        void 0 === t[i] && e.removeValue(i);
                    return t
                }(this, this.scrapeMotionValuesFromProps(e, this.prevProps), this.prevMotionValues),
                this.handleChildMotionValue && this.handleChildMotionValue()
            }
            getProps() {
                return this.props
            }
            getVariant(e) {
                return this.props.variants ? this.props.variants[e] : void 0
            }
            getDefaultTransition() {
                return this.props.transition
            }
            getTransformPagePoint() {
                return this.props.transformPagePoint
            }
            getClosestVariantNode() {
                return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0
            }
            getVariantContext(e=!1) {
                if (e)
                    return this.parent ? this.parent.getVariantContext() : void 0;
                if (!this.isControllingVariants) {
                    const e = this.parent && this.parent.getVariantContext() || {};
                    return void 0 !== this.props.initial && (e.initial = this.props.initial),
                    e
                }
                const t = {};
                for (let e = 0; e < zt; e++) {
                    const n = Ut[e]
                      , i = this.props[n];
                    (Lt(i) || !1 === i) && (t[n] = i)
                }
                return t
            }
            addVariantChild(e) {
                const t = this.getClosestVariantNode();
                if (t)
                    return t.variantChildren && t.variantChildren.add(e),
                    () => t.variantChildren.delete(e)
            }
            addValue(e, t) {
                t !== this.values.get(e) && (this.removeValue(e),
                this.bindToMotionValue(e, t)),
                this.values.set(e, t),
                this.latestValues[e] = t.get()
            }
            removeValue(e) {
                this.values.delete(e);
                const t = this.valueSubscriptions.get(e);
                t && (t(),
                this.valueSubscriptions.delete(e)),
                delete this.latestValues[e],
                this.removeValueFromRenderState(e, this.renderState)
            }
            hasValue(e) {
                return this.values.has(e)
            }
            getValue(e, t) {
                if (this.props.values && this.props.values[e])
                    return this.props.values[e];
                let n = this.values.get(e);
                return void 0 === n && void 0 !== t && (n = bt(null === t ? void 0 : t, {
                    owner: this
                }),
                this.addValue(e, n)),
                n
            }
            readValue(e, t) {
                var n;
                let i = void 0 === this.latestValues[e] && this.current ? null !== (n = this.getBaseTargetFromProps(this.props, e)) && void 0 !== n ? n : this.readValueFromInstance(this.current, e, this.options) : this.latestValues[e];
                var r;
                return null != i && ("string" == typeof i && (T(i) || M(i)) ? i = parseFloat(i) : (r = i,
                !Qt.find(H(r)) && J.f.test(t) && (i = le(e, t))),
                this.setBaseTarget(e, At(i) ? i.get() : i)),
                At(i) ? i.get() : i
            }
            setBaseTarget(e, t) {
                this.baseTarget[e] = t
            }
            getBaseTarget(e) {
                var t, n;
                const {initial: i} = this.props
                  , r = "string" == typeof i || "object" == typeof i ? null === (n = Et(this.props, i, null === (t = this.presenceContext) || void 0 === t ? void 0 : t.custom)) || void 0 === n ? void 0 : n[e] : void 0;
                if (i && void 0 !== r)
                    return r;
                const s = this.getBaseTargetFromProps(this.props, e);
                return void 0 === s || At(s) ? void 0 !== this.initialValues[e] && void 0 === r ? void 0 : this.baseTarget[e] : s
            }
            on(e, t) {
                return this.events[e] || (this.events[e] = new yt),
                this.events[e].add(t)
            }
            notify(e, ...t) {
                this.events[e] && this.events[e].notify(...t)
            }
        }
        class Wt extends Vt {
            constructor() {
                super(...arguments),
                this.KeyframeResolver = ce
            }
            sortInstanceNodePosition(e, t) {
                return 2 & e.compareDocumentPosition(t) ? 1 : -1
            }
            getBaseTargetFromProps(e, t) {
                return e.style ? e.style[t] : void 0
            }
            removeValueFromRenderState(e, {vars: t, style: n}) {
                delete t[e],
                delete n[e]
            }
        }
        const jt = {
            x: "translateX",
            y: "translateY",
            z: "translateZ",
            transformPerspective: "perspective"
        }
          , qt = c.length;
        const Yt = (e, t) => t && "number" == typeof e ? t.transform(e) : e;
        function Xt(e, t, n, i) {
            const {style: r, vars: s, transform: a, transformOrigin: o} = e;
            let l = !1
              , h = !1
              , d = !0;
            for (const e in t) {
                const n = t[e];
                if ((0,
                B.j)(e)) {
                    s[e] = n;
                    continue
                }
                const i = se[e]
                  , c = Yt(n, i);
                if (u.has(e)) {
                    if (l = !0,
                    a[e] = c,
                    !d)
                        continue;
                    n !== (i.default || 0) && (d = !1)
                } else
                    e.startsWith("origin") ? (h = !0,
                    o[e] = c) : r[e] = c
            }
            if (t.transform || (l || i ? r.transform = function(e, {enableHardwareAcceleration: t=!0, allowTransformNone: n=!0}, i, r) {
                let s = "";
                for (let t = 0; t < qt; t++) {
                    const n = c[t];
                    void 0 !== e[n] && (s += `${jt[n] || n}(${e[n]}) `)
                }
                return t && !e.z && (s += "translateZ(0)"),
                s = s.trim(),
                r ? s = r(e, i ? "" : s) : n && i && (s = "none"),
                s
            }(e.transform, n, d, i) : r.transform && (r.transform = "none")),
            h) {
                const {originX: e="50%", originY: t="50%", originZ: n=0} = o;
                r.transformOrigin = `${e} ${t} ${n}`
            }
        }
        function Kt(e, t, n) {
            return "string" == typeof e ? e : L.px.transform(t + n * e)
        }
        const Jt = {
            offset: "stroke-dashoffset",
            array: "stroke-dasharray"
        }
          , Zt = {
            offset: "strokeDashoffset",
            array: "strokeDasharray"
        };
        function $t(e, {attrX: t, attrY: n, attrScale: i, originX: r, originY: s, pathLength: a, pathSpacing: o=1, pathOffset: l=0, ...c}, u, h, d) {
            if (Xt(e, c, u, d),
            h)
                return void (e.style.viewBox && (e.attrs.viewBox = e.style.viewBox));
            e.attrs = e.style,
            e.style = {};
            const {attrs: p, style: f, dimensions: A} = e;
            p.transform && (A && (f.transform = p.transform),
            delete p.transform),
            A && (void 0 !== r || void 0 !== s || f.transform) && (f.transformOrigin = function(e, t, n) {
                return `${Kt(t, e.x, e.width)} ${Kt(n, e.y, e.height)}`
            }(A, void 0 !== r ? r : .5, void 0 !== s ? s : .5)),
            void 0 !== t && (p.x = t),
            void 0 !== n && (p.y = n),
            void 0 !== i && (p.scale = i),
            void 0 !== a && function(e, t, n=1, i=0, r=!0) {
                e.pathLength = 1;
                const s = r ? Jt : Zt;
                e[s.offset] = L.px.transform(-i);
                const a = L.px.transform(t)
                  , o = L.px.transform(n);
                e[s.array] = `${a} ${o}`
            }(p, a, o, l, !1)
        }
        const en = new Set(["baseFrequency", "diffuseConstant", "kernelMatrix", "kernelUnitLength", "keySplines", "keyTimes", "limitingConeAngle", "markerHeight", "markerWidth", "numOctaves", "targetX", "targetY", "surfaceScale", "specularConstant", "specularExponent", "stdDeviation", "tableValues", "viewBox", "gradientTransform", "pathLength", "startOffset", "textLength", "lengthAdjust"]);
        function tn(e, {style: t, vars: n}, i, r) {
            Object.assign(e.style, t, r && r.getProjectionStyles(i));
            for (const t in n)
                e.style.setProperty(t, n[t])
        }
        class nn extends Wt {
            constructor() {
                super(...arguments),
                this.type = "svg",
                this.isSVGTag = !1
            }
            getBaseTargetFromProps(e, t) {
                return e[t]
            }
            readValueFromInstance(e, t) {
                if (u.has(t)) {
                    const e = oe(t);
                    return e && e.default || 0
                }
                return t = en.has(t) ? t : h(t),
                e.getAttribute(t)
            }
            measureInstanceViewportBox() {
                return {
                    x: {
                        min: 0,
                        max: 0
                    },
                    y: {
                        min: 0,
                        max: 0
                    }
                }
            }
            scrapeMotionValuesFromProps(e, t) {
                return function(e, t) {
                    const n = Bt(e, t);
                    for (const i in e)
                        (At(e[i]) || At(t[i])) && (n[-1 !== c.indexOf(i) ? "attr" + i.charAt(0).toUpperCase() + i.substring(1) : i] = e[i]);
                    return n
                }(e, t)
            }
            build(e, t, n, i) {
                $t(e, t, n, this.isSVGTag, i.transformTemplate)
            }
            renderInstance(e, t, n, i) {
                !function(e, t, n, i) {
                    tn(e, t, void 0, i);
                    for (const n in t.attrs)
                        e.setAttribute(en.has(n) ? n : h(n), t.attrs[n])
                }(e, t, 0, i)
            }
            mount(e) {
                var t;
                this.isSVGTag = "string" == typeof (t = e.tagName) && "svg" === t.toLowerCase(),
                super.mount(e)
            }
        }
        function rn(e, t) {
            return function({top: e, left: t, right: n, bottom: i}) {
                return {
                    x: {
                        min: t,
                        max: n
                    },
                    y: {
                        min: e,
                        max: i
                    }
                }
            }(function(e, t) {
                if (!t)
                    return e;
                const n = t({
                    x: e.left,
                    y: e.top
                })
                  , i = t({
                    x: e.right,
                    y: e.bottom
                });
                return {
                    top: n.y,
                    left: n.x,
                    bottom: i.y,
                    right: i.x
                }
            }(e.getBoundingClientRect(), t))
        }
        class sn extends Wt {
            constructor() {
                super(...arguments),
                this.type = "html"
            }
            readValueFromInstance(e, t) {
                if (u.has(t)) {
                    const e = oe(t);
                    return e && e.default || 0
                }
                {
                    const i = (n = e,
                    window.getComputedStyle(n))
                      , r = ((0,
                    B.j)(t) ? i.getPropertyValue(t) : i[t]) || 0;
                    return "string" == typeof r ? r.trim() : r
                }
                var n
            }
            measureInstanceViewportBox(e, {transformPagePoint: t}) {
                return rn(e, t)
            }
            build(e, t, n, i) {
                Xt(e, t, n, i.transformTemplate)
            }
            scrapeMotionValuesFromProps(e, t) {
                return Bt(e, t)
            }
            handleChildMotionValue() {
                this.childSubscription && (this.childSubscription(),
                delete this.childSubscription);
                const {children: e} = this.props;
                At(e) && (this.childSubscription = e.on("change", (e => {
                    this.current && (this.current.textContent = `${e}`)
                }
                )))
            }
            renderInstance(e, t, n, i) {
                tn(e, t, n, i)
            }
        }
        function an(e) {
            const t = {
                presenceContext: null,
                props: {},
                visualState: {
                    renderState: {
                        transform: {},
                        transformOrigin: {},
                        style: {},
                        vars: {},
                        attrs: {}
                    },
                    latestValues: {}
                }
            }
              , n = function(e) {
                return e instanceof SVGElement && "svg" !== e.tagName
            }(e) ? new nn(t,{
                enableHardwareAcceleration: !1
            }) : new sn(t,{
                enableHardwareAcceleration: !0
            });
            n.mount(e),
            r.set(e, n)
        }
        function on(e, t, n) {
            const i = At(e) ? e : bt(e);
            return i.start(ft("", i, t, n)),
            i.animation
        }
        function ln(e, t=100) {
            const n = Te({
                keyframes: [0, t],
                ...e
            })
              , i = Math.min(tt(n), et);
            return {
                type: "keyframes",
                ease: e => n.next(i * e).value / t,
                duration: f(i)
            }
        }
        var cn = n(842)
          , un = n(7699);
        function hn(e, t, n, i) {
            var r;
            return "number" == typeof t ? t : t.startsWith("-") || t.startsWith("+") ? Math.max(0, e + parseFloat(t)) : "<" === t ? n : null !== (r = i.get(t)) && void 0 !== r ? r : e
        }
        const dn = (e, t, n) => {
            const i = t - e;
            return ((n - e) % i + i) % i + e
        }
        ;
        function pn(e, t) {
            return Oe(e) ? e[dn(0, e.length, t)] : e
        }
        var fn = n(5244);
        function An(e, t, n, i, r, s) {
            !function(e, t, n) {
                for (let i = 0; i < e.length; i++) {
                    const r = e[i];
                    r.at > t && r.at < n && (vt(e, r),
                    i--)
                }
            }(e, r, s);
            for (let a = 0; a < t.length; a++)
                e.push({
                    value: t[a],
                    at: (0,
                    fn.k)(r, s, i[a]),
                    easing: pn(n, a)
                })
        }
        function gn(e, t) {
            return e.at === t.at ? null === e.value ? 1 : null === t.value ? -1 : 0 : e.at - t.at
        }
        const mn = "easeInOut";
        function vn(e, t) {
            return !t.has(e) && t.set(e, {}),
            t.get(e)
        }
        function yn(e, t) {
            return t[e] || (t[e] = []),
            t[e]
        }
        function xn(e) {
            return Array.isArray(e) ? e : [e]
        }
        function _n(e, t) {
            return e[t] ? {
                ...e,
                ...e[t]
            } : {
                ...e
            }
        }
        const bn = e => "number" == typeof e
          , En = e => e.every(bn);
        function wn(e, t, n, a) {
            const o = (0,
            i.K)(e, a)
              , c = o.length;
            (0,
            s.V)(Boolean(c), "No valid element provided.");
            const u = [];
            for (let e = 0; e < c; e++) {
                const i = o[e];
                r.has(i) || an(i);
                const s = r.get(i)
                  , a = {
                    ...n
                };
                "function" == typeof a.delay && (a.delay = a.delay(e, c)),
                u.push(...St(s, {
                    ...t,
                    transition: a
                }, {}))
            }
            return new l(u)
        }
        function Cn(e, t, n) {
            const r = []
              , s = function(e, {defaultTransition: t={}, ...n}={}, r) {
                const s = t.duration || .3
                  , a = new Map
                  , o = new Map
                  , l = {}
                  , c = new Map;
                let u = 0
                  , h = 0
                  , d = 0;
                for (let n = 0; n < e.length; n++) {
                    const a = e[n];
                    if ("string" == typeof a) {
                        c.set(a, h);
                        continue
                    }
                    if (!Array.isArray(a)) {
                        c.set(a.name, hn(h, a.at, u, c));
                        continue
                    }
                    let[f,A,g={}] = a;
                    void 0 !== g.at && (h = hn(h, g.at, u, c));
                    let m = 0;
                    const v = (e, n, i, r=0, a=0) => {
                        const o = xn(e)
                          , {delay: l=0, times: c=(0,
                        Ke.Z)(o), type: u="keyframes", ...f} = n;
                        let {ease: A=t.ease || "easeOut", duration: g} = n;
                        const v = "function" == typeof l ? l(r, a) : l
                          , y = o.length;
                        if (y <= 2 && "spring" === u) {
                            let e = 100;
                            if (2 === y && En(o)) {
                                const t = o[1] - o[0];
                                e = Math.abs(t)
                            }
                            const t = {
                                ...f
                            };
                            void 0 !== g && (t.duration = p(g));
                            const n = ln(t, e);
                            A = n.ease,
                            g = n.duration
                        }
                        null != g || (g = s);
                        const x = h + v
                          , _ = x + g;
                        1 === c.length && 0 === c[0] && (c[1] = 1);
                        const b = c.length - o.length;
                        b > 0 && (0,
                        cn.f)(c, b),
                        1 === o.length && o.unshift(null),
                        An(i, o, A, c, x, _),
                        m = Math.max(v + g, m),
                        d = Math.max(_, d)
                    }
                    ;
                    if (At(f))
                        v(A, g, yn("default", vn(f, o)));
                    else {
                        const e = (0,
                        i.K)(f, r, l)
                          , t = e.length;
                        for (let n = 0; n < t; n++) {
                            const i = vn(e[n], o);
                            for (const e in A)
                                v(A[e], _n(g, e), yn(e, i), n, t)
                        }
                    }
                    u = h,
                    h += m
                }
                return o.forEach(( (e, i) => {
                    for (const r in e) {
                        const s = e[r];
                        s.sort(gn);
                        const o = []
                          , l = []
                          , c = [];
                        for (let e = 0; e < s.length; e++) {
                            const {at: t, value: n, easing: i} = s[e];
                            o.push(n),
                            l.push((0,
                            un.q)(0, d, t)),
                            c.push(i || "easeOut")
                        }
                        0 !== l[0] && (l.unshift(0),
                        o.unshift(o[0]),
                        c.unshift(mn)),
                        1 !== l[l.length - 1] && (l.push(1),
                        o.push(null)),
                        a.has(i) || a.set(i, {
                            keyframes: {},
                            transition: {}
                        });
                        const u = a.get(i);
                        u.keyframes[r] = o,
                        u.transition[r] = {
                            ...t,
                            duration: d,
                            ease: c,
                            times: l,
                            ...n
                        }
                    }
                }
                )),
                a
            }(e, t, n);
            return s.forEach(( ({keyframes: e, transition: t}, n) => {
                let i;
                i = At(n) ? on(n, e.default, t.default) : wn(n, e, t),
                r.push(i)
            }
            )),
            new l(r)
        }
        const In = function(e, t, n) {
            let i;
            var r;
            return r = e,
            i = Array.isArray(r) && Array.isArray(r[0]) ? Cn(e, t, Sn) : function(e) {
                return "object" == typeof e && !Array.isArray(e)
            }(t) ? wn(e, t, n, Sn) : on(e, t, n),
            Sn && Sn.animations.push(i),
            i
        };
        var Sn
    }
    ,
    4124: (e, t, n) => {
        "use strict";
        n.d(t, {
            WG: () => l,
            Gt: () => o,
            uv: () => c
        });
        var i = n(3146)
          , r = n(6021);
        class s {
            constructor() {
                this.order = [],
                this.scheduled = new Set
            }
            add(e) {
                if (!this.scheduled.has(e))
                    return this.scheduled.add(e),
                    this.order.push(e),
                    !0
            }
            remove(e) {
                const t = this.order.indexOf(e);
                -1 !== t && (this.order.splice(t, 1),
                this.scheduled.delete(e))
            }
            clear() {
                this.order.length = 0,
                this.scheduled.clear()
            }
        }
        const a = ["read", "resolveKeyframes", "update", "preRender", "render", "postRender"];
        const {schedule: o, cancel: l, state: c, steps: u} = function(e, t) {
            let n = !1
              , i = !0;
            const o = {
                delta: 0,
                timestamp: 0,
                isProcessing: !1
            }
              , l = a.reduce(( (e, t) => (e[t] = function(e) {
                let t = new s
                  , n = new s
                  , i = 0
                  , r = !1
                  , a = !1;
                const o = new WeakSet
                  , l = {
                    schedule: (e, s=!1, a=!1) => {
                        const l = a && r
                          , c = l ? t : n;
                        return s && o.add(e),
                        c.add(e) && l && r && (i = t.order.length),
                        e
                    }
                    ,
                    cancel: e => {
                        n.remove(e),
                        o.delete(e)
                    }
                    ,
                    process: s => {
                        if (r)
                            a = !0;
                        else {
                            if (r = !0,
                            [t,n] = [n, t],
                            n.clear(),
                            i = t.order.length,
                            i)
                                for (let n = 0; n < i; n++) {
                                    const i = t.order[n];
                                    o.has(i) && (l.schedule(i),
                                    e()),
                                    i(s)
                                }
                            r = !1,
                            a && (a = !1,
                            l.process(s))
                        }
                    }
                };
                return l
            }(( () => n = !0)),
            e)), {})
              , c = e => {
                l[e].process(o)
            }
              , u = () => {
                const s = r.W.useManualTiming ? o.timestamp : performance.now();
                n = !1,
                o.delta = i ? 1e3 / 60 : Math.max(Math.min(s - o.timestamp, 40), 1),
                o.timestamp = s,
                o.isProcessing = !0,
                a.forEach(c),
                o.isProcessing = !1,
                n && t && (i = !1,
                e(u))
            }
            ;
            return {
                schedule: a.reduce(( (t, r) => {
                    const s = l[r];
                    return t[r] = (t, r=!1, a=!1) => (n || (n = !0,
                    i = !0,
                    o.isProcessing || e(u)),
                    s.schedule(t, r, a)),
                    t
                }
                ), {}),
                cancel: e => a.forEach((t => l[t].cancel(e))),
                state: o,
                steps: l
            }
        }("undefined" != typeof requestAnimationFrame ? requestAnimationFrame : i.l, !0)
    }
    ,
    5450: (e, t, n) => {
        "use strict";
        n.d(t, {
            W: () => O
        });
        var i = n(1773);
        const r = new WeakMap;
        let s;
        function a({target: e, contentRect: t, borderBoxSize: n}) {
            var i;
            null === (i = r.get(e)) || void 0 === i || i.forEach((i => {
                i({
                    target: e,
                    contentSize: t,
                    get size() {
                        return function(e, t) {
                            if (t) {
                                const {inlineSize: e, blockSize: n} = t[0];
                                return {
                                    width: e,
                                    height: n
                                }
                            }
                            return e instanceof SVGElement && "getBBox"in e ? e.getBBox() : {
                                width: e.offsetWidth,
                                height: e.offsetHeight
                            }
                        }(e, n)
                    }
                })
            }
            ))
        }
        function o(e) {
            e.forEach(a)
        }
        function l(e, t) {
            s || "undefined" != typeof ResizeObserver && (s = new ResizeObserver(o));
            const n = (0,
            i.K)(e);
            return n.forEach((e => {
                let n = r.get(e);
                n || (n = new Set,
                r.set(e, n)),
                n.add(t),
                null == s || s.observe(e)
            }
            )),
            () => {
                n.forEach((e => {
                    const n = r.get(e);
                    null == n || n.delete(t),
                    (null == n ? void 0 : n.size) || null == s || s.unobserve(e)
                }
                ))
            }
        }
        const c = new Set;
        let u;
        function h(e) {
            return c.add(e),
            u || (u = () => {
                const e = {
                    width: window.innerWidth,
                    height: window.innerHeight
                }
                  , t = {
                    target: window,
                    size: e,
                    contentSize: e
                };
                c.forEach((e => e(t)))
            }
            ,
            window.addEventListener("resize", u)),
            () => {
                c.delete(e),
                !c.size && u && (u = void 0)
            }
        }
        var d = n(7699)
          , p = n(6898);
        const f = 50
          , A = () => ({
            time: 0,
            x: {
                current: 0,
                offset: [],
                progress: 0,
                scrollLength: 0,
                targetOffset: 0,
                targetLength: 0,
                containerLength: 0,
                velocity: 0
            },
            y: {
                current: 0,
                offset: [],
                progress: 0,
                scrollLength: 0,
                targetOffset: 0,
                targetLength: 0,
                containerLength: 0,
                velocity: 0
            }
        })
          , g = {
            x: {
                length: "Width",
                position: "Left"
            },
            y: {
                length: "Height",
                position: "Top"
            }
        };
        function m(e, t, n, i) {
            const r = n[t]
              , {length: s, position: a} = g[t]
              , o = r.current
              , l = n.time;
            r.current = e["scroll" + a],
            r.scrollLength = e["scroll" + s] - e["client" + s],
            r.offset.length = 0,
            r.offset[0] = 0,
            r.offset[1] = r.scrollLength,
            r.progress = (0,
            d.q)(0, r.scrollLength, r.current);
            const c = i - l;
            r.velocity = c > f ? 0 : (0,
            p.f)(r.current - o, c)
        }
        const v = {
            Enter: [[0, 1], [1, 1]],
            Exit: [[0, 0], [1, 0]],
            Any: [[1, 0], [0, 1]],
            All: [[0, 0], [1, 1]]
        }
          , y = {
            start: 0,
            center: .5,
            end: 1
        };
        function x(e, t, n=0) {
            let i = 0;
            if (void 0 !== y[e] && (e = y[e]),
            "string" == typeof e) {
                const t = parseFloat(e);
                e.endsWith("px") ? i = t : e.endsWith("%") ? e = t / 100 : e.endsWith("vw") ? i = t / 100 * document.documentElement.clientWidth : e.endsWith("vh") ? i = t / 100 * document.documentElement.clientHeight : e = t
            }
            return "number" == typeof e && (i = t * e),
            n + i
        }
        const _ = [0, 0];
        function b(e, t, n, i) {
            let r = Array.isArray(e) ? e : _
              , s = 0
              , a = 0;
            return "number" == typeof e ? r = [e, e] : "string" == typeof e && (r = (e = e.trim()).includes(" ") ? e.split(" ") : [e, y[e] ? e : "0"]),
            s = x(r[0], n, i),
            a = x(r[1], t),
            s - a
        }
        var E = n(3167)
          , w = n(8952);
        const C = {
            x: 0,
            y: 0
        };
        function I(e, t, n) {
            const {offset: i=v.All} = n
              , {target: r=e, axis: s="y"} = n
              , a = "y" === s ? "height" : "width"
              , o = r !== e ? function(e, t) {
                const n = {
                    x: 0,
                    y: 0
                };
                let i = e;
                for (; i && i !== t; )
                    if (i instanceof HTMLElement)
                        n.x += i.offsetLeft,
                        n.y += i.offsetTop,
                        i = i.offsetParent;
                    else if ("svg" === i.tagName) {
                        const e = i.getBoundingClientRect();
                        i = i.parentElement;
                        const t = i.getBoundingClientRect();
                        n.x += e.left - t.left,
                        n.y += e.top - t.top
                    } else {
                        if (!(i instanceof SVGGraphicsElement))
                            break;
                        {
                            const {x: e, y: t} = i.getBBox();
                            n.x += e,
                            n.y += t;
                            let r = null
                              , s = i.parentNode;
                            for (; !r; )
                                "svg" === s.tagName && (r = s),
                                s = i.parentNode;
                            i = r
                        }
                    }
                return n
            }(r, e) : C
              , l = r === e ? {
                width: e.scrollWidth,
                height: e.scrollHeight
            } : function(e) {
                return "getBBox"in e && "svg" !== e.tagName ? e.getBBox() : {
                    width: e.clientWidth,
                    height: e.clientHeight
                }
            }(r)
              , c = {
                width: e.clientWidth,
                height: e.clientHeight
            };
            t[s].offset.length = 0;
            let u = !t[s].interpolate;
            const h = i.length;
            for (let e = 0; e < h; e++) {
                const n = b(i[e], c[a], l[a], o[s]);
                u || n === t[s].interpolatorOffsets[e] || (u = !0),
                t[s].offset[e] = n
            }
            u && (t[s].interpolate = (0,
            E.G)(t[s].offset, (0,
            w.Z)(i)),
            t[s].interpolatorOffsets = [...t[s].offset]),
            t[s].progress = t[s].interpolate(t[s].current)
        }
        function S(e, t, n, i={}) {
            return {
                measure: () => function(e, t=e, n) {
                    if (n.x.targetOffset = 0,
                    n.y.targetOffset = 0,
                    t !== e) {
                        let i = t;
                        for (; i && i !== e; )
                            n.x.targetOffset += i.offsetLeft,
                            n.y.targetOffset += i.offsetTop,
                            i = i.offsetParent
                    }
                    n.x.targetLength = t === e ? t.scrollWidth : t.clientWidth,
                    n.y.targetLength = t === e ? t.scrollHeight : t.clientHeight,
                    n.x.containerLength = e.clientWidth,
                    n.y.containerLength = e.clientHeight
                }(e, i.target, n),
                update: t => {
                    !function(e, t, n) {
                        m(e, "x", t, n),
                        m(e, "y", t, n),
                        t.time = n
                    }(e, n, t),
                    (i.offset || i.target) && I(e, n, i)
                }
                ,
                notify: () => t(n)
            }
        }
        var M = n(4124);
        const T = new WeakMap
          , B = new WeakMap
          , R = new WeakMap
          , D = e => e === document.documentElement ? window : e;
        function P(e, {container: t=document.documentElement, ...n}={}) {
            let i = R.get(t);
            i || (i = new Set,
            R.set(t, i));
            const r = A()
              , s = S(t, e, r, n);
            if (i.add(s),
            !T.has(t)) {
                const e = () => {
                    for (const e of i)
                        e.measure()
                }
                  , n = () => {
                    for (const e of i)
                        e.update(M.uv.timestamp)
                }
                  , r = () => {
                    for (const e of i)
                        e.notify()
                }
                  , s = () => {
                    M.Gt.read(e, !1, !0),
                    M.Gt.read(n, !1, !0),
                    M.Gt.update(r, !1, !0)
                }
                ;
                T.set(t, s);
                const c = D(t);
                window.addEventListener("resize", s, {
                    passive: !0
                }),
                t !== document.documentElement && B.set(t, (o = s,
                "function" == typeof (a = t) ? h(a) : l(a, o))),
                c.addEventListener("scroll", s, {
                    passive: !0
                })
            }
            var a, o;
            const c = T.get(t);
            return M.Gt.read(c, !1, !0),
            () => {
                var e;
                (0,
                M.WG)(c);
                const n = R.get(t);
                if (!n)
                    return;
                if (n.delete(s),
                n.size)
                    return;
                const i = T.get(t);
                T.delete(t),
                i && (D(t).removeEventListener("scroll", i),
                null === (e = B.get(t)) || void 0 === e || e(),
                window.removeEventListener("resize", i))
            }
        }
        var L = n(2378)
          , U = n(154);
        const F = new Map;
        function N({source: e=document.documentElement, axis: t="y"}={}) {
            F.has(e) || F.set(e, {});
            const n = F.get(e);
            return n[t] || (n[t] = (0,
            U.J)() ? new ScrollTimeline({
                source: e,
                axis: t
            }) : function({source: e, axis: t="y"}) {
                const n = {
                    value: 0
                }
                  , i = P((e => {
                    n.value = 100 * e[t].progress
                }
                ), {
                    container: e,
                    axis: t
                });
                return {
                    currentTime: n,
                    cancel: i
                }
            }({
                source: e,
                axis: t
            })),
            n[t]
        }
        function O(e, t) {
            const n = N(t);
            return "function" == typeof e ? (0,
            L.y)(e, n) : e.attachTimeline(n)
        }
    }
    ,
    2378: (e, t, n) => {
        "use strict";
        n.d(t, {
            y: () => r
        });
        var i = n(4124);
        function r(e, t) {
            let n;
            const r = () => {
                const {currentTime: i} = t
                  , r = (null === i ? 0 : i.value) / 100;
                n !== r && e(r),
                n = r
            }
            ;
            return i.Gt.update(r, !0),
            () => (0,
            i.WG)(r)
        }
    }
    ,
    154: (e, t, n) => {
        "use strict";
        n.d(t, {
            J: () => i
        });
        const i = (0,
        n(3628).p)(( () => void 0 !== window.ScrollTimeline))
    }
    ,
    5813: (e, t, n) => {
        "use strict";
        n.d(t, {
            j: () => r,
            p: () => a
        });
        const i = e => t => "string" == typeof t && t.startsWith(e)
          , r = i("--")
          , s = i("var(--")
          , a = e => !!s(e) && o.test(e.split("/*")[0].trim())
          , o = /var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu
    }
    ,
    1773: (e, t, n) => {
        "use strict";
        n.d(t, {
            K: () => r
        });
        var i = n(9791);
        function r(e, t, n) {
            var r;
            if ("string" == typeof e) {
                let s = document;
                t && ((0,
                i.V)(Boolean(t.current), "Scope provided, but no element detected."),
                s = t.current),
                n ? (null !== (r = n[e]) && void 0 !== r || (n[e] = s.querySelectorAll(e)),
                e = n[e]) : e = s.querySelectorAll(e)
            } else
                e instanceof Element && (e = [e]);
            return Array.from(e || [])
        }
    }
    ,
    2407: (e, t, n) => {
        "use strict";
        n.d(t, {
            l: () => s
        });
        var i = n(1773);
        const r = {
            some: 0,
            all: 1
        };
        function s(e, t, {root: n, margin: s, amount: a="some"}={}) {
            const o = (0,
            i.K)(e)
              , l = new WeakMap
              , c = new IntersectionObserver((e => {
                e.forEach((e => {
                    const n = l.get(e.target);
                    if (e.isIntersecting !== Boolean(n))
                        if (e.isIntersecting) {
                            const n = t(e);
                            "function" == typeof n ? l.set(e.target, n) : c.unobserve(e.target)
                        } else
                            n && (n(e),
                            l.delete(e.target))
                }
                ))
            }
            ),{
                root: n,
                rootMargin: s,
                threshold: "number" == typeof a ? a : r[a]
            });
            return o.forEach((e => c.observe(e))),
            () => c.disconnect()
        }
    }
    ,
    6021: (e, t, n) => {
        "use strict";
        n.d(t, {
            W: () => i
        });
        const i = {
            skipAnimations: !1,
            useManualTiming: !1
        }
    }
    ,
    9239: (e, t, n) => {
        "use strict";
        n.d(t, {
            q: () => i
        });
        const i = (e, t, n) => n > t ? t : n < e ? e : n
    }
    ,
    9791: (e, t, n) => {
        "use strict";
        n.d(t, {
            $: () => r,
            V: () => s
        });
        var i = n(3146);
        let r = i.l
          , s = i.l
    }
    ,
    3167: (e, t, n) => {
        "use strict";
        n.d(t, {
            G: () => c
        });
        var i = n(9791)
          , r = n(9239)
          , s = n(2302)
          , a = n(7699)
          , o = n(3146)
          , l = n(1105);
        function c(e, t, {clamp: n=!0, ease: c, mixer: u}={}) {
            const h = e.length;
            if ((0,
            i.V)(h === t.length, "Both input and output ranges must be the same length"),
            1 === h)
                return () => t[0];
            if (2 === h && e[0] === e[1])
                return () => t[1];
            e[0] > e[h - 1] && (e = [...e].reverse(),
            t = [...t].reverse());
            const d = function(e, t, n) {
                const i = []
                  , r = n || l.j
                  , a = e.length - 1;
                for (let n = 0; n < a; n++) {
                    let a = r(e[n], e[n + 1]);
                    if (t) {
                        const e = Array.isArray(t) ? t[n] || o.l : t;
                        a = (0,
                        s.F)(e, a)
                    }
                    i.push(a)
                }
                return i
            }(t, c, u)
              , p = d.length
              , f = t => {
                let n = 0;
                if (p > 1)
                    for (; n < e.length - 2 && !(t < e[n + 1]); n++)
                        ;
                const i = (0,
                a.q)(e[n], e[n + 1], t);
                return d[n](i)
            }
            ;
            return n ? t => f((0,
            r.q)(e[0], e[h - 1], t)) : f
        }
    }
    ,
    3628: (e, t, n) => {
        "use strict";
        function i(e) {
            let t;
            return () => (void 0 === t && (t = e()),
            t)
        }
        n.d(t, {
            p: () => i
        })
    }
    ,
    1105: (e, t, n) => {
        "use strict";
        n.d(t, {
            j: () => E
        });
        var i = n(5244)
          , r = n(9791);
        function s(e, t, n) {
            return n < 0 && (n += 1),
            n > 1 && (n -= 1),
            n < 1 / 6 ? e + 6 * (t - e) * n : n < .5 ? t : n < 2 / 3 ? e + (t - e) * (2 / 3 - n) * 6 : e
        }
        var a = n(9131)
          , o = n(8678)
          , l = n(2946);
        const c = (e, t, n) => {
            const i = e * e
              , r = n * (t * t - i) + i;
            return r < 0 ? 0 : Math.sqrt(r)
        }
          , u = [a.u, o.B, l.V];
        function h(e) {
            const t = (n = e,
            u.find((e => e.test(n))));
            var n;
            (0,
            r.V)(Boolean(t), `'${e}' is not an animatable color. Use the equivalent color code instead.`);
            let i = t.parse(e);
            return t === l.V && (i = function({hue: e, saturation: t, lightness: n, alpha: i}) {
                e /= 360,
                n /= 100;
                let r = 0
                  , a = 0
                  , o = 0;
                if (t /= 100) {
                    const i = n < .5 ? n * (1 + t) : n + t - n * t
                      , l = 2 * n - i;
                    r = s(l, i, e + 1 / 3),
                    a = s(l, i, e),
                    o = s(l, i, e - 1 / 3)
                } else
                    r = a = o = n;
                return {
                    red: Math.round(255 * r),
                    green: Math.round(255 * a),
                    blue: Math.round(255 * o),
                    alpha: i
                }
            }(i)),
            i
        }
        const d = (e, t) => {
            const n = h(e)
              , r = h(t)
              , s = {
                ...n
            };
            return e => (s.red = c(n.red, r.red, e),
            s.green = c(n.green, r.green, e),
            s.blue = c(n.blue, r.blue, e),
            s.alpha = (0,
            i.k)(n.alpha, r.alpha, e),
            o.B.transform(s))
        }
        ;
        var p = n(2302)
          , f = n(4984)
          , A = n(7865)
          , g = n(5813);
        function m(e, t) {
            return n => n > 0 ? t : e
        }
        function v(e, t) {
            return n => (0,
            i.k)(e, t, n)
        }
        function y(e) {
            return "number" == typeof e ? v : "string" == typeof e ? (0,
            g.p)(e) ? m : f.y.test(e) ? d : b : Array.isArray(e) ? x : "object" == typeof e ? f.y.test(e) ? d : _ : m
        }
        function x(e, t) {
            const n = [...e]
              , i = n.length
              , r = e.map(( (e, n) => y(e)(e, t[n])));
            return e => {
                for (let t = 0; t < i; t++)
                    n[t] = r[t](e);
                return n
            }
        }
        function _(e, t) {
            const n = {
                ...e,
                ...t
            }
              , i = {};
            for (const r in n)
                void 0 !== e[r] && void 0 !== t[r] && (i[r] = y(e[r])(e[r], t[r]));
            return e => {
                for (const t in i)
                    n[t] = i[t](e);
                return n
            }
        }
        const b = (e, t) => {
            const n = A.f.createTransformer(t)
              , i = (0,
            A.V)(e)
              , s = (0,
            A.V)(t);
            return i.indexes.var.length === s.indexes.var.length && i.indexes.color.length === s.indexes.color.length && i.indexes.number.length >= s.indexes.number.length ? (0,
            p.F)(x(function(e, t) {
                var n;
                const i = []
                  , r = {
                    color: 0,
                    var: 0,
                    number: 0
                };
                for (let s = 0; s < t.values.length; s++) {
                    const a = t.types[s]
                      , o = e.indexes[a][r[a]]
                      , l = null !== (n = e.values[o]) && void 0 !== n ? n : 0;
                    i[s] = l,
                    r[a]++
                }
                return i
            }(i, s), s.values), n) : ((0,
            r.$)(!0, `Complex values '${e}' and '${t}' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`),
            m(e, t))
        }
        ;
        function E(e, t, n) {
            if ("number" == typeof e && "number" == typeof t && "number" == typeof n)
                return (0,
                i.k)(e, t, n);
            return y(e)(e, t)
        }
    }
    ,
    5244: (e, t, n) => {
        "use strict";
        n.d(t, {
            k: () => i
        });
        const i = (e, t, n) => e + (t - e) * n
    }
    ,
    3146: (e, t, n) => {
        "use strict";
        n.d(t, {
            l: () => i
        });
        const i = e => e
    }
    ,
    8952: (e, t, n) => {
        "use strict";
        n.d(t, {
            Z: () => r
        });
        var i = n(842);
        function r(e) {
            const t = [0];
            return (0,
            i.f)(t, e.length - 1),
            t
        }
    }
    ,
    842: (e, t, n) => {
        "use strict";
        n.d(t, {
            f: () => s
        });
        var i = n(5244)
          , r = n(7699);
        function s(e, t) {
            const n = e[e.length - 1];
            for (let s = 1; s <= t; s++) {
                const a = (0,
                r.q)(0, t, s);
                e.push((0,
                i.k)(n, 1, a))
            }
        }
    }
    ,
    2302: (e, t, n) => {
        "use strict";
        n.d(t, {
            F: () => r
        });
        const i = (e, t) => n => t(e(n))
          , r = (...e) => e.reduce(i)
    }
    ,
    7699: (e, t, n) => {
        "use strict";
        n.d(t, {
            q: () => i
        });
        const i = (e, t, n) => {
            const i = t - e;
            return 0 === i ? 1 : (n - e) / i
        }
    }
    ,
    6898: (e, t, n) => {
        "use strict";
        function i(e, t) {
            return t ? e * (1e3 / t) : 0
        }
        n.d(t, {
            f: () => i
        })
    }
    ,
    9131: (e, t, n) => {
        "use strict";
        n.d(t, {
            u: () => r
        });
        var i = n(8678);
        const r = {
            test: (0,
            n(8711).$)("#"),
            parse: function(e) {
                let t = ""
                  , n = ""
                  , i = ""
                  , r = "";
                return e.length > 5 ? (t = e.substring(1, 3),
                n = e.substring(3, 5),
                i = e.substring(5, 7),
                r = e.substring(7, 9)) : (t = e.substring(1, 2),
                n = e.substring(2, 3),
                i = e.substring(3, 4),
                r = e.substring(4, 5),
                t += t,
                n += n,
                i += i,
                r += r),
                {
                    red: parseInt(t, 16),
                    green: parseInt(n, 16),
                    blue: parseInt(i, 16),
                    alpha: r ? parseInt(r, 16) / 255 : 1
                }
            },
            transform: i.B.transform
        }
    }
    ,
    2946: (e, t, n) => {
        "use strict";
        n.d(t, {
            V: () => o
        });
        var i = n(8411)
          , r = n(4238)
          , s = n(211)
          , a = n(8711);
        const o = {
            test: (0,
            a.$)("hsl", "hue"),
            parse: (0,
            a.q)("hue", "saturation", "lightness"),
            transform: ({hue: e, saturation: t, lightness: n, alpha: a=1}) => "hsla(" + Math.round(e) + ", " + r.KN.transform((0,
            s.aj)(t)) + ", " + r.KN.transform((0,
            s.aj)(n)) + ", " + (0,
            s.aj)(i.X4.transform(a)) + ")"
        }
    }
    ,
    4984: (e, t, n) => {
        "use strict";
        n.d(t, {
            y: () => o
        });
        var i = n(211)
          , r = n(9131)
          , s = n(2946)
          , a = n(8678);
        const o = {
            test: e => a.B.test(e) || r.u.test(e) || s.V.test(e),
            parse: e => a.B.test(e) ? a.B.parse(e) : s.V.test(e) ? s.V.parse(e) : r.u.parse(e),
            transform: e => (0,
            i.Kg)(e) ? e : e.hasOwnProperty("red") ? a.B.transform(e) : s.V.transform(e)
        }
    }
    ,
    8678: (e, t, n) => {
        "use strict";
        n.d(t, {
            B: () => l
        });
        var i = n(9239)
          , r = n(8411)
          , s = n(211)
          , a = n(8711);
        const o = {
            ...r.ai,
            transform: e => Math.round((e => (0,
            i.q)(0, 255, e))(e))
        }
          , l = {
            test: (0,
            a.$)("rgb", "red"),
            parse: (0,
            a.q)("red", "green", "blue"),
            transform: ({red: e, green: t, blue: n, alpha: i=1}) => "rgba(" + o.transform(e) + ", " + o.transform(t) + ", " + o.transform(n) + ", " + (0,
            s.aj)(r.X4.transform(i)) + ")"
        }
    }
    ,
    8711: (e, t, n) => {
        "use strict";
        n.d(t, {
            $: () => r,
            q: () => s
        });
        var i = n(211);
        const r = (e, t) => n => Boolean((0,
        i.Kg)(n) && i.Fl.test(n) && n.startsWith(e) || t && Object.prototype.hasOwnProperty.call(n, t))
          , s = (e, t, n) => r => {
            if (!(0,
            i.Kg)(r))
                return r;
            const [s,a,o,l] = r.match(i.SY);
            return {
                [e]: parseFloat(s),
                [t]: parseFloat(a),
                [n]: parseFloat(o),
                alpha: void 0 !== l ? parseFloat(l) : 1
            }
        }
    }
    ,
    7865: (e, t, n) => {
        "use strict";
        n.d(t, {
            V: () => h,
            f: () => A
        });
        var i = n(4984)
          , r = n(211);
        const s = "number"
          , a = "color"
          , o = "var"
          , l = "var("
          , c = "${}"
          , u = /var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu;
        function h(e) {
            const t = e.toString()
              , n = []
              , r = {
                color: [],
                number: [],
                var: []
            }
              , h = [];
            let d = 0;
            const p = t.replace(u, (e => (i.y.test(e) ? (r.color.push(d),
            h.push(a),
            n.push(i.y.parse(e))) : e.startsWith(l) ? (r.var.push(d),
            h.push(o),
            n.push(e)) : (r.number.push(d),
            h.push(s),
            n.push(parseFloat(e))),
            ++d,
            c))).split(c);
            return {
                values: n,
                split: p,
                indexes: r,
                types: h
            }
        }
        function d(e) {
            return h(e).values
        }
        function p(e) {
            const {split: t, types: n} = h(e)
              , o = t.length;
            return e => {
                let l = "";
                for (let c = 0; c < o; c++)
                    if (l += t[c],
                    void 0 !== e[c]) {
                        const t = n[c];
                        l += t === s ? (0,
                        r.aj)(e[c]) : t === a ? i.y.transform(e[c]) : e[c]
                    }
                return l
            }
        }
        const f = e => "number" == typeof e ? 0 : e;
        const A = {
            test: function(e) {
                var t, n;
                return isNaN(e) && (0,
                r.Kg)(e) && ((null === (t = e.match(r.SY)) || void 0 === t ? void 0 : t.length) || 0) + ((null === (n = e.match(r.ne)) || void 0 === n ? void 0 : n.length) || 0) > 0
            },
            parse: d,
            createTransformer: p,
            getAnimatableNone: function(e) {
                const t = d(e);
                return p(e)(t.map(f))
            }
        }
    }
    ,
    8411: (e, t, n) => {
        "use strict";
        n.d(t, {
            X4: () => s,
            ai: () => r,
            hs: () => a
        });
        var i = n(9239);
        const r = {
            test: e => "number" == typeof e,
            parse: parseFloat,
            transform: e => e
        }
          , s = {
            ...r,
            transform: e => (0,
            i.q)(0, 1, e)
        }
          , a = {
            ...r,
            default: 1
        }
    }
    ,
    4238: (e, t, n) => {
        "use strict";
        n.d(t, {
            KN: () => a,
            gQ: () => u,
            px: () => o,
            uj: () => s,
            vh: () => l,
            vw: () => c
        });
        var i = n(211);
        const r = e => ({
            test: t => (0,
            i.Kg)(t) && t.endsWith(e) && 1 === t.split(" ").length,
            parse: parseFloat,
            transform: t => `${t}${e}`
        })
          , s = r("deg")
          , a = r("%")
          , o = r("px")
          , l = r("vh")
          , c = r("vw")
          , u = {
            ...a,
            parse: e => a.parse(e) / 100,
            transform: e => a.transform(100 * e)
        }
    }
    ,
    211: (e, t, n) => {
        "use strict";
        n.d(t, {
            Fl: () => a,
            Kg: () => o,
            SY: () => r,
            aj: () => i,
            ne: () => s
        });
        const i = e => Math.round(1e5 * e) / 1e5
          , r = /-?(?:\d+(?:\.\d+)?|\.\d+)/gu
          , s = /(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu
          , a = /^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu;
        function o(e) {
            return "string" == typeof e
        }
    }
    ,
    5803: (e, t, n) => {
        "use strict";
        n.d(t, {
            A: () => u
        });
        function i(e, t, n) {
            return Math.max(e, Math.min(t, n))
        }
        var r = class {
            isRunning = !1;
            value = 0;
            from = 0;
            to = 0;
            currentTime = 0;
            lerp;
            duration;
            easing;
            onUpdate;
            advance(e) {
                if (!this.isRunning)
                    return;
                let t = !1;
                if (this.duration && this.easing) {
                    this.currentTime += e;
                    const n = i(0, this.currentTime / this.duration, 1);
                    t = n >= 1;
                    const r = t ? 1 : this.easing(n);
                    this.value = this.from + (this.to - this.from) * r
                } else
                    this.lerp ? (this.value = function(e, t, n, i) {
                        return function(e, t, n) {
                            return (1 - n) * e + n * t
                        }(e, t, 1 - Math.exp(-n * i))
                    }(this.value, this.to, 60 * this.lerp, e),
                    Math.round(this.value) === this.to && (this.value = this.to,
                    t = !0)) : (this.value = this.to,
                    t = !0);
                t && this.stop(),
                this.onUpdate?.(this.value, t)
            }
            stop() {
                this.isRunning = !1
            }
            fromTo(e, t, {lerp: n, duration: i, easing: r, onStart: s, onUpdate: a}) {
                this.from = this.value = e,
                this.to = t,
                this.lerp = n,
                this.duration = i,
                this.easing = r,
                this.currentTime = 0,
                this.isRunning = !0,
                s?.(),
                this.onUpdate = a
            }
        }
        ;
        var s = class {
            constructor(e, t, {autoResize: n=!0, debounce: i=250}={}) {
                this.wrapper = e,
                this.content = t,
                n && (this.debouncedResize = function(e, t) {
                    let n;
                    return function(...i) {
                        let r = this;
                        clearTimeout(n),
                        n = setTimeout(( () => {
                            n = void 0,
                            e.apply(r, i)
                        }
                        ), t)
                    }
                }(this.resize, i),
                this.wrapper instanceof Window ? window.addEventListener("resize", this.debouncedResize, !1) : (this.wrapperResizeObserver = new ResizeObserver(this.debouncedResize),
                this.wrapperResizeObserver.observe(this.wrapper)),
                this.contentResizeObserver = new ResizeObserver(this.debouncedResize),
                this.contentResizeObserver.observe(this.content)),
                this.resize()
            }
            width = 0;
            height = 0;
            scrollHeight = 0;
            scrollWidth = 0;
            debouncedResize;
            wrapperResizeObserver;
            contentResizeObserver;
            destroy() {
                this.wrapperResizeObserver?.disconnect(),
                this.contentResizeObserver?.disconnect(),
                this.wrapper === window && this.debouncedResize && window.removeEventListener("resize", this.debouncedResize, !1)
            }
            resize = () => {
                this.onWrapperResize(),
                this.onContentResize()
            }
            ;
            onWrapperResize = () => {
                this.wrapper instanceof Window ? (this.width = window.innerWidth,
                this.height = window.innerHeight) : (this.width = this.wrapper.clientWidth,
                this.height = this.wrapper.clientHeight)
            }
            ;
            onContentResize = () => {
                this.wrapper instanceof Window ? (this.scrollHeight = this.content.scrollHeight,
                this.scrollWidth = this.content.scrollWidth) : (this.scrollHeight = this.wrapper.scrollHeight,
                this.scrollWidth = this.wrapper.scrollWidth)
            }
            ;
            get limit() {
                return {
                    x: this.scrollWidth - this.width,
                    y: this.scrollHeight - this.height
                }
            }
        }
          , a = class {
            events = {};
            emit(e, ...t) {
                let n = this.events[e] || [];
                for (let e = 0, i = n.length; e < i; e++)
                    n[e]?.(...t)
            }
            on(e, t) {
                return this.events[e]?.push(t) || (this.events[e] = [t]),
                () => {
                    this.events[e] = this.events[e]?.filter((e => t !== e))
                }
            }
            off(e, t) {
                this.events[e] = this.events[e]?.filter((e => t !== e))
            }
            destroy() {
                this.events = {}
            }
        }
          , o = 100 / 6
          , l = {
            passive: !1
        }
          , c = class {
            constructor(e, t={
                wheelMultiplier: 1,
                touchMultiplier: 1
            }) {
                this.element = e,
                this.options = t,
                window.addEventListener("resize", this.onWindowResize, !1),
                this.onWindowResize(),
                this.element.addEventListener("wheel", this.onWheel, l),
                this.element.addEventListener("touchstart", this.onTouchStart, l),
                this.element.addEventListener("touchmove", this.onTouchMove, l),
                this.element.addEventListener("touchend", this.onTouchEnd, l)
            }
            touchStart = {
                x: 0,
                y: 0
            };
            lastDelta = {
                x: 0,
                y: 0
            };
            window = {
                width: 0,
                height: 0
            };
            emitter = new a;
            on(e, t) {
                return this.emitter.on(e, t)
            }
            destroy() {
                this.emitter.destroy(),
                window.removeEventListener("resize", this.onWindowResize, !1),
                this.element.removeEventListener("wheel", this.onWheel, l),
                this.element.removeEventListener("touchstart", this.onTouchStart, l),
                this.element.removeEventListener("touchmove", this.onTouchMove, l),
                this.element.removeEventListener("touchend", this.onTouchEnd, l)
            }
            onTouchStart = e => {
                const {clientX: t, clientY: n} = e.targetTouches ? e.targetTouches[0] : e;
                this.touchStart.x = t,
                this.touchStart.y = n,
                this.lastDelta = {
                    x: 0,
                    y: 0
                },
                this.emitter.emit("scroll", {
                    deltaX: 0,
                    deltaY: 0,
                    event: e
                })
            }
            ;
            onTouchMove = e => {
                const {clientX: t, clientY: n} = e.targetTouches ? e.targetTouches[0] : e
                  , i = -(t - this.touchStart.x) * this.options.touchMultiplier
                  , r = -(n - this.touchStart.y) * this.options.touchMultiplier;
                this.touchStart.x = t,
                this.touchStart.y = n,
                this.lastDelta = {
                    x: i,
                    y: r
                },
                this.emitter.emit("scroll", {
                    deltaX: i,
                    deltaY: r,
                    event: e
                })
            }
            ;
            onTouchEnd = e => {
                this.emitter.emit("scroll", {
                    deltaX: this.lastDelta.x,
                    deltaY: this.lastDelta.y,
                    event: e
                })
            }
            ;
            onWheel = e => {
                let {deltaX: t, deltaY: n, deltaMode: i} = e;
                t *= 1 === i ? o : 2 === i ? this.window.width : 1,
                n *= 1 === i ? o : 2 === i ? this.window.height : 1,
                t *= this.options.wheelMultiplier,
                n *= this.options.wheelMultiplier,
                this.emitter.emit("scroll", {
                    deltaX: t,
                    deltaY: n,
                    event: e
                })
            }
            ;
            onWindowResize = () => {
                this.window = {
                    width: window.innerWidth,
                    height: window.innerHeight
                }
            }
        }
          , u = class {
            _isScrolling = !1;
            _isStopped = !1;
            _isLocked = !1;
            _preventNextNativeScrollEvent = !1;
            _resetVelocityTimeout = null;
            __rafID = null;
            isTouching;
            time = 0;
            userData = {};
            lastVelocity = 0;
            velocity = 0;
            direction = 0;
            options;
            targetScroll;
            animatedScroll;
            animate = new r;
            emitter = new a;
            dimensions;
            virtualScroll;
            constructor({wrapper: e=window, content: t=document.documentElement, eventsTarget: n=e, smoothWheel: i=!0, syncTouch: r=!1, syncTouchLerp: a=.075, touchInertiaMultiplier: o=35, duration: l, easing: u=(e => Math.min(1, 1.001 - Math.pow(2, -10 * e))), lerp: h=.1, infinite: d=!1, orientation: p="vertical", gestureOrientation: f="vertical", touchMultiplier: A=1, wheelMultiplier: g=1, autoResize: m=!0, prevent: v, virtualScroll: y, overscroll: x=!0, autoRaf: _=!1, __experimental__naiveDimensions: b=!1}={}) {
                window.lenisVersion = "1.1.16",
                e && e !== document.documentElement && e !== document.body || (e = window),
                this.options = {
                    wrapper: e,
                    content: t,
                    eventsTarget: n,
                    smoothWheel: i,
                    syncTouch: r,
                    syncTouchLerp: a,
                    touchInertiaMultiplier: o,
                    duration: l,
                    easing: u,
                    lerp: h,
                    infinite: d,
                    gestureOrientation: f,
                    orientation: p,
                    touchMultiplier: A,
                    wheelMultiplier: g,
                    autoResize: m,
                    prevent: v,
                    virtualScroll: y,
                    overscroll: x,
                    autoRaf: _,
                    __experimental__naiveDimensions: b
                },
                this.dimensions = new s(e,t,{
                    autoResize: m
                }),
                this.updateClassName(),
                this.targetScroll = this.animatedScroll = this.actualScroll,
                this.options.wrapper.addEventListener("scroll", this.onNativeScroll, !1),
                this.options.wrapper.addEventListener("pointerdown", this.onPointerDown, !1),
                this.virtualScroll = new c(n,{
                    touchMultiplier: A,
                    wheelMultiplier: g
                }),
                this.virtualScroll.on("scroll", this.onVirtualScroll),
                this.options.autoRaf && (this.__rafID = requestAnimationFrame(this.raf))
            }
            destroy() {
                this.emitter.destroy(),
                this.options.wrapper.removeEventListener("scroll", this.onNativeScroll, !1),
                this.options.wrapper.removeEventListener("pointerdown", this.onPointerDown, !1),
                this.virtualScroll.destroy(),
                this.dimensions.destroy(),
                this.cleanUpClassName(),
                this.__rafID && cancelAnimationFrame(this.__rafID)
            }
            on(e, t) {
                return this.emitter.on(e, t)
            }
            off(e, t) {
                return this.emitter.off(e, t)
            }
            setScroll(e) {
                this.isHorizontal ? this.rootElement.scrollLeft = e : this.rootElement.scrollTop = e
            }
            onPointerDown = e => {
                1 === e.button && this.reset()
            }
            ;
            onVirtualScroll = e => {
                if ("function" == typeof this.options.virtualScroll && !1 === this.options.virtualScroll(e))
                    return;
                const {deltaX: t, deltaY: n, event: i} = e;
                if (this.emitter.emit("virtual-scroll", {
                    deltaX: t,
                    deltaY: n,
                    event: i
                }),
                i.ctrlKey)
                    return;
                if (i.lenisStopPropagation)
                    return;
                const r = i.type.includes("touch")
                  , s = i.type.includes("wheel");
                this.isTouching = "touchstart" === i.type || "touchmove" === i.type;
                if (this.options.syncTouch && r && "touchstart" === i.type && !this.isStopped && !this.isLocked)
                    return void this.reset();
                const a = 0 === t && 0 === n
                  , o = "vertical" === this.options.gestureOrientation && 0 === n || "horizontal" === this.options.gestureOrientation && 0 === t;
                if (a || o)
                    return;
                let l = i.composedPath();
                l = l.slice(0, l.indexOf(this.rootElement));
                const c = this.options.prevent;
                if (l.find((e => e instanceof HTMLElement && ("function" == typeof c && c?.(e) || e.hasAttribute?.("data-lenis-prevent") || r && e.hasAttribute?.("data-lenis-prevent-touch") || s && e.hasAttribute?.("data-lenis-prevent-wheel")))))
                    return;
                if (this.isStopped || this.isLocked)
                    return void i.preventDefault();
                if (!(this.options.syncTouch && r || this.options.smoothWheel && s))
                    return this.isScrolling = "native",
                    this.animate.stop(),
                    void (i.lenisStopPropagation = !0);
                let u = n;
                "both" === this.options.gestureOrientation ? u = Math.abs(n) > Math.abs(t) ? n : t : "horizontal" === this.options.gestureOrientation && (u = t),
                (!this.options.overscroll || this.options.infinite || this.options.wrapper !== window && (this.animatedScroll > 0 && this.animatedScroll < this.limit || 0 === this.animatedScroll && n > 0 || this.animatedScroll === this.limit && n < 0)) && (i.lenisStopPropagation = !0),
                i.preventDefault();
                const h = r && this.options.syncTouch
                  , d = r && "touchend" === i.type && Math.abs(u) > 5;
                d && (u = this.velocity * this.options.touchInertiaMultiplier),
                this.scrollTo(this.targetScroll + u, {
                    programmatic: !1,
                    ...h ? {
                        lerp: d ? this.options.syncTouchLerp : 1
                    } : {
                        lerp: this.options.lerp,
                        duration: this.options.duration,
                        easing: this.options.easing
                    }
                })
            }
            ;
            resize() {
                this.dimensions.resize(),
                this.animatedScroll = this.targetScroll = this.actualScroll,
                this.emit()
            }
            emit() {
                this.emitter.emit("scroll", this)
            }
            onNativeScroll = () => {
                if (null !== this._resetVelocityTimeout && (clearTimeout(this._resetVelocityTimeout),
                this._resetVelocityTimeout = null),
                this._preventNextNativeScrollEvent)
                    this._preventNextNativeScrollEvent = !1;
                else if (!1 === this.isScrolling || "native" === this.isScrolling) {
                    const e = this.animatedScroll;
                    this.animatedScroll = this.targetScroll = this.actualScroll,
                    this.lastVelocity = this.velocity,
                    this.velocity = this.animatedScroll - e,
                    this.direction = Math.sign(this.animatedScroll - e),
                    this.isScrolling = "native",
                    this.emit(),
                    0 !== this.velocity && (this._resetVelocityTimeout = setTimeout(( () => {
                        this.lastVelocity = this.velocity,
                        this.velocity = 0,
                        this.isScrolling = !1,
                        this.emit()
                    }
                    ), 400))
                }
            }
            ;
            reset() {
                this.isLocked = !1,
                this.isScrolling = !1,
                this.animatedScroll = this.targetScroll = this.actualScroll,
                this.lastVelocity = this.velocity = 0,
                this.animate.stop()
            }
            start() {
                this.isStopped && (this.isStopped = !1,
                this.reset())
            }
            stop() {
                this.isStopped || (this.isStopped = !0,
                this.animate.stop(),
                this.reset())
            }
            raf = e => {
                const t = e - (this.time || e);
                this.time = e,
                this.animate.advance(.001 * t),
                this.options.autoRaf && (this.__rafID = requestAnimationFrame(this.raf))
            }
            ;
            scrollTo(e, {offset: t=0, immediate: n=!1, lock: r=!1, duration: s=this.options.duration, easing: a=this.options.easing, lerp: o=this.options.lerp, onStart: l, onComplete: c, force: u=!1, programmatic: h=!0, userData: d}={}) {
                if (!this.isStopped && !this.isLocked || u) {
                    if ("string" == typeof e && ["top", "left", "start"].includes(e))
                        e = 0;
                    else if ("string" == typeof e && ["bottom", "right", "end"].includes(e))
                        e = this.limit;
                    else {
                        let n;
                        if ("string" == typeof e ? n = document.querySelector(e) : e instanceof HTMLElement && e?.nodeType && (n = e),
                        n) {
                            if (this.options.wrapper !== window) {
                                const e = this.rootElement.getBoundingClientRect();
                                t -= this.isHorizontal ? e.left : e.top
                            }
                            const i = n.getBoundingClientRect();
                            e = (this.isHorizontal ? i.left : i.top) + this.animatedScroll
                        }
                    }
                    if ("number" == typeof e) {
                        if (e += t,
                        e = Math.round(e),
                        this.options.infinite ? h && (this.targetScroll = this.animatedScroll = this.scroll) : e = i(0, e, this.limit),
                        e === this.targetScroll)
                            return l?.(this),
                            void c?.(this);
                        if (this.userData = d ?? {},
                        n)
                            return this.animatedScroll = this.targetScroll = e,
                            this.setScroll(this.scroll),
                            this.reset(),
                            this.preventNextNativeScrollEvent(),
                            this.emit(),
                            c?.(this),
                            void (this.userData = {});
                        h || (this.targetScroll = e),
                        this.animate.fromTo(this.animatedScroll, e, {
                            duration: s,
                            easing: a,
                            lerp: o,
                            onStart: () => {
                                r && (this.isLocked = !0),
                                this.isScrolling = "smooth",
                                l?.(this)
                            }
                            ,
                            onUpdate: (e, t) => {
                                this.isScrolling = "smooth",
                                this.lastVelocity = this.velocity,
                                this.velocity = e - this.animatedScroll,
                                this.direction = Math.sign(this.velocity),
                                this.animatedScroll = e,
                                this.setScroll(this.scroll),
                                h && (this.targetScroll = e),
                                t || this.emit(),
                                t && (this.reset(),
                                this.emit(),
                                c?.(this),
                                this.userData = {},
                                this.preventNextNativeScrollEvent())
                            }
                        })
                    }
                }
            }
            preventNextNativeScrollEvent() {
                this._preventNextNativeScrollEvent = !0,
                requestAnimationFrame(( () => {
                    this._preventNextNativeScrollEvent = !1
                }
                ))
            }
            get rootElement() {
                return this.options.wrapper === window ? document.documentElement : this.options.wrapper
            }
            get limit() {
                return this.options.__experimental__naiveDimensions ? this.isHorizontal ? this.rootElement.scrollWidth - this.rootElement.clientWidth : this.rootElement.scrollHeight - this.rootElement.clientHeight : this.dimensions.limit[this.isHorizontal ? "x" : "y"]
            }
            get isHorizontal() {
                return "horizontal" === this.options.orientation
            }
            get actualScroll() {
                return this.isHorizontal ? this.rootElement.scrollLeft : this.rootElement.scrollTop
            }
            get scroll() {
                return this.options.infinite ? (e = this.animatedScroll,
                t = this.limit,
                (e % t + t) % t) : this.animatedScroll;
                var e, t
            }
            get progress() {
                return 0 === this.limit ? 1 : this.scroll / this.limit
            }
            get isScrolling() {
                return this._isScrolling
            }
            set isScrolling(e) {
                this._isScrolling !== e && (this._isScrolling = e,
                this.updateClassName())
            }
            get isStopped() {
                return this._isStopped
            }
            set isStopped(e) {
                this._isStopped !== e && (this._isStopped = e,
                this.updateClassName())
            }
            get isLocked() {
                return this._isLocked
            }
            set isLocked(e) {
                this._isLocked !== e && (this._isLocked = e,
                this.updateClassName())
            }
            get isSmooth() {
                return "smooth" === this.isScrolling
            }
            get className() {
                let e = "lenis";
                return this.isStopped && (e += " lenis-stopped"),
                this.isLocked && (e += " lenis-locked"),
                this.isScrolling && (e += " lenis-scrolling"),
                "smooth" === this.isScrolling && (e += " lenis-smooth"),
                e
            }
            updateClassName() {
                this.cleanUpClassName(),
                this.rootElement.className = `${this.rootElement.className} ${this.className}`.trim()
            }
            cleanUpClassName() {
                this.rootElement.className = this.rootElement.className.replace(/lenis(-\w+)?/g, "").trim()
            }
        }
    }
    ,
    6781: (e, t, n) => {
        "use strict";
        n.d(t, {
            A: () => d
        });
        var i = n(6096);
        const r = function() {
            this.__data__ = new i.A,
            this.size = 0
        };
        const s = function(e) {
            var t = this.__data__
              , n = t.delete(e);
            return this.size = t.size,
            n
        };
        const a = function(e) {
            return this.__data__.get(e)
        };
        const o = function(e) {
            return this.__data__.has(e)
        };
        var l = n(5436)
          , c = n(3269);
        const u = function(e, t) {
            var n = this.__data__;
            if (n instanceof i.A) {
                var r = n.__data__;
                if (!l.A || r.length < 199)
                    return r.push([e, t]),
                    this.size = ++n.size,
                    this;
                n = this.__data__ = new c.A(r)
            }
            return n.set(e, t),
            this.size = n.size,
            this
        };
        function h(e) {
            var t = this.__data__ = new i.A(e);
            this.size = t.size
        }
        h.prototype.clear = r,
        h.prototype.delete = s,
        h.prototype.get = a,
        h.prototype.has = o,
        h.prototype.set = u;
        const d = h
    }
    ,
    7913: (e, t, n) => {
        "use strict";
        n.d(t, {
            A: () => i
        });
        const i = n(9600).A.Uint8Array
    }
    ,
    7252: (e, t, n) => {
        "use strict";
        n.d(t, {
            A: () => u
        });
        const i = function(e, t) {
            for (var n = -1, i = Array(e); ++n < e; )
                i[n] = t(n);
            return i
        };
        var r = n(8748)
          , s = n(6956)
          , a = n(4517)
          , o = n(5378)
          , l = n(2888)
          , c = Object.prototype.hasOwnProperty;
        const u = function(e, t) {
            var n = (0,
            s.A)(e)
              , u = !n && (0,
            r.A)(e)
              , h = !n && !u && (0,
            a.A)(e)
              , d = !n && !u && !h && (0,
            l.A)(e)
              , p = n || u || h || d
              , f = p ? i(e.length, String) : []
              , A = f.length;
            for (var g in e)
                !t && !c.call(e, g) || p && ("length" == g || h && ("offset" == g || "parent" == g) || d && ("buffer" == g || "byteLength" == g || "byteOffset" == g) || (0,
                o.A)(g, A)) || f.push(g);
            return f
        }
    }
    ,
    3271: (e, t, n) => {
        "use strict";
        n.d(t, {
            A: () => i
        });
        const i = function(e, t) {
            for (var n = -1, i = t.length, r = e.length; ++n < i; )
                e[r + n] = t[n];
            return e
        }
    }
    ,
    6124: (e, t, n) => {
        "use strict";
        n.d(t, {
            A: () => a
        });
        var i = n(9465)
          , r = n(6979)
          , s = Object.prototype.hasOwnProperty;
        const a = function(e, t, n) {
            var a = e[t];
            s.call(e, t) && (0,
            r.A)(a, n) && (void 0 !== n || t in e) || (0,
            i.A)(e, t, n)
        }
    }
    ,
    9465: (e, t, n) => {
        "use strict";
        n.d(t, {
            A: () => s
        });
        var i = n(123);
        const r = function() {
            try {
                var e = (0,
                i.A)(Object, "defineProperty");
                return e({}, "", {}),
                e
            } catch (e) {}
        }();
        const s = function(e, t, n) {
            "__proto__" == t && r ? r(e, t, {
                configurable: !0,
                enumerable: !0,
                value: n,
                writable: !0
            }) : e[t] = n
        }
    }
    ,
    4494: (e, t, n) => {
        "use strict";
        n.d(t, {
            A: () => s
        });
        var i = n(3271)
          , r = n(6956);
        const s = function(e, t, n) {
            var s = t(e);
            return (0,
            r.A)(e) ? s : (0,
            i.A)(s, n(e))
        }
    }
    ,
    1730: (e, t, n) => {
        "use strict";
        n.d(t, {
            A: () => P
        });
        var i = n(6781)
          , r = n(3269);
        const s = function(e) {
            return this.__data__.set(e, "__lodash_hash_undefined__"),
            this
        };
        const a = function(e) {
            return this.__data__.has(e)
        };
        function o(e) {
            var t = -1
              , n = null == e ? 0 : e.length;
            for (this.__data__ = new r.A; ++t < n; )
                this.add(e[t])
        }
        o.prototype.add = o.prototype.push = s,
        o.prototype.has = a;
        const l = o;
        const c = function(e, t) {
            for (var n = -1, i = null == e ? 0 : e.length; ++n < i; )
                if (t(e[n], n, e))
                    return !0;
            return !1
        };
        const u = function(e, t) {
            return e.has(t)
        };
        const h = function(e, t, n, i, r, s) {
            var a = 1 & n
              , o = e.length
              , h = t.length;
            if (o != h && !(a && h > o))
                return !1;
            var d = s.get(e)
              , p = s.get(t);
            if (d && p)
                return d == t && p == e;
            var f = -1
              , A = !0
              , g = 2 & n ? new l : void 0;
            for (s.set(e, t),
            s.set(t, e); ++f < o; ) {
                var m = e[f]
                  , v = t[f];
                if (i)
                    var y = a ? i(v, m, f, t, e, s) : i(m, v, f, e, t, s);
                if (void 0 !== y) {
                    if (y)
                        continue;
                    A = !1;
                    break
                }
                if (g) {
                    if (!c(t, (function(e, t) {
                        if (!u(g, t) && (m === e || r(m, e, n, i, s)))
                            return g.push(t)
                    }
                    ))) {
                        A = !1;
                        break
                    }
                } else if (m !== v && !r(m, v, n, i, s)) {
                    A = !1;
                    break
                }
            }
            return s.delete(e),
            s.delete(t),
            A
        };
        var d = n(3516)
          , p = n(7913)
          , f = n(6979);
        const A = function(e) {
            var t = -1
              , n = Array(e.size);
            return e.forEach((function(e, i) {
                n[++t] = [i, e]
            }
            )),
            n
        };
        const g = function(e) {
            var t = -1
              , n = Array(e.size);
            return e.forEach((function(e) {
                n[++t] = e
            }
            )),
            n
        };
        var m = d.A ? d.A.prototype : void 0
          , v = m ? m.valueOf : void 0;
        const y = function(e, t, n, i, r, s, a) {
            switch (n) {
            case "[object DataView]":
                if (e.byteLength != t.byteLength || e.byteOffset != t.byteOffset)
                    return !1;
                e = e.buffer,
                t = t.buffer;
            case "[object ArrayBuffer]":
                return !(e.byteLength != t.byteLength || !s(new p.A(e), new p.A(t)));
            case "[object Boolean]":
            case "[object Date]":
            case "[object Number]":
                return (0,
                f.A)(+e, +t);
            case "[object Error]":
                return e.name == t.name && e.message == t.message;
            case "[object RegExp]":
            case "[object String]":
                return e == t + "";
            case "[object Map]":
                var o = A;
            case "[object Set]":
                var l = 1 & i;
                if (o || (o = g),
                e.size != t.size && !l)
                    return !1;
                var c = a.get(e);
                if (c)
                    return c == t;
                i |= 2,
                a.set(e, t);
                var u = h(o(e), o(t), i, r, s, a);
                return a.delete(e),
                u;
            case "[object Symbol]":
                if (v)
                    return v.call(e) == v.call(t)
            }
            return !1
        };
        var x = n(2475)
          , _ = Object.prototype.hasOwnProperty;
        const b = function(e, t, n, i, r, s) {
            var a = 1 & n
              , o = (0,
            x.A)(e)
              , l = o.length;
            if (l != (0,
            x.A)(t).length && !a)
                return !1;
            for (var c = l; c--; ) {
                var u = o[c];
                if (!(a ? u in t : _.call(t, u)))
                    return !1
            }
            var h = s.get(e)
              , d = s.get(t);
            if (h && d)
                return h == t && d == e;
            var p = !0;
            s.set(e, t),
            s.set(t, e);
            for (var f = a; ++c < l; ) {
                var A = e[u = o[c]]
                  , g = t[u];
                if (i)
                    var m = a ? i(g, A, u, t, e, s) : i(A, g, u, e, t, s);
                if (!(void 0 === m ? A === g || r(A, g, n, i, s) : m)) {
                    p = !1;
                    break
                }
                f || (f = "constructor" == u)
            }
            if (p && !f) {
                var v = e.constructor
                  , y = t.constructor;
                v == y || !("constructor"in e) || !("constructor"in t) || "function" == typeof v && v instanceof v && "function" == typeof y && y instanceof y || (p = !1)
            }
            return s.delete(e),
            s.delete(t),
            p
        };
        var E = n(6881)
          , w = n(6956)
          , C = n(4517)
          , I = n(2888)
          , S = "[object Arguments]"
          , M = "[object Array]"
          , T = "[object Object]"
          , B = Object.prototype.hasOwnProperty;
        const R = function(e, t, n, r, s, a) {
            var o = (0,
            w.A)(e)
              , l = (0,
            w.A)(t)
              , c = o ? M : (0,
            E.A)(e)
              , u = l ? M : (0,
            E.A)(t)
              , d = (c = c == S ? T : c) == T
              , p = (u = u == S ? T : u) == T
              , f = c == u;
            if (f && (0,
            C.A)(e)) {
                if (!(0,
                C.A)(t))
                    return !1;
                o = !0,
                d = !1
            }
            if (f && !d)
                return a || (a = new i.A),
                o || (0,
                I.A)(e) ? h(e, t, n, r, s, a) : y(e, t, c, n, r, s, a);
            if (!(1 & n)) {
                var A = d && B.call(e, "__wrapped__")
                  , g = p && B.call(t, "__wrapped__");
                if (A || g) {
                    var m = A ? e.value() : e
                      , v = g ? t.value() : t;
                    return a || (a = new i.A),
                    s(m, v, n, r, a)
                }
            }
            return !!f && (a || (a = new i.A),
            b(e, t, n, r, s, a))
        };
        var D = n(7313);
        const P = function e(t, n, i, r, s) {
            return t === n || (null == t || null == n || !(0,
            D.A)(t) && !(0,
            D.A)(n) ? t != t && n != n : R(t, n, i, r, e, s))
        }
    }
    ,
    6132: (e, t, n) => {
        "use strict";
        n.d(t, {
            A: () => i
        });
        const i = function(e) {
            return function(t) {
                return null == t ? void 0 : t[e]
            }
        }
    }
    ,
    8007: (e, t, n) => {
        "use strict";
        n.d(t, {
            A: () => i
        });
        const i = function(e, t, n) {
            var i = -1
              , r = e.length;
            t < 0 && (t = -t > r ? 0 : r + t),
            (n = n > r ? r : n) < 0 && (n += r),
            r = t > n ? 0 : n - t >>> 0,
            t >>>= 0;
            for (var s = Array(r); ++i < r; )
                s[i] = e[i + t];
            return s
        }
    }
    ,
    8126: (e, t, n) => {
        "use strict";
        n.d(t, {
            A: () => i
        });
        const i = function(e) {
            return function(t) {
                return e(t)
            }
        }
    }
    ,
    2475: (e, t, n) => {
        "use strict";
        n.d(t, {
            A: () => a
        });
        var i = n(4494)
          , r = n(4402)
          , s = n(8964);
        const a = function(e) {
            return (0,
            i.A)(e, s.A, r.A)
        }
    }
    ,
    4878: (e, t, n) => {
        "use strict";
        n.d(t, {
            A: () => i
        });
        const i = (0,
        n(7244).A)(Object.getPrototypeOf, Object)
    }
    ,
    4402: (e, t, n) => {
        "use strict";
        n.d(t, {
            A: () => o
        });
        const i = function(e, t) {
            for (var n = -1, i = null == e ? 0 : e.length, r = 0, s = []; ++n < i; ) {
                var a = e[n];
                t(a, n, e) && (s[r++] = a)
            }
            return s
        };
        var r = n(1276)
          , s = Object.prototype.propertyIsEnumerable
          , a = Object.getOwnPropertySymbols;
        const o = a ? function(e) {
            return null == e ? [] : (e = Object(e),
            i(a(e), (function(t) {
                return s.call(e, t)
            }
            )))
        }
        : r.A
    }
    ,
    6881: (e, t, n) => {
        "use strict";
        n.d(t, {
            A: () => E
        });
        var i = n(123)
          , r = n(9600);
        const s = (0,
        i.A)(r.A, "DataView");
        var a = n(5436);
        const o = (0,
        i.A)(r.A, "Promise");
        const l = (0,
        i.A)(r.A, "Set");
        const c = (0,
        i.A)(r.A, "WeakMap");
        var u = n(4044)
          , h = n(1548)
          , d = "[object Map]"
          , p = "[object Promise]"
          , f = "[object Set]"
          , A = "[object WeakMap]"
          , g = "[object DataView]"
          , m = (0,
        h.A)(s)
          , v = (0,
        h.A)(a.A)
          , y = (0,
        h.A)(o)
          , x = (0,
        h.A)(l)
          , _ = (0,
        h.A)(c)
          , b = u.A;
        (s && b(new s(new ArrayBuffer(1))) != g || a.A && b(new a.A) != d || o && b(o.resolve()) != p || l && b(new l) != f || c && b(new c) != A) && (b = function(e) {
            var t = (0,
            u.A)(e)
              , n = "[object Object]" == t ? e.constructor : void 0
              , i = n ? (0,
            h.A)(n) : "";
            if (i)
                switch (i) {
                case m:
                    return g;
                case v:
                    return d;
                case y:
                    return p;
                case x:
                    return f;
                case _:
                    return A
                }
            return t
        }
        );
        const E = b
    }
    ,
    5378: (e, t, n) => {
        "use strict";
        n.d(t, {
            A: () => r
        });
        var i = /^(?:0|[1-9]\d*)$/;
        const r = function(e, t) {
            var n = typeof e;
            return !!(t = null == t ? 9007199254740991 : t) && ("number" == n || "symbol" != n && i.test(e)) && e > -1 && e % 1 == 0 && e < t
        }
    }
    ,
    1140: (e, t, n) => {
        "use strict";
        n.d(t, {
            A: () => r
        });
        var i = Object.prototype;
        const r = function(e) {
            var t = e && e.constructor;
            return e === ("function" == typeof t && t.prototype || i)
        }
    }
    ,
    248: (e, t, n) => {
        "use strict";
        n.d(t, {
            A: () => o
        });
        var i = n(6713)
          , r = "object" == typeof exports && exports && !exports.nodeType && exports
          , s = r && "object" == typeof module && module && !module.nodeType && module
          , a = s && s.exports === r && i.A.process;
        const o = function() {
            try {
                var e = s && s.require && s.require("util").types;
                return e || a && a.binding && a.binding("util")
            } catch (e) {}
        }()
    }
    ,
    7244: (e, t, n) => {
        "use strict";
        n.d(t, {
            A: () => i
        });
        const i = function(e, t) {
            return function(n) {
                return e(t(n))
            }
        }
    }
    ,
    5434: (e, t, n) => {
        "use strict";
        n.d(t, {
            A: () => s
        });
        const i = function(e, t, n) {
            return e == e && (void 0 !== n && (e = e <= n ? e : n),
            void 0 !== t && (e = e >= t ? e : t)),
            e
        };
        var r = n(3558);
        const s = function(e, t, n) {
            return void 0 === n && (n = t,
            t = void 0),
            void 0 !== n && (n = (n = (0,
            r.A)(n)) == n ? n : 0),
            void 0 !== t && (t = (t = (0,
            r.A)(t)) == t ? t : 0),
            i((0,
            r.A)(e), t, n)
        }
    }
    ,
    7853: (e, t, n) => {
        "use strict";
        n.d(t, {
            A: () => Ae
        });
        var i = n(6781);
        const r = function(e, t) {
            for (var n = -1, i = null == e ? 0 : e.length; ++n < i && !1 !== t(e[n], n, e); )
                ;
            return e
        };
        var s = n(6124)
          , a = n(9465);
        const o = function(e, t, n, i) {
            var r = !n;
            n || (n = {});
            for (var o = -1, l = t.length; ++o < l; ) {
                var c = t[o]
                  , u = i ? i(n[c], e[c], c, n, e) : void 0;
                void 0 === u && (u = e[c]),
                r ? (0,
                a.A)(n, c, u) : (0,
                s.A)(n, c, u)
            }
            return n
        };
        var l = n(8964);
        const c = function(e, t) {
            return e && o(t, (0,
            l.A)(t), e)
        };
        var u = n(7252)
          , h = n(7942)
          , d = n(1140);
        const p = function(e) {
            var t = [];
            if (null != e)
                for (var n in Object(e))
                    t.push(n);
            return t
        };
        var f = Object.prototype.hasOwnProperty;
        const A = function(e) {
            if (!(0,
            h.A)(e))
                return p(e);
            var t = (0,
            d.A)(e)
              , n = [];
            for (var i in e)
                ("constructor" != i || !t && f.call(e, i)) && n.push(i);
            return n
        };
        var g = n(1475);
        const m = function(e) {
            return (0,
            g.A)(e) ? (0,
            u.A)(e, !0) : A(e)
        };
        const v = function(e, t) {
            return e && o(t, m(t), e)
        };
        var y = n(9600)
          , x = "object" == typeof exports && exports && !exports.nodeType && exports
          , _ = x && "object" == typeof module && module && !module.nodeType && module
          , b = _ && _.exports === x ? y.A.Buffer : void 0
          , E = b ? b.allocUnsafe : void 0;
        const w = function(e, t) {
            if (t)
                return e.slice();
            var n = e.length
              , i = E ? E(n) : new e.constructor(n);
            return e.copy(i),
            i
        };
        const C = function(e, t) {
            var n = -1
              , i = e.length;
            for (t || (t = Array(i)); ++n < i; )
                t[n] = e[n];
            return t
        };
        var I = n(4402);
        const S = function(e, t) {
            return o(e, (0,
            I.A)(e), t)
        };
        var M = n(3271)
          , T = n(4878)
          , B = n(1276);
        const R = Object.getOwnPropertySymbols ? function(e) {
            for (var t = []; e; )
                (0,
                M.A)(t, (0,
                I.A)(e)),
                e = (0,
                T.A)(e);
            return t
        }
        : B.A;
        const D = function(e, t) {
            return o(e, R(e), t)
        };
        var P = n(2475)
          , L = n(4494);
        const U = function(e) {
            return (0,
            L.A)(e, m, R)
        };
        var F = n(6881)
          , N = Object.prototype.hasOwnProperty;
        const O = function(e) {
            var t = e.length
              , n = new e.constructor(t);
            return t && "string" == typeof e[0] && N.call(e, "index") && (n.index = e.index,
            n.input = e.input),
            n
        };
        var Q = n(7913);
        const k = function(e) {
            var t = new e.constructor(e.byteLength);
            return new Q.A(t).set(new Q.A(e)),
            t
        };
        const G = function(e, t) {
            var n = t ? k(e.buffer) : e.buffer;
            return new e.constructor(n,e.byteOffset,e.byteLength)
        };
        var H = /\w*$/;
        const z = function(e) {
            var t = new e.constructor(e.source,H.exec(e));
            return t.lastIndex = e.lastIndex,
            t
        };
        var V = n(3516)
          , W = V.A ? V.A.prototype : void 0
          , j = W ? W.valueOf : void 0;
        const q = function(e) {
            return j ? Object(j.call(e)) : {}
        };
        const Y = function(e, t) {
            var n = t ? k(e.buffer) : e.buffer;
            return new e.constructor(n,e.byteOffset,e.length)
        };
        const X = function(e, t, n) {
            var i = e.constructor;
            switch (t) {
            case "[object ArrayBuffer]":
                return k(e);
            case "[object Boolean]":
            case "[object Date]":
                return new i(+e);
            case "[object DataView]":
                return G(e, n);
            case "[object Float32Array]":
            case "[object Float64Array]":
            case "[object Int8Array]":
            case "[object Int16Array]":
            case "[object Int32Array]":
            case "[object Uint8Array]":
            case "[object Uint8ClampedArray]":
            case "[object Uint16Array]":
            case "[object Uint32Array]":
                return Y(e, n);
            case "[object Map]":
            case "[object Set]":
                return new i;
            case "[object Number]":
            case "[object String]":
                return new i(e);
            case "[object RegExp]":
                return z(e);
            case "[object Symbol]":
                return q(e)
            }
        };
        var K = Object.create;
        const J = function() {
            function e() {}
            return function(t) {
                if (!(0,
                h.A)(t))
                    return {};
                if (K)
                    return K(t);
                e.prototype = t;
                var n = new e;
                return e.prototype = void 0,
                n
            }
        }();
        const Z = function(e) {
            return "function" != typeof e.constructor || (0,
            d.A)(e) ? {} : J((0,
            T.A)(e))
        };
        var $ = n(6956)
          , ee = n(4517)
          , te = n(7313);
        const ne = function(e) {
            return (0,
            te.A)(e) && "[object Map]" == (0,
            F.A)(e)
        };
        var ie = n(8126)
          , re = n(248)
          , se = re.A && re.A.isMap;
        const ae = se ? (0,
        ie.A)(se) : ne;
        const oe = function(e) {
            return (0,
            te.A)(e) && "[object Set]" == (0,
            F.A)(e)
        };
        var le = re.A && re.A.isSet;
        const ce = le ? (0,
        ie.A)(le) : oe;
        var ue = "[object Arguments]"
          , he = "[object Function]"
          , de = "[object Object]"
          , pe = {};
        pe[ue] = pe["[object Array]"] = pe["[object ArrayBuffer]"] = pe["[object DataView]"] = pe["[object Boolean]"] = pe["[object Date]"] = pe["[object Float32Array]"] = pe["[object Float64Array]"] = pe["[object Int8Array]"] = pe["[object Int16Array]"] = pe["[object Int32Array]"] = pe["[object Map]"] = pe["[object Number]"] = pe[de] = pe["[object RegExp]"] = pe["[object Set]"] = pe["[object String]"] = pe["[object Symbol]"] = pe["[object Uint8Array]"] = pe["[object Uint8ClampedArray]"] = pe["[object Uint16Array]"] = pe["[object Uint32Array]"] = !0,
        pe["[object Error]"] = pe[he] = pe["[object WeakMap]"] = !1;
        const fe = function e(t, n, a, o, u, d) {
            var p, f = 1 & n, A = 2 & n, g = 4 & n;
            if (a && (p = u ? a(t, o, u, d) : a(t)),
            void 0 !== p)
                return p;
            if (!(0,
            h.A)(t))
                return t;
            var y = (0,
            $.A)(t);
            if (y) {
                if (p = O(t),
                !f)
                    return C(t, p)
            } else {
                var x = (0,
                F.A)(t)
                  , _ = x == he || "[object GeneratorFunction]" == x;
                if ((0,
                ee.A)(t))
                    return w(t, f);
                if (x == de || x == ue || _ && !u) {
                    if (p = A || _ ? {} : Z(t),
                    !f)
                        return A ? D(t, v(p, t)) : S(t, c(p, t))
                } else {
                    if (!pe[x])
                        return u ? t : {};
                    p = X(t, x, f)
                }
            }
            d || (d = new i.A);
            var b = d.get(t);
            if (b)
                return b;
            d.set(t, p),
            ce(t) ? t.forEach((function(i) {
                p.add(e(i, n, a, i, t, d))
            }
            )) : ae(t) && t.forEach((function(i, r) {
                p.set(r, e(i, n, a, r, t, d))
            }
            ));
            var E = g ? A ? U : P.A : A ? m : l.A
              , I = y ? void 0 : E(t);
            return r(I || t, (function(i, r) {
                I && (i = t[r = i]),
                (0,
                s.A)(p, r, e(i, n, a, r, t, d))
            }
            )),
            p
        };
        const Ae = function(e) {
            return fe(e, 5)
        }
    }
    ,
    7028: (e, t, n) => {
        "use strict";
        n.d(t, {
            A: () => c
        });
        var i = n(7942)
          , r = n(9600);
        const s = function() {
            return r.A.Date.now()
        };
        var a = n(3558)
          , o = Math.max
          , l = Math.min;
        const c = function(e, t, n) {
            var r, c, u, h, d, p, f = 0, A = !1, g = !1, m = !0;
            if ("function" != typeof e)
                throw new TypeError("Expected a function");
            function v(t) {
                var n = r
                  , i = c;
                return r = c = void 0,
                f = t,
                h = e.apply(i, n)
            }
            function y(e) {
                var n = e - p;
                return void 0 === p || n >= t || n < 0 || g && e - f >= u
            }
            function x() {
                var e = s();
                if (y(e))
                    return _(e);
                d = setTimeout(x, function(e) {
                    var n = t - (e - p);
                    return g ? l(n, u - (e - f)) : n
                }(e))
            }
            function _(e) {
                return d = void 0,
                m && r ? v(e) : (r = c = void 0,
                h)
            }
            function b() {
                var e = s()
                  , n = y(e);
                if (r = arguments,
                c = this,
                p = e,
                n) {
                    if (void 0 === d)
                        return function(e) {
                            return f = e,
                            d = setTimeout(x, t),
                            A ? v(e) : h
                        }(p);
                    if (g)
                        return clearTimeout(d),
                        d = setTimeout(x, t),
                        v(p)
                }
                return void 0 === d && (d = setTimeout(x, t)),
                h
            }
            return t = (0,
            a.A)(t) || 0,
            (0,
            i.A)(n) && (A = !!n.leading,
            u = (g = "maxWait"in n) ? o((0,
            a.A)(n.maxWait) || 0, t) : u,
            m = "trailing"in n ? !!n.trailing : m),
            b.cancel = function() {
                void 0 !== d && clearTimeout(d),
                f = 0,
                r = p = c = d = void 0
            }
            ,
            b.flush = function() {
                return void 0 === d ? h : _(s())
            }
            ,
            b
        }
    }
    ,
    8748: (e, t, n) => {
        "use strict";
        n.d(t, {
            A: () => c
        });
        var i = n(4044)
          , r = n(7313);
        const s = function(e) {
            return (0,
            r.A)(e) && "[object Arguments]" == (0,
            i.A)(e)
        };
        var a = Object.prototype
          , o = a.hasOwnProperty
          , l = a.propertyIsEnumerable;
        const c = s(function() {
            return arguments
        }()) ? s : function(e) {
            return (0,
            r.A)(e) && o.call(e, "callee") && !l.call(e, "callee")
        }
    }
    ,
    1475: (e, t, n) => {
        "use strict";
        n.d(t, {
            A: () => s
        });
        var i = n(405)
          , r = n(7893);
        const s = function(e) {
            return null != e && (0,
            r.A)(e.length) && !(0,
            i.A)(e)
        }
    }
    ,
    4517: (e, t, n) => {
        "use strict";
        n.d(t, {
            A: () => l
        });
        var i = n(9600);
        const r = function() {
            return !1
        };
        var s = "object" == typeof exports && exports && !exports.nodeType && exports
          , a = s && "object" == typeof module && module && !module.nodeType && module
          , o = a && a.exports === s ? i.A.Buffer : void 0;
        const l = (o ? o.isBuffer : void 0) || r
    }
    ,
    2853: (e, t, n) => {
        "use strict";
        n.d(t, {
            A: () => r
        });
        var i = n(1730);
        const r = function(e, t) {
            return (0,
            i.A)(e, t)
        }
    }
    ,
    2727: (e, t, n) => {
        "use strict";
        n.d(t, {
            A: () => r
        });
        var i = n(684);
        const r = function(e) {
            return "number" == typeof e && e == (0,
            i.A)(e)
        }
    }
    ,
    7893: (e, t, n) => {
        "use strict";
        n.d(t, {
            A: () => i
        });
        const i = function(e) {
            return "number" == typeof e && e > -1 && e % 1 == 0 && e <= 9007199254740991
        }
    }
    ,
    8938: (e, t, n) => {
        "use strict";
        n.d(t, {
            A: () => h
        });
        var i = n(4044)
          , r = n(4878)
          , s = n(7313)
          , a = Function.prototype
          , o = Object.prototype
          , l = a.toString
          , c = o.hasOwnProperty
          , u = l.call(Object);
        const h = function(e) {
            if (!(0,
            s.A)(e) || "[object Object]" != (0,
            i.A)(e))
                return !1;
            var t = (0,
            r.A)(e);
            if (null === t)
                return !0;
            var n = c.call(t, "constructor") && t.constructor;
            return "function" == typeof n && n instanceof n && l.call(n) == u
        }
    }
    ,
    2888: (e, t, n) => {
        "use strict";
        n.d(t, {
            A: () => h
        });
        var i = n(4044)
          , r = n(7893)
          , s = n(7313)
          , a = {};
        a["[object Float32Array]"] = a["[object Float64Array]"] = a["[object Int8Array]"] = a["[object Int16Array]"] = a["[object Int32Array]"] = a["[object Uint8Array]"] = a["[object Uint8ClampedArray]"] = a["[object Uint16Array]"] = a["[object Uint32Array]"] = !0,
        a["[object Arguments]"] = a["[object Array]"] = a["[object ArrayBuffer]"] = a["[object Boolean]"] = a["[object DataView]"] = a["[object Date]"] = a["[object Error]"] = a["[object Function]"] = a["[object Map]"] = a["[object Number]"] = a["[object Object]"] = a["[object RegExp]"] = a["[object Set]"] = a["[object String]"] = a["[object WeakMap]"] = !1;
        const o = function(e) {
            return (0,
            s.A)(e) && (0,
            r.A)(e.length) && !!a[(0,
            i.A)(e)]
        };
        var l = n(8126)
          , c = n(248)
          , u = c.A && c.A.isTypedArray;
        const h = u ? (0,
        l.A)(u) : o
    }
    ,
    8964: (e, t, n) => {
        "use strict";
        n.d(t, {
            A: () => c
        });
        var i = n(7252)
          , r = n(1140);
        const s = (0,
        n(7244).A)(Object.keys, Object);
        var a = Object.prototype.hasOwnProperty;
        const o = function(e) {
            if (!(0,
            r.A)(e))
                return s(e);
            var t = [];
            for (var n in Object(e))
                a.call(e, n) && "constructor" != n && t.push(n);
            return t
        };
        var l = n(1475);
        const c = function(e) {
            return (0,
            l.A)(e) ? (0,
            i.A)(e) : o(e)
        }
    }
    ,
    4441: (e, t, n) => {
        "use strict";
        n.d(t, {
            A: () => i
        });
        const i = function(e) {
            var t = null == e ? 0 : e.length;
            return t ? e[t - 1] : void 0
        }
    }
    ,
    2854: (e, t, n) => {
        "use strict";
        n.d(t, {
            A: () => P
        });
        var i = n(9465);
        const r = function(e) {
            return function(t, n, i) {
                for (var r = -1, s = Object(t), a = i(t), o = a.length; o--; ) {
                    var l = a[e ? o : ++r];
                    if (!1 === n(s[l], l, s))
                        break
                }
                return t
            }
        }();
        var s = n(8964);
        const a = function(e, t) {
            return e && r(e, t, s.A)
        };
        var o = n(6781)
          , l = n(1730);
        const c = function(e, t, n, i) {
            var r = n.length
              , s = r
              , a = !i;
            if (null == e)
                return !s;
            for (e = Object(e); r--; ) {
                var c = n[r];
                if (a && c[2] ? c[1] !== e[c[0]] : !(c[0]in e))
                    return !1
            }
            for (; ++r < s; ) {
                var u = (c = n[r])[0]
                  , h = e[u]
                  , d = c[1];
                if (a && c[2]) {
                    if (void 0 === h && !(u in e))
                        return !1
                } else {
                    var p = new o.A;
                    if (i)
                        var f = i(h, d, u, e, t, p);
                    if (!(void 0 === f ? (0,
                    l.A)(d, h, 3, i, p) : f))
                        return !1
                }
            }
            return !0
        };
        var u = n(7942);
        const h = function(e) {
            return e == e && !(0,
            u.A)(e)
        };
        const d = function(e) {
            for (var t = (0,
            s.A)(e), n = t.length; n--; ) {
                var i = t[n]
                  , r = e[i];
                t[n] = [i, r, h(r)]
            }
            return t
        };
        const p = function(e, t) {
            return function(n) {
                return null != n && (n[e] === t && (void 0 !== t || e in Object(n)))
            }
        };
        const f = function(e) {
            var t = d(e);
            return 1 == t.length && t[0][2] ? p(t[0][0], t[0][1]) : function(n) {
                return n === e || c(n, e, t)
            }
        };
        var A = n(385);
        const g = function(e, t) {
            return null != e && t in Object(e)
        };
        var m = n(9333)
          , v = n(8748)
          , y = n(6956)
          , x = n(5378)
          , _ = n(7893)
          , b = n(9322);
        const E = function(e, t, n) {
            for (var i = -1, r = (t = (0,
            m.A)(t, e)).length, s = !1; ++i < r; ) {
                var a = (0,
                b.A)(t[i]);
                if (!(s = null != e && n(e, a)))
                    break;
                e = e[a]
            }
            return s || ++i != r ? s : !!(r = null == e ? 0 : e.length) && (0,
            _.A)(r) && (0,
            x.A)(a, r) && ((0,
            y.A)(e) || (0,
            v.A)(e))
        };
        const w = function(e, t) {
            return null != e && E(e, t, g)
        };
        var C = n(1677);
        const I = function(e, t) {
            return (0,
            C.A)(e) && h(t) ? p((0,
            b.A)(e), t) : function(n) {
                var i = (0,
                A.A)(n, e);
                return void 0 === i && i === t ? w(n, e) : (0,
                l.A)(t, i, 3)
            }
        };
        const S = function(e) {
            return e
        };
        var M = n(6132)
          , T = n(5841);
        const B = function(e) {
            return function(t) {
                return (0,
                T.A)(t, e)
            }
        };
        const R = function(e) {
            return (0,
            C.A)(e) ? (0,
            M.A)((0,
            b.A)(e)) : B(e)
        };
        const D = function(e) {
            return "function" == typeof e ? e : null == e ? S : "object" == typeof e ? (0,
            y.A)(e) ? I(e[0], e[1]) : f(e) : R(e)
        };
        const P = function(e, t) {
            var n = {};
            return t = D(t, 3),
            a(e, (function(e, r, s) {
                (0,
                i.A)(n, r, t(e, r, s))
            }
            )),
            n
        }
    }
    ,
    4225: (e, t, n) => {
        "use strict";
        n.d(t, {
            A: () => V
        });
        var i = Math.floor;
        const r = function(e, t) {
            var n = "";
            if (!e || t < 1 || t > 9007199254740991)
                return n;
            do {
                t % 2 && (n += e),
                (t = i(t / 2)) && (e += e)
            } while (t);
            return n
        };
        var s = n(817)
          , a = n(8007);
        const o = function(e, t, n) {
            var i = e.length;
            return n = void 0 === n ? i : n,
            !t && n >= i ? e : (0,
            a.A)(e, t, n)
        };
        var l = RegExp("[\\u200d\\ud800-\\udfff\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff\\ufe0e\\ufe0f]");
        const c = function(e) {
            return l.test(e)
        };
        const u = (0,
        n(6132).A)("length");
        var h = "\\ud800-\\udfff"
          , d = "[" + h + "]"
          , p = "[\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff]"
          , f = "\\ud83c[\\udffb-\\udfff]"
          , A = "[^" + h + "]"
          , g = "(?:\\ud83c[\\udde6-\\uddff]){2}"
          , m = "[\\ud800-\\udbff][\\udc00-\\udfff]"
          , v = "(?:" + p + "|" + f + ")" + "?"
          , y = "[\\ufe0e\\ufe0f]?"
          , x = y + v + ("(?:\\u200d(?:" + [A, g, m].join("|") + ")" + y + v + ")*")
          , _ = "(?:" + [A + p + "?", p, g, m, d].join("|") + ")"
          , b = RegExp(f + "(?=" + f + ")|" + _ + x, "g");
        const E = function(e) {
            for (var t = b.lastIndex = 0; b.test(e); )
                ++t;
            return t
        };
        const w = function(e) {
            return c(e) ? E(e) : u(e)
        };
        const C = function(e) {
            return e.split("")
        };
        var I = "\\ud800-\\udfff"
          , S = "[" + I + "]"
          , M = "[\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff]"
          , T = "\\ud83c[\\udffb-\\udfff]"
          , B = "[^" + I + "]"
          , R = "(?:\\ud83c[\\udde6-\\uddff]){2}"
          , D = "[\\ud800-\\udbff][\\udc00-\\udfff]"
          , P = "(?:" + M + "|" + T + ")" + "?"
          , L = "[\\ufe0e\\ufe0f]?"
          , U = L + P + ("(?:\\u200d(?:" + [B, R, D].join("|") + ")" + L + P + ")*")
          , F = "(?:" + [B + M + "?", M, R, D, S].join("|") + ")"
          , N = RegExp(T + "(?=" + T + ")|" + F + U, "g");
        const O = function(e) {
            return e.match(N) || []
        };
        const Q = function(e) {
            return c(e) ? O(e) : C(e)
        };
        var k = Math.ceil;
        const G = function(e, t) {
            var n = (t = void 0 === t ? " " : (0,
            s.A)(t)).length;
            if (n < 2)
                return n ? r(t, e) : t;
            var i = r(t, k(e / w(t)));
            return c(t) ? o(Q(i), 0, e).join("") : i.slice(0, e)
        };
        var H = n(684)
          , z = n(2021);
        const V = function(e, t, n) {
            e = (0,
            z.A)(e);
            var i = (t = (0,
            H.A)(t)) ? w(e) : 0;
            return t && i < t ? G(t - i, n) + e : e
        }
    }
    ,
    6822: (e, t, n) => {
        "use strict";
        n.d(t, {
            A: () => c
        });
        var i = n(6124)
          , r = n(9333)
          , s = n(5378)
          , a = n(7942)
          , o = n(9322);
        const l = function(e, t, n, l) {
            if (!(0,
            a.A)(e))
                return e;
            for (var c = -1, u = (t = (0,
            r.A)(t, e)).length, h = u - 1, d = e; null != d && ++c < u; ) {
                var p = (0,
                o.A)(t[c])
                  , f = n;
                if ("__proto__" === p || "constructor" === p || "prototype" === p)
                    return e;
                if (c != h) {
                    var A = d[p];
                    void 0 === (f = l ? l(A, p, d) : void 0) && (f = (0,
                    a.A)(A) ? A : (0,
                    s.A)(t[c + 1]) ? [] : {})
                }
                (0,
                i.A)(d, p, f),
                d = d[p]
            }
            return e
        };
        const c = function(e, t, n) {
            return null == e ? e : l(e, t, n)
        }
    }
    ,
    1276: (e, t, n) => {
        "use strict";
        n.d(t, {
            A: () => i
        });
        const i = function() {
            return []
        }
    }
    ,
    2777: (e, t, n) => {
        "use strict";
        n.d(t, {
            A: () => s
        });
        var i = n(7028)
          , r = n(7942);
        const s = function(e, t, n) {
            var s = !0
              , a = !0;
            if ("function" != typeof e)
                throw new TypeError("Expected a function");
            return (0,
            r.A)(n) && (s = "leading"in n ? !!n.leading : s,
            a = "trailing"in n ? !!n.trailing : a),
            (0,
            i.A)(e, t, {
                leading: s,
                maxWait: t,
                trailing: a
            })
        }
    }
    ,
    684: (e, t, n) => {
        "use strict";
        n.d(t, {
            A: () => a
        });
        var i = n(3558)
          , r = 1 / 0;
        const s = function(e) {
            return e ? (e = (0,
            i.A)(e)) === r || e === -1 / 0 ? 17976931348623157e292 * (e < 0 ? -1 : 1) : e == e ? e : 0 : 0 === e ? e : 0
        };
        const a = function(e) {
            var t = s(e)
              , n = t % 1;
            return t == t ? n ? t - n : t : 0
        }
    }
    ,
    3558: (e, t, n) => {
        "use strict";
        n.d(t, {
            A: () => p
        });
        var i = /\s/;
        const r = function(e) {
            for (var t = e.length; t-- && i.test(e.charAt(t)); )
                ;
            return t
        };
        var s = /^\s+/;
        const a = function(e) {
            return e ? e.slice(0, r(e) + 1).replace(s, "") : e
        };
        var o = n(7942)
          , l = n(4089)
          , c = /^[-+]0x[0-9a-f]+$/i
          , u = /^0b[01]+$/i
          , h = /^0o[0-7]+$/i
          , d = parseInt;
        const p = function(e) {
            if ("number" == typeof e)
                return e;
            if ((0,
            l.A)(e))
                return NaN;
            if ((0,
            o.A)(e)) {
                var t = "function" == typeof e.valueOf ? e.valueOf() : e;
                e = (0,
                o.A)(t) ? t + "" : t
            }
            if ("string" != typeof e)
                return 0 === e ? e : +e;
            e = a(e);
            var n = u.test(e);
            return n || h.test(e) ? d(e.slice(2), n ? 2 : 8) : c.test(e) ? NaN : +e
        }
    }
    ,
    2190: (e, t, n) => {
        "use strict";
        n.d(t, {
            A: () => u
        });
        var i = n(9333)
          , r = n(4441)
          , s = n(5841)
          , a = n(8007);
        const o = function(e, t) {
            return t.length < 2 ? e : (0,
            s.A)(e, (0,
            a.A)(t, 0, -1))
        };
        var l = n(9322);
        const c = function(e, t) {
            return t = (0,
            i.A)(t, e),
            null == (e = o(e, t)) || delete e[(0,
            l.A)((0,
            r.A)(t))]
        };
        const u = function(e, t) {
            return null == e || c(e, t)
        }
    }
    ,
    7469: (e, t, n) => {
        "use strict";
        n.d(t, {
            AH: () => ue,
            IF: () => g,
            K1: () => Ye,
            LN: () => I,
            Ql: () => he,
            Vu: () => $e,
            Xe: () => et,
            bv: () => q,
            eF: () => ke,
            ei: () => X,
            i: () => Le,
            i4: () => qe,
            jz: () => Ue,
            kt: () => ae,
            lq: () => Y,
            nV: () => h,
            oF: () => o,
            s0: () => A,
            w2: () => Ve
        });
        var i = n(5062)
          , r = .001
          , s = class {
            constructor() {
                this.startTime = performance.now(),
                this.previousTime = 0,
                this.currentTime = 0,
                this._delta = 0,
                this._elapsed = 0,
                this._fixedDelta = 1e3 / 60,
                this.timescale = 1,
                this.useFixedDelta = !1,
                this._autoReset = !1
            }
            get autoReset() {
                return this._autoReset
            }
            set autoReset(e) {
                "undefined" != typeof document && void 0 !== document.hidden && (e ? document.addEventListener("visibilitychange", this) : document.removeEventListener("visibilitychange", this),
                this._autoReset = e)
            }
            get delta() {
                return this._delta * r
            }
            get fixedDelta() {
                return this._fixedDelta * r
            }
            set fixedDelta(e) {
                this._fixedDelta = 1e3 * e
            }
            get elapsed() {
                return this._elapsed * r
            }
            update(e) {
                this.useFixedDelta ? this._delta = this.fixedDelta : (this.previousTime = this.currentTime,
                this.currentTime = (void 0 !== e ? e : performance.now()) - this.startTime,
                this._delta = this.currentTime - this.previousTime),
                this._delta *= this.timescale,
                this._elapsed += this._delta
            }
            reset() {
                this._delta = 0,
                this._elapsed = 0,
                this.currentTime = performance.now() - this.startTime
            }
            getDelta() {
                return this.delta
            }
            getElapsed() {
                return this.elapsed
            }
            handleEvent(e) {
                document.hidden || (this.currentTime = performance.now() - this.startTime)
            }
            dispose() {
                this.autoReset = !1
            }
        }
          , a = ( () => {
            const e = new Float32Array([-1, -1, 0, 3, -1, 0, -1, 3, 0])
              , t = new Float32Array([0, 0, 2, 0, 0, 2])
              , n = new i.LoY;
            return n.setAttribute("position", new i.THS(e,3)),
            n.setAttribute("uv", new i.THS(t,2)),
            n
        }
        )()
          , o = class e {
            static get fullscreenGeometry() {
                return a
            }
            constructor(e="Pass", t=new i.Z58, n=new i.i7d) {
                this.name = e,
                this.renderer = null,
                this.scene = t,
                this.camera = n,
                this.screen = null,
                this.rtt = !0,
                this.needsSwap = !0,
                this.needsDepthTexture = !1,
                this.enabled = !0
            }
            get renderToScreen() {
                return !this.rtt
            }
            set renderToScreen(e) {
                if (this.rtt === e) {
                    const t = this.fullscreenMaterial;
                    null !== t && (t.needsUpdate = !0),
                    this.rtt = !e
                }
            }
            set mainScene(e) {}
            set mainCamera(e) {}
            setRenderer(e) {
                this.renderer = e
            }
            isEnabled() {
                return this.enabled
            }
            setEnabled(e) {
                this.enabled = e
            }
            get fullscreenMaterial() {
                return null !== this.screen ? this.screen.material : null
            }
            set fullscreenMaterial(t) {
                let n = this.screen;
                null !== n ? n.material = t : (n = new i.eaF(e.fullscreenGeometry,t),
                n.frustumCulled = !1,
                null === this.scene && (this.scene = new i.Z58),
                this.scene.add(n),
                this.screen = n)
            }
            getFullscreenMaterial() {
                return this.fullscreenMaterial
            }
            setFullscreenMaterial(e) {
                this.fullscreenMaterial = e
            }
            getDepthTexture() {
                return null
            }
            setDepthTexture(e, t=i.Rkk) {}
            render(e, t, n, i, r) {
                throw new Error("Render method not implemented!")
            }
            setSize(e, t) {}
            initialize(e, t, n) {}
            dispose() {
                for (const t of Object.keys(this)) {
                    const n = this[t];
                    (n instanceof i.nWS || n instanceof i.imn || n instanceof i.gPd || n instanceof e) && this[t].dispose()
                }
                null !== this.fullscreenMaterial && this.fullscreenMaterial.dispose()
            }
        }
          , l = class extends o {
            constructor() {
                super("ClearMaskPass", null, null),
                this.needsSwap = !1
            }
            render(e, t, n, i, r) {
                const s = e.state.buffers.stencil;
                s.setLocked(!1),
                s.setTest(!1)
            }
        }
          , c = "varying vec2 vUv;void main(){vUv=position.xy*0.5+0.5;gl_Position=vec4(position.xy,1.0,1.0);}"
          , u = class extends i.BKk {
            constructor() {
                super({
                    name: "CopyMaterial",
                    uniforms: {
                        inputBuffer: new i.nc$(null),
                        opacity: new i.nc$(1)
                    },
                    blending: i.XIg,
                    toneMapped: !1,
                    depthWrite: !1,
                    depthTest: !1,
                    fragmentShader: "#include <common>\n#include <dithering_pars_fragment>\n#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\nuniform float opacity;varying vec2 vUv;void main(){vec4 texel=texture2D(inputBuffer,vUv);gl_FragColor=opacity*texel;\n#include <colorspace_fragment>\n#include <dithering_fragment>\n}",
                    vertexShader: c
                })
            }
            set inputBuffer(e) {
                this.uniforms.inputBuffer.value = e
            }
            setInputBuffer(e) {
                this.uniforms.inputBuffer.value = e
            }
            getOpacity(e) {
                return this.uniforms.opacity.value
            }
            setOpacity(e) {
                this.uniforms.opacity.value = e
            }
        }
          , h = class extends o {
            constructor(e, t=!0) {
                super("CopyPass"),
                this.fullscreenMaterial = new u,
                this.needsSwap = !1,
                this.renderTarget = e,
                void 0 === e && (this.renderTarget = new i.nWS(1,1,{
                    minFilter: i.k6q,
                    magFilter: i.k6q,
                    stencilBuffer: !1,
                    depthBuffer: !1
                }),
                this.renderTarget.texture.name = "CopyPass.Target"),
                this.autoResize = t
            }
            get resize() {
                return this.autoResize
            }
            set resize(e) {
                this.autoResize = e
            }
            get texture() {
                return this.renderTarget.texture
            }
            getTexture() {
                return this.renderTarget.texture
            }
            setAutoResizeEnabled(e) {
                this.autoResize = e
            }
            render(e, t, n, i, r) {
                this.fullscreenMaterial.inputBuffer = t.texture,
                e.setRenderTarget(this.renderToScreen ? null : this.renderTarget),
                e.render(this.scene, this.camera)
            }
            setSize(e, t) {
                this.autoResize && this.renderTarget.setSize(e, t)
            }
            initialize(e, t, n) {
                void 0 !== n && (this.renderTarget.texture.type = n,
                n !== i.OUM ? this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1" : null !== e && e.outputColorSpace === i.er$ && (this.renderTarget.texture.colorSpace = i.er$))
            }
        }
          , d = new i.Q1f
          , p = class extends o {
            constructor(e=!0, t=!0, n=!1) {
                super("ClearPass", null, null),
                this.needsSwap = !1,
                this.color = e,
                this.depth = t,
                this.stencil = n,
                this.overrideClearColor = null,
                this.overrideClearAlpha = -1
            }
            setClearFlags(e, t, n) {
                this.color = e,
                this.depth = t,
                this.stencil = n
            }
            getOverrideClearColor() {
                return this.overrideClearColor
            }
            setOverrideClearColor(e) {
                this.overrideClearColor = e
            }
            getOverrideClearAlpha() {
                return this.overrideClearAlpha
            }
            setOverrideClearAlpha(e) {
                this.overrideClearAlpha = e
            }
            render(e, t, n, i, r) {
                const s = this.overrideClearColor
                  , a = this.overrideClearAlpha
                  , o = e.getClearAlpha()
                  , l = null !== s
                  , c = a >= 0;
                l ? (e.getClearColor(d),
                e.setClearColor(s, c ? a : o)) : c && e.setClearAlpha(a),
                e.setRenderTarget(this.renderToScreen ? null : t),
                e.clear(this.color, this.depth, this.stencil),
                l ? e.setClearColor(d, o) : c && e.setClearAlpha(o)
            }
        }
          , f = class extends o {
            constructor(e, t) {
                super("MaskPass", e, t),
                this.needsSwap = !1,
                this.clearPass = new p(!1,!1,!0),
                this.inverse = !1
            }
            set mainScene(e) {
                this.scene = e
            }
            set mainCamera(e) {
                this.camera = e
            }
            get inverted() {
                return this.inverse
            }
            set inverted(e) {
                this.inverse = e
            }
            get clear() {
                return this.clearPass.enabled
            }
            set clear(e) {
                this.clearPass.enabled = e
            }
            getClearPass() {
                return this.clearPass
            }
            isInverted() {
                return this.inverted
            }
            setInverted(e) {
                this.inverted = e
            }
            render(e, t, n, i, r) {
                const s = e.getContext()
                  , a = e.state.buffers
                  , o = this.scene
                  , l = this.camera
                  , c = this.clearPass
                  , u = this.inverted ? 0 : 1
                  , h = 1 - u;
                a.color.setMask(!1),
                a.depth.setMask(!1),
                a.color.setLocked(!0),
                a.depth.setLocked(!0),
                a.stencil.setTest(!0),
                a.stencil.setOp(s.REPLACE, s.REPLACE, s.REPLACE),
                a.stencil.setFunc(s.ALWAYS, u, 4294967295),
                a.stencil.setClear(h),
                a.stencil.setLocked(!0),
                this.clearPass.enabled && (this.renderToScreen ? c.render(e, null) : (c.render(e, t),
                c.render(e, n))),
                this.renderToScreen ? (e.setRenderTarget(null),
                e.render(o, l)) : (e.setRenderTarget(t),
                e.render(o, l),
                e.setRenderTarget(n),
                e.render(o, l)),
                a.color.setLocked(!1),
                a.depth.setLocked(!1),
                a.stencil.setLocked(!1),
                a.stencil.setFunc(s.EQUAL, 1, 4294967295),
                a.stencil.setOp(s.KEEP, s.KEEP, s.KEEP),
                a.stencil.setLocked(!0)
            }
        }
          , A = class {
            constructor(e=null, {depthBuffer: t=!0, stencilBuffer: n=!1, multisampling: i=0, frameBufferType: r}={}) {
                this.renderer = null,
                this.inputBuffer = this.createBuffer(t, n, r, i),
                this.outputBuffer = this.inputBuffer.clone(),
                this.copyPass = new h,
                this.depthTexture = null,
                this.passes = [],
                this.timer = new s,
                this.autoRenderToScreen = !0,
                this.setRenderer(e)
            }
            get multisampling() {
                return this.inputBuffer.samples || 0
            }
            set multisampling(e) {
                const t = this.inputBuffer
                  , n = this.multisampling;
                n > 0 && e > 0 ? (this.inputBuffer.samples = e,
                this.outputBuffer.samples = e,
                this.inputBuffer.dispose(),
                this.outputBuffer.dispose()) : n !== e && (this.inputBuffer.dispose(),
                this.outputBuffer.dispose(),
                this.inputBuffer = this.createBuffer(t.depthBuffer, t.stencilBuffer, t.texture.type, e),
                this.inputBuffer.depthTexture = this.depthTexture,
                this.outputBuffer = this.inputBuffer.clone())
            }
            getTimer() {
                return this.timer
            }
            getRenderer() {
                return this.renderer
            }
            setRenderer(e) {
                if (this.renderer = e,
                null !== e) {
                    const t = e.getSize(new i.I9Y)
                      , n = e.getContext().getContextAttributes().alpha
                      , r = this.inputBuffer.texture.type;
                    r === i.OUM && e.outputColorSpace === i.er$ && (this.inputBuffer.texture.colorSpace = i.er$,
                    this.outputBuffer.texture.colorSpace = i.er$,
                    this.inputBuffer.dispose(),
                    this.outputBuffer.dispose()),
                    e.autoClear = !1,
                    this.setSize(t.width, t.height);
                    for (const t of this.passes)
                        t.initialize(e, n, r)
                }
            }
            replaceRenderer(e, t=!0) {
                const n = this.renderer
                  , i = n.domElement.parentNode;
                return this.setRenderer(e),
                t && null !== i && (i.removeChild(n.domElement),
                i.appendChild(e.domElement)),
                n
            }
            createDepthTexture() {
                const e = this.depthTexture = new i.VCu;
                return this.inputBuffer.depthTexture = e,
                this.inputBuffer.dispose(),
                this.inputBuffer.stencilBuffer ? (e.format = i.dcC,
                e.type = i.V3x) : e.type = i.bkx,
                e
            }
            deleteDepthTexture() {
                if (null !== this.depthTexture) {
                    this.depthTexture.dispose(),
                    this.depthTexture = null,
                    this.inputBuffer.depthTexture = null,
                    this.inputBuffer.dispose();
                    for (const e of this.passes)
                        e.setDepthTexture(null)
                }
            }
            createBuffer(e, t, n, r) {
                const s = this.renderer
                  , a = null === s ? new i.I9Y : s.getDrawingBufferSize(new i.I9Y)
                  , o = {
                    minFilter: i.k6q,
                    magFilter: i.k6q,
                    stencilBuffer: t,
                    depthBuffer: e,
                    type: n
                }
                  , l = new i.nWS(a.width,a.height,o);
                return r > 0 && (l.ignoreDepthForMultisampleCopy = !1,
                l.samples = r),
                n === i.OUM && null !== s && s.outputColorSpace === i.er$ && (l.texture.colorSpace = i.er$),
                l.texture.name = "EffectComposer.Buffer",
                l.texture.generateMipmaps = !1,
                l
            }
            setMainScene(e) {
                for (const t of this.passes)
                    t.mainScene = e
            }
            setMainCamera(e) {
                for (const t of this.passes)
                    t.mainCamera = e
            }
            addPass(e, t) {
                const n = this.passes
                  , r = this.renderer
                  , s = r.getDrawingBufferSize(new i.I9Y)
                  , a = r.getContext().getContextAttributes().alpha
                  , o = this.inputBuffer.texture.type;
                if (e.setRenderer(r),
                e.setSize(s.width, s.height),
                e.initialize(r, a, o),
                this.autoRenderToScreen && (n.length > 0 && (n[n.length - 1].renderToScreen = !1),
                e.renderToScreen && (this.autoRenderToScreen = !1)),
                void 0 !== t ? n.splice(t, 0, e) : n.push(e),
                this.autoRenderToScreen && (n[n.length - 1].renderToScreen = !0),
                e.needsDepthTexture || null !== this.depthTexture)
                    if (null === this.depthTexture) {
                        const t = this.createDepthTexture();
                        for (e of n)
                            e.setDepthTexture(t)
                    } else
                        e.setDepthTexture(this.depthTexture)
            }
            removePass(e) {
                const t = this.passes
                  , n = t.indexOf(e);
                if (-1 !== n && t.splice(n, 1).length > 0) {
                    if (null !== this.depthTexture) {
                        const n = (e, t) => e || t.needsDepthTexture;
                        t.reduce(n, !1) || (e.getDepthTexture() === this.depthTexture && e.setDepthTexture(null),
                        this.deleteDepthTexture())
                    }
                    this.autoRenderToScreen && n === t.length && (e.renderToScreen = !1,
                    t.length > 0 && (t[t.length - 1].renderToScreen = !0))
                }
            }
            removeAllPasses() {
                const e = this.passes;
                this.deleteDepthTexture(),
                e.length > 0 && (this.autoRenderToScreen && (e[e.length - 1].renderToScreen = !1),
                this.passes = [])
            }
            render(e) {
                const t = this.renderer
                  , n = this.copyPass;
                let i, r, s, a = this.inputBuffer, o = this.outputBuffer, c = !1;
                void 0 === e && (this.timer.update(),
                e = this.timer.getDelta());
                for (const u of this.passes)
                    u.enabled && (u.render(t, a, o, e, c),
                    u.needsSwap && (c && (n.renderToScreen = u.renderToScreen,
                    i = t.getContext(),
                    r = t.state.buffers.stencil,
                    r.setFunc(i.NOTEQUAL, 1, 4294967295),
                    n.render(t, a, o, e, c),
                    r.setFunc(i.EQUAL, 1, 4294967295)),
                    s = a,
                    a = o,
                    o = s),
                    u instanceof f ? c = !0 : u instanceof l && (c = !1))
            }
            setSize(e, t, n) {
                const r = this.renderer
                  , s = r.getSize(new i.I9Y);
                void 0 !== e && void 0 !== t || (e = s.width,
                t = s.height),
                s.width === e && s.height === t || r.setSize(e, t, n);
                const a = r.getDrawingBufferSize(new i.I9Y);
                this.inputBuffer.setSize(a.width, a.height),
                this.outputBuffer.setSize(a.width, a.height);
                for (const e of this.passes)
                    e.setSize(a.width, a.height)
            }
            reset() {
                this.dispose(),
                this.autoRenderToScreen = !0
            }
            dispose() {
                for (const e of this.passes)
                    e.dispose();
                this.passes = [],
                null !== this.inputBuffer && this.inputBuffer.dispose(),
                null !== this.outputBuffer && this.outputBuffer.dispose(),
                this.deleteDepthTexture(),
                this.copyPass.dispose(),
                this.timer.dispose(),
                o.fullscreenGeometry.dispose()
            }
        }
          , g = {
            NONE: 0,
            DEPTH: 1,
            CONVOLUTION: 2
        }
          , m = {
            FRAGMENT_HEAD: "FRAGMENT_HEAD",
            FRAGMENT_MAIN_UV: "FRAGMENT_MAIN_UV",
            FRAGMENT_MAIN_IMAGE: "FRAGMENT_MAIN_IMAGE",
            VERTEX_HEAD: "VERTEX_HEAD",
            VERTEX_MAIN_SUPPORT: "VERTEX_MAIN_SUPPORT"
        }
          , v = class {
            constructor() {
                this.shaderParts = new Map([[m.FRAGMENT_HEAD, null], [m.FRAGMENT_MAIN_UV, null], [m.FRAGMENT_MAIN_IMAGE, null], [m.VERTEX_HEAD, null], [m.VERTEX_MAIN_SUPPORT, null]]),
                this.defines = new Map,
                this.uniforms = new Map,
                this.blendModes = new Map,
                this.extensions = new Set,
                this.attributes = g.NONE,
                this.varyings = new Set,
                this.uvTransformation = !1,
                this.readDepth = !1,
                this.colorSpace = i.Zr2
            }
        }
        ;
        function y(e) {
            let t;
            if (0 === e)
                t = new Float64Array(0);
            else if (1 === e)
                t = new Float64Array([1]);
            else if (e > 1) {
                let n = new Float64Array(e)
                  , i = new Float64Array(e);
                for (let r = 1; r <= e; ++r) {
                    for (let e = 0; e < r; ++e)
                        i[e] = 0 === e || e === r - 1 ? 1 : n[e - 1] + n[e];
                    t = i,
                    i = n,
                    n = t
                }
            }
            return t
        }
        var x = class {
            constructor(e, t=2) {
                this.weights = null,
                this.offsets = null,
                this.linearWeights = null,
                this.linearOffsets = null,
                this.generate(e, t)
            }
            get steps() {
                return null === this.offsets ? 0 : this.offsets.length
            }
            get linearSteps() {
                return null === this.linearOffsets ? 0 : this.linearOffsets.length
            }
            generate(e, t) {
                if (e < 3 || e > 1020)
                    throw new Error("The kernel size must be in the range [3, 1020]");
                const n = e + 2 * t
                  , i = t > 0 ? y(n).slice(t, -t) : y(n)
                  , r = Math.floor((i.length - 1) / 2)
                  , s = i.reduce(( (e, t) => e + t), 0)
                  , a = i.slice(r)
                  , o = [...Array(r + 1).keys()]
                  , l = new Float64Array(Math.floor(o.length / 2))
                  , c = new Float64Array(l.length);
                l[0] = a[0] / s;
                for (let e = 1, t = 1, n = o.length - 1; e < n; e += 2,
                ++t) {
                    const n = o[e]
                      , i = o[e + 1]
                      , r = a[e]
                      , u = a[e + 1]
                      , h = r + u
                      , d = (n * r + i * u) / h;
                    l[t] = h / s,
                    c[t] = d
                }
                for (let e = 0, t = a.length, n = 1 / s; e < t; ++e)
                    a[e] *= n;
                const u = 2 * (l.reduce(( (e, t) => e + t), 0) - .5 * l[0]);
                if (0 !== u)
                    for (let e = 0, t = l.length, n = 1 / u; e < t; ++e)
                        l[e] *= n;
                this.offsets = o,
                this.weights = a,
                this.linearOffsets = c,
                this.linearWeights = l
            }
        }
          , _ = !1
          , b = class {
            constructor(e=null) {
                this.originalMaterials = new Map,
                this.material = null,
                this.materials = null,
                this.materialsBackSide = null,
                this.materialsDoubleSide = null,
                this.materialsFlatShaded = null,
                this.materialsFlatShadedBackSide = null,
                this.materialsFlatShadedDoubleSide = null,
                this.setMaterial(e),
                this.meshCount = 0,
                this.replaceMaterial = e => {
                    if (e.isMesh) {
                        let t;
                        if (e.material.flatShading)
                            switch (e.material.side) {
                            case i.$EB:
                                t = this.materialsFlatShadedDoubleSide;
                                break;
                            case i.hsX:
                                t = this.materialsFlatShadedBackSide;
                                break;
                            default:
                                t = this.materialsFlatShaded
                            }
                        else
                            switch (e.material.side) {
                            case i.$EB:
                                t = this.materialsDoubleSide;
                                break;
                            case i.hsX:
                                t = this.materialsBackSide;
                                break;
                            default:
                                t = this.materials
                            }
                        this.originalMaterials.set(e, e.material),
                        e.isSkinnedMesh ? e.material = t[2] : e.isInstancedMesh ? e.material = t[1] : e.material = t[0],
                        ++this.meshCount
                    }
                }
            }
            cloneMaterial(e) {
                if (!(e instanceof i.BKk))
                    return e.clone();
                const t = e.uniforms
                  , n = new Map;
                for (const e in t) {
                    const i = t[e].value;
                    i.isRenderTargetTexture && (t[e].value = null,
                    n.set(e, i))
                }
                const r = e.clone();
                for (const e of n)
                    t[e[0]].value = e[1],
                    r.uniforms[e[0]].value = e[1];
                return r
            }
            setMaterial(e) {
                if (this.disposeMaterials(),
                this.material = e,
                null !== e) {
                    const t = this.materials = [this.cloneMaterial(e), this.cloneMaterial(e), this.cloneMaterial(e)];
                    for (const n of t)
                        n.uniforms = Object.assign({}, e.uniforms),
                        n.side = i.hB5;
                    t[2].skinning = !0,
                    this.materialsBackSide = t.map((t => {
                        const n = this.cloneMaterial(t);
                        return n.uniforms = Object.assign({}, e.uniforms),
                        n.side = i.hsX,
                        n
                    }
                    )),
                    this.materialsDoubleSide = t.map((t => {
                        const n = this.cloneMaterial(t);
                        return n.uniforms = Object.assign({}, e.uniforms),
                        n.side = i.$EB,
                        n
                    }
                    )),
                    this.materialsFlatShaded = t.map((t => {
                        const n = this.cloneMaterial(t);
                        return n.uniforms = Object.assign({}, e.uniforms),
                        n.flatShading = !0,
                        n
                    }
                    )),
                    this.materialsFlatShadedBackSide = t.map((t => {
                        const n = this.cloneMaterial(t);
                        return n.uniforms = Object.assign({}, e.uniforms),
                        n.flatShading = !0,
                        n.side = i.hsX,
                        n
                    }
                    )),
                    this.materialsFlatShadedDoubleSide = t.map((t => {
                        const n = this.cloneMaterial(t);
                        return n.uniforms = Object.assign({}, e.uniforms),
                        n.flatShading = !0,
                        n.side = i.$EB,
                        n
                    }
                    ))
                }
            }
            render(e, t, n) {
                const i = e.shadowMap.enabled;
                if (e.shadowMap.enabled = !1,
                _) {
                    const i = this.originalMaterials;
                    this.meshCount = 0,
                    t.traverse(this.replaceMaterial),
                    e.render(t, n);
                    for (const e of i)
                        e[0].material = e[1];
                    this.meshCount !== i.size && i.clear()
                } else {
                    const i = t.overrideMaterial;
                    t.overrideMaterial = this.material,
                    e.render(t, n),
                    t.overrideMaterial = i
                }
                e.shadowMap.enabled = i
            }
            disposeMaterials() {
                if (null !== this.material) {
                    const e = this.materials.concat(this.materialsBackSide).concat(this.materialsDoubleSide).concat(this.materialsFlatShaded).concat(this.materialsFlatShadedBackSide).concat(this.materialsFlatShadedDoubleSide);
                    for (const t of e)
                        t.dispose()
                }
            }
            dispose() {
                this.originalMaterials.clear(),
                this.disposeMaterials()
            }
            static get workaroundEnabled() {
                return _
            }
            static set workaroundEnabled(e) {
                _ = e
            }
        }
          , E = -1
          , w = class extends i.Qev {
            constructor(e, t=-1, n=-1, r=1) {
                super(),
                this.resizable = e,
                this.baseSize = new i.I9Y(1,1),
                this.preferredSize = new i.I9Y(t,n),
                this.target = this.preferredSize,
                this.s = r,
                this.effectiveSize = new i.I9Y,
                this.addEventListener("change", ( () => this.updateEffectiveSize())),
                this.updateEffectiveSize()
            }
            updateEffectiveSize() {
                const e = this.baseSize
                  , t = this.preferredSize
                  , n = this.effectiveSize
                  , i = this.scale;
                t.width !== E ? n.width = t.width : t.height !== E ? n.width = Math.round(t.height * (e.width / Math.max(e.height, 1))) : n.width = Math.round(e.width * i),
                t.height !== E ? n.height = t.height : t.width !== E ? n.height = Math.round(t.width / Math.max(e.width / Math.max(e.height, 1), 1)) : n.height = Math.round(e.height * i)
            }
            get width() {
                return this.effectiveSize.width
            }
            set width(e) {
                this.preferredWidth = e
            }
            get height() {
                return this.effectiveSize.height
            }
            set height(e) {
                this.preferredHeight = e
            }
            getWidth() {
                return this.width
            }
            getHeight() {
                return this.height
            }
            get scale() {
                return this.s
            }
            set scale(e) {
                this.s !== e && (this.s = e,
                this.preferredSize.setScalar(E),
                this.dispatchEvent({
                    type: "change"
                }),
                this.resizable.setSize(this.baseSize.width, this.baseSize.height))
            }
            getScale() {
                return this.scale
            }
            setScale(e) {
                this.scale = e
            }
            get baseWidth() {
                return this.baseSize.width
            }
            set baseWidth(e) {
                this.baseSize.width !== e && (this.baseSize.width = e,
                this.dispatchEvent({
                    type: "change"
                }),
                this.resizable.setSize(this.baseSize.width, this.baseSize.height))
            }
            getBaseWidth() {
                return this.baseWidth
            }
            setBaseWidth(e) {
                this.baseWidth = e
            }
            get baseHeight() {
                return this.baseSize.height
            }
            set baseHeight(e) {
                this.baseSize.height !== e && (this.baseSize.height = e,
                this.dispatchEvent({
                    type: "change"
                }),
                this.resizable.setSize(this.baseSize.width, this.baseSize.height))
            }
            getBaseHeight() {
                return this.baseHeight
            }
            setBaseHeight(e) {
                this.baseHeight = e
            }
            setBaseSize(e, t) {
                this.baseSize.width === e && this.baseSize.height === t || (this.baseSize.set(e, t),
                this.dispatchEvent({
                    type: "change"
                }),
                this.resizable.setSize(this.baseSize.width, this.baseSize.height))
            }
            get preferredWidth() {
                return this.preferredSize.width
            }
            set preferredWidth(e) {
                this.preferredSize.width !== e && (this.preferredSize.width = e,
                this.dispatchEvent({
                    type: "change"
                }),
                this.resizable.setSize(this.baseSize.width, this.baseSize.height))
            }
            getPreferredWidth() {
                return this.preferredWidth
            }
            setPreferredWidth(e) {
                this.preferredWidth = e
            }
            get preferredHeight() {
                return this.preferredSize.height
            }
            set preferredHeight(e) {
                this.preferredSize.height !== e && (this.preferredSize.height = e,
                this.dispatchEvent({
                    type: "change"
                }),
                this.resizable.setSize(this.baseSize.width, this.baseSize.height))
            }
            getPreferredHeight() {
                return this.preferredHeight
            }
            setPreferredHeight(e) {
                this.preferredHeight = e
            }
            setPreferredSize(e, t) {
                this.preferredSize.width === e && this.preferredSize.height === t || (this.preferredSize.set(e, t),
                this.dispatchEvent({
                    type: "change"
                }),
                this.resizable.setSize(this.baseSize.width, this.baseSize.height))
            }
            copy(e) {
                this.s = e.scale,
                this.baseSize.set(e.baseWidth, e.baseHeight),
                this.preferredSize.set(e.preferredWidth, e.preferredHeight),
                this.dispatchEvent({
                    type: "change"
                }),
                this.resizable.setSize(this.baseSize.width, this.baseSize.height)
            }
            static get AUTO_SIZE() {
                return E
            }
        }
          , C = new class {
            constructor(e=0) {
                this.nextId = e
            }
            getNextId() {
                return this.nextId++
            }
            reset(e=0) {
                return this.nextId = e,
                this
            }
        }
        (2)
          , I = class extends Set {
            constructor(e, t=C.getNextId()) {
                super(),
                this.exclusive = !1,
                this._layer = t,
                (this._layer < 1 || this._layer > 31) && (console.warn("Layer out of range, resetting to 2"),
                C.reset(2),
                this._layer = C.getNextId()),
                void 0 !== e && this.set(e)
            }
            get layer() {
                return this._layer
            }
            set layer(e) {
                const t = this._layer;
                for (const n of this)
                    n.layers.disable(t),
                    n.layers.enable(e);
                this._layer = e
            }
            getLayer() {
                return this.layer
            }
            setLayer(e) {
                this.layer = e
            }
            isExclusive() {
                return this.exclusive
            }
            setExclusive(e) {
                this.exclusive = e
            }
            clear() {
                const e = this.layer;
                for (const t of this)
                    t.layers.disable(e);
                return super.clear()
            }
            set(e) {
                this.clear();
                for (const t of e)
                    this.add(t);
                return this
            }
            indexOf(e) {
                return this.has(e) ? 0 : -1
            }
            add(e) {
                return this.exclusive ? e.layers.set(this.layer) : e.layers.enable(this.layer),
                super.add(e)
            }
            delete(e) {
                return this.has(e) && e.layers.disable(this.layer),
                super.delete(e)
            }
            toggle(e) {
                let t;
                return this.has(e) ? (this.delete(e),
                t = !1) : (this.add(e),
                t = !0),
                t
            }
            setVisible(e) {
                for (const t of this)
                    e ? t.layers.enable(0) : t.layers.disable(0);
                return this
            }
        }
          , S = 1
          , M = 9
          , T = 21
          , B = 23
          , R = 24
          , D = 28
          , P = 30
          , L = new Map([[0, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,x+y,opacity);}"], [S, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,y,min(y.a,opacity));}"], [2, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,(x+y)*0.5,opacity);}"], [3, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(yHSL.rg,xHSL.b));return vec4(mix(x.rgb,z,opacity),y.a);}"], [4, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=mix(step(0.0,y)*(1.0-min(vec4(1.0),(1.0-x)/y)),vec4(1.0),step(1.0,x));return mix(x,z,opacity);}"], [5, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=step(0.0,x)*mix(min(vec4(1.0),x/max(1.0-y,1e-9)),vec4(1.0),step(1.0,y));return mix(x,z,opacity);}"], [6, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,min(x,y),opacity);}"], [7, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,abs(x-y),opacity);}"], [8, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,x/max(y,1e-12),opacity);}"], [M, null], [10, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,(x+y-2.0*x*y),opacity);}"], [11, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 a=min(x,1.0),b=min(y,1.0);vec4 z=mix(2.0*a*b,1.0-2.0*(1.0-a)*(1.0-b),step(0.5,y));return mix(x,z,opacity);}"], [12, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,step(1.0,x+y),opacity);}"], [13, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(yHSL.r,xHSL.gb));return vec4(mix(x.rgb,z,opacity),y.a);}"], [14, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,1.0-y,opacity);}"], [15, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,y*(1.0-x),opacity);}"], [16, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,max(x,y),opacity);}"], [17, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,clamp(y+x-1.0,0.0,1.0),opacity);}"], [18, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,min(x+y,1.0),opacity);}"], [19, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,clamp(2.0*y+x-1.0,0.0,1.0),opacity);}"], [20, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(xHSL.rg,yHSL.b));return vec4(mix(x.rgb,z,opacity),y.a);}"], [T, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,x*y,opacity);}"], [22, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,1.0-abs(1.0-x-y),opacity);}"], [B, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,y,opacity);}"], [R, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=mix(2.0*y*x,1.0-2.0*(1.0-y)*(1.0-x),step(0.5,x));return mix(x,z,opacity);}"], [25, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 y2=2.0*y;vec4 z=mix(mix(y2,x,step(0.5*x,y)),max(vec4(0.0),y2-1.0),step(x,(y2-1.0)));return mix(x,z,opacity);}"], [26, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=mix(min(x*x/max(1.0-y,1e-12),1.0),y,step(1.0,y));return mix(x,z,opacity);}"], [27, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(xHSL.r,yHSL.g,xHSL.b));return vec4(mix(x.rgb,z,opacity),y.a);}"], [D, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,x+y-min(x*y,1.0),opacity);}"], [29, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 y2=2.0*y;vec4 w=step(0.5,y);vec4 z=mix(x-(1.0-y2)*x*(1.0-x),mix(x+(y2-1.0)*(sqrt(x)-x),x+(y2-1.0)*x*((16.0*x-12.0)*x+3.0),w*(1.0-step(0.25,x))),w);return mix(x,z,opacity);}"], [P, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return y;}"], [31, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,max(x+y-1.0,0.0),opacity);}"], [32, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=mix(max(1.0-min((1.0-x)/(2.0*y),1.0),0.0),min(x/(2.0*(1.0-y)),1.0),step(0.5,y));return mix(x,z,opacity);}"]])
          , U = class extends i.Qev {
            constructor(e, t=1) {
                super(),
                this._blendFunction = e,
                this.opacity = new i.nc$(t)
            }
            getOpacity() {
                return this.opacity.value
            }
            setOpacity(e) {
                this.opacity.value = e
            }
            get blendFunction() {
                return this._blendFunction
            }
            set blendFunction(e) {
                this._blendFunction = e,
                this.dispatchEvent({
                    type: "change"
                })
            }
            getBlendFunction() {
                return this.blendFunction
            }
            setBlendFunction(e) {
                this.blendFunction = e
            }
            getShaderCode() {
                return L.get(this.blendFunction)
            }
        }
          , F = 2
          , N = 3
          , O = [new Float32Array([0, 0]), new Float32Array([0, 1, 1]), new Float32Array([0, 1, 1, 2]), new Float32Array([0, 1, 2, 2, 3]), new Float32Array([0, 1, 2, 3, 4, 4, 5]), new Float32Array([0, 1, 2, 3, 4, 5, 7, 8, 9, 10])]
          , Q = class extends i.BKk {
            constructor(e=new i.IUQ) {
                super({
                    name: "KawaseBlurMaterial",
                    uniforms: {
                        inputBuffer: new i.nc$(null),
                        texelSize: new i.nc$(new i.IUQ),
                        scale: new i.nc$(1),
                        kernel: new i.nc$(0)
                    },
                    blending: i.XIg,
                    toneMapped: !1,
                    depthWrite: !1,
                    depthTest: !1,
                    fragmentShader: "#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\nvarying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec4 sum=texture2D(inputBuffer,vUv0);sum+=texture2D(inputBuffer,vUv1);sum+=texture2D(inputBuffer,vUv2);sum+=texture2D(inputBuffer,vUv3);gl_FragColor=sum*0.25;\n#include <colorspace_fragment>\n}",
                    vertexShader: "uniform vec4 texelSize;uniform float kernel;uniform float scale;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec2 uv=position.xy*0.5+0.5;vec2 dUv=(texelSize.xy*vec2(kernel)+texelSize.zw)*scale;vUv0=vec2(uv.x-dUv.x,uv.y+dUv.y);vUv1=vec2(uv.x+dUv.x,uv.y+dUv.y);vUv2=vec2(uv.x+dUv.x,uv.y-dUv.y);vUv3=vec2(uv.x-dUv.x,uv.y-dUv.y);gl_Position=vec4(position.xy,1.0,1.0);}"
                }),
                this.setTexelSize(e.x, e.y),
                this.kernelSize = F
            }
            set inputBuffer(e) {
                this.uniforms.inputBuffer.value = e
            }
            setInputBuffer(e) {
                this.inputBuffer = e
            }
            get kernelSequence() {
                return O[this.kernelSize]
            }
            get scale() {
                return this.uniforms.scale.value
            }
            set scale(e) {
                this.uniforms.scale.value = e
            }
            getScale() {
                return this.uniforms.scale.value
            }
            setScale(e) {
                this.uniforms.scale.value = e
            }
            getKernel() {
                return null
            }
            get kernel() {
                return this.uniforms.kernel.value
            }
            set kernel(e) {
                this.uniforms.kernel.value = e
            }
            setKernel(e) {
                this.kernel = e
            }
            setTexelSize(e, t) {
                this.uniforms.texelSize.value.set(e, t, .5 * e, .5 * t)
            }
            setSize(e, t) {
                const n = 1 / e
                  , i = 1 / t;
                this.uniforms.texelSize.value.set(n, i, .5 * n, .5 * i)
            }
        }
          , k = class extends o {
            constructor({kernelSize: e=F, resolutionScale: t=.5, width: n=w.AUTO_SIZE, height: r=w.AUTO_SIZE, resolutionX: s=n, resolutionY: a=r}={}) {
                super("KawaseBlurPass"),
                this.renderTargetA = new i.nWS(1,1,{
                    depthBuffer: !1
                }),
                this.renderTargetA.texture.name = "Blur.Target.A",
                this.renderTargetB = this.renderTargetA.clone(),
                this.renderTargetB.texture.name = "Blur.Target.B";
                const o = this.resolution = new w(this,s,a,t);
                o.addEventListener("change", (e => this.setSize(o.baseWidth, o.baseHeight))),
                this._blurMaterial = new Q,
                this._blurMaterial.kernelSize = e,
                this.copyMaterial = new u
            }
            getResolution() {
                return this.resolution
            }
            get blurMaterial() {
                return this._blurMaterial
            }
            set blurMaterial(e) {
                this._blurMaterial = e
            }
            get dithering() {
                return this.copyMaterial.dithering
            }
            set dithering(e) {
                this.copyMaterial.dithering = e
            }
            get kernelSize() {
                return this.blurMaterial.kernelSize
            }
            set kernelSize(e) {
                this.blurMaterial.kernelSize = e
            }
            get width() {
                return this.resolution.width
            }
            set width(e) {
                this.resolution.preferredWidth = e
            }
            get height() {
                return this.resolution.height
            }
            set height(e) {
                this.resolution.preferredHeight = e
            }
            get scale() {
                return this.blurMaterial.scale
            }
            set scale(e) {
                this.blurMaterial.scale = e
            }
            getScale() {
                return this.blurMaterial.scale
            }
            setScale(e) {
                this.blurMaterial.scale = e
            }
            getKernelSize() {
                return this.kernelSize
            }
            setKernelSize(e) {
                this.kernelSize = e
            }
            getResolutionScale() {
                return this.resolution.scale
            }
            setResolutionScale(e) {
                this.resolution.scale = e
            }
            render(e, t, n, i, r) {
                const s = this.scene
                  , a = this.camera
                  , o = this.renderTargetA
                  , l = this.renderTargetB
                  , c = this.blurMaterial
                  , u = c.kernelSequence;
                let h = t;
                this.fullscreenMaterial = c;
                for (let t = 0, n = u.length; t < n; ++t) {
                    const n = 1 & t ? l : o;
                    c.kernel = u[t],
                    c.inputBuffer = h.texture,
                    e.setRenderTarget(n),
                    e.render(s, a),
                    h = n
                }
                this.fullscreenMaterial = this.copyMaterial,
                this.copyMaterial.inputBuffer = h.texture,
                e.setRenderTarget(this.renderToScreen ? null : n),
                e.render(s, a)
            }
            setSize(e, t) {
                const n = this.resolution;
                n.setBaseSize(e, t);
                const i = n.width
                  , r = n.height;
                this.renderTargetA.setSize(i, r),
                this.renderTargetB.setSize(i, r),
                this.blurMaterial.setSize(e, t)
            }
            initialize(e, t, n) {
                void 0 !== n && (this.renderTargetA.texture.type = n,
                this.renderTargetB.texture.type = n,
                n !== i.OUM ? (this.blurMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1",
                this.copyMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1") : null !== e && e.outputColorSpace === i.er$ && (this.renderTargetA.texture.colorSpace = i.er$,
                this.renderTargetB.texture.colorSpace = i.er$))
            }
            static get AUTO_SIZE() {
                return w.AUTO_SIZE
            }
        }
          , G = class extends i.BKk {
            constructor(e=!1, t=null) {
                super({
                    name: "LuminanceMaterial",
                    defines: {
                        THREE_REVISION: i.sPf.replace(/\D+/g, "")
                    },
                    uniforms: {
                        inputBuffer: new i.nc$(null),
                        threshold: new i.nc$(0),
                        smoothing: new i.nc$(1),
                        range: new i.nc$(null)
                    },
                    blending: i.XIg,
                    toneMapped: !1,
                    depthWrite: !1,
                    depthTest: !1,
                    fragmentShader: "#include <common>\n#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\n#ifdef RANGE\nuniform vec2 range;\n#elif defined(THRESHOLD)\nuniform float threshold;uniform float smoothing;\n#endif\nvarying vec2 vUv;void main(){vec4 texel=texture2D(inputBuffer,vUv);float l=luminance(texel.rgb);\n#ifdef RANGE\nfloat low=step(range.x,l);float high=step(l,range.y);l*=low*high;\n#elif defined(THRESHOLD)\nl=smoothstep(threshold,threshold+smoothing,l)*l;\n#endif\n#ifdef COLOR\ngl_FragColor=vec4(texel.rgb*clamp(l,0.0,1.0),l);\n#else\ngl_FragColor=vec4(l);\n#endif\n}",
                    vertexShader: c
                }),
                this.colorOutput = e,
                this.luminanceRange = t
            }
            set inputBuffer(e) {
                this.uniforms.inputBuffer.value = e
            }
            setInputBuffer(e) {
                this.uniforms.inputBuffer.value = e
            }
            get threshold() {
                return this.uniforms.threshold.value
            }
            set threshold(e) {
                this.smoothing > 0 || e > 0 ? this.defines.THRESHOLD = "1" : delete this.defines.THRESHOLD,
                this.uniforms.threshold.value = e
            }
            getThreshold() {
                return this.threshold
            }
            setThreshold(e) {
                this.threshold = e
            }
            get smoothing() {
                return this.uniforms.smoothing.value
            }
            set smoothing(e) {
                this.threshold > 0 || e > 0 ? this.defines.THRESHOLD = "1" : delete this.defines.THRESHOLD,
                this.uniforms.smoothing.value = e
            }
            getSmoothingFactor() {
                return this.smoothing
            }
            setSmoothingFactor(e) {
                this.smoothing = e
            }
            get useThreshold() {
                return this.threshold > 0 || this.smoothing > 0
            }
            set useThreshold(e) {}
            get colorOutput() {
                return void 0 !== this.defines.COLOR
            }
            set colorOutput(e) {
                e ? this.defines.COLOR = "1" : delete this.defines.COLOR,
                this.needsUpdate = !0
            }
            isColorOutputEnabled(e) {
                return this.colorOutput
            }
            setColorOutputEnabled(e) {
                this.colorOutput = e
            }
            get useRange() {
                return null !== this.luminanceRange
            }
            set useRange(e) {
                this.luminanceRange = null
            }
            get luminanceRange() {
                return this.uniforms.range.value
            }
            set luminanceRange(e) {
                null !== e ? this.defines.RANGE = "1" : delete this.defines.RANGE,
                this.uniforms.range.value = e,
                this.needsUpdate = !0
            }
            getLuminanceRange() {
                return this.luminanceRange
            }
            setLuminanceRange(e) {
                this.luminanceRange = e
            }
        }
          , H = class extends o {
            constructor({renderTarget: e, luminanceRange: t, colorOutput: n, resolutionScale: r=1, width: s=w.AUTO_SIZE, height: a=w.AUTO_SIZE, resolutionX: o=s, resolutionY: l=a}={}) {
                super("LuminancePass"),
                this.fullscreenMaterial = new G(n,t),
                this.needsSwap = !1,
                this.renderTarget = e,
                void 0 === this.renderTarget && (this.renderTarget = new i.nWS(1,1,{
                    depthBuffer: !1
                }),
                this.renderTarget.texture.name = "LuminancePass.Target");
                const c = this.resolution = new w(this,o,l,r);
                c.addEventListener("change", (e => this.setSize(c.baseWidth, c.baseHeight)))
            }
            get texture() {
                return this.renderTarget.texture
            }
            getTexture() {
                return this.renderTarget.texture
            }
            getResolution() {
                return this.resolution
            }
            render(e, t, n, i, r) {
                this.fullscreenMaterial.inputBuffer = t.texture,
                e.setRenderTarget(this.renderToScreen ? null : this.renderTarget),
                e.render(this.scene, this.camera)
            }
            setSize(e, t) {
                const n = this.resolution;
                n.setBaseSize(e, t),
                this.renderTarget.setSize(n.width, n.height)
            }
            initialize(e, t, n) {
                void 0 !== n && n !== i.OUM && (this.renderTarget.texture.type = n,
                this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1")
            }
        }
          , z = class extends i.BKk {
            constructor() {
                super({
                    name: "DownsamplingMaterial",
                    uniforms: {
                        inputBuffer: new i.nc$(null),
                        texelSize: new i.nc$(new i.I9Y)
                    },
                    blending: i.XIg,
                    toneMapped: !1,
                    depthWrite: !1,
                    depthTest: !1,
                    fragmentShader: "#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\n#define WEIGHT_INNER 0.125\n#define WEIGHT_OUTER 0.0555555\nvarying vec2 vUv;varying vec2 vUv00;varying vec2 vUv01;varying vec2 vUv02;varying vec2 vUv03;varying vec2 vUv04;varying vec2 vUv05;varying vec2 vUv06;varying vec2 vUv07;varying vec2 vUv08;varying vec2 vUv09;varying vec2 vUv10;varying vec2 vUv11;float clampToBorder(const in vec2 uv){return float(uv.s>=0.0&&uv.s<=1.0&&uv.t>=0.0&&uv.t<=1.0);}void main(){vec4 c=vec4(0.0);vec4 w=WEIGHT_INNER*vec4(clampToBorder(vUv00),clampToBorder(vUv01),clampToBorder(vUv02),clampToBorder(vUv03));c+=w.x*texture2D(inputBuffer,vUv00);c+=w.y*texture2D(inputBuffer,vUv01);c+=w.z*texture2D(inputBuffer,vUv02);c+=w.w*texture2D(inputBuffer,vUv03);w=WEIGHT_OUTER*vec4(clampToBorder(vUv04),clampToBorder(vUv05),clampToBorder(vUv06),clampToBorder(vUv07));c+=w.x*texture2D(inputBuffer,vUv04);c+=w.y*texture2D(inputBuffer,vUv05);c+=w.z*texture2D(inputBuffer,vUv06);c+=w.w*texture2D(inputBuffer,vUv07);w=WEIGHT_OUTER*vec4(clampToBorder(vUv08),clampToBorder(vUv09),clampToBorder(vUv10),clampToBorder(vUv11));c+=w.x*texture2D(inputBuffer,vUv08);c+=w.y*texture2D(inputBuffer,vUv09);c+=w.z*texture2D(inputBuffer,vUv10);c+=w.w*texture2D(inputBuffer,vUv11);c+=WEIGHT_OUTER*texture2D(inputBuffer,vUv);gl_FragColor=c;\n#include <colorspace_fragment>\n}",
                    vertexShader: "uniform vec2 texelSize;varying vec2 vUv;varying vec2 vUv00;varying vec2 vUv01;varying vec2 vUv02;varying vec2 vUv03;varying vec2 vUv04;varying vec2 vUv05;varying vec2 vUv06;varying vec2 vUv07;varying vec2 vUv08;varying vec2 vUv09;varying vec2 vUv10;varying vec2 vUv11;void main(){vUv=position.xy*0.5+0.5;vUv00=vUv+texelSize*vec2(-1.0,1.0);vUv01=vUv+texelSize*vec2(1.0,1.0);vUv02=vUv+texelSize*vec2(-1.0,-1.0);vUv03=vUv+texelSize*vec2(1.0,-1.0);vUv04=vUv+texelSize*vec2(-2.0,2.0);vUv05=vUv+texelSize*vec2(0.0,2.0);vUv06=vUv+texelSize*vec2(2.0,2.0);vUv07=vUv+texelSize*vec2(-2.0,0.0);vUv08=vUv+texelSize*vec2(2.0,0.0);vUv09=vUv+texelSize*vec2(-2.0,-2.0);vUv10=vUv+texelSize*vec2(0.0,-2.0);vUv11=vUv+texelSize*vec2(2.0,-2.0);gl_Position=vec4(position.xy,1.0,1.0);}"
                })
            }
            set inputBuffer(e) {
                this.uniforms.inputBuffer.value = e
            }
            setSize(e, t) {
                this.uniforms.texelSize.value.set(1 / e, 1 / t)
            }
        }
          , V = class extends i.BKk {
            constructor() {
                super({
                    name: "UpsamplingMaterial",
                    uniforms: {
                        inputBuffer: new i.nc$(null),
                        supportBuffer: new i.nc$(null),
                        texelSize: new i.nc$(new i.I9Y),
                        radius: new i.nc$(.85)
                    },
                    blending: i.XIg,
                    toneMapped: !1,
                    depthWrite: !1,
                    depthTest: !1,
                    fragmentShader: "#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;uniform mediump sampler2D supportBuffer;\n#else\nuniform lowp sampler2D inputBuffer;uniform lowp sampler2D supportBuffer;\n#endif\nuniform float radius;varying vec2 vUv;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;varying vec2 vUv4;varying vec2 vUv5;varying vec2 vUv6;varying vec2 vUv7;void main(){vec4 c=vec4(0.0);c+=texture2D(inputBuffer,vUv0)*0.0625;c+=texture2D(inputBuffer,vUv1)*0.125;c+=texture2D(inputBuffer,vUv2)*0.0625;c+=texture2D(inputBuffer,vUv3)*0.125;c+=texture2D(inputBuffer,vUv)*0.25;c+=texture2D(inputBuffer,vUv4)*0.125;c+=texture2D(inputBuffer,vUv5)*0.0625;c+=texture2D(inputBuffer,vUv6)*0.125;c+=texture2D(inputBuffer,vUv7)*0.0625;vec4 baseColor=texture2D(supportBuffer,vUv);gl_FragColor=mix(baseColor,c,radius);\n#include <colorspace_fragment>\n}",
                    vertexShader: "uniform vec2 texelSize;varying vec2 vUv;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;varying vec2 vUv4;varying vec2 vUv5;varying vec2 vUv6;varying vec2 vUv7;void main(){vUv=position.xy*0.5+0.5;vUv0=vUv+texelSize*vec2(-1.0,1.0);vUv1=vUv+texelSize*vec2(0.0,1.0);vUv2=vUv+texelSize*vec2(1.0,1.0);vUv3=vUv+texelSize*vec2(-1.0,0.0);vUv4=vUv+texelSize*vec2(1.0,0.0);vUv5=vUv+texelSize*vec2(-1.0,-1.0);vUv6=vUv+texelSize*vec2(0.0,-1.0);vUv7=vUv+texelSize*vec2(1.0,-1.0);gl_Position=vec4(position.xy,1.0,1.0);}"
                })
            }
            set inputBuffer(e) {
                this.uniforms.inputBuffer.value = e
            }
            set supportBuffer(e) {
                this.uniforms.supportBuffer.value = e
            }
            get radius() {
                return this.uniforms.radius.value
            }
            set radius(e) {
                this.uniforms.radius.value = e
            }
            setSize(e, t) {
                this.uniforms.texelSize.value.set(1 / e, 1 / t)
            }
        }
          , W = class extends o {
            constructor() {
                super("MipmapBlurPass"),
                this.needsSwap = !1,
                this.renderTarget = new i.nWS(1,1,{
                    depthBuffer: !1
                }),
                this.renderTarget.texture.name = "Upsampling.Mipmap0",
                this.downsamplingMipmaps = [],
                this.upsamplingMipmaps = [],
                this.downsamplingMaterial = new z,
                this.upsamplingMaterial = new V,
                this.resolution = new i.I9Y
            }
            get texture() {
                return this.renderTarget.texture
            }
            get levels() {
                return this.downsamplingMipmaps.length
            }
            set levels(e) {
                if (this.levels !== e) {
                    const t = this.renderTarget;
                    this.dispose(),
                    this.downsamplingMipmaps = [],
                    this.upsamplingMipmaps = [];
                    for (let n = 0; n < e; ++n) {
                        const e = t.clone();
                        e.texture.name = "Downsampling.Mipmap" + n,
                        this.downsamplingMipmaps.push(e)
                    }
                    this.upsamplingMipmaps.push(t);
                    for (let n = 1, i = e - 1; n < i; ++n) {
                        const e = t.clone();
                        e.texture.name = "Upsampling.Mipmap" + n,
                        this.upsamplingMipmaps.push(e)
                    }
                    this.setSize(this.resolution.x, this.resolution.y)
                }
            }
            get radius() {
                return this.upsamplingMaterial.radius
            }
            set radius(e) {
                this.upsamplingMaterial.radius = e
            }
            render(e, t, n, i, r) {
                const {scene: s, camera: a} = this
                  , {downsamplingMaterial: o, upsamplingMaterial: l} = this
                  , {downsamplingMipmaps: c, upsamplingMipmaps: u} = this;
                let h = t;
                this.fullscreenMaterial = o;
                for (let t = 0, n = c.length; t < n; ++t) {
                    const n = c[t];
                    o.setSize(h.width, h.height),
                    o.inputBuffer = h.texture,
                    e.setRenderTarget(n),
                    e.render(s, a),
                    h = n
                }
                this.fullscreenMaterial = l;
                for (let t = u.length - 1; t >= 0; --t) {
                    const n = u[t];
                    l.setSize(h.width, h.height),
                    l.inputBuffer = h.texture,
                    l.supportBuffer = c[t].texture,
                    e.setRenderTarget(n),
                    e.render(s, a),
                    h = n
                }
            }
            setSize(e, t) {
                const n = this.resolution;
                n.set(e, t);
                let i = n.width
                  , r = n.height;
                for (let e = 0, t = this.downsamplingMipmaps.length; e < t; ++e)
                    i = Math.round(.5 * i),
                    r = Math.round(.5 * r),
                    this.downsamplingMipmaps[e].setSize(i, r),
                    e < this.upsamplingMipmaps.length && this.upsamplingMipmaps[e].setSize(i, r)
            }
            initialize(e, t, n) {
                if (void 0 !== n) {
                    const t = this.downsamplingMipmaps.concat(this.upsamplingMipmaps);
                    for (const e of t)
                        e.texture.type = n;
                    if (n !== i.OUM)
                        this.downsamplingMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1",
                        this.upsamplingMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1";
                    else if (null !== e && e.outputColorSpace === i.er$)
                        for (const e of t)
                            e.texture.colorSpace = i.er$
                }
            }
            dispose() {
                super.dispose();
                for (const e of this.downsamplingMipmaps.concat(this.upsamplingMipmaps))
                    e.dispose()
            }
        }
          , j = class extends i.Qev {
            constructor(e, t, {attributes: n=g.NONE, blendFunction: r=B, defines: s=new Map, uniforms: a=new Map, extensions: o=null, vertexShader: l=null}={}) {
                super(),
                this.name = e,
                this.renderer = null,
                this.attributes = n,
                this.fragmentShader = t,
                this.vertexShader = l,
                this.defines = s,
                this.uniforms = a,
                this.extensions = o,
                this.blendMode = new U(r),
                this.blendMode.addEventListener("change", (e => this.setChanged())),
                this._inputColorSpace = i.Zr2,
                this._outputColorSpace = i.jf0
            }
            get inputColorSpace() {
                return this._inputColorSpace
            }
            set inputColorSpace(e) {
                this._inputColorSpace = e,
                this.setChanged()
            }
            get outputColorSpace() {
                return this._outputColorSpace
            }
            set outputColorSpace(e) {
                this._outputColorSpace = e,
                this.setChanged()
            }
            set mainScene(e) {}
            set mainCamera(e) {}
            getName() {
                return this.name
            }
            setRenderer(e) {
                this.renderer = e
            }
            getDefines() {
                return this.defines
            }
            getUniforms() {
                return this.uniforms
            }
            getExtensions() {
                return this.extensions
            }
            getBlendMode() {
                return this.blendMode
            }
            getAttributes() {
                return this.attributes
            }
            setAttributes(e) {
                this.attributes = e,
                this.setChanged()
            }
            getFragmentShader() {
                return this.fragmentShader
            }
            setFragmentShader(e) {
                this.fragmentShader = e,
                this.setChanged()
            }
            getVertexShader() {
                return this.vertexShader
            }
            setVertexShader(e) {
                this.vertexShader = e,
                this.setChanged()
            }
            setChanged() {
                this.dispatchEvent({
                    type: "change"
                })
            }
            setDepthTexture(e, t=i.Rkk) {}
            update(e, t, n) {}
            setSize(e, t) {}
            initialize(e, t, n) {}
            dispose() {
                for (const e of Object.keys(this)) {
                    const t = this[e];
                    (t instanceof i.nWS || t instanceof i.imn || t instanceof i.gPd || t instanceof o) && this[e].dispose()
                }
            }
        }
          , q = class extends j {
            constructor({blendFunction: e=D, luminanceThreshold: t=.9, luminanceSmoothing: n=.025, mipmapBlur: r=!1, intensity: s=1, radius: a=.85, levels: o=8, kernelSize: l=N, resolutionScale: c=.5, width: u=w.AUTO_SIZE, height: h=w.AUTO_SIZE, resolutionX: d=u, resolutionY: p=h}={}) {
                super("BloomEffect", "#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D map;\n#else\nuniform lowp sampler2D map;\n#endif\nuniform float intensity;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec4 texel=texture2D(map,uv);outputColor=vec4(texel.rgb*intensity,texel.a);}", {
                    blendFunction: e,
                    uniforms: new Map([["map", new i.nc$(null)], ["intensity", new i.nc$(s)]])
                }),
                this.renderTarget = new i.nWS(1,1,{
                    depthBuffer: !1
                }),
                this.renderTarget.texture.name = "Bloom.Target",
                this.blurPass = new k({
                    kernelSize: l
                }),
                this.luminancePass = new H({
                    colorOutput: !0
                }),
                this.luminanceMaterial.threshold = t,
                this.luminanceMaterial.smoothing = n,
                this.mipmapBlurPass = new W,
                this.mipmapBlurPass.enabled = r,
                this.mipmapBlurPass.radius = a,
                this.mipmapBlurPass.levels = o,
                this.uniforms.get("map").value = r ? this.mipmapBlurPass.texture : this.renderTarget.texture;
                const f = this.resolution = new w(this,d,p,c);
                f.addEventListener("change", (e => this.setSize(f.baseWidth, f.baseHeight)))
            }
            get texture() {
                return this.mipmapBlurPass.enabled ? this.mipmapBlurPass.texture : this.renderTarget.texture
            }
            getTexture() {
                return this.texture
            }
            getResolution() {
                return this.resolution
            }
            getBlurPass() {
                return this.blurPass
            }
            getLuminancePass() {
                return this.luminancePass
            }
            get luminanceMaterial() {
                return this.luminancePass.fullscreenMaterial
            }
            getLuminanceMaterial() {
                return this.luminancePass.fullscreenMaterial
            }
            get width() {
                return this.resolution.width
            }
            set width(e) {
                this.resolution.preferredWidth = e
            }
            get height() {
                return this.resolution.height
            }
            set height(e) {
                this.resolution.preferredHeight = e
            }
            get dithering() {
                return this.blurPass.dithering
            }
            set dithering(e) {
                this.blurPass.dithering = e
            }
            get kernelSize() {
                return this.blurPass.kernelSize
            }
            set kernelSize(e) {
                this.blurPass.kernelSize = e
            }
            get distinction() {
                return console.warn(this.name, "distinction was removed"),
                1
            }
            set distinction(e) {
                console.warn(this.name, "distinction was removed")
            }
            get intensity() {
                return this.uniforms.get("intensity").value
            }
            set intensity(e) {
                this.uniforms.get("intensity").value = e
            }
            getIntensity() {
                return this.intensity
            }
            setIntensity(e) {
                this.intensity = e
            }
            getResolutionScale() {
                return this.resolution.scale
            }
            setResolutionScale(e) {
                this.resolution.scale = e
            }
            update(e, t, n) {
                const i = this.renderTarget
                  , r = this.luminancePass;
                r.enabled ? (r.render(e, t),
                this.mipmapBlurPass.enabled ? this.mipmapBlurPass.render(e, r.renderTarget) : this.blurPass.render(e, r.renderTarget, i)) : this.mipmapBlurPass.enabled ? this.mipmapBlurPass.render(e, t) : this.blurPass.render(e, t, i)
            }
            setSize(e, t) {
                const n = this.resolution;
                n.setBaseSize(e, t),
                this.renderTarget.setSize(n.width, n.height),
                this.blurPass.resolution.copy(n),
                this.luminancePass.setSize(e, t),
                this.mipmapBlurPass.setSize(e, t)
            }
            initialize(e, t, n) {
                this.blurPass.initialize(e, t, n),
                this.luminancePass.initialize(e, t, n),
                this.mipmapBlurPass.initialize(e, t, n),
                void 0 !== n && (this.renderTarget.texture.type = n,
                null !== e && e.outputColorSpace === i.er$ && (this.renderTarget.texture.colorSpace = i.er$))
            }
        }
          , Y = class extends j {
            constructor({blendFunction: e=P, brightness: t=0, contrast: n=0}={}) {
                super("BrightnessContrastEffect", "uniform float brightness;uniform float contrast;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec3 color=inputColor.rgb+vec3(brightness-0.5);if(contrast>0.0){color/=vec3(1.0-contrast);}else{color*=vec3(1.0+contrast);}outputColor=vec4(color+vec3(0.5),inputColor.a);}", {
                    blendFunction: e,
                    uniforms: new Map([["brightness", new i.nc$(t)], ["contrast", new i.nc$(n)]])
                }),
                this.inputColorSpace = i.er$
            }
            get brightness() {
                return this.uniforms.get("brightness").value
            }
            set brightness(e) {
                this.uniforms.get("brightness").value = e
            }
            getBrightness() {
                return this.brightness
            }
            setBrightness(e) {
                this.brightness = e
            }
            get contrast() {
                return this.uniforms.get("contrast").value
            }
            set contrast(e) {
                this.uniforms.get("contrast").value = e
            }
            getContrast() {
                return this.contrast
            }
            setContrast(e) {
                this.contrast = e
            }
        }
          , X = class extends j {
            constructor({blendFunction: e, bits: t=16}={}) {
                super("ColorDepthEffect", "uniform float factor;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){outputColor=vec4(floor(inputColor.rgb*factor+0.5)/factor,inputColor.a);}", {
                    blendFunction: e,
                    uniforms: new Map([["factor", new i.nc$(1)]])
                }),
                this.bits = 0,
                this.bitDepth = t
            }
            get bitDepth() {
                return this.bits
            }
            set bitDepth(e) {
                this.bits = e,
                this.uniforms.get("factor").value = Math.pow(2, e / 3)
            }
            getBitDepth() {
                return this.bitDepth
            }
            setBitDepth(e) {
                this.bitDepth = e
            }
        }
          , K = 0
          , J = 1
          , Z = 0
          , $ = 3
          , ee = class extends i.BKk {
            constructor(e=!1, t=!1) {
                super({
                    name: "BokehMaterial",
                    defines: {
                        PASS: e ? "2" : "1"
                    },
                    uniforms: {
                        inputBuffer: new i.nc$(null),
                        cocBuffer: new i.nc$(null),
                        texelSize: new i.nc$(new i.I9Y),
                        kernel64: new i.nc$(null),
                        kernel16: new i.nc$(null),
                        scale: new i.nc$(1)
                    },
                    blending: i.XIg,
                    toneMapped: !1,
                    depthWrite: !1,
                    depthTest: !1,
                    fragmentShader: "#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\n#if PASS == 1\nuniform vec4 kernel64[32];\n#else\nuniform vec4 kernel16[8];\n#endif\nuniform lowp sampler2D cocBuffer;uniform vec2 texelSize;uniform float scale;varying vec2 vUv;void main(){\n#ifdef FOREGROUND\nvec2 cocNearFar=texture2D(cocBuffer,vUv).rg*scale;float coc=cocNearFar.x;\n#else\nfloat coc=texture2D(cocBuffer,vUv).g*scale;\n#endif\nif(coc==0.0){gl_FragColor=texture2D(inputBuffer,vUv);}else{\n#ifdef FOREGROUND\nvec2 step=texelSize*max(cocNearFar.x,cocNearFar.y);\n#else\nvec2 step=texelSize*coc;\n#endif\n#if PASS == 1\nvec4 acc=vec4(0.0);for(int i=0;i<32;++i){vec4 kernel=kernel64[i];vec2 uv=step*kernel.xy+vUv;acc+=texture2D(inputBuffer,uv);uv=step*kernel.zw+vUv;acc+=texture2D(inputBuffer,uv);}gl_FragColor=acc/64.0;\n#else\nvec4 maxValue=texture2D(inputBuffer,vUv);for(int i=0;i<8;++i){vec4 kernel=kernel16[i];vec2 uv=step*kernel.xy+vUv;maxValue=max(texture2D(inputBuffer,uv),maxValue);uv=step*kernel.zw+vUv;maxValue=max(texture2D(inputBuffer,uv),maxValue);}gl_FragColor=maxValue;\n#endif\n}}",
                    vertexShader: c
                }),
                t && (this.defines.FOREGROUND = "1"),
                this.generateKernel()
            }
            set inputBuffer(e) {
                this.uniforms.inputBuffer.value = e
            }
            setInputBuffer(e) {
                this.uniforms.inputBuffer.value = e
            }
            set cocBuffer(e) {
                this.uniforms.cocBuffer.value = e
            }
            setCoCBuffer(e) {
                this.uniforms.cocBuffer.value = e
            }
            get scale() {
                return this.uniforms.scale.value
            }
            set scale(e) {
                this.uniforms.scale.value = e
            }
            getScale(e) {
                return this.scale
            }
            setScale(e) {
                this.scale = e
            }
            generateKernel() {
                const e = new Float64Array(128)
                  , t = new Float64Array(32);
                let n = 0
                  , i = 0;
                for (let r = 0, s = Math.sqrt(80); r < 80; ++r) {
                    const a = 2.39996323 * r
                      , o = Math.sqrt(r) / s
                      , l = o * Math.cos(a)
                      , c = o * Math.sin(a);
                    r % 5 == 0 ? (t[i++] = l,
                    t[i++] = c) : (e[n++] = l,
                    e[n++] = c)
                }
                this.uniforms.kernel64.value = e,
                this.uniforms.kernel16.value = t
            }
            setTexelSize(e, t) {
                this.uniforms.texelSize.value.set(e, t)
            }
            setSize(e, t) {
                this.uniforms.texelSize.value.set(1 / e, 1 / t)
            }
        }
        ;
        function te(e, t, n) {
            return e * (t - n) - t
        }
        function ne(e, t, n) {
            return Math.min(Math.max((e + t) / (t - n), 0), 1)
        }
        var ie = class extends i.BKk {
            constructor(e) {
                super({
                    name: "CircleOfConfusionMaterial",
                    defines: {
                        DEPTH_PACKING: "0"
                    },
                    uniforms: {
                        depthBuffer: new i.nc$(null),
                        focusDistance: new i.nc$(0),
                        focusRange: new i.nc$(0),
                        cameraNear: new i.nc$(.3),
                        cameraFar: new i.nc$(1e3)
                    },
                    blending: i.XIg,
                    toneMapped: !1,
                    depthWrite: !1,
                    depthTest: !1,
                    fragmentShader: "#include <common>\n#include <packing>\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nuniform highp sampler2D depthBuffer;\n#else\nuniform mediump sampler2D depthBuffer;\n#endif\nuniform float focusDistance;uniform float focusRange;uniform float cameraNear;uniform float cameraFar;varying vec2 vUv;float readDepth(const in vec2 uv){\n#if DEPTH_PACKING == 3201\nfloat depth=unpackRGBAToDepth(texture2D(depthBuffer,uv));\n#else\nfloat depth=texture2D(depthBuffer,uv).r;\n#endif\n#ifdef LOG_DEPTH\nfloat d=pow(2.0,depth*log2(cameraFar+1.0))-1.0;float a=cameraFar/(cameraFar-cameraNear);float b=cameraFar*cameraNear/(cameraNear-cameraFar);depth=a+b/d;\n#endif\nreturn depth;}void main(){float depth=readDepth(vUv);\n#ifdef PERSPECTIVE_CAMERA\nfloat viewZ=perspectiveDepthToViewZ(depth,cameraNear,cameraFar);float linearDepth=viewZToOrthographicDepth(viewZ,cameraNear,cameraFar);\n#else\nfloat linearDepth=depth;\n#endif\nfloat signedDistance=linearDepth-focusDistance;float magnitude=smoothstep(0.0,focusRange,abs(signedDistance));gl_FragColor.rg=magnitude*vec2(step(signedDistance,0.0),step(0.0,signedDistance));}",
                    vertexShader: c
                }),
                this.uniforms.focalLength = this.uniforms.focusRange,
                this.copyCameraSettings(e)
            }
            get near() {
                return this.uniforms.cameraNear.value
            }
            get far() {
                return this.uniforms.cameraFar.value
            }
            set depthBuffer(e) {
                this.uniforms.depthBuffer.value = e
            }
            set depthPacking(e) {
                this.defines.DEPTH_PACKING = e.toFixed(0),
                this.needsUpdate = !0
            }
            setDepthBuffer(e, t=i.Rkk) {
                this.depthBuffer = e,
                this.depthPacking = t
            }
            get focusDistance() {
                return this.uniforms.focusDistance.value
            }
            set focusDistance(e) {
                this.uniforms.focusDistance.value = e
            }
            get worldFocusDistance() {
                return -te(this.focusDistance, this.near, this.far)
            }
            set worldFocusDistance(e) {
                this.focusDistance = ne(-e, this.near, this.far)
            }
            getFocusDistance(e) {
                this.uniforms.focusDistance.value = e
            }
            setFocusDistance(e) {
                this.uniforms.focusDistance.value = e
            }
            get focalLength() {
                return this.focusRange
            }
            set focalLength(e) {
                this.focusRange = e
            }
            get focusRange() {
                return this.uniforms.focusRange.value
            }
            set focusRange(e) {
                this.uniforms.focusRange.value = e
            }
            get worldFocusRange() {
                return -te(this.focusRange, this.near, this.far)
            }
            set worldFocusRange(e) {
                this.focusRange = ne(-e, this.near, this.far)
            }
            getFocalLength(e) {
                return this.focusRange
            }
            setFocalLength(e) {
                this.focusRange = e
            }
            adoptCameraSettings(e) {
                this.copyCameraSettings(e)
            }
            copyCameraSettings(e) {
                e && (this.uniforms.cameraNear.value = e.near,
                this.uniforms.cameraFar.value = e.far,
                e instanceof i.ubm ? this.defines.PERSPECTIVE_CAMERA = "1" : delete this.defines.PERSPECTIVE_CAMERA,
                this.needsUpdate = !0)
            }
        }
          , re = class extends i.BKk {
            constructor(e=null) {
                super({
                    name: "MaskMaterial",
                    uniforms: {
                        maskTexture: new i.nc$(e),
                        inputBuffer: new i.nc$(null),
                        strength: new i.nc$(1)
                    },
                    blending: i.XIg,
                    toneMapped: !1,
                    depthWrite: !1,
                    depthTest: !1,
                    fragmentShader: "#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\n#ifdef MASK_PRECISION_HIGH\nuniform mediump sampler2D maskTexture;\n#else\nuniform lowp sampler2D maskTexture;\n#endif\n#if MASK_FUNCTION != 0\nuniform float strength;\n#endif\nvarying vec2 vUv;void main(){\n#if COLOR_CHANNEL == 0\nfloat mask=texture2D(maskTexture,vUv).r;\n#elif COLOR_CHANNEL == 1\nfloat mask=texture2D(maskTexture,vUv).g;\n#elif COLOR_CHANNEL == 2\nfloat mask=texture2D(maskTexture,vUv).b;\n#else\nfloat mask=texture2D(maskTexture,vUv).a;\n#endif\n#if MASK_FUNCTION == 0\n#ifdef INVERTED\nmask=step(mask,0.0);\n#else\nmask=1.0-step(mask,0.0);\n#endif\n#else\nmask=clamp(mask*strength,0.0,1.0);\n#ifdef INVERTED\nmask=1.0-mask;\n#endif\n#endif\n#if MASK_FUNCTION == 3\nvec4 texel=texture2D(inputBuffer,vUv);gl_FragColor=vec4(mask*texel.rgb,texel.a);\n#elif MASK_FUNCTION == 2\ngl_FragColor=vec4(mask*texture2D(inputBuffer,vUv).rgb,mask);\n#else\ngl_FragColor=mask*texture2D(inputBuffer,vUv);\n#endif\n}",
                    vertexShader: c
                }),
                this.colorChannel = K,
                this.maskFunction = Z
            }
            set inputBuffer(e) {
                this.uniforms.inputBuffer.value = e
            }
            setInputBuffer(e) {
                this.uniforms.inputBuffer.value = e
            }
            set maskTexture(e) {
                this.uniforms.maskTexture.value = e,
                delete this.defines.MASK_PRECISION_HIGH,
                e.type !== i.OUM && (this.defines.MASK_PRECISION_HIGH = "1"),
                this.needsUpdate = !0
            }
            setMaskTexture(e) {
                this.maskTexture = e
            }
            set colorChannel(e) {
                this.defines.COLOR_CHANNEL = e.toFixed(0),
                this.needsUpdate = !0
            }
            setColorChannel(e) {
                this.colorChannel = e
            }
            set maskFunction(e) {
                this.defines.MASK_FUNCTION = e.toFixed(0),
                this.needsUpdate = !0
            }
            setMaskFunction(e) {
                this.maskFunction = e
            }
            get inverted() {
                return void 0 !== this.defines.INVERTED
            }
            set inverted(e) {
                this.inverted && !e ? delete this.defines.INVERTED : e && (this.defines.INVERTED = "1"),
                this.needsUpdate = !0
            }
            isInverted() {
                return this.inverted
            }
            setInverted(e) {
                this.inverted = e
            }
            get strength() {
                return this.uniforms.strength.value
            }
            set strength(e) {
                this.uniforms.strength.value = e
            }
            getStrength() {
                return this.strength
            }
            setStrength(e) {
                this.strength = e
            }
        }
          , se = class extends o {
            constructor(e, t="inputBuffer") {
                super("ShaderPass"),
                this.fullscreenMaterial = e,
                this.input = t
            }
            setInput(e) {
                this.input = e
            }
            render(e, t, n, i, r) {
                const s = this.fullscreenMaterial.uniforms;
                null !== t && void 0 !== s && void 0 !== s[this.input] && (s[this.input].value = t.texture),
                e.setRenderTarget(this.renderToScreen ? null : n),
                e.render(this.scene, this.camera)
            }
            initialize(e, t, n) {
                void 0 !== n && n !== i.OUM && (this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1")
            }
        }
          , ae = class extends j {
            constructor(e, {blendFunction: t, worldFocusDistance: n, worldFocusRange: r, focusDistance: s=0, focalLength: a=.1, focusRange: o=a, bokehScale: l=1, resolutionScale: c=1, width: u=w.AUTO_SIZE, height: h=w.AUTO_SIZE, resolutionX: d=u, resolutionY: p=h}={}) {
                super("DepthOfFieldEffect", "#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D nearColorBuffer;uniform mediump sampler2D farColorBuffer;\n#else\nuniform lowp sampler2D nearColorBuffer;uniform lowp sampler2D farColorBuffer;\n#endif\nuniform lowp sampler2D nearCoCBuffer;uniform lowp sampler2D farCoCBuffer;uniform float scale;void mainImage(const in vec4 inputColor,const in vec2 uv,const in float depth,out vec4 outputColor){vec4 colorNear=texture2D(nearColorBuffer,uv);vec4 colorFar=texture2D(farColorBuffer,uv);\n#if MASK_FUNCTION == 1\nvec2 cocNearFar=vec2(texture2D(nearCoCBuffer,uv).r,colorFar.a);cocNearFar.x=min(cocNearFar.x*scale,1.0);\n#else\nvec2 cocNearFar=vec2(texture2D(nearCoCBuffer,uv).r,texture2D(farCoCBuffer,uv).g);cocNearFar=min(cocNearFar*scale,1.0);\n#endif\nvec4 result=inputColor*(1.0-cocNearFar.y)+colorFar;result=mix(result,colorNear,cocNearFar.x);outputColor=result;}", {
                    blendFunction: t,
                    attributes: g.DEPTH,
                    uniforms: new Map([["nearColorBuffer", new i.nc$(null)], ["farColorBuffer", new i.nc$(null)], ["nearCoCBuffer", new i.nc$(null)], ["farCoCBuffer", new i.nc$(null)], ["scale", new i.nc$(1)]])
                }),
                this.camera = e,
                this.renderTarget = new i.nWS(1,1,{
                    depthBuffer: !1
                }),
                this.renderTarget.texture.name = "DoF.Intermediate",
                this.renderTargetMasked = this.renderTarget.clone(),
                this.renderTargetMasked.texture.name = "DoF.Masked.Far",
                this.renderTargetNear = this.renderTarget.clone(),
                this.renderTargetNear.texture.name = "DoF.Bokeh.Near",
                this.uniforms.get("nearColorBuffer").value = this.renderTargetNear.texture,
                this.renderTargetFar = this.renderTarget.clone(),
                this.renderTargetFar.texture.name = "DoF.Bokeh.Far",
                this.uniforms.get("farColorBuffer").value = this.renderTargetFar.texture,
                this.renderTargetCoC = this.renderTarget.clone(),
                this.renderTargetCoC.texture.name = "DoF.CoC",
                this.uniforms.get("farCoCBuffer").value = this.renderTargetCoC.texture,
                this.renderTargetCoCBlurred = this.renderTargetCoC.clone(),
                this.renderTargetCoCBlurred.texture.name = "DoF.CoC.Blurred",
                this.uniforms.get("nearCoCBuffer").value = this.renderTargetCoCBlurred.texture,
                this.cocPass = new se(new ie(e));
                const f = this.cocMaterial;
                f.focusDistance = s,
                f.focusRange = o,
                void 0 !== n && (f.worldFocusDistance = n),
                void 0 !== r && (f.worldFocusRange = r),
                this.blurPass = new k({
                    resolutionScale: c,
                    resolutionX: d,
                    resolutionY: p,
                    kernelSize: F
                }),
                this.maskPass = new se(new re(this.renderTargetCoC.texture));
                this.maskPass.fullscreenMaterial.colorChannel = J,
                this.maskFunction = $,
                this.bokehNearBasePass = new se(new ee(!1,!0)),
                this.bokehNearBasePass.fullscreenMaterial.cocBuffer = this.renderTargetCoCBlurred.texture,
                this.bokehNearFillPass = new se(new ee(!0,!0)),
                this.bokehNearFillPass.fullscreenMaterial.cocBuffer = this.renderTargetCoCBlurred.texture,
                this.bokehFarBasePass = new se(new ee(!1,!1)),
                this.bokehFarBasePass.fullscreenMaterial.cocBuffer = this.renderTargetCoC.texture,
                this.bokehFarFillPass = new se(new ee(!0,!1)),
                this.bokehFarFillPass.fullscreenMaterial.cocBuffer = this.renderTargetCoC.texture,
                this.target = null;
                const A = this.resolution = new w(this,d,p,c);
                A.addEventListener("change", (e => this.setSize(A.baseWidth, A.baseHeight))),
                this.bokehScale = l
            }
            set mainCamera(e) {
                this.camera = e,
                this.cocMaterial.copyCameraSettings(e)
            }
            get cocTexture() {
                return this.renderTargetCoC.texture
            }
            get maskFunction() {
                return this.maskPass.fullscreenMaterial.maskFunction
            }
            set maskFunction(e) {
                this.maskFunction !== e && (this.defines.set("MASK_FUNCTION", e.toFixed(0)),
                this.maskPass.fullscreenMaterial.maskFunction = e,
                this.setChanged())
            }
            get cocMaterial() {
                return this.cocPass.fullscreenMaterial
            }
            get circleOfConfusionMaterial() {
                return this.cocMaterial
            }
            getCircleOfConfusionMaterial() {
                return this.cocMaterial
            }
            getBlurPass() {
                return this.blurPass
            }
            getResolution() {
                return this.resolution
            }
            get bokehScale() {
                return this.uniforms.get("scale").value
            }
            set bokehScale(e) {
                this.bokehNearBasePass.fullscreenMaterial.scale = e,
                this.bokehNearFillPass.fullscreenMaterial.scale = e,
                this.bokehFarBasePass.fullscreenMaterial.scale = e,
                this.bokehFarFillPass.fullscreenMaterial.scale = e,
                this.maskPass.fullscreenMaterial.strength = e,
                this.uniforms.get("scale").value = e
            }
            getBokehScale() {
                return this.bokehScale
            }
            setBokehScale(e) {
                this.bokehScale = e
            }
            getTarget() {
                return this.target
            }
            setTarget(e) {
                this.target = e
            }
            calculateFocusDistance(e) {
                const t = this.camera;
                return ne(-t.position.distanceTo(e), t.near, t.far)
            }
            setDepthTexture(e, t=i.Rkk) {
                this.cocMaterial.depthBuffer = e,
                this.cocMaterial.depthPacking = t
            }
            update(e, t, n) {
                const i = this.renderTarget
                  , r = this.renderTargetCoC
                  , s = this.renderTargetCoCBlurred
                  , a = this.renderTargetMasked;
                if (null !== this.target) {
                    const e = this.calculateFocusDistance(this.target);
                    this.cocMaterial.focusDistance = e
                }
                this.cocPass.render(e, null, r),
                this.blurPass.render(e, r, s),
                this.maskPass.render(e, t, a),
                this.bokehFarBasePass.render(e, a, i),
                this.bokehFarFillPass.render(e, i, this.renderTargetFar),
                this.bokehNearBasePass.render(e, t, i),
                this.bokehNearFillPass.render(e, i, this.renderTargetNear)
            }
            setSize(e, t) {
                const n = this.resolution;
                n.setBaseSize(e, t);
                const i = n.width
                  , r = n.height;
                this.cocPass.setSize(e, t),
                this.blurPass.setSize(e, t),
                this.maskPass.setSize(e, t),
                this.renderTargetFar.setSize(e, t),
                this.renderTargetCoC.setSize(e, t),
                this.renderTargetMasked.setSize(e, t),
                this.renderTarget.setSize(i, r),
                this.renderTargetNear.setSize(i, r),
                this.renderTargetCoCBlurred.setSize(i, r),
                this.bokehNearBasePass.fullscreenMaterial.setSize(e, t),
                this.bokehNearFillPass.fullscreenMaterial.setSize(e, t),
                this.bokehFarBasePass.fullscreenMaterial.setSize(e, t),
                this.bokehFarFillPass.fullscreenMaterial.setSize(e, t)
            }
            initialize(e, t, n) {
                this.cocPass.initialize(e, t, n),
                this.maskPass.initialize(e, t, n),
                this.bokehNearBasePass.initialize(e, t, n),
                this.bokehNearFillPass.initialize(e, t, n),
                this.bokehFarBasePass.initialize(e, t, n),
                this.bokehFarFillPass.initialize(e, t, n),
                this.blurPass.initialize(e, t, i.OUM),
                e.capabilities.logarithmicDepthBuffer && (this.cocPass.fullscreenMaterial.defines.LOG_DEPTH = "1"),
                void 0 !== n && (this.renderTarget.texture.type = n,
                this.renderTargetNear.texture.type = n,
                this.renderTargetFar.texture.type = n,
                this.renderTargetMasked.texture.type = n,
                null !== e && e.outputColorSpace === i.er$ && (this.renderTarget.texture.colorSpace = i.er$,
                this.renderTargetNear.texture.colorSpace = i.er$,
                this.renderTargetFar.texture.colorSpace = i.er$,
                this.renderTargetMasked.texture.colorSpace = i.er$))
            }
        }
        ;
        var oe = class extends i.GYF {
            constructor(e, t, n=i.Kzv, r=i.OUM) {
                super(function(e, t, n) {
                    const r = new Map([[i.Kzv, 1], [i.VT0, 1], [i.paN, 2], [i.GWd, 4]]);
                    let s;
                    if (r.has(t) || console.error("Invalid noise texture format"),
                    n === i.OUM) {
                        s = new Uint8Array(e * r.get(t));
                        for (let e = 0, t = s.length; e < t; ++e)
                            s[e] = 255 * Math.random() + .5
                    } else {
                        s = new Float32Array(e * r.get(t));
                        for (let e = 0, t = s.length; e < t; ++e)
                            s[e] = Math.random()
                    }
                    return s
                }(e * t, n, r), e, t, n, r),
                this.needsUpdate = !0
            }
        }
        ;
        var le = 1
          , ce = 2
          , ue = (i.BKk,
        i.BKk,
        class extends o {
            constructor(e, t, n=null) {
                super("RenderPass", e, t),
                this.needsSwap = !1,
                this.clearPass = new p,
                this.overrideMaterialManager = null === n ? null : new b(n),
                this.ignoreBackground = !1,
                this.skipShadowMapUpdate = !1,
                this.selection = null
            }
            set mainScene(e) {
                this.scene = e
            }
            set mainCamera(e) {
                this.camera = e
            }
            get renderToScreen() {
                return super.renderToScreen
            }
            set renderToScreen(e) {
                super.renderToScreen = e,
                this.clearPass.renderToScreen = e
            }
            get overrideMaterial() {
                const e = this.overrideMaterialManager;
                return null !== e ? e.material : null
            }
            set overrideMaterial(e) {
                const t = this.overrideMaterialManager;
                null !== e ? null !== t ? t.setMaterial(e) : this.overrideMaterialManager = new b(e) : null !== t && (t.dispose(),
                this.overrideMaterialManager = null)
            }
            getOverrideMaterial() {
                return this.overrideMaterial
            }
            setOverrideMaterial(e) {
                this.overrideMaterial = e
            }
            get clear() {
                return this.clearPass.enabled
            }
            set clear(e) {
                this.clearPass.enabled = e
            }
            getSelection() {
                return this.selection
            }
            setSelection(e) {
                this.selection = e
            }
            isBackgroundDisabled() {
                return this.ignoreBackground
            }
            setBackgroundDisabled(e) {
                this.ignoreBackground = e
            }
            isShadowMapDisabled() {
                return this.skipShadowMapUpdate
            }
            setShadowMapDisabled(e) {
                this.skipShadowMapUpdate = e
            }
            getClearPass() {
                return this.clearPass
            }
            render(e, t, n, i, r) {
                const s = this.scene
                  , a = this.camera
                  , o = this.selection
                  , l = a.layers.mask
                  , c = s.background
                  , u = e.shadowMap.autoUpdate
                  , h = this.renderToScreen ? null : t;
                null !== o && a.layers.set(o.getLayer()),
                this.skipShadowMapUpdate && (e.shadowMap.autoUpdate = !1),
                (this.ignoreBackground || null !== this.clearPass.overrideClearColor) && (s.background = null),
                this.clearPass.enabled && this.clearPass.render(e, t),
                e.setRenderTarget(h),
                null !== this.overrideMaterialManager ? this.overrideMaterialManager.render(e, s, a) : e.render(s, a),
                a.layers.mask = l,
                s.background = c,
                e.shadowMap.autoUpdate = u
            }
        }
        )
          , he = class extends j {
            constructor({blendFunction: e=P, hue: t=0, saturation: n=0}={}) {
                super("HueSaturationEffect", "uniform vec3 hue;uniform float saturation;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec3 color=vec3(dot(inputColor.rgb,hue.xyz),dot(inputColor.rgb,hue.zxy),dot(inputColor.rgb,hue.yzx));float average=(color.r+color.g+color.b)/3.0;vec3 diff=average-color;if(saturation>0.0){color+=diff*(1.0-1.0/(1.001-saturation));}else{color+=diff*-saturation;}outputColor=vec4(min(color,1.0),inputColor.a);}", {
                    blendFunction: e,
                    uniforms: new Map([["hue", new i.nc$(new i.Pq0)], ["saturation", new i.nc$(n)]])
                }),
                this.hue = t
            }
            get saturation() {
                return this.uniforms.get("saturation").value
            }
            set saturation(e) {
                this.uniforms.get("saturation").value = e
            }
            getSaturation() {
                return this.saturation
            }
            setSaturation(e) {
                this.saturation = e
            }
            get hue() {
                const e = this.uniforms.get("hue").value;
                return Math.acos((3 * e.x - 1) / 2)
            }
            set hue(e) {
                const t = Math.sin(e)
                  , n = Math.cos(e);
                this.uniforms.get("hue").value.set((2 * n + 1) / 3, (-Math.sqrt(3) * t - n + 1) / 3, (Math.sqrt(3) * t - n + 1) / 3)
            }
            getHue() {
                return this.hue
            }
            setHue(e) {
                this.hue = e
            }
        }
          , de = "lut.scaleup";
        function pe(e, t, n) {
            const i = document.createElement("canvas")
              , r = i.getContext("2d");
            if (i.width = e,
            i.height = t,
            n instanceof Image)
                r.drawImage(n, 0, 0);
            else {
                const i = r.createImageData(e, t);
                i.data.set(n),
                r.putImageData(i, 0, 0)
            }
            return i
        }
        var fe = class e {
            constructor(e=0, t=0, n=null) {
                this.width = e,
                this.height = t,
                this.data = n
            }
            toCanvas() {
                return "undefined" == typeof document ? null : pe(this.width, this.height, this.data)
            }
            static from(t) {
                const {width: n, height: i} = t;
                let r;
                if (t instanceof Image) {
                    const e = pe(n, i, t);
                    if (null !== e) {
                        r = e.getContext("2d").getImageData(0, 0, n, i).data
                    }
                } else
                    r = t.data;
                return new e(n,i,r)
            }
        }
          , Ae = new i.Q1f
          , ge = (i.dYF,
        0)
          , me = 2
          , ve = 0
          , ye = 0
          , xe = 1
          , _e = 2
          , be = 3
          , Ee = 0
          , we = 1
          , Ce = 2
          , Ie = 3
          , Se = 5
          , Me = 5
          , Te = 6
          , Be = 7
          , Re = 8
          , De = 0
          , Pe = 1
          , Le = class extends j {
            constructor({blendFunction: e=D, premultiply: t=!1}={}) {
                super("NoiseEffect", "void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec3 noise=vec3(rand(uv*(1.0+time)));\n#ifdef PREMULTIPLY\noutputColor=vec4(min(inputColor.rgb*noise,vec3(1.0)),inputColor.a);\n#else\noutputColor=vec4(noise,inputColor.a);\n#endif\n}", {
                    blendFunction: e
                }),
                this.premultiply = t
            }
            get premultiply() {
                return this.defines.has("PREMULTIPLY")
            }
            set premultiply(e) {
                this.premultiply !== e && (e ? this.defines.set("PREMULTIPLY", "1") : this.defines.delete("PREMULTIPLY"),
                this.setChanged())
            }
            isPremultiplied() {
                return this.premultiply
            }
            setPremultiplied(e) {
                this.premultiply = e
            }
        }
          , Ue = (i.BKk,
        i.BKk,
        class extends j {
            constructor(e=30) {
                super("PixelationEffect", "uniform bool active;uniform vec4 d;void mainUv(inout vec2 uv){if(active){uv=d.xy*(floor(uv*d.zw)+0.5);}}", {
                    uniforms: new Map([["active", new i.nc$(!1)], ["d", new i.nc$(new i.IUQ)]])
                }),
                this.resolution = new i.I9Y,
                this._granularity = 0,
                this.granularity = e
            }
            get granularity() {
                return this._granularity
            }
            set granularity(e) {
                let t = Math.floor(e);
                t % 2 > 0 && (t += 1),
                this._granularity = t,
                this.uniforms.get("active").value = t > 0,
                this.setSize(this.resolution.width, this.resolution.height)
            }
            getGranularity() {
                return this.granularity
            }
            setGranularity(e) {
                this.granularity = e
            }
            setSize(e, t) {
                const n = this.resolution;
                n.set(e, t);
                const i = this.granularity
                  , r = i / n.x
                  , s = i / n.y;
                this.uniforms.get("d").value.set(r, s, 1 / r, 1 / s)
            }
        }
        )
          , Fe = (Math.PI,
        class extends i.BKk {
            constructor(e=new i.I9Y, t=me) {
                super({
                    name: "EdgeDetectionMaterial",
                    defines: {
                        THREE_REVISION: i.sPf.replace(/\D+/g, ""),
                        LOCAL_CONTRAST_ADAPTATION_FACTOR: "2.0",
                        EDGE_THRESHOLD: "0.1",
                        DEPTH_THRESHOLD: "0.01",
                        PREDICATION_MODE: "0",
                        PREDICATION_THRESHOLD: "0.01",
                        PREDICATION_SCALE: "2.0",
                        PREDICATION_STRENGTH: "1.0",
                        DEPTH_PACKING: "0"
                    },
                    uniforms: {
                        inputBuffer: new i.nc$(null),
                        depthBuffer: new i.nc$(null),
                        predicationBuffer: new i.nc$(null),
                        texelSize: new i.nc$(e)
                    },
                    blending: i.XIg,
                    toneMapped: !1,
                    depthWrite: !1,
                    depthTest: !1,
                    fragmentShader: "varying vec2 vUv;varying vec2 vUv0;varying vec2 vUv1;\n#if EDGE_DETECTION_MODE != 0\nvarying vec2 vUv2;varying vec2 vUv3;varying vec2 vUv4;varying vec2 vUv5;\n#endif\n#if EDGE_DETECTION_MODE == 1\n#include <common>\n#endif\n#if EDGE_DETECTION_MODE == 0 || PREDICATION_MODE == 1\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nuniform highp sampler2D depthBuffer;\n#else\nuniform mediump sampler2D depthBuffer;\n#endif\nfloat readDepth(const in vec2 uv){\n#if DEPTH_PACKING == 3201\nreturn unpackRGBAToDepth(texture2D(depthBuffer,uv));\n#else\nreturn texture2D(depthBuffer,uv).r;\n#endif\n}vec3 gatherNeighbors(){float p=readDepth(vUv);float pLeft=readDepth(vUv0);float pTop=readDepth(vUv1);return vec3(p,pLeft,pTop);}\n#elif PREDICATION_MODE == 2\nuniform sampler2D predicationBuffer;vec3 gatherNeighbors(){float p=texture2D(predicationBuffer,vUv).r;float pLeft=texture2D(predicationBuffer,vUv0).r;float pTop=texture2D(predicationBuffer,vUv1).r;return vec3(p,pLeft,pTop);}\n#endif\n#if PREDICATION_MODE != 0\nvec2 calculatePredicatedThreshold(){vec3 neighbours=gatherNeighbors();vec2 delta=abs(neighbours.xx-neighbours.yz);vec2 edges=step(PREDICATION_THRESHOLD,delta);return PREDICATION_SCALE*EDGE_THRESHOLD*(1.0-PREDICATION_STRENGTH*edges);}\n#endif\n#if EDGE_DETECTION_MODE != 0\nuniform sampler2D inputBuffer;\n#endif\nvoid main(){\n#if EDGE_DETECTION_MODE == 0\nconst vec2 threshold=vec2(DEPTH_THRESHOLD);\n#elif PREDICATION_MODE != 0\nvec2 threshold=calculatePredicatedThreshold();\n#else\nconst vec2 threshold=vec2(EDGE_THRESHOLD);\n#endif\n#if EDGE_DETECTION_MODE == 0\nvec3 neighbors=gatherNeighbors();vec2 delta=abs(neighbors.xx-vec2(neighbors.y,neighbors.z));vec2 edges=step(threshold,delta);if(dot(edges,vec2(1.0))==0.0){discard;}gl_FragColor=vec4(edges,0.0,1.0);\n#elif EDGE_DETECTION_MODE == 1\nfloat l=luminance(texture2D(inputBuffer,vUv).rgb);float lLeft=luminance(texture2D(inputBuffer,vUv0).rgb);float lTop=luminance(texture2D(inputBuffer,vUv1).rgb);vec4 delta;delta.xy=abs(l-vec2(lLeft,lTop));vec2 edges=step(threshold,delta.xy);if(dot(edges,vec2(1.0))==0.0){discard;}float lRight=luminance(texture2D(inputBuffer,vUv2).rgb);float lBottom=luminance(texture2D(inputBuffer,vUv3).rgb);delta.zw=abs(l-vec2(lRight,lBottom));vec2 maxDelta=max(delta.xy,delta.zw);float lLeftLeft=luminance(texture2D(inputBuffer,vUv4).rgb);float lTopTop=luminance(texture2D(inputBuffer,vUv5).rgb);delta.zw=abs(vec2(lLeft,lTop)-vec2(lLeftLeft,lTopTop));maxDelta=max(maxDelta.xy,delta.zw);float finalDelta=max(maxDelta.x,maxDelta.y);edges.xy*=step(finalDelta,LOCAL_CONTRAST_ADAPTATION_FACTOR*delta.xy);gl_FragColor=vec4(edges,0.0,1.0);\n#elif EDGE_DETECTION_MODE == 2\nvec4 delta;vec3 c=texture2D(inputBuffer,vUv).rgb;vec3 cLeft=texture2D(inputBuffer,vUv0).rgb;vec3 t=abs(c-cLeft);delta.x=max(max(t.r,t.g),t.b);vec3 cTop=texture2D(inputBuffer,vUv1).rgb;t=abs(c-cTop);delta.y=max(max(t.r,t.g),t.b);vec2 edges=step(threshold,delta.xy);if(dot(edges,vec2(1.0))==0.0){discard;}vec3 cRight=texture2D(inputBuffer,vUv2).rgb;t=abs(c-cRight);delta.z=max(max(t.r,t.g),t.b);vec3 cBottom=texture2D(inputBuffer,vUv3).rgb;t=abs(c-cBottom);delta.w=max(max(t.r,t.g),t.b);vec2 maxDelta=max(delta.xy,delta.zw);vec3 cLeftLeft=texture2D(inputBuffer,vUv4).rgb;t=abs(c-cLeftLeft);delta.z=max(max(t.r,t.g),t.b);vec3 cTopTop=texture2D(inputBuffer,vUv5).rgb;t=abs(c-cTopTop);delta.w=max(max(t.r,t.g),t.b);maxDelta=max(maxDelta.xy,delta.zw);float finalDelta=max(maxDelta.x,maxDelta.y);edges*=step(finalDelta,LOCAL_CONTRAST_ADAPTATION_FACTOR*delta.xy);gl_FragColor=vec4(edges,0.0,1.0);\n#endif\n}",
                    vertexShader: "uniform vec2 texelSize;varying vec2 vUv;varying vec2 vUv0;varying vec2 vUv1;\n#if EDGE_DETECTION_MODE != 0\nvarying vec2 vUv2;varying vec2 vUv3;varying vec2 vUv4;varying vec2 vUv5;\n#endif\nvoid main(){vUv=position.xy*0.5+0.5;vUv0=vUv+texelSize*vec2(-1.0,0.0);vUv1=vUv+texelSize*vec2(0.0,-1.0);\n#if EDGE_DETECTION_MODE != 0\nvUv2=vUv+texelSize*vec2(1.0,0.0);vUv3=vUv+texelSize*vec2(0.0,1.0);vUv4=vUv+texelSize*vec2(-2.0,0.0);vUv5=vUv+texelSize*vec2(0.0,-2.0);\n#endif\ngl_Position=vec4(position.xy,1.0,1.0);}"
                }),
                this.edgeDetectionMode = t
            }
            set depthBuffer(e) {
                this.uniforms.depthBuffer.value = e
            }
            set depthPacking(e) {
                this.defines.DEPTH_PACKING = e.toFixed(0),
                this.needsUpdate = !0
            }
            setDepthBuffer(e, t=i.Rkk) {
                this.depthBuffer = e,
                this.depthPacking = t
            }
            get edgeDetectionMode() {
                return Number(this.defines.EDGE_DETECTION_MODE)
            }
            set edgeDetectionMode(e) {
                this.defines.EDGE_DETECTION_MODE = e.toFixed(0),
                this.needsUpdate = !0
            }
            getEdgeDetectionMode() {
                return this.edgeDetectionMode
            }
            setEdgeDetectionMode(e) {
                this.edgeDetectionMode = e
            }
            get localContrastAdaptationFactor() {
                return Number(this.defines.LOCAL_CONTRAST_ADAPTATION_FACTOR)
            }
            set localContrastAdaptationFactor(e) {
                this.defines.LOCAL_CONTRAST_ADAPTATION_FACTOR = e.toFixed("6"),
                this.needsUpdate = !0
            }
            getLocalContrastAdaptationFactor() {
                return this.localContrastAdaptationFactor
            }
            setLocalContrastAdaptationFactor(e) {
                this.localContrastAdaptationFactor = e
            }
            get edgeDetectionThreshold() {
                return Number(this.defines.EDGE_THRESHOLD)
            }
            set edgeDetectionThreshold(e) {
                this.defines.EDGE_THRESHOLD = e.toFixed("6"),
                this.defines.DEPTH_THRESHOLD = (.1 * e).toFixed("6"),
                this.needsUpdate = !0
            }
            getEdgeDetectionThreshold() {
                return this.edgeDetectionThreshold
            }
            setEdgeDetectionThreshold(e) {
                this.edgeDetectionThreshold = e
            }
            get predicationMode() {
                return Number(this.defines.PREDICATION_MODE)
            }
            set predicationMode(e) {
                this.defines.PREDICATION_MODE = e.toFixed(0),
                this.needsUpdate = !0
            }
            getPredicationMode() {
                return this.predicationMode
            }
            setPredicationMode(e) {
                this.predicationMode = e
            }
            set predicationBuffer(e) {
                this.uniforms.predicationBuffer.value = e
            }
            setPredicationBuffer(e) {
                this.uniforms.predicationBuffer.value = e
            }
            get predicationThreshold() {
                return Number(this.defines.PREDICATION_THRESHOLD)
            }
            set predicationThreshold(e) {
                this.defines.PREDICATION_THRESHOLD = e.toFixed("6"),
                this.needsUpdate = !0
            }
            getPredicationThreshold() {
                return this.predicationThreshold
            }
            setPredicationThreshold(e) {
                this.predicationThreshold = e
            }
            get predicationScale() {
                return Number(this.defines.PREDICATION_SCALE)
            }
            set predicationScale(e) {
                this.defines.PREDICATION_SCALE = e.toFixed("6"),
                this.needsUpdate = !0
            }
            getPredicationScale() {
                return this.predicationScale
            }
            setPredicationScale(e) {
                this.predicationScale = e
            }
            get predicationStrength() {
                return Number(this.defines.PREDICATION_STRENGTH)
            }
            set predicationStrength(e) {
                this.defines.PREDICATION_STRENGTH = e.toFixed("6"),
                this.needsUpdate = !0
            }
            getPredicationStrength() {
                return this.predicationStrength
            }
            setPredicationStrength(e) {
                this.predicationStrength = e
            }
            setSize(e, t) {
                this.uniforms.texelSize.value.set(1 / e, 1 / t)
            }
        }
        )
          , Ne = class extends i.BKk {
            constructor(e=new i.I9Y, t=new i.I9Y) {
                super({
                    name: "SMAAWeightsMaterial",
                    defines: {
                        MAX_SEARCH_STEPS_INT: "16",
                        MAX_SEARCH_STEPS_FLOAT: "16.0",
                        MAX_SEARCH_STEPS_DIAG_INT: "8",
                        MAX_SEARCH_STEPS_DIAG_FLOAT: "8.0",
                        CORNER_ROUNDING: "25",
                        CORNER_ROUNDING_NORM: "0.25",
                        AREATEX_MAX_DISTANCE: "16.0",
                        AREATEX_MAX_DISTANCE_DIAG: "20.0",
                        AREATEX_PIXEL_SIZE: "(1.0 / vec2(160.0, 560.0))",
                        AREATEX_SUBTEX_SIZE: "(1.0 / 7.0)",
                        SEARCHTEX_SIZE: "vec2(66.0, 33.0)",
                        SEARCHTEX_PACKED_SIZE: "vec2(64.0, 16.0)"
                    },
                    uniforms: {
                        inputBuffer: new i.nc$(null),
                        searchTexture: new i.nc$(null),
                        areaTexture: new i.nc$(null),
                        resolution: new i.nc$(t),
                        texelSize: new i.nc$(e)
                    },
                    blending: i.XIg,
                    toneMapped: !1,
                    depthWrite: !1,
                    depthTest: !1,
                    fragmentShader: "#define sampleLevelZeroOffset(t, coord, offset) texture2D(t, coord + offset * texelSize)\n#if __VERSION__ < 300\n#define round(v) floor(v + 0.5)\n#endif\n#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\nuniform lowp sampler2D areaTexture;uniform lowp sampler2D searchTexture;uniform vec2 texelSize;uniform vec2 resolution;varying vec2 vUv;varying vec4 vOffset[3];varying vec2 vPixCoord;void movec(const in bvec2 c,inout vec2 variable,const in vec2 value){if(c.x){variable.x=value.x;}if(c.y){variable.y=value.y;}}void movec(const in bvec4 c,inout vec4 variable,const in vec4 value){movec(c.xy,variable.xy,value.xy);movec(c.zw,variable.zw,value.zw);}vec2 decodeDiagBilinearAccess(in vec2 e){e.r=e.r*abs(5.0*e.r-5.0*0.75);return round(e);}vec4 decodeDiagBilinearAccess(in vec4 e){e.rb=e.rb*abs(5.0*e.rb-5.0*0.75);return round(e);}vec2 searchDiag1(const in vec2 texCoord,const in vec2 dir,out vec2 e){vec4 coord=vec4(texCoord,-1.0,1.0);vec3 t=vec3(texelSize,1.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(coord.z<float(MAX_SEARCH_STEPS_DIAG_INT-1)&&coord.w>0.9)){break;}coord.xyz=t*vec3(dir,1.0)+coord.xyz;e=texture2D(inputBuffer,coord.xy).rg;coord.w=dot(e,vec2(0.5));}return coord.zw;}vec2 searchDiag2(const in vec2 texCoord,const in vec2 dir,out vec2 e){vec4 coord=vec4(texCoord,-1.0,1.0);coord.x+=0.25*texelSize.x;vec3 t=vec3(texelSize,1.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(coord.z<float(MAX_SEARCH_STEPS_DIAG_INT-1)&&coord.w>0.9)){break;}coord.xyz=t*vec3(dir,1.0)+coord.xyz;e=texture2D(inputBuffer,coord.xy).rg;e=decodeDiagBilinearAccess(e);coord.w=dot(e,vec2(0.5));}return coord.zw;}vec2 areaDiag(const in vec2 dist,const in vec2 e,const in float offset){vec2 texCoord=vec2(AREATEX_MAX_DISTANCE_DIAG,AREATEX_MAX_DISTANCE_DIAG)*e+dist;texCoord=AREATEX_PIXEL_SIZE*texCoord+0.5*AREATEX_PIXEL_SIZE;texCoord.x+=0.5;texCoord.y+=AREATEX_SUBTEX_SIZE*offset;return texture2D(areaTexture,texCoord).rg;}vec2 calculateDiagWeights(const in vec2 texCoord,const in vec2 e,const in vec4 subsampleIndices){vec2 weights=vec2(0.0);vec4 d;vec2 end;if(e.r>0.0){d.xz=searchDiag1(texCoord,vec2(-1.0,1.0),end);d.x+=float(end.y>0.9);}else{d.xz=vec2(0.0);}d.yw=searchDiag1(texCoord,vec2(1.0,-1.0),end);if(d.x+d.y>2.0){vec4 coords=vec4(-d.x+0.25,d.x,d.y,-d.y-0.25)*texelSize.xyxy+texCoord.xyxy;vec4 c;c.xy=sampleLevelZeroOffset(inputBuffer,coords.xy,vec2(-1,0)).rg;c.zw=sampleLevelZeroOffset(inputBuffer,coords.zw,vec2(1,0)).rg;c.yxwz=decodeDiagBilinearAccess(c.xyzw);vec2 cc=vec2(2.0)*c.xz+c.yw;movec(bvec2(step(0.9,d.zw)),cc,vec2(0.0));weights+=areaDiag(d.xy,cc,subsampleIndices.z);}d.xz=searchDiag2(texCoord,vec2(-1.0,-1.0),end);if(sampleLevelZeroOffset(inputBuffer,texCoord,vec2(1,0)).r>0.0){d.yw=searchDiag2(texCoord,vec2(1.0),end);d.y+=float(end.y>0.9);}else{d.yw=vec2(0.0);}if(d.x+d.y>2.0){vec4 coords=vec4(-d.x,-d.x,d.y,d.y)*texelSize.xyxy+texCoord.xyxy;vec4 c;c.x=sampleLevelZeroOffset(inputBuffer,coords.xy,vec2(-1,0)).g;c.y=sampleLevelZeroOffset(inputBuffer,coords.xy,vec2(0,-1)).r;c.zw=sampleLevelZeroOffset(inputBuffer,coords.zw,vec2(1,0)).gr;vec2 cc=vec2(2.0)*c.xz+c.yw;movec(bvec2(step(0.9,d.zw)),cc,vec2(0.0));weights+=areaDiag(d.xy,cc,subsampleIndices.w).gr;}return weights;}float searchLength(const in vec2 e,const in float offset){vec2 scale=SEARCHTEX_SIZE*vec2(0.5,-1.0);vec2 bias=SEARCHTEX_SIZE*vec2(offset,1.0);scale+=vec2(-1.0,1.0);bias+=vec2(0.5,-0.5);scale*=1.0/SEARCHTEX_PACKED_SIZE;bias*=1.0/SEARCHTEX_PACKED_SIZE;return texture2D(searchTexture,scale*e+bias).r;}float searchXLeft(in vec2 texCoord,const in float end){vec2 e=vec2(0.0,1.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(texCoord.x>end&&e.g>0.8281&&e.r==0.0)){break;}e=texture2D(inputBuffer,texCoord).rg;texCoord=vec2(-2.0,0.0)*texelSize+texCoord;}float offset=-(255.0/127.0)*searchLength(e,0.0)+3.25;return texelSize.x*offset+texCoord.x;}float searchXRight(vec2 texCoord,const in float end){vec2 e=vec2(0.0,1.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(texCoord.x<end&&e.g>0.8281&&e.r==0.0)){break;}e=texture2D(inputBuffer,texCoord).rg;texCoord=vec2(2.0,0.0)*texelSize.xy+texCoord;}float offset=-(255.0/127.0)*searchLength(e,0.5)+3.25;return-texelSize.x*offset+texCoord.x;}float searchYUp(vec2 texCoord,const in float end){vec2 e=vec2(1.0,0.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(texCoord.y>end&&e.r>0.8281&&e.g==0.0)){break;}e=texture2D(inputBuffer,texCoord).rg;texCoord=-vec2(0.0,2.0)*texelSize.xy+texCoord;}float offset=-(255.0/127.0)*searchLength(e.gr,0.0)+3.25;return texelSize.y*offset+texCoord.y;}float searchYDown(vec2 texCoord,const in float end){vec2 e=vec2(1.0,0.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;i++){if(!(texCoord.y<end&&e.r>0.8281&&e.g==0.0)){break;}e=texture2D(inputBuffer,texCoord).rg;texCoord=vec2(0.0,2.0)*texelSize.xy+texCoord;}float offset=-(255.0/127.0)*searchLength(e.gr,0.5)+3.25;return-texelSize.y*offset+texCoord.y;}vec2 area(const in vec2 dist,const in float e1,const in float e2,const in float offset){vec2 texCoord=vec2(AREATEX_MAX_DISTANCE)*round(4.0*vec2(e1,e2))+dist;texCoord=AREATEX_PIXEL_SIZE*texCoord+0.5*AREATEX_PIXEL_SIZE;texCoord.y=AREATEX_SUBTEX_SIZE*offset+texCoord.y;return texture2D(areaTexture,texCoord).rg;}void detectHorizontalCornerPattern(inout vec2 weights,const in vec4 texCoord,const in vec2 d){\n#if !defined(DISABLE_CORNER_DETECTION)\nvec2 leftRight=step(d.xy,d.yx);vec2 rounding=(1.0-CORNER_ROUNDING_NORM)*leftRight;rounding/=leftRight.x+leftRight.y;vec2 factor=vec2(1.0);factor.x-=rounding.x*sampleLevelZeroOffset(inputBuffer,texCoord.xy,vec2(0,1)).r;factor.x-=rounding.y*sampleLevelZeroOffset(inputBuffer,texCoord.zw,vec2(1,1)).r;factor.y-=rounding.x*sampleLevelZeroOffset(inputBuffer,texCoord.xy,vec2(0,-2)).r;factor.y-=rounding.y*sampleLevelZeroOffset(inputBuffer,texCoord.zw,vec2(1,-2)).r;weights*=clamp(factor,0.0,1.0);\n#endif\n}void detectVerticalCornerPattern(inout vec2 weights,const in vec4 texCoord,const in vec2 d){\n#if !defined(DISABLE_CORNER_DETECTION)\nvec2 leftRight=step(d.xy,d.yx);vec2 rounding=(1.0-CORNER_ROUNDING_NORM)*leftRight;rounding/=leftRight.x+leftRight.y;vec2 factor=vec2(1.0);factor.x-=rounding.x*sampleLevelZeroOffset(inputBuffer,texCoord.xy,vec2(1,0)).g;factor.x-=rounding.y*sampleLevelZeroOffset(inputBuffer,texCoord.zw,vec2(1,1)).g;factor.y-=rounding.x*sampleLevelZeroOffset(inputBuffer,texCoord.xy,vec2(-2,0)).g;factor.y-=rounding.y*sampleLevelZeroOffset(inputBuffer,texCoord.zw,vec2(-2,1)).g;weights*=clamp(factor,0.0,1.0);\n#endif\n}void main(){vec4 weights=vec4(0.0);vec4 subsampleIndices=vec4(0.0);vec2 e=texture2D(inputBuffer,vUv).rg;if(e.g>0.0){\n#if !defined(DISABLE_DIAG_DETECTION)\nweights.rg=calculateDiagWeights(vUv,e,subsampleIndices);if(weights.r==-weights.g){\n#endif\nvec2 d;vec3 coords;coords.x=searchXLeft(vOffset[0].xy,vOffset[2].x);coords.y=vOffset[1].y;d.x=coords.x;float e1=texture2D(inputBuffer,coords.xy).r;coords.z=searchXRight(vOffset[0].zw,vOffset[2].y);d.y=coords.z;d=round(resolution.xx*d+-vPixCoord.xx);vec2 sqrtD=sqrt(abs(d));float e2=sampleLevelZeroOffset(inputBuffer,coords.zy,vec2(1,0)).r;weights.rg=area(sqrtD,e1,e2,subsampleIndices.y);coords.y=vUv.y;detectHorizontalCornerPattern(weights.rg,coords.xyzy,d);\n#if !defined(DISABLE_DIAG_DETECTION)\n}else{e.r=0.0;}\n#endif\n}if(e.r>0.0){vec2 d;vec3 coords;coords.y=searchYUp(vOffset[1].xy,vOffset[2].z);coords.x=vOffset[0].x;d.x=coords.y;float e1=texture2D(inputBuffer,coords.xy).g;coords.z=searchYDown(vOffset[1].zw,vOffset[2].w);d.y=coords.z;d=round(resolution.yy*d-vPixCoord.yy);vec2 sqrtD=sqrt(abs(d));float e2=sampleLevelZeroOffset(inputBuffer,coords.xz,vec2(0,1)).g;weights.ba=area(sqrtD,e1,e2,subsampleIndices.x);coords.x=vUv.x;detectVerticalCornerPattern(weights.ba,coords.xyxz,d);}gl_FragColor=weights;}",
                    vertexShader: "uniform vec2 texelSize;uniform vec2 resolution;varying vec2 vUv;varying vec4 vOffset[3];varying vec2 vPixCoord;void main(){vUv=position.xy*0.5+0.5;vPixCoord=vUv*resolution;vOffset[0]=vUv.xyxy+texelSize.xyxy*vec4(-0.25,-0.125,1.25,-0.125);vOffset[1]=vUv.xyxy+texelSize.xyxy*vec4(-0.125,-0.25,-0.125,1.25);vOffset[2]=vec4(vOffset[0].xz,vOffset[1].yw)+vec4(-2.0,2.0,-2.0,2.0)*texelSize.xxyy*MAX_SEARCH_STEPS_FLOAT;gl_Position=vec4(position.xy,1.0,1.0);}"
                })
            }
            set inputBuffer(e) {
                this.uniforms.inputBuffer.value = e
            }
            setInputBuffer(e) {
                this.uniforms.inputBuffer.value = e
            }
            get searchTexture() {
                return this.uniforms.searchTexture.value
            }
            set searchTexture(e) {
                this.uniforms.searchTexture.value = e
            }
            get areaTexture() {
                return this.uniforms.areaTexture.value
            }
            set areaTexture(e) {
                this.uniforms.areaTexture.value = e
            }
            setLookupTextures(e, t) {
                this.searchTexture = e,
                this.areaTexture = t
            }
            get orthogonalSearchSteps() {
                return Number(this.defines.MAX_SEARCH_STEPS_INT)
            }
            set orthogonalSearchSteps(e) {
                const t = Math.min(Math.max(e, 0), 112);
                this.defines.MAX_SEARCH_STEPS_INT = t.toFixed("0"),
                this.defines.MAX_SEARCH_STEPS_FLOAT = t.toFixed("1"),
                this.needsUpdate = !0
            }
            setOrthogonalSearchSteps(e) {
                this.orthogonalSearchSteps = e
            }
            get diagonalSearchSteps() {
                return Number(this.defines.MAX_SEARCH_STEPS_DIAG_INT)
            }
            set diagonalSearchSteps(e) {
                const t = Math.min(Math.max(e, 0), 20);
                this.defines.MAX_SEARCH_STEPS_DIAG_INT = t.toFixed("0"),
                this.defines.MAX_SEARCH_STEPS_DIAG_FLOAT = t.toFixed("1"),
                this.needsUpdate = !0
            }
            setDiagonalSearchSteps(e) {
                this.diagonalSearchSteps = e
            }
            get diagonalDetection() {
                return void 0 === this.defines.DISABLE_DIAG_DETECTION
            }
            set diagonalDetection(e) {
                e ? delete this.defines.DISABLE_DIAG_DETECTION : this.defines.DISABLE_DIAG_DETECTION = "1",
                this.needsUpdate = !0
            }
            isDiagonalDetectionEnabled() {
                return this.diagonalDetection
            }
            setDiagonalDetectionEnabled(e) {
                this.diagonalDetection = e
            }
            get cornerRounding() {
                return Number(this.defines.CORNER_ROUNDING)
            }
            set cornerRounding(e) {
                const t = Math.min(Math.max(e, 0), 100);
                this.defines.CORNER_ROUNDING = t.toFixed("4"),
                this.defines.CORNER_ROUNDING_NORM = (t / 100).toFixed("4"),
                this.needsUpdate = !0
            }
            setCornerRounding(e) {
                this.cornerRounding = e
            }
            get cornerDetection() {
                return void 0 === this.defines.DISABLE_CORNER_DETECTION
            }
            set cornerDetection(e) {
                e ? delete this.defines.DISABLE_CORNER_DETECTION : this.defines.DISABLE_CORNER_DETECTION = "1",
                this.needsUpdate = !0
            }
            isCornerRoundingEnabled() {
                return this.cornerDetection
            }
            setCornerRoundingEnabled(e) {
                this.cornerDetection = e
            }
            setSize(e, t) {
                const n = this.uniforms;
                n.texelSize.value.set(1 / e, 1 / t),
                n.resolution.value.set(e, t)
            }
        }
          , Oe = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAAAQCAYAAACm53kpAAAAeElEQVRYR+2XSwqAMAxEJ168ePEqwRSKhIIiuHjJqiU0gWE+1CQdApcVAMUAuARaMGCX1MIL/Ow13++9lW2s3mW9MWvsnWc/2fvGygwPAN4E8QzAA4CXAB6AHjG4JTHYI1ey3pcx6FHnEfhLDOIBKAmUBK6/ANUDTlROXAHd9EC1AAAAAElFTkSuQmCC"
          , Qe = "data:image/png;base64,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"
          , ke = class extends j {
            constructor({blendFunction: e=P, preset: t=xe, edgeDetectionMode: n=me, predicationMode: r=ve}={}) {
                let s, a;
                super("SMAAEffect", "uniform sampler2D weightMap;varying vec2 vOffset0;varying vec2 vOffset1;void movec(const in bvec2 c,inout vec2 variable,const in vec2 value){if(c.x){variable.x=value.x;}if(c.y){variable.y=value.y;}}void movec(const in bvec4 c,inout vec4 variable,const in vec4 value){movec(c.xy,variable.xy,value.xy);movec(c.zw,variable.zw,value.zw);}void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec4 a;a.x=texture2D(weightMap,vOffset0).a;a.y=texture2D(weightMap,vOffset1).g;a.wz=texture2D(weightMap,uv).rb;vec4 color=inputColor;if(dot(a,vec4(1.0))>=1e-5){bool h=max(a.x,a.z)>max(a.y,a.w);vec4 blendingOffset=vec4(0.0,a.y,0.0,a.w);vec2 blendingWeight=a.yw;movec(bvec4(h),blendingOffset,vec4(a.x,0.0,a.z,0.0));movec(bvec2(h),blendingWeight,a.xz);blendingWeight/=dot(blendingWeight,vec2(1.0));vec4 blendingCoord=blendingOffset*vec4(texelSize,-texelSize)+uv.xyxy;color=blendingWeight.x*texture2D(inputBuffer,blendingCoord.xy);color+=blendingWeight.y*texture2D(inputBuffer,blendingCoord.zw);}outputColor=color;}", {
                    vertexShader: "varying vec2 vOffset0;varying vec2 vOffset1;void mainSupport(const in vec2 uv){vOffset0=uv+texelSize*vec2(1.0,0.0);vOffset1=uv+texelSize*vec2(0.0,1.0);}",
                    blendFunction: e,
                    attributes: g.CONVOLUTION | g.DEPTH,
                    uniforms: new Map([["weightMap", new i.nc$(null)]])
                }),
                arguments.length > 1 && (s = arguments[0],
                a = arguments[1],
                arguments.length > 2 && (t = arguments[2]),
                arguments.length > 3 && (n = arguments[3])),
                this.renderTargetEdges = new i.nWS(1,1,{
                    depthBuffer: !1
                }),
                this.renderTargetEdges.texture.name = "SMAA.Edges",
                this.renderTargetWeights = this.renderTargetEdges.clone(),
                this.renderTargetWeights.texture.name = "SMAA.Weights",
                this.uniforms.get("weightMap").value = this.renderTargetWeights.texture,
                this.clearPass = new p(!0,!1,!1),
                this.clearPass.overrideClearColor = new i.Q1f(0),
                this.clearPass.overrideClearAlpha = 1,
                this.edgeDetectionPass = new se(new Fe),
                this.edgeDetectionMaterial.edgeDetectionMode = n,
                this.edgeDetectionMaterial.predicationMode = r,
                this.weightsPass = new se(new Ne);
                const o = new i.KPJ;
                o.onLoad = () => {
                    const e = new i.gPd(s);
                    e.name = "SMAA.Search",
                    e.magFilter = i.hxR,
                    e.minFilter = i.hxR,
                    e.generateMipmaps = !1,
                    e.needsUpdate = !0,
                    e.flipY = !0,
                    this.weightsMaterial.searchTexture = e;
                    const t = new i.gPd(a);
                    t.name = "SMAA.Area",
                    t.magFilter = i.k6q,
                    t.minFilter = i.k6q,
                    t.generateMipmaps = !1,
                    t.needsUpdate = !0,
                    t.flipY = !1,
                    this.weightsMaterial.areaTexture = t,
                    this.dispatchEvent({
                        type: "load"
                    })
                }
                ,
                o.itemStart("search"),
                o.itemStart("area"),
                void 0 !== s && void 0 !== a ? (o.itemEnd("search"),
                o.itemEnd("area")) : "undefined" != typeof Image && (s = new Image,
                a = new Image,
                s.addEventListener("load", ( () => o.itemEnd("search"))),
                a.addEventListener("load", ( () => o.itemEnd("area"))),
                s.src = Oe,
                a.src = Qe),
                this.applyPreset(t)
            }
            get edgesTexture() {
                return this.renderTargetEdges.texture
            }
            getEdgesTexture() {
                return this.edgesTexture
            }
            get weightsTexture() {
                return this.renderTargetWeights.texture
            }
            getWeightsTexture() {
                return this.weightsTexture
            }
            get edgeDetectionMaterial() {
                return this.edgeDetectionPass.fullscreenMaterial
            }
            get colorEdgesMaterial() {
                return this.edgeDetectionMaterial
            }
            getEdgeDetectionMaterial() {
                return this.edgeDetectionMaterial
            }
            get weightsMaterial() {
                return this.weightsPass.fullscreenMaterial
            }
            getWeightsMaterial() {
                return this.weightsMaterial
            }
            setEdgeDetectionThreshold(e) {
                this.edgeDetectionMaterial.edgeDetectionThreshold = e
            }
            setOrthogonalSearchSteps(e) {
                this.weightsMaterial.orthogonalSearchSteps = e
            }
            applyPreset(e) {
                const t = this.edgeDetectionMaterial
                  , n = this.weightsMaterial;
                switch (e) {
                case ye:
                    t.edgeDetectionThreshold = .15,
                    n.orthogonalSearchSteps = 4,
                    n.diagonalDetection = !1,
                    n.cornerDetection = !1;
                    break;
                case xe:
                    t.edgeDetectionThreshold = .1,
                    n.orthogonalSearchSteps = 8,
                    n.diagonalDetection = !1,
                    n.cornerDetection = !1;
                    break;
                case _e:
                    t.edgeDetectionThreshold = .1,
                    n.orthogonalSearchSteps = 16,
                    n.diagonalSearchSteps = 8,
                    n.cornerRounding = 25,
                    n.diagonalDetection = !0,
                    n.cornerDetection = !0;
                    break;
                case be:
                    t.edgeDetectionThreshold = .05,
                    n.orthogonalSearchSteps = 32,
                    n.diagonalSearchSteps = 16,
                    n.cornerRounding = 25,
                    n.diagonalDetection = !0,
                    n.cornerDetection = !0
                }
            }
            setDepthTexture(e, t=i.Rkk) {
                this.edgeDetectionMaterial.depthBuffer = e,
                this.edgeDetectionMaterial.depthPacking = t
            }
            update(e, t, n) {
                this.clearPass.render(e, this.renderTargetEdges),
                this.edgeDetectionPass.render(e, t, this.renderTargetEdges),
                this.weightsPass.render(e, this.renderTargetEdges, this.renderTargetWeights)
            }
            setSize(e, t) {
                this.edgeDetectionMaterial.setSize(e, t),
                this.weightsMaterial.setSize(e, t),
                this.renderTargetEdges.setSize(e, t),
                this.renderTargetWeights.setSize(e, t)
            }
            dispose() {
                const {searchTexture: e, areaTexture: t} = this.weightsMaterial;
                null !== e && null !== t && (e.dispose(),
                t.dispose()),
                super.dispose()
            }
            static get searchImageDataURL() {
                return Oe
            }
            static get areaImageDataURL() {
                return Qe
            }
        }
          , Ge = class extends i.BKk {
            constructor(e) {
                super({
                    name: "SSAOMaterial",
                    defines: {
                        SAMPLES_INT: "0",
                        INV_SAMPLES_FLOAT: "0.0",
                        SPIRAL_TURNS: "0.0",
                        RADIUS: "1.0",
                        RADIUS_SQ: "1.0",
                        DISTANCE_SCALING: "1",
                        DEPTH_PACKING: "0"
                    },
                    uniforms: {
                        depthBuffer: new i.nc$(null),
                        normalBuffer: new i.nc$(null),
                        normalDepthBuffer: new i.nc$(null),
                        noiseTexture: new i.nc$(null),
                        inverseProjectionMatrix: new i.nc$(new i.kn4),
                        projectionMatrix: new i.nc$(new i.kn4),
                        texelSize: new i.nc$(new i.I9Y),
                        cameraNearFar: new i.nc$(new i.I9Y),
                        distanceCutoff: new i.nc$(new i.I9Y),
                        proximityCutoff: new i.nc$(new i.I9Y),
                        noiseScale: new i.nc$(new i.I9Y),
                        minRadiusScale: new i.nc$(.33),
                        intensity: new i.nc$(1),
                        fade: new i.nc$(.01),
                        bias: new i.nc$(0)
                    },
                    blending: i.XIg,
                    toneMapped: !1,
                    depthWrite: !1,
                    depthTest: !1,
                    fragmentShader: "#include <common>\n#include <packing>\n#ifdef NORMAL_DEPTH\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nuniform highp sampler2D normalDepthBuffer;\n#else\nuniform mediump sampler2D normalDepthBuffer;\n#endif\nfloat readDepth(const in vec2 uv){return texture2D(normalDepthBuffer,uv).a;}\n#else\nuniform lowp sampler2D normalBuffer;\n#if DEPTH_PACKING == 3201\nuniform lowp sampler2D depthBuffer;\n#elif defined(GL_FRAGMENT_PRECISION_HIGH)\nuniform highp sampler2D depthBuffer;\n#else\nuniform mediump sampler2D depthBuffer;\n#endif\nfloat readDepth(const in vec2 uv){\n#if DEPTH_PACKING == 3201\nreturn unpackRGBAToDepth(texture2D(depthBuffer,uv));\n#else\nreturn texture2D(depthBuffer,uv).r;\n#endif\n}\n#endif\nuniform lowp sampler2D noiseTexture;uniform mat4 inverseProjectionMatrix;uniform mat4 projectionMatrix;uniform vec2 texelSize;uniform vec2 cameraNearFar;uniform float intensity;uniform float minRadiusScale;uniform float fade;uniform float bias;uniform vec2 distanceCutoff;uniform vec2 proximityCutoff;varying vec2 vUv;varying vec2 vUv2;float getViewZ(const in float depth){\n#ifdef PERSPECTIVE_CAMERA\nreturn perspectiveDepthToViewZ(depth,cameraNearFar.x,cameraNearFar.y);\n#else\nreturn orthographicDepthToViewZ(depth,cameraNearFar.x,cameraNearFar.y);\n#endif\n}vec3 getViewPosition(const in vec2 screenPosition,const in float depth,const in float viewZ){vec4 clipPosition=vec4(vec3(screenPosition,depth)*2.0-1.0,1.0);float clipW=projectionMatrix[2][3]*viewZ+projectionMatrix[3][3];clipPosition*=clipW;return(inverseProjectionMatrix*clipPosition).xyz;}float getAmbientOcclusion(const in vec3 p,const in vec3 n,const in float depth,const in vec2 uv){float radiusScale=1.0-smoothstep(0.0,distanceCutoff.y,depth);radiusScale=radiusScale*(1.0-minRadiusScale)+minRadiusScale;float radius=RADIUS*radiusScale;float noise=texture2D(noiseTexture,vUv2).r;float baseAngle=noise*PI2;float rings=SPIRAL_TURNS*PI2;float occlusion=0.0;int taps=0;for(int i=0;i<SAMPLES_INT;++i){float alpha=(float(i)+0.5)*INV_SAMPLES_FLOAT;float angle=alpha*rings+baseAngle;vec2 rotation=vec2(cos(angle),sin(angle));vec2 coords=alpha*radius*rotation*texelSize+uv;if(coords.s<0.0||coords.s>1.0||coords.t<0.0||coords.t>1.0){continue;}float sampleDepth=readDepth(coords);float viewZ=getViewZ(sampleDepth);\n#ifdef PERSPECTIVE_CAMERA\nfloat linearSampleDepth=viewZToOrthographicDepth(viewZ,cameraNearFar.x,cameraNearFar.y);\n#else\nfloat linearSampleDepth=sampleDepth;\n#endif\nfloat proximity=abs(depth-linearSampleDepth);if(proximity<proximityCutoff.y){float falloff=1.0-smoothstep(proximityCutoff.x,proximityCutoff.y,proximity);vec3 Q=getViewPosition(coords,sampleDepth,viewZ);vec3 v=Q-p;float vv=dot(v,v);float vn=dot(v,n)-bias;float f=max(RADIUS_SQ-vv,0.0)/RADIUS_SQ;occlusion+=(f*f*f*max(vn/(fade+vv),0.0))*falloff;}++taps;}return occlusion/(4.0*max(float(taps),1.0));}void main(){\n#ifdef NORMAL_DEPTH\nvec4 normalDepth=texture2D(normalDepthBuffer,vUv);\n#else\nvec4 normalDepth=vec4(texture2D(normalBuffer,vUv).xyz,readDepth(vUv));\n#endif\nfloat ao=0.0;float depth=normalDepth.a;float viewZ=getViewZ(depth);\n#ifdef PERSPECTIVE_CAMERA\nfloat linearDepth=viewZToOrthographicDepth(viewZ,cameraNearFar.x,cameraNearFar.y);\n#else\nfloat linearDepth=depth;\n#endif\nif(linearDepth<distanceCutoff.y){vec3 viewPosition=getViewPosition(vUv,depth,viewZ);vec3 viewNormal=unpackRGBToNormal(normalDepth.rgb);ao+=getAmbientOcclusion(viewPosition,viewNormal,linearDepth,vUv);float d=smoothstep(distanceCutoff.x,distanceCutoff.y,linearDepth);ao=mix(ao,0.0,d);\n#ifdef LEGACY_INTENSITY\nao=clamp(1.0-pow(1.0-ao,abs(intensity)),0.0,1.0);\n#endif\n}gl_FragColor.r=ao;}",
                    vertexShader: "uniform vec2 noiseScale;varying vec2 vUv;varying vec2 vUv2;void main(){vUv=position.xy*0.5+0.5;vUv2=vUv*noiseScale;gl_Position=vec4(position.xy,1.0,1.0);}"
                }),
                this.copyCameraSettings(e),
                this.resolution = new i.I9Y,
                this.r = 1
            }
            get near() {
                return this.uniforms.cameraNearFar.value.x
            }
            get far() {
                return this.uniforms.cameraNearFar.value.y
            }
            set normalDepthBuffer(e) {
                this.uniforms.normalDepthBuffer.value = e,
                null !== e ? this.defines.NORMAL_DEPTH = "1" : delete this.defines.NORMAL_DEPTH,
                this.needsUpdate = !0
            }
            setNormalDepthBuffer(e) {
                this.normalDepthBuffer = e
            }
            set normalBuffer(e) {
                this.uniforms.normalBuffer.value = e
            }
            setNormalBuffer(e) {
                this.uniforms.normalBuffer.value = e
            }
            set depthBuffer(e) {
                this.uniforms.depthBuffer.value = e
            }
            set depthPacking(e) {
                this.defines.DEPTH_PACKING = e.toFixed(0),
                this.needsUpdate = !0
            }
            setDepthBuffer(e, t=i.Rkk) {
                this.depthBuffer = e,
                this.depthPacking = t
            }
            set noiseTexture(e) {
                this.uniforms.noiseTexture.value = e
            }
            setNoiseTexture(e) {
                this.uniforms.noiseTexture.value = e
            }
            get samples() {
                return Number(this.defines.SAMPLES_INT)
            }
            set samples(e) {
                this.defines.SAMPLES_INT = e.toFixed(0),
                this.defines.INV_SAMPLES_FLOAT = (1 / e).toFixed(9),
                this.needsUpdate = !0
            }
            getSamples() {
                return this.samples
            }
            setSamples(e) {
                this.samples = e
            }
            get rings() {
                return Number(this.defines.SPIRAL_TURNS)
            }
            set rings(e) {
                this.defines.SPIRAL_TURNS = e.toFixed(1),
                this.needsUpdate = !0
            }
            getRings() {
                return this.rings
            }
            setRings(e) {
                this.rings = e
            }
            get intensity() {
                return this.uniforms.intensity.value
            }
            set intensity(e) {
                this.uniforms.intensity.value = e,
                void 0 === this.defines.LEGACY_INTENSITY && (this.defines.LEGACY_INTENSITY = "1",
                this.needsUpdate = !0)
            }
            getIntensity() {
                return this.uniforms.intensity.value
            }
            setIntensity(e) {
                this.uniforms.intensity.value = e
            }
            get fade() {
                return this.uniforms.fade.value
            }
            set fade(e) {
                this.uniforms.fade.value = e
            }
            getFade() {
                return this.uniforms.fade.value
            }
            setFade(e) {
                this.uniforms.fade.value = e
            }
            get bias() {
                return this.uniforms.bias.value
            }
            set bias(e) {
                this.uniforms.bias.value = e
            }
            getBias() {
                return this.uniforms.bias.value
            }
            setBias(e) {
                this.uniforms.bias.value = e
            }
            get minRadiusScale() {
                return this.uniforms.minRadiusScale.value
            }
            set minRadiusScale(e) {
                this.uniforms.minRadiusScale.value = e
            }
            getMinRadiusScale() {
                return this.uniforms.minRadiusScale.value
            }
            setMinRadiusScale(e) {
                this.uniforms.minRadiusScale.value = e
            }
            updateRadius() {
                const e = this.r * this.resolution.height;
                this.defines.RADIUS = e.toFixed(11),
                this.defines.RADIUS_SQ = (e * e).toFixed(11),
                this.needsUpdate = !0
            }
            get radius() {
                return this.r
            }
            set radius(e) {
                this.r = Math.min(Math.max(e, 1e-6), 1),
                this.updateRadius()
            }
            getRadius() {
                return this.radius
            }
            setRadius(e) {
                this.radius = e
            }
            get distanceScaling() {
                return !0
            }
            set distanceScaling(e) {}
            isDistanceScalingEnabled() {
                return this.distanceScaling
            }
            setDistanceScalingEnabled(e) {
                this.distanceScaling = e
            }
            get distanceThreshold() {
                return this.uniforms.distanceCutoff.value.x
            }
            set distanceThreshold(e) {
                this.uniforms.distanceCutoff.value.set(Math.min(Math.max(e, 0), 1), Math.min(Math.max(e + this.distanceFalloff, 0), 1))
            }
            get worldDistanceThreshold() {
                return -te(this.distanceThreshold, this.near, this.far)
            }
            set worldDistanceThreshold(e) {
                this.distanceThreshold = ne(-e, this.near, this.far)
            }
            get distanceFalloff() {
                return this.uniforms.distanceCutoff.value.y - this.distanceThreshold
            }
            set distanceFalloff(e) {
                this.uniforms.distanceCutoff.value.y = Math.min(Math.max(this.distanceThreshold + e, 0), 1)
            }
            get worldDistanceFalloff() {
                return -te(this.distanceFalloff, this.near, this.far)
            }
            set worldDistanceFalloff(e) {
                this.distanceFalloff = ne(-e, this.near, this.far)
            }
            setDistanceCutoff(e, t) {
                this.uniforms.distanceCutoff.value.set(Math.min(Math.max(e, 0), 1), Math.min(Math.max(e + t, 0), 1))
            }
            get proximityThreshold() {
                return this.uniforms.proximityCutoff.value.x
            }
            set proximityThreshold(e) {
                this.uniforms.proximityCutoff.value.set(Math.min(Math.max(e, 0), 1), Math.min(Math.max(e + this.proximityFalloff, 0), 1))
            }
            get worldProximityThreshold() {
                return -te(this.proximityThreshold, this.near, this.far)
            }
            set worldProximityThreshold(e) {
                this.proximityThreshold = ne(-e, this.near, this.far)
            }
            get proximityFalloff() {
                return this.uniforms.proximityCutoff.value.y - this.proximityThreshold
            }
            set proximityFalloff(e) {
                this.uniforms.proximityCutoff.value.y = Math.min(Math.max(this.proximityThreshold + e, 0), 1)
            }
            get worldProximityFalloff() {
                return -te(this.proximityFalloff, this.near, this.far)
            }
            set worldProximityFalloff(e) {
                this.proximityFalloff = ne(-e, this.near, this.far)
            }
            setProximityCutoff(e, t) {
                this.uniforms.proximityCutoff.value.set(Math.min(Math.max(e, 0), 1), Math.min(Math.max(e + t, 0), 1))
            }
            setTexelSize(e, t) {
                this.uniforms.texelSize.value.set(e, t)
            }
            adoptCameraSettings(e) {
                this.copyCameraSettings(e)
            }
            copyCameraSettings(e) {
                e && (this.uniforms.cameraNearFar.value.set(e.near, e.far),
                this.uniforms.projectionMatrix.value.copy(e.projectionMatrix),
                this.uniforms.inverseProjectionMatrix.value.copy(e.projectionMatrix).invert(),
                e instanceof i.ubm ? this.defines.PERSPECTIVE_CAMERA = "1" : delete this.defines.PERSPECTIVE_CAMERA,
                this.needsUpdate = !0)
            }
            setSize(e, t) {
                const n = this.uniforms
                  , i = n.noiseTexture.value;
                null !== i && n.noiseScale.value.set(e / i.image.width, t / i.image.height),
                n.texelSize.value.set(1 / e, 1 / t),
                this.resolution.set(e, t),
                this.updateRadius()
            }
        }
          , He = class extends i.BKk {
            constructor() {
                super({
                    name: "DepthDownsamplingMaterial",
                    defines: {
                        DEPTH_PACKING: "0"
                    },
                    uniforms: {
                        depthBuffer: new i.nc$(null),
                        normalBuffer: new i.nc$(null),
                        texelSize: new i.nc$(new i.I9Y)
                    },
                    blending: i.XIg,
                    toneMapped: !1,
                    depthWrite: !1,
                    depthTest: !1,
                    fragmentShader: "#include <packing>\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nuniform highp sampler2D depthBuffer;\n#else\nuniform mediump sampler2D depthBuffer;\n#endif\n#ifdef DOWNSAMPLE_NORMALS\nuniform lowp sampler2D normalBuffer;\n#endif\nvarying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;float readDepth(const in vec2 uv){\n#if DEPTH_PACKING == 3201\nreturn unpackRGBAToDepth(texture2D(depthBuffer,uv));\n#else\nreturn texture2D(depthBuffer,uv).r;\n#endif\n}int findBestDepth(const in float samples[4]){float c=(samples[0]+samples[1]+samples[2]+samples[3])*0.25;float distances[4];distances[0]=abs(c-samples[0]);distances[1]=abs(c-samples[1]);distances[2]=abs(c-samples[2]);distances[3]=abs(c-samples[3]);float maxDistance=max(max(distances[0],distances[1]),max(distances[2],distances[3]));int remaining[3];int rejected[3];int i,j,k;for(i=0,j=0,k=0;i<4;++i){if(distances[i]<maxDistance){remaining[j++]=i;}else{rejected[k++]=i;}}for(;j<3;++j){remaining[j]=rejected[--k];}vec3 s=vec3(samples[remaining[0]],samples[remaining[1]],samples[remaining[2]]);c=(s.x+s.y+s.z)/3.0;distances[0]=abs(c-s.x);distances[1]=abs(c-s.y);distances[2]=abs(c-s.z);float minDistance=min(distances[0],min(distances[1],distances[2]));for(i=0;i<3;++i){if(distances[i]==minDistance){break;}}return remaining[i];}void main(){float d[4];d[0]=readDepth(vUv0);d[1]=readDepth(vUv1);d[2]=readDepth(vUv2);d[3]=readDepth(vUv3);int index=findBestDepth(d);\n#ifdef DOWNSAMPLE_NORMALS\nvec3 n[4];n[0]=texture2D(normalBuffer,vUv0).rgb;n[1]=texture2D(normalBuffer,vUv1).rgb;n[2]=texture2D(normalBuffer,vUv2).rgb;n[3]=texture2D(normalBuffer,vUv3).rgb;\n#else\nvec3 n[4];n[0]=vec3(0.0);n[1]=vec3(0.0);n[2]=vec3(0.0);n[3]=vec3(0.0);\n#endif\ngl_FragColor=vec4(n[index],d[index]);}",
                    vertexShader: "uniform vec2 texelSize;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec2 uv=position.xy*0.5+0.5;vUv0=uv;vUv1=vec2(uv.x,uv.y+texelSize.y);vUv2=vec2(uv.x+texelSize.x,uv.y);vUv3=uv+texelSize;gl_Position=vec4(position.xy,1.0,1.0);}"
                })
            }
            set depthBuffer(e) {
                this.uniforms.depthBuffer.value = e
            }
            set depthPacking(e) {
                this.defines.DEPTH_PACKING = e.toFixed(0),
                this.needsUpdate = !0
            }
            setDepthBuffer(e, t=i.Rkk) {
                this.depthBuffer = e,
                this.depthPacking = t
            }
            set normalBuffer(e) {
                this.uniforms.normalBuffer.value = e,
                null !== e ? this.defines.DOWNSAMPLE_NORMALS = "1" : delete this.defines.DOWNSAMPLE_NORMALS,
                this.needsUpdate = !0
            }
            setNormalBuffer(e) {
                this.normalBuffer = e
            }
            setTexelSize(e, t) {
                this.uniforms.texelSize.value.set(e, t)
            }
            setSize(e, t) {
                this.uniforms.texelSize.value.set(1 / e, 1 / t)
            }
        }
          , ze = class extends o {
            constructor({normalBuffer: e=null, resolutionScale: t=.5, width: n=w.AUTO_SIZE, height: r=w.AUTO_SIZE, resolutionX: s=n, resolutionY: a=r}={}) {
                super("DepthDownsamplingPass");
                const o = new He;
                o.normalBuffer = e,
                this.fullscreenMaterial = o,
                this.needsDepthTexture = !0,
                this.needsSwap = !1,
                this.renderTarget = new i.nWS(1,1,{
                    minFilter: i.hxR,
                    magFilter: i.hxR,
                    depthBuffer: !1,
                    type: i.RQf
                }),
                this.renderTarget.texture.name = "DepthDownsamplingPass.Target",
                this.renderTarget.texture.generateMipmaps = !1;
                const l = this.resolution = new w(this,s,a,t);
                l.addEventListener("change", (e => this.setSize(l.baseWidth, l.baseHeight)))
            }
            get texture() {
                return this.renderTarget.texture
            }
            getTexture() {
                return this.renderTarget.texture
            }
            getResolution() {
                return this.resolution
            }
            setDepthTexture(e, t=i.Rkk) {
                this.fullscreenMaterial.depthBuffer = e,
                this.fullscreenMaterial.depthPacking = t
            }
            render(e, t, n, i, r) {
                e.setRenderTarget(this.renderToScreen ? null : this.renderTarget),
                e.render(this.scene, this.camera)
            }
            setSize(e, t) {
                const n = this.resolution;
                n.setBaseSize(e, t),
                this.renderTarget.setSize(n.width, n.height),
                this.fullscreenMaterial.setSize(e, t)
            }
            initialize(e, t, n) {
                const i = e.getContext();
                if (!(i.getExtension("EXT_color_buffer_float") || i.getExtension("EXT_color_buffer_half_float")))
                    throw new Error("Rendering to float texture is not supported.")
            }
        }
          , Ve = class extends j {
            constructor(e, t, {blendFunction: n=T, samples: r=9, rings: s=7, normalDepthBuffer: a=null, depthAwareUpsampling: o=!0, worldDistanceThreshold: l, worldDistanceFalloff: c, worldProximityThreshold: u, worldProximityFalloff: h, distanceThreshold: d=.97, distanceFalloff: p=.03, rangeThreshold: f=5e-4, rangeFalloff: A=.001, minRadiusScale: m=.1, luminanceInfluence: v=.7, radius: y=.1825, intensity: x=1, bias: _=.025, fade: b=.01, color: E=null, resolutionScale: C=1, width: I=w.AUTO_SIZE, height: S=w.AUTO_SIZE, resolutionX: M=I, resolutionY: B=S}={}) {
                super("SSAOEffect", "uniform lowp sampler2D aoBuffer;uniform float luminanceInfluence;uniform float intensity;\n#if defined(DEPTH_AWARE_UPSAMPLING) && defined(NORMAL_DEPTH)\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nuniform highp sampler2D normalDepthBuffer;\n#else\nuniform mediump sampler2D normalDepthBuffer;\n#endif\n#endif\n#ifdef COLORIZE\nuniform vec3 color;\n#endif\nvoid mainImage(const in vec4 inputColor,const in vec2 uv,const in float depth,out vec4 outputColor){float aoLinear=texture2D(aoBuffer,uv).r;\n#if defined(DEPTH_AWARE_UPSAMPLING) && defined(NORMAL_DEPTH) && __VERSION__ == 300\nvec4 normalDepth[4];normalDepth[0]=textureOffset(normalDepthBuffer,uv,ivec2(0,0));normalDepth[1]=textureOffset(normalDepthBuffer,uv,ivec2(0,1));normalDepth[2]=textureOffset(normalDepthBuffer,uv,ivec2(1,0));normalDepth[3]=textureOffset(normalDepthBuffer,uv,ivec2(1,1));float dot01=dot(normalDepth[0].rgb,normalDepth[1].rgb);float dot02=dot(normalDepth[0].rgb,normalDepth[2].rgb);float dot03=dot(normalDepth[0].rgb,normalDepth[3].rgb);float minDot=min(dot01,min(dot02,dot03));float s=step(THRESHOLD,minDot);float smallestDistance=1.0;int index;for(int i=0;i<4;++i){float distance=abs(depth-normalDepth[i].a);if(distance<smallestDistance){smallestDistance=distance;index=i;}}ivec2 offsets[4];offsets[0]=ivec2(0,0);offsets[1]=ivec2(0,1);offsets[2]=ivec2(1,0);offsets[3]=ivec2(1,1);ivec2 coord=ivec2(uv*vec2(textureSize(aoBuffer,0)))+offsets[index];float aoNearest=texelFetch(aoBuffer,coord,0).r;float ao=mix(aoNearest,aoLinear,s);\n#else\nfloat ao=aoLinear;\n#endif\nfloat l=luminance(inputColor.rgb);ao=mix(ao,0.0,l*luminanceInfluence);ao=clamp(ao*intensity,0.0,1.0);\n#ifdef COLORIZE\noutputColor=vec4(1.0-ao*(1.0-color),inputColor.a);\n#else\noutputColor=vec4(vec3(1.0-ao),inputColor.a);\n#endif\n}", {
                    blendFunction: n,
                    attributes: g.DEPTH,
                    defines: new Map([["THRESHOLD", "0.997"]]),
                    uniforms: new Map([["aoBuffer", new i.nc$(null)], ["normalDepthBuffer", new i.nc$(a)], ["luminanceInfluence", new i.nc$(v)], ["color", new i.nc$(null)], ["intensity", new i.nc$(x)], ["scale", new i.nc$(0)]])
                }),
                this.renderTarget = new i.nWS(1,1,{
                    depthBuffer: !1
                }),
                this.renderTarget.texture.name = "AO.Target",
                this.uniforms.get("aoBuffer").value = this.renderTarget.texture;
                const R = this.resolution = new w(this,M,B,C);
                R.addEventListener("change", (e => this.setSize(R.baseWidth, R.baseHeight))),
                this.camera = e,
                this.depthDownsamplingPass = new ze({
                    normalBuffer: t,
                    resolutionScale: C
                }),
                this.depthDownsamplingPass.enabled = null === a,
                this.ssaoPass = new se(new Ge(e));
                const D = new oe(64,64,i.GWd);
                D.wrapS = D.wrapT = i.GJx;
                const P = this.ssaoMaterial;
                P.normalBuffer = t,
                P.noiseTexture = D,
                P.minRadiusScale = m,
                P.samples = r,
                P.radius = y,
                P.rings = s,
                P.fade = b,
                P.bias = _,
                P.distanceThreshold = d,
                P.distanceFalloff = p,
                P.proximityThreshold = f,
                P.proximityFalloff = A,
                void 0 !== l && (P.worldDistanceThreshold = l),
                void 0 !== c && (P.worldDistanceFalloff = c),
                void 0 !== u && (P.worldProximityThreshold = u),
                void 0 !== h && (P.worldProximityFalloff = h),
                null !== a && (this.ssaoMaterial.normalDepthBuffer = a,
                this.defines.set("NORMAL_DEPTH", "1")),
                this.depthAwareUpsampling = o,
                this.color = E
            }
            set mainCamera(e) {
                this.camera = e,
                this.ssaoMaterial.copyCameraSettings(e)
            }
            get normalBuffer() {
                return this.ssaoMaterial.normalBuffer
            }
            set normalBuffer(e) {
                this.ssaoMaterial.normalBuffer = e,
                this.depthDownsamplingPass.fullscreenMaterial.normalBuffer = e
            }
            getResolution() {
                return this.resolution
            }
            get ssaoMaterial() {
                return this.ssaoPass.fullscreenMaterial
            }
            getSSAOMaterial() {
                return this.ssaoMaterial
            }
            get samples() {
                return this.ssaoMaterial.samples
            }
            set samples(e) {
                this.ssaoMaterial.samples = e
            }
            get rings() {
                return this.ssaoMaterial.rings
            }
            set rings(e) {
                this.ssaoMaterial.rings = e
            }
            get radius() {
                return this.ssaoMaterial.radius
            }
            set radius(e) {
                this.ssaoMaterial.radius = e
            }
            get depthAwareUpsampling() {
                return this.defines.has("DEPTH_AWARE_UPSAMPLING")
            }
            set depthAwareUpsampling(e) {
                this.depthAwareUpsampling !== e && (e ? this.defines.set("DEPTH_AWARE_UPSAMPLING", "1") : this.defines.delete("DEPTH_AWARE_UPSAMPLING"),
                this.setChanged())
            }
            isDepthAwareUpsamplingEnabled() {
                return this.depthAwareUpsampling
            }
            setDepthAwareUpsamplingEnabled(e) {
                this.depthAwareUpsampling = e
            }
            get distanceScaling() {
                return !0
            }
            set distanceScaling(e) {}
            get color() {
                return this.uniforms.get("color").value
            }
            set color(e) {
                const t = this.uniforms
                  , n = this.defines;
                null !== e ? n.has("COLORIZE") ? t.get("color").value.set(e) : (n.set("COLORIZE", "1"),
                t.get("color").value = new i.Q1f(e),
                this.setChanged()) : n.has("COLORIZE") && (n.delete("COLORIZE"),
                t.get("color").value = null,
                this.setChanged())
            }
            get luminanceInfluence() {
                return this.uniforms.get("luminanceInfluence").value
            }
            set luminanceInfluence(e) {
                this.uniforms.get("luminanceInfluence").value = e
            }
            get intensity() {
                return this.uniforms.get("intensity").value
            }
            set intensity(e) {
                this.uniforms.get("intensity").value = e
            }
            getColor() {
                return this.color
            }
            setColor(e) {
                this.color = e
            }
            setDistanceCutoff(e, t) {
                this.ssaoMaterial.distanceThreshold = e,
                this.ssaoMaterial.distanceFalloff = t
            }
            setProximityCutoff(e, t) {
                this.ssaoMaterial.proximityThreshold = e,
                this.ssaoMaterial.proximityFalloff = t
            }
            setDepthTexture(e, t=i.Rkk) {
                this.depthDownsamplingPass.setDepthTexture(e, t),
                this.ssaoMaterial.depthBuffer = e,
                this.ssaoMaterial.depthPacking = t
            }
            update(e, t, n) {
                const i = this.renderTarget;
                this.depthDownsamplingPass.enabled && this.depthDownsamplingPass.render(e),
                this.ssaoPass.render(e, null, i)
            }
            setSize(e, t) {
                const n = this.resolution;
                n.setBaseSize(e, t);
                const i = n.width
                  , r = n.height;
                this.ssaoMaterial.copyCameraSettings(this.camera),
                this.ssaoMaterial.setSize(i, r),
                this.renderTarget.setSize(i, r),
                this.depthDownsamplingPass.resolution.scale = n.scale,
                this.depthDownsamplingPass.setSize(e, t)
            }
            initialize(e, t, n) {
                try {
                    let i = this.uniforms.get("normalDepthBuffer").value;
                    null === i && (this.depthDownsamplingPass.initialize(e, t, n),
                    i = this.depthDownsamplingPass.texture,
                    this.uniforms.get("normalDepthBuffer").value = i,
                    this.ssaoMaterial.normalDepthBuffer = i,
                    this.defines.set("NORMAL_DEPTH", "1"))
                } catch (e) {
                    this.depthDownsamplingPass.enabled = !1
                }
            }
        }
          , We = class extends i.BKk {
            constructor() {
                super({
                    name: "AdaptiveLuminanceMaterial",
                    defines: {
                        MIP_LEVEL_1X1: "0.0"
                    },
                    uniforms: {
                        luminanceBuffer0: new i.nc$(null),
                        luminanceBuffer1: new i.nc$(null),
                        minLuminance: new i.nc$(.01),
                        deltaTime: new i.nc$(0),
                        tau: new i.nc$(1)
                    },
                    extensions: {
                        shaderTextureLOD: !0
                    },
                    blending: i.XIg,
                    toneMapped: !1,
                    depthWrite: !1,
                    depthTest: !1,
                    fragmentShader: "#include <packing>\n#define packFloatToRGBA(v) packDepthToRGBA(v)\n#define unpackRGBAToFloat(v) unpackRGBAToDepth(v)\nuniform lowp sampler2D luminanceBuffer0;uniform lowp sampler2D luminanceBuffer1;uniform float minLuminance;uniform float deltaTime;uniform float tau;varying vec2 vUv;void main(){float l0=unpackRGBAToFloat(texture2D(luminanceBuffer0,vUv));\n#if __VERSION__ < 300\nfloat l1=texture2DLodEXT(luminanceBuffer1,vUv,MIP_LEVEL_1X1).r;\n#else\nfloat l1=textureLod(luminanceBuffer1,vUv,MIP_LEVEL_1X1).r;\n#endif\nl0=max(minLuminance,l0);l1=max(minLuminance,l1);float adaptedLum=l0+(l1-l0)*(1.0-exp(-deltaTime*tau));gl_FragColor=(adaptedLum==1.0)?vec4(1.0):packFloatToRGBA(adaptedLum);}",
                    vertexShader: c
                })
            }
            set luminanceBuffer0(e) {
                this.uniforms.luminanceBuffer0.value = e
            }
            setLuminanceBuffer0(e) {
                this.uniforms.luminanceBuffer0.value = e
            }
            set luminanceBuffer1(e) {
                this.uniforms.luminanceBuffer1.value = e
            }
            setLuminanceBuffer1(e) {
                this.uniforms.luminanceBuffer1.value = e
            }
            set mipLevel1x1(e) {
                this.defines.MIP_LEVEL_1X1 = e.toFixed(1),
                this.needsUpdate = !0
            }
            setMipLevel1x1(e) {
                this.mipLevel1x1 = e
            }
            set deltaTime(e) {
                this.uniforms.deltaTime.value = e
            }
            setDeltaTime(e) {
                this.uniforms.deltaTime.value = e
            }
            get minLuminance() {
                return this.uniforms.minLuminance.value
            }
            set minLuminance(e) {
                this.uniforms.minLuminance.value = e
            }
            getMinLuminance() {
                return this.uniforms.minLuminance.value
            }
            setMinLuminance(e) {
                this.uniforms.minLuminance.value = e
            }
            get adaptationRate() {
                return this.uniforms.tau.value
            }
            set adaptationRate(e) {
                this.uniforms.tau.value = e
            }
            getAdaptationRate() {
                return this.uniforms.tau.value
            }
            setAdaptationRate(e) {
                this.uniforms.tau.value = e
            }
        }
          , je = class extends o {
            constructor(e, {minLuminance: t=.01, adaptationRate: n=1}={}) {
                super("AdaptiveLuminancePass"),
                this.fullscreenMaterial = new We,
                this.needsSwap = !1,
                this.renderTargetPrevious = new i.nWS(1,1,{
                    minFilter: i.hxR,
                    magFilter: i.hxR,
                    depthBuffer: !1
                }),
                this.renderTargetPrevious.texture.name = "Luminance.Previous";
                const r = this.fullscreenMaterial;
                r.luminanceBuffer0 = this.renderTargetPrevious.texture,
                r.luminanceBuffer1 = e,
                r.minLuminance = t,
                r.adaptationRate = n,
                this.renderTargetAdapted = this.renderTargetPrevious.clone(),
                this.renderTargetAdapted.texture.name = "Luminance.Adapted",
                this.copyPass = new h(this.renderTargetPrevious,!1)
            }
            get texture() {
                return this.renderTargetAdapted.texture
            }
            getTexture() {
                return this.renderTargetAdapted.texture
            }
            set mipLevel1x1(e) {
                this.fullscreenMaterial.mipLevel1x1 = e
            }
            get adaptationRate() {
                return this.fullscreenMaterial.adaptationRate
            }
            set adaptationRate(e) {
                this.fullscreenMaterial.adaptationRate = e
            }
            render(e, t, n, i, r) {
                this.fullscreenMaterial.deltaTime = i,
                e.setRenderTarget(this.renderToScreen ? null : this.renderTargetAdapted),
                e.render(this.scene, this.camera),
                this.copyPass.render(e, this.renderTargetAdapted)
            }
        }
          , qe = class extends j {
            constructor({blendFunction: e=P, adaptive: t=!1, mode: n=(t ? Ie : Be), resolution: r=256, maxLuminance: s=4, whitePoint: a=s, middleGrey: o=.6, minLuminance: l=.01, averageLuminance: c=1, adaptationRate: u=1}={}) {
                super("ToneMappingEffect", "#include <tonemapping_pars_fragment>\nuniform float whitePoint;\n#if TONE_MAPPING_MODE == 2 || TONE_MAPPING_MODE == 3\nuniform float middleGrey;\n#if TONE_MAPPING_MODE == 3\nuniform lowp sampler2D luminanceBuffer;\n#else\nuniform float averageLuminance;\n#endif\nvec3 Reinhard2ToneMapping(vec3 color){color*=toneMappingExposure;float l=luminance(color);\n#if TONE_MAPPING_MODE == 3\nfloat lumAvg=unpackRGBAToFloat(texture2D(luminanceBuffer,vec2(0.5)));\n#else\nfloat lumAvg=averageLuminance;\n#endif\nfloat lumScaled=(l*middleGrey)/max(lumAvg,1e-6);float lumCompressed=lumScaled*(1.0+lumScaled/(whitePoint*whitePoint));lumCompressed/=(1.0+lumScaled);return clamp(lumCompressed*color,0.0,1.0);}\n#elif TONE_MAPPING_MODE == 4\n#define A 0.15\n#define B 0.50\n#define C 0.10\n#define D 0.20\n#define E 0.02\n#define F 0.30\nvec3 Uncharted2Helper(const in vec3 x){return((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;}vec3 Uncharted2ToneMapping(vec3 color){color*=toneMappingExposure;return clamp(Uncharted2Helper(color)/Uncharted2Helper(vec3(whitePoint)),0.0,1.0);}\n#endif\nvoid mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){\n#if TONE_MAPPING_MODE == 2 || TONE_MAPPING_MODE == 3\noutputColor=vec4(Reinhard2ToneMapping(inputColor.rgb),inputColor.a);\n#elif TONE_MAPPING_MODE == 4\noutputColor=vec4(Uncharted2ToneMapping(inputColor.rgb),inputColor.a);\n#else\noutputColor=vec4(toneMapping(inputColor.rgb),inputColor.a);\n#endif\n}", {
                    blendFunction: e,
                    uniforms: new Map([["luminanceBuffer", new i.nc$(null)], ["maxLuminance", new i.nc$(s)], ["whitePoint", new i.nc$(a)], ["middleGrey", new i.nc$(o)], ["averageLuminance", new i.nc$(c)]])
                }),
                this.renderTargetLuminance = new i.nWS(1,1,{
                    minFilter: i.$_I,
                    depthBuffer: !1
                }),
                this.renderTargetLuminance.texture.generateMipmaps = !0,
                this.renderTargetLuminance.texture.name = "Luminance",
                this.luminancePass = new H({
                    renderTarget: this.renderTargetLuminance
                }),
                this.adaptiveLuminancePass = new je(this.luminancePass.texture,{
                    minLuminance: l,
                    adaptationRate: u
                }),
                this.uniforms.get("luminanceBuffer").value = this.adaptiveLuminancePass.texture,
                this.resolution = r,
                this.mode = n
            }
            get mode() {
                return Number(this.defines.get("TONE_MAPPING_MODE"))
            }
            set mode(e) {
                if (this.mode === e)
                    return;
                const t = i.sPf.replace(/\D+/g, "") >= 168 ? "CineonToneMapping(texel)" : "OptimizedCineonToneMapping(texel)";
                switch (this.defines.clear(),
                this.defines.set("TONE_MAPPING_MODE", e.toFixed(0)),
                e) {
                case Ee:
                    this.defines.set("toneMapping(texel)", "LinearToneMapping(texel)");
                    break;
                case we:
                    this.defines.set("toneMapping(texel)", "ReinhardToneMapping(texel)");
                    break;
                case Me:
                case Se:
                    this.defines.set("toneMapping(texel)", t);
                    break;
                case Te:
                    this.defines.set("toneMapping(texel)", "ACESFilmicToneMapping(texel)");
                    break;
                case Be:
                    this.defines.set("toneMapping(texel)", "AgXToneMapping(texel)");
                    break;
                case Re:
                    this.defines.set("toneMapping(texel)", "NeutralToneMapping(texel)");
                    break;
                default:
                    this.defines.set("toneMapping(texel)", "texel")
                }
                this.adaptiveLuminancePass.enabled = e === Ie,
                this.setChanged()
            }
            getMode() {
                return this.mode
            }
            setMode(e) {
                this.mode = e
            }
            get whitePoint() {
                return this.uniforms.get("whitePoint").value
            }
            set whitePoint(e) {
                this.uniforms.get("whitePoint").value = e
            }
            get middleGrey() {
                return this.uniforms.get("middleGrey").value
            }
            set middleGrey(e) {
                this.uniforms.get("middleGrey").value = e
            }
            get averageLuminance() {
                return this.uniforms.get("averageLuminance").value
            }
            set averageLuminance(e) {
                this.uniforms.get("averageLuminance").value = e
            }
            get adaptiveLuminanceMaterial() {
                return this.adaptiveLuminancePass.fullscreenMaterial
            }
            getAdaptiveLuminanceMaterial() {
                return this.adaptiveLuminanceMaterial
            }
            get resolution() {
                return this.luminancePass.resolution.width
            }
            set resolution(e) {
                const t = Math.max(0, Math.ceil(Math.log2(e)))
                  , n = Math.pow(2, t);
                this.luminancePass.resolution.setPreferredSize(n, n),
                this.adaptiveLuminanceMaterial.mipLevel1x1 = t
            }
            getResolution() {
                return this.resolution
            }
            setResolution(e) {
                this.resolution = e
            }
            get adaptive() {
                return this.mode === Ie
            }
            set adaptive(e) {
                this.mode = e ? Ie : Ce
            }
            get adaptationRate() {
                return this.adaptiveLuminanceMaterial.adaptationRate
            }
            set adaptationRate(e) {
                this.adaptiveLuminanceMaterial.adaptationRate = e
            }
            get distinction() {
                return console.warn(this.name, "distinction was removed."),
                1
            }
            set distinction(e) {
                console.warn(this.name, "distinction was removed.")
            }
            update(e, t, n) {
                this.adaptiveLuminancePass.enabled && (this.luminancePass.render(e, t),
                this.adaptiveLuminancePass.render(e, null, null, n))
            }
            initialize(e, t, n) {
                this.adaptiveLuminancePass.initialize(e, t, n)
            }
        }
          , Ye = class extends j {
            constructor({blendFunction: e, eskil: t=!1, technique: n=(t ? Pe : De), offset: r=.5, darkness: s=.5}={}) {
                super("VignetteEffect", "uniform float offset;uniform float darkness;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){const vec2 center=vec2(0.5);vec3 color=inputColor.rgb;\n#if VIGNETTE_TECHNIQUE == 0\nfloat d=distance(uv,center);color*=smoothstep(0.8,offset*0.799,d*(darkness+offset));\n#else\nvec2 coord=(uv-center)*vec2(offset);color=mix(color,vec3(1.0-darkness),dot(coord,coord));\n#endif\noutputColor=vec4(color,inputColor.a);}", {
                    blendFunction: e,
                    defines: new Map([["VIGNETTE_TECHNIQUE", n.toFixed(0)]]),
                    uniforms: new Map([["offset", new i.nc$(r)], ["darkness", new i.nc$(s)]])
                })
            }
            get technique() {
                return Number(this.defines.get("VIGNETTE_TECHNIQUE"))
            }
            set technique(e) {
                this.technique !== e && (this.defines.set("VIGNETTE_TECHNIQUE", e.toFixed(0)),
                this.setChanged())
            }
            get eskil() {
                return this.technique === Pe
            }
            set eskil(e) {
                this.technique = e ? Pe : De
            }
            getTechnique() {
                return this.technique
            }
            setTechnique(e) {
                this.technique = e
            }
            get offset() {
                return this.uniforms.get("offset").value
            }
            set offset(e) {
                this.uniforms.get("offset").value = e
            }
            getOffset() {
                return this.offset
            }
            setOffset(e) {
                this.offset = e
            }
            get darkness() {
                return this.uniforms.get("darkness").value
            }
            set darkness(e) {
                this.uniforms.get("darkness").value = e
            }
            getDarkness() {
                return this.darkness
            }
            setDarkness(e) {
                this.darkness = e
            }
        }
          , Xe = (i.BKk,
        i.BKk,
        class extends i.BKk {
            constructor(e, t, n, r, s=!1) {
                super({
                    name: "EffectMaterial",
                    defines: {
                        THREE_REVISION: i.sPf.replace(/\D+/g, ""),
                        DEPTH_PACKING: "0",
                        ENCODE_OUTPUT: "1"
                    },
                    uniforms: {
                        inputBuffer: new i.nc$(null),
                        depthBuffer: new i.nc$(null),
                        resolution: new i.nc$(new i.I9Y),
                        texelSize: new i.nc$(new i.I9Y),
                        cameraNear: new i.nc$(.3),
                        cameraFar: new i.nc$(1e3),
                        aspect: new i.nc$(1),
                        time: new i.nc$(0)
                    },
                    blending: i.XIg,
                    toneMapped: !1,
                    depthWrite: !1,
                    depthTest: !1,
                    dithering: s
                }),
                e && this.setShaderParts(e),
                t && this.setDefines(t),
                n && this.setUniforms(n),
                this.copyCameraSettings(r)
            }
            set inputBuffer(e) {
                this.uniforms.inputBuffer.value = e
            }
            setInputBuffer(e) {
                this.uniforms.inputBuffer.value = e
            }
            get depthBuffer() {
                return this.uniforms.depthBuffer.value
            }
            set depthBuffer(e) {
                this.uniforms.depthBuffer.value = e
            }
            get depthPacking() {
                return Number(this.defines.DEPTH_PACKING)
            }
            set depthPacking(e) {
                this.defines.DEPTH_PACKING = e.toFixed(0),
                this.needsUpdate = !0
            }
            setDepthBuffer(e, t=i.Rkk) {
                this.depthBuffer = e,
                this.depthPacking = t
            }
            setShaderData(e) {
                this.setShaderParts(e.shaderParts),
                this.setDefines(e.defines),
                this.setUniforms(e.uniforms),
                this.setExtensions(e.extensions)
            }
            setShaderParts(e) {
                return this.fragmentShader = "#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#define packFloatToRGBA(v) packDepthToRGBA(v)\n#define unpackRGBAToFloat(v) unpackRGBAToDepth(v)\n#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\n#if DEPTH_PACKING == 3201\nuniform lowp sampler2D depthBuffer;\n#elif defined(GL_FRAGMENT_PRECISION_HIGH)\nuniform highp sampler2D depthBuffer;\n#else\nuniform mediump sampler2D depthBuffer;\n#endif\nuniform vec2 resolution;uniform vec2 texelSize;uniform float cameraNear;uniform float cameraFar;uniform float aspect;uniform float time;varying vec2 vUv;vec4 sRGBToLinear(const in vec4 value){return vec4(mix(pow(value.rgb*0.9478672986+vec3(0.0521327014),vec3(2.4)),value.rgb*0.0773993808,vec3(lessThanEqual(value.rgb,vec3(0.04045)))),value.a);}float readDepth(const in vec2 uv){\n#if DEPTH_PACKING == 3201\nreturn unpackRGBAToDepth(texture2D(depthBuffer,uv));\n#else\nreturn texture2D(depthBuffer,uv).r;\n#endif\n}float getViewZ(const in float depth){\n#ifdef PERSPECTIVE_CAMERA\nreturn perspectiveDepthToViewZ(depth,cameraNear,cameraFar);\n#else\nreturn orthographicDepthToViewZ(depth,cameraNear,cameraFar);\n#endif\n}vec3 RGBToHCV(const in vec3 RGB){vec4 P=mix(vec4(RGB.bg,-1.0,2.0/3.0),vec4(RGB.gb,0.0,-1.0/3.0),step(RGB.b,RGB.g));vec4 Q=mix(vec4(P.xyw,RGB.r),vec4(RGB.r,P.yzx),step(P.x,RGB.r));float C=Q.x-min(Q.w,Q.y);float H=abs((Q.w-Q.y)/(6.0*C+EPSILON)+Q.z);return vec3(H,C,Q.x);}vec3 RGBToHSL(const in vec3 RGB){vec3 HCV=RGBToHCV(RGB);float L=HCV.z-HCV.y*0.5;float S=HCV.y/(1.0-abs(L*2.0-1.0)+EPSILON);return vec3(HCV.x,S,L);}vec3 HueToRGB(const in float H){float R=abs(H*6.0-3.0)-1.0;float G=2.0-abs(H*6.0-2.0);float B=2.0-abs(H*6.0-4.0);return clamp(vec3(R,G,B),0.0,1.0);}vec3 HSLToRGB(const in vec3 HSL){vec3 RGB=HueToRGB(HSL.x);float C=(1.0-abs(2.0*HSL.z-1.0))*HSL.y;return(RGB-0.5)*C+HSL.z;}FRAGMENT_HEAD void main(){FRAGMENT_MAIN_UV vec4 color0=texture2D(inputBuffer,UV);vec4 color1=vec4(0.0);FRAGMENT_MAIN_IMAGE color0.a=clamp(color0.a,0.0,1.0);gl_FragColor=color0;\n#ifdef ENCODE_OUTPUT\n#include <colorspace_fragment>\n#endif\n#include <dithering_fragment>\n}".replace(m.FRAGMENT_HEAD, e.get(m.FRAGMENT_HEAD) || "").replace(m.FRAGMENT_MAIN_UV, e.get(m.FRAGMENT_MAIN_UV) || "").replace(m.FRAGMENT_MAIN_IMAGE, e.get(m.FRAGMENT_MAIN_IMAGE) || ""),
                this.vertexShader = "uniform vec2 resolution;uniform vec2 texelSize;uniform float cameraNear;uniform float cameraFar;uniform float aspect;uniform float time;varying vec2 vUv;VERTEX_HEAD void main(){vUv=position.xy*0.5+0.5;VERTEX_MAIN_SUPPORT gl_Position=vec4(position.xy,1.0,1.0);}".replace(m.VERTEX_HEAD, e.get(m.VERTEX_HEAD) || "").replace(m.VERTEX_MAIN_SUPPORT, e.get(m.VERTEX_MAIN_SUPPORT) || ""),
                this.needsUpdate = !0,
                this
            }
            setDefines(e) {
                for (const t of e.entries())
                    this.defines[t[0]] = t[1];
                return this.needsUpdate = !0,
                this
            }
            setUniforms(e) {
                for (const t of e.entries())
                    this.uniforms[t[0]] = t[1];
                return this
            }
            setExtensions(e) {
                this.extensions = {};
                for (const t of e)
                    this.extensions[t] = !0;
                return this
            }
            get encodeOutput() {
                return void 0 !== this.defines.ENCODE_OUTPUT
            }
            set encodeOutput(e) {
                this.encodeOutput !== e && (e ? this.defines.ENCODE_OUTPUT = "1" : delete this.defines.ENCODE_OUTPUT,
                this.needsUpdate = !0)
            }
            isOutputEncodingEnabled(e) {
                return this.encodeOutput
            }
            setOutputEncodingEnabled(e) {
                this.encodeOutput = e
            }
            get time() {
                return this.uniforms.time.value
            }
            set time(e) {
                this.uniforms.time.value = e
            }
            setDeltaTime(e) {
                this.uniforms.time.value += e
            }
            adoptCameraSettings(e) {
                this.copyCameraSettings(e)
            }
            copyCameraSettings(e) {
                e && (this.uniforms.cameraNear.value = e.near,
                this.uniforms.cameraFar.value = e.far,
                e instanceof i.ubm ? this.defines.PERSPECTIVE_CAMERA = "1" : delete this.defines.PERSPECTIVE_CAMERA,
                this.needsUpdate = !0)
            }
            setSize(e, t) {
                const n = this.uniforms;
                n.resolution.value.set(e, t),
                n.texelSize.value.set(1 / e, 1 / t),
                n.aspect.value = e / t
            }
            static get Section() {
                return m
            }
        }
        )
          , Ke = (i.BKk,
        Number(i.sPf.replace(/\D+/g, "")),
        255 / 256);
        new Float32Array([5.9371814131736755e-8, Ke / 65536, .0038909912109375, Ke]),
        new Float32Array([Ke, .0038909912109375, Ke / 65536, 1 / 256 ** 3]);
        function Je(e, t, n) {
            for (const i of t) {
                const t = "$1" + e + i.charAt(0).toUpperCase() + i.slice(1)
                  , r = new RegExp("([^\\.])(\\b" + i + "\\b)","g");
                for (const e of n.entries())
                    null !== e[1] && n.set(e[0], e[1].replace(r, t))
            }
        }
        function Ze(e, t, n) {
            let r = t.getFragmentShader()
              , s = t.getVertexShader();
            const a = void 0 !== r && /mainImage/.test(r)
              , o = void 0 !== r && /mainUv/.test(r);
            if (n.attributes |= t.getAttributes(),
            void 0 === r)
                throw new Error(`Missing fragment shader (${t.name})`);
            if (o && n.attributes & g.CONVOLUTION)
                throw new Error(`Effects that transform UVs are incompatible with convolution effects (${t.name})`);
            if (!a && !o)
                throw new Error(`Could not find mainImage or mainUv function (${t.name})`);
            {
                const l = /\w+\s+(\w+)\([\w\s,]*\)\s*{/g
                  , c = n.shaderParts;
                let u = c.get(m.FRAGMENT_HEAD) || ""
                  , h = c.get(m.FRAGMENT_MAIN_UV) || ""
                  , d = c.get(m.FRAGMENT_MAIN_IMAGE) || ""
                  , p = c.get(m.VERTEX_HEAD) || ""
                  , f = c.get(m.VERTEX_MAIN_SUPPORT) || "";
                const A = new Set
                  , v = new Set;
                if (o && (h += `\t${e}MainUv(UV);\n`,
                n.uvTransformation = !0),
                null !== s && /mainSupport/.test(s)) {
                    const t = /mainSupport *\([\w\s]*?uv\s*?\)/.test(s);
                    f += `\t${e}MainSupport(`,
                    f += t ? "vUv);\n" : ");\n";
                    for (const e of s.matchAll(/(?:varying\s+\w+\s+([\S\s]*?);)/g))
                        for (const t of e[1].split(/\s*,\s*/))
                            n.varyings.add(t),
                            A.add(t),
                            v.add(t);
                    for (const e of s.matchAll(l))
                        v.add(e[1])
                }
                for (const e of r.matchAll(l))
                    v.add(e[1]);
                for (const e of t.defines.keys())
                    v.add(e.replace(/\([\w\s,]*\)/g, ""));
                for (const e of t.uniforms.keys())
                    v.add(e);
                v.delete("while"),
                v.delete("for"),
                v.delete("if"),
                t.uniforms.forEach(( (t, i) => n.uniforms.set(e + i.charAt(0).toUpperCase() + i.slice(1), t))),
                t.defines.forEach(( (t, i) => n.defines.set(e + i.charAt(0).toUpperCase() + i.slice(1), t)));
                const y = new Map([["fragment", r], ["vertex", s]]);
                Je(e, v, n.defines),
                Je(e, v, y),
                r = y.get("fragment"),
                s = y.get("vertex");
                const x = t.blendMode;
                if (n.blendModes.set(x.blendFunction, x),
                a) {
                    null !== t.inputColorSpace && t.inputColorSpace !== n.colorSpace && (d += t.inputColorSpace === i.er$ ? "color0 = sRGBTransferOETF(color0);\n\t" : "color0 = sRGBToLinear(color0);\n\t"),
                    t.outputColorSpace !== i.jf0 ? n.colorSpace = t.outputColorSpace : null !== t.inputColorSpace && (n.colorSpace = t.inputColorSpace);
                    const s = /MainImage *\([\w\s,]*?depth[\w\s,]*?\)/;
                    d += `${e}MainImage(color0, UV, `,
                    n.attributes & g.DEPTH && s.test(r) && (d += "depth, ",
                    n.readDepth = !0),
                    d += "color1);\n\t";
                    const a = e + "BlendOpacity";
                    n.uniforms.set(a, x.opacity),
                    d += `color0 = blend${x.blendFunction}(color0, color1, ${a});\n\n\t`,
                    u += `uniform float ${a};\n\n`
                }
                if (u += r + "\n",
                null !== s && (p += s + "\n"),
                c.set(m.FRAGMENT_HEAD, u),
                c.set(m.FRAGMENT_MAIN_UV, h),
                c.set(m.FRAGMENT_MAIN_IMAGE, d),
                c.set(m.VERTEX_HEAD, p),
                c.set(m.VERTEX_MAIN_SUPPORT, f),
                null !== t.extensions)
                    for (const e of t.extensions)
                        n.extensions.add(e)
            }
        }
        var $e = class extends o {
            constructor(e, ...t) {
                super("EffectPass"),
                this.fullscreenMaterial = new Xe(null,null,null,e),
                this.listener = e => this.handleEvent(e),
                this.effects = [],
                this.setEffects(t),
                this.skipRendering = !1,
                this.minTime = 1,
                this.maxTime = Number.POSITIVE_INFINITY,
                this.timeScale = 1
            }
            set mainScene(e) {
                for (const t of this.effects)
                    t.mainScene = e
            }
            set mainCamera(e) {
                this.fullscreenMaterial.copyCameraSettings(e);
                for (const t of this.effects)
                    t.mainCamera = e
            }
            get encodeOutput() {
                return this.fullscreenMaterial.encodeOutput
            }
            set encodeOutput(e) {
                this.fullscreenMaterial.encodeOutput = e
            }
            get dithering() {
                return this.fullscreenMaterial.dithering
            }
            set dithering(e) {
                const t = this.fullscreenMaterial;
                t.dithering = e,
                t.needsUpdate = !0
            }
            setEffects(e) {
                for (const e of this.effects)
                    e.removeEventListener("change", this.listener);
                this.effects = e.sort(( (e, t) => t.attributes - e.attributes));
                for (const e of this.effects)
                    e.addEventListener("change", this.listener)
            }
            updateMaterial() {
                const e = new v;
                let t = 0;
                for (const n of this.effects)
                    if (n.blendMode.blendFunction === M)
                        e.attributes |= n.getAttributes() & g.DEPTH;
                    else {
                        if (e.attributes & n.getAttributes() & g.CONVOLUTION)
                            throw new Error(`Convolution effects cannot be merged (${n.name})`);
                        Ze("e" + t++, n, e)
                    }
                let n = e.shaderParts.get(m.FRAGMENT_HEAD)
                  , r = e.shaderParts.get(m.FRAGMENT_MAIN_IMAGE)
                  , s = e.shaderParts.get(m.FRAGMENT_MAIN_UV);
                const a = /\bblend\b/g;
                for (const t of e.blendModes.values())
                    n += t.getShaderCode().replace(a, `blend${t.blendFunction}`) + "\n";
                e.attributes & g.DEPTH ? (e.readDepth && (r = "float depth = readDepth(UV);\n\n\t" + r),
                this.needsDepthTexture = null === this.getDepthTexture()) : this.needsDepthTexture = !1,
                e.colorSpace === i.er$ && (r += "color0 = sRGBToLinear(color0);\n\t"),
                e.uvTransformation ? (s = "vec2 transformedUv = vUv;\n" + s,
                e.defines.set("UV", "transformedUv")) : e.defines.set("UV", "vUv"),
                e.shaderParts.set(m.FRAGMENT_HEAD, n),
                e.shaderParts.set(m.FRAGMENT_MAIN_IMAGE, r),
                e.shaderParts.set(m.FRAGMENT_MAIN_UV, s);
                for (const [t,n] of e.shaderParts)
                    null !== n && e.shaderParts.set(t, n.trim().replace(/^#/, "\n#"));
                this.skipRendering = 0 === t,
                this.needsSwap = !this.skipRendering,
                this.fullscreenMaterial.setShaderData(e)
            }
            recompile() {
                this.updateMaterial()
            }
            getDepthTexture() {
                return this.fullscreenMaterial.depthBuffer
            }
            setDepthTexture(e, t=i.Rkk) {
                this.fullscreenMaterial.depthBuffer = e,
                this.fullscreenMaterial.depthPacking = t;
                for (const n of this.effects)
                    n.setDepthTexture(e, t)
            }
            render(e, t, n, i, r) {
                for (const n of this.effects)
                    n.update(e, t, i);
                if (!this.skipRendering || this.renderToScreen) {
                    const r = this.fullscreenMaterial;
                    r.inputBuffer = t.texture,
                    r.time += i * this.timeScale,
                    e.setRenderTarget(this.renderToScreen ? null : n),
                    e.render(this.scene, this.camera)
                }
            }
            setSize(e, t) {
                this.fullscreenMaterial.setSize(e, t);
                for (const n of this.effects)
                    n.setSize(e, t)
            }
            initialize(e, t, n) {
                this.renderer = e;
                for (const i of this.effects)
                    i.initialize(e, t, n);
                this.updateMaterial(),
                void 0 !== n && n !== i.OUM && (this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1")
            }
            dispose() {
                super.dispose();
                for (const e of this.effects)
                    e.removeEventListener("change", this.listener),
                    e.dispose()
            }
            handleEvent(e) {
                if ("change" === e.type)
                    this.recompile()
            }
        }
          , et = class extends o {
            constructor(e, t, {renderTarget: n, resolutionScale: r=1, width: s=w.AUTO_SIZE, height: a=w.AUTO_SIZE, resolutionX: o=s, resolutionY: l=a}={}) {
                super("NormalPass"),
                this.needsSwap = !1,
                this.renderPass = new ue(e,t,new i.qBx);
                const c = this.renderPass;
                c.ignoreBackground = !0,
                c.skipShadowMapUpdate = !0;
                const u = c.getClearPass();
                u.overrideClearColor = new i.Q1f(7829503),
                u.overrideClearAlpha = 1,
                this.renderTarget = n,
                void 0 === this.renderTarget && (this.renderTarget = new i.nWS(1,1,{
                    minFilter: i.hxR,
                    magFilter: i.hxR
                }),
                this.renderTarget.texture.name = "NormalPass.Target");
                const h = this.resolution = new w(this,o,l,r);
                h.addEventListener("change", (e => this.setSize(h.baseWidth, h.baseHeight)))
            }
            set mainScene(e) {
                this.renderPass.mainScene = e
            }
            set mainCamera(e) {
                this.renderPass.mainCamera = e
            }
            get texture() {
                return this.renderTarget.texture
            }
            getTexture() {
                return this.renderTarget.texture
            }
            getResolution() {
                return this.resolution
            }
            getResolutionScale() {
                return this.resolution.scale
            }
            setResolutionScale(e) {
                this.resolution.scale = e
            }
            render(e, t, n, i, r) {
                const s = this.renderToScreen ? null : this.renderTarget;
                this.renderPass.render(e, s, s)
            }
            setSize(e, t) {
                const n = this.resolution;
                n.setBaseSize(e, t),
                this.renderTarget.setSize(n.width, n.height)
            }
        }
        ;
        new Float32Array(3),
        new Float32Array(3),
        new Float32Array(3),
        new Float32Array(3),
        new Float32Array(3),
        new Float32Array(3),
        new Float32Array([0, 0, 0]),
        new Float32Array([1, 0, 0]),
        new Float32Array([1, 1, 0]),
        new Float32Array([1, 1, 1]),
        new Float32Array([0, 0, 0]),
        new Float32Array([1, 0, 0]),
        new Float32Array([1, 0, 1]),
        new Float32Array([1, 1, 1]),
        new Float32Array([0, 0, 0]),
        new Float32Array([0, 0, 1]),
        new Float32Array([1, 0, 1]),
        new Float32Array([1, 1, 1]),
        new Float32Array([0, 0, 0]),
        new Float32Array([0, 1, 0]),
        new Float32Array([1, 1, 0]),
        new Float32Array([1, 1, 1]),
        new Float32Array([0, 0, 0]),
        new Float32Array([0, 1, 0]),
        new Float32Array([0, 1, 1]),
        new Float32Array([1, 1, 1]),
        new Float32Array([0, 0, 0]),
        new Float32Array([0, 0, 1]),
        new Float32Array([0, 1, 1]),
        new Float32Array([1, 1, 1]);
        new Float32Array(2),
        new Float32Array(2),
        new Float32Array([0, -.25, .25, -.125, .125, -.375, .375]),
        new Float32Array([0, 0]),
        new Float32Array([.25, -.25]),
        new Float32Array([-.25, .25]),
        new Float32Array([.125, -.125]),
        new Float32Array([-.125, .125]),
        new Uint8Array([0, 0]),
        new Uint8Array([3, 0]),
        new Uint8Array([0, 3]),
        new Uint8Array([3, 3]),
        new Uint8Array([1, 0]),
        new Uint8Array([4, 0]),
        new Uint8Array([1, 3]),
        new Uint8Array([4, 3]),
        new Uint8Array([0, 1]),
        new Uint8Array([3, 1]),
        new Uint8Array([0, 4]),
        new Uint8Array([3, 4]),
        new Uint8Array([1, 1]),
        new Uint8Array([4, 1]),
        new Uint8Array([1, 4]),
        new Uint8Array([4, 4]),
        new Uint8Array([0, 0]),
        new Uint8Array([1, 0]),
        new Uint8Array([0, 2]),
        new Uint8Array([1, 2]),
        new Uint8Array([2, 0]),
        new Uint8Array([3, 0]),
        new Uint8Array([2, 2]),
        new Uint8Array([3, 2]),
        new Uint8Array([0, 1]),
        new Uint8Array([1, 1]),
        new Uint8Array([0, 3]),
        new Uint8Array([1, 3]),
        new Uint8Array([2, 1]),
        new Uint8Array([3, 1]),
        new Uint8Array([2, 3]),
        new Uint8Array([3, 3]);
        nt(0, 0, 0, 0),
        new Float32Array([0, 0, 0, 0]),
        nt(0, 0, 0, 1),
        new Float32Array([0, 0, 0, 1]),
        nt(0, 0, 1, 0),
        new Float32Array([0, 0, 1, 0]),
        nt(0, 0, 1, 1),
        new Float32Array([0, 0, 1, 1]),
        nt(0, 1, 0, 0),
        new Float32Array([0, 1, 0, 0]),
        nt(0, 1, 0, 1),
        new Float32Array([0, 1, 0, 1]),
        nt(0, 1, 1, 0),
        new Float32Array([0, 1, 1, 0]),
        nt(0, 1, 1, 1),
        new Float32Array([0, 1, 1, 1]),
        nt(1, 0, 0, 0),
        new Float32Array([1, 0, 0, 0]),
        nt(1, 0, 0, 1),
        new Float32Array([1, 0, 0, 1]),
        nt(1, 0, 1, 0),
        new Float32Array([1, 0, 1, 0]),
        nt(1, 0, 1, 1),
        new Float32Array([1, 0, 1, 1]),
        nt(1, 1, 0, 0),
        new Float32Array([1, 1, 0, 0]),
        nt(1, 1, 0, 1),
        new Float32Array([1, 1, 0, 1]),
        nt(1, 1, 1, 0),
        new Float32Array([1, 1, 1, 0]),
        nt(1, 1, 1, 1),
        new Float32Array([1, 1, 1, 1]);
        function tt(e, t, n) {
            return e + (t - e) * n
        }
        function nt(e, t, n, i) {
            const r = tt(e, t, .75)
              , s = tt(n, i, .75);
            return tt(r, s, .875)
        }
    }
    ,
    4428: (e, t, n) => {
        "use strict";
        n.d(t, {
            $J: () => o,
            BE: () => u,
            Gm: () => r,
            Ne: () => c,
            Q7: () => i,
            Xe: () => s,
            bf: () => h,
            nw: () => l,
            vl: () => d,
            yj: () => a
        });
        const i = 0
          , r = 1
          , s = 2
          , a = 2
          , o = 1.25
          , l = 1
          , c = 32
          , u = 65535
          , h = Math.pow(2, -24)
          , d = Symbol("SKIP_GENERATION")
    }
    ,
    387: (e, t, n) => {
        "use strict";
        n.d(t, {
            zQ: () => Dt,
            LO: () => Pt,
            je: () => Lt
        });
        var i = n(5062);
        function r(e, t, n) {
            return null === e ? null : (e.point.applyMatrix4(t.matrixWorld),
            e.distance = e.point.distanceTo(n.ray.origin),
            e.object = t,
            e.distance < n.near || e.distance > n.far ? null : e)
        }
        var s = n(4428);
        function a(e) {
            return function(e) {
                return e.index ? e.index.count : e.attributes.position.count
            }(e) / 3
        }
        function o(e, t) {
            if (!e.index) {
                const n = e.attributes.position.count
                  , r = function(e, t=ArrayBuffer) {
                    return e > 65535 ? new Uint32Array(new t(4 * e)) : new Uint16Array(new t(2 * e))
                }(n, t.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer);
                e.setIndex(new i.THS(r,1));
                for (let e = 0; e < n; e++)
                    r[e] = e
            }
        }
        function l(e) {
            const t = a(e)
              , n = e.drawRange
              , i = n.start / 3
              , r = (n.start + n.count) / 3
              , s = Math.max(0, i)
              , o = Math.min(t, r) - s;
            return [{
                offset: Math.floor(s),
                count: Math.floor(o)
            }]
        }
        function c(e) {
            if (!e.groups || !e.groups.length)
                return l(e);
            const t = []
              , n = new Set
              , i = e.drawRange
              , r = i.start / 3
              , s = (i.start + i.count) / 3;
            for (const t of e.groups) {
                const e = t.start / 3
                  , i = (t.start + t.count) / 3;
                n.add(Math.max(r, e)),
                n.add(Math.min(s, i))
            }
            const a = Array.from(n.values()).sort(( (e, t) => e - t));
            for (let e = 0; e < a.length - 1; e++) {
                const n = a[e]
                  , i = a[e + 1];
                t.push({
                    offset: Math.floor(n),
                    count: Math.floor(i - n)
                })
            }
            return t
        }
        function u(e, t, n, i, r) {
            let s = 1 / 0
              , a = 1 / 0
              , o = 1 / 0
              , l = -1 / 0
              , c = -1 / 0
              , u = -1 / 0
              , h = 1 / 0
              , d = 1 / 0
              , p = 1 / 0
              , f = -1 / 0
              , A = -1 / 0
              , g = -1 / 0;
            for (let i = 6 * t, r = 6 * (t + n); i < r; i += 6) {
                const t = e[i + 0]
                  , n = e[i + 1]
                  , r = t - n
                  , m = t + n;
                r < s && (s = r),
                m > l && (l = m),
                t < h && (h = t),
                t > f && (f = t);
                const v = e[i + 2]
                  , y = e[i + 3]
                  , x = v - y
                  , _ = v + y;
                x < a && (a = x),
                _ > c && (c = _),
                v < d && (d = v),
                v > A && (A = v);
                const b = e[i + 4]
                  , E = e[i + 5]
                  , w = b - E
                  , C = b + E;
                w < o && (o = w),
                C > u && (u = C),
                b < p && (p = b),
                b > g && (g = b)
            }
            i[0] = s,
            i[1] = a,
            i[2] = o,
            i[3] = l,
            i[4] = c,
            i[5] = u,
            r[0] = h,
            r[1] = d,
            r[2] = p,
            r[3] = f,
            r[4] = A,
            r[5] = g
        }
        function h(e, t, n) {
            return n.min.x = t[e],
            n.min.y = t[e + 1],
            n.min.z = t[e + 2],
            n.max.x = t[e + 3],
            n.max.y = t[e + 4],
            n.max.z = t[e + 5],
            n
        }
        function d(e) {
            let t = -1
              , n = -1 / 0;
            for (let i = 0; i < 3; i++) {
                const r = e[i + 3] - e[i];
                r > n && (n = r,
                t = i)
            }
            return t
        }
        function p(e, t) {
            t.set(e)
        }
        function f(e, t, n) {
            let i, r;
            for (let s = 0; s < 3; s++) {
                const a = s + 3;
                i = e[s],
                r = t[s],
                n[s] = i < r ? i : r,
                i = e[a],
                r = t[a],
                n[a] = i > r ? i : r
            }
        }
        function A(e, t, n) {
            for (let i = 0; i < 3; i++) {
                const r = t[e + 2 * i]
                  , s = t[e + 2 * i + 1]
                  , a = r - s
                  , o = r + s;
                a < n[i] && (n[i] = a),
                o > n[i + 3] && (n[i + 3] = o)
            }
        }
        function g(e) {
            const t = e[3] - e[0]
              , n = e[4] - e[1]
              , i = e[5] - e[2];
            return 2 * (t * n + n * i + i * t)
        }
        const m = 32
          , v = (e, t) => e.candidate - t.candidate
          , y = new Array(m).fill().map(( () => ({
            count: 0,
            bounds: new Float32Array(6),
            rightCacheBounds: new Float32Array(6),
            leftCacheBounds: new Float32Array(6),
            candidate: 0
        })))
          , x = new Float32Array(6);
        class _ {
            constructor() {
                this.boundingData = new Float32Array(6)
            }
        }
        function b(e, t, n, i, r, s) {
            let a = i
              , o = i + r - 1;
            const l = s.pos
              , c = 2 * s.axis;
            for (; ; ) {
                for (; a <= o && n[6 * a + c] < l; )
                    a++;
                for (; a <= o && n[6 * o + c] >= l; )
                    o--;
                if (!(a < o))
                    return a;
                for (let e = 0; e < 3; e++) {
                    let n = t[3 * a + e];
                    t[3 * a + e] = t[3 * o + e],
                    t[3 * o + e] = n
                }
                for (let e = 0; e < 6; e++) {
                    let t = n[6 * a + e];
                    n[6 * a + e] = n[6 * o + e],
                    n[6 * o + e] = t
                }
                a++,
                o--
            }
        }
        function E(e, t, n, i, r, s) {
            let a = i
              , o = i + r - 1;
            const l = s.pos
              , c = 2 * s.axis;
            for (; ; ) {
                for (; a <= o && n[6 * a + c] < l; )
                    a++;
                for (; a <= o && n[6 * o + c] >= l; )
                    o--;
                if (!(a < o))
                    return a;
                {
                    let t = e[a];
                    e[a] = e[o],
                    e[o] = t;
                    for (let e = 0; e < 6; e++) {
                        let t = n[6 * a + e];
                        n[6 * a + e] = n[6 * o + e],
                        n[6 * o + e] = t
                    }
                    a++,
                    o--
                }
            }
        }
        function w(e, t) {
            return 65535 === t[e + 15]
        }
        function C(e, t) {
            return t[e + 6]
        }
        function I(e, t) {
            return t[e + 14]
        }
        function S(e) {
            return e + 8
        }
        function M(e, t) {
            return t[e + 6]
        }
        function T(e, t) {
            return t[e + 7]
        }
        let B, R, D, P;
        const L = Math.pow(2, 32);
        function U(e) {
            return "count"in e ? 1 : 1 + U(e.left) + U(e.right)
        }
        function F(e, t, n) {
            return B = new Float32Array(n),
            R = new Uint32Array(n),
            D = new Uint16Array(n),
            P = new Uint8Array(n),
            N(e, t)
        }
        function N(e, t) {
            const n = e / 4
              , i = e / 2
              , r = "count"in t
              , a = t.boundingData;
            for (let e = 0; e < 6; e++)
                B[n + e] = a[e];
            if (r) {
                if (t.buffer) {
                    const i = t.buffer;
                    P.set(new Uint8Array(i), e);
                    for (let t = e, r = e + i.byteLength; t < r; t += s.Ne) {
                        w(t / 2, D) || (R[t / 4 + 6] += n)
                    }
                    return e + i.byteLength
                }
                {
                    const r = t.offset
                      , a = t.count;
                    return R[n + 6] = r,
                    D[i + 14] = a,
                    D[i + 15] = s.BE,
                    e + s.Ne
                }
            }
            {
                const i = t.left
                  , r = t.right
                  , a = t.splitAxis;
                let o;
                if (o = N(e + s.Ne, i),
                o / 4 > L)
                    throw new Error("MeshBVH: Cannot store child pointer greater than 32 bits.");
                return R[n + 6] = o / 4,
                o = N(o, r),
                R[n + 7] = a,
                o
            }
        }
        function O(e, t, n, i, r) {
            const {maxDepth: o, verbose: l, maxLeafTris: c, strategy: h, onProgress: w, indirect: C} = r
              , I = e._indirectBuffer
              , S = e.geometry
              , M = S.index ? S.index.array : null
              , T = C ? E : b
              , B = a(S)
              , R = new Float32Array(6);
            let D = !1;
            const P = new _;
            return u(t, n, i, P.boundingData, R),
            function e(n, i, r, a=null, b=0) {
                !D && b >= o && (D = !0,
                l && (console.warn(`MeshBVH: Max depth of ${o} reached when generating BVH. Consider increasing maxDepth.`),
                console.warn(S)));
                if (r <= c || b >= o)
                    return L(i + r),
                    n.offset = i,
                    n.count = r,
                    n;
                const E = function(e, t, n, i, r, a) {
                    let o = -1
                      , l = 0;
                    if (a === s.Q7)
                        o = d(t),
                        -1 !== o && (l = (t[o] + t[o + 3]) / 2);
                    else if (a === s.Gm)
                        o = d(e),
                        -1 !== o && (l = function(e, t, n, i) {
                            let r = 0;
                            for (let s = t, a = t + n; s < a; s++)
                                r += e[6 * s + 2 * i];
                            return r / n
                        }(n, i, r, o));
                    else if (a === s.Xe) {
                        const a = g(e);
                        let c = s.$J * r;
                        const u = 6 * i
                          , h = 6 * (i + r);
                        for (let e = 0; e < 3; e++) {
                            const i = t[e]
                              , d = (t[e + 3] - i) / m;
                            if (r < m / 4) {
                                const t = [...y];
                                t.length = r;
                                let i = 0;
                                for (let r = u; r < h; r += 6,
                                i++) {
                                    const s = t[i];
                                    s.candidate = n[r + 2 * e],
                                    s.count = 0;
                                    const {bounds: a, leftCacheBounds: o, rightCacheBounds: l} = s;
                                    for (let e = 0; e < 3; e++)
                                        l[e] = 1 / 0,
                                        l[e + 3] = -1 / 0,
                                        o[e] = 1 / 0,
                                        o[e + 3] = -1 / 0,
                                        a[e] = 1 / 0,
                                        a[e + 3] = -1 / 0;
                                    A(r, n, a)
                                }
                                t.sort(v);
                                let d = r;
                                for (let e = 0; e < d; e++) {
                                    const n = t[e];
                                    for (; e + 1 < d && t[e + 1].candidate === n.candidate; )
                                        t.splice(e + 1, 1),
                                        d--
                                }
                                for (let i = u; i < h; i += 6) {
                                    const r = n[i + 2 * e];
                                    for (let e = 0; e < d; e++) {
                                        const s = t[e];
                                        r >= s.candidate ? A(i, n, s.rightCacheBounds) : (A(i, n, s.leftCacheBounds),
                                        s.count++)
                                    }
                                }
                                for (let n = 0; n < d; n++) {
                                    const i = t[n]
                                      , u = i.count
                                      , h = r - i.count
                                      , d = i.leftCacheBounds
                                      , p = i.rightCacheBounds;
                                    let f = 0;
                                    0 !== u && (f = g(d) / a);
                                    let A = 0;
                                    0 !== h && (A = g(p) / a);
                                    const m = s.nw + s.$J * (f * u + A * h);
                                    m < c && (o = e,
                                    c = m,
                                    l = i.candidate)
                                }
                            } else {
                                for (let e = 0; e < m; e++) {
                                    const t = y[e];
                                    t.count = 0,
                                    t.candidate = i + d + e * d;
                                    const n = t.bounds;
                                    for (let e = 0; e < 3; e++)
                                        n[e] = 1 / 0,
                                        n[e + 3] = -1 / 0
                                }
                                for (let t = u; t < h; t += 6) {
                                    let r = ~~((n[t + 2 * e] - i) / d);
                                    r >= m && (r = m - 1);
                                    const s = y[r];
                                    s.count++,
                                    A(t, n, s.bounds)
                                }
                                const t = y[m - 1];
                                p(t.bounds, t.rightCacheBounds);
                                for (let e = m - 2; e >= 0; e--) {
                                    const t = y[e]
                                      , n = y[e + 1];
                                    f(t.bounds, n.rightCacheBounds, t.rightCacheBounds)
                                }
                                let v = 0;
                                for (let t = 0; t < m - 1; t++) {
                                    const n = y[t]
                                      , i = n.count
                                      , u = n.bounds
                                      , h = y[t + 1].rightCacheBounds;
                                    0 !== i && (0 === v ? p(u, x) : f(u, x, x)),
                                    v += i;
                                    let d = 0
                                      , A = 0;
                                    0 !== v && (d = g(x) / a);
                                    const m = r - v;
                                    0 !== m && (A = g(h) / a);
                                    const _ = s.nw + s.$J * (d * v + A * m);
                                    _ < c && (o = e,
                                    c = _,
                                    l = n.candidate)
                                }
                            }
                        }
                    } else
                        console.warn(`MeshBVH: Invalid build strategy value ${a} used.`);
                    return {
                        axis: o,
                        pos: l
                    }
                }(n.boundingData, a, t, i, r, h);
                if (-1 === E.axis)
                    return L(i + r),
                    n.offset = i,
                    n.count = r,
                    n;
                const w = T(I, M, t, i, r, E);
                if (w === i || w === i + r)
                    L(i + r),
                    n.offset = i,
                    n.count = r;
                else {
                    n.splitAxis = E.axis;
                    const s = new _
                      , a = i
                      , o = w - i;
                    n.left = s,
                    u(t, a, o, s.boundingData, R),
                    e(s, a, o, R, b + 1);
                    const l = new _
                      , c = w
                      , h = r - o;
                    n.right = l,
                    u(t, c, h, l.boundingData, R),
                    e(l, c, h, R, b + 1)
                }
                return n
            }(P, n, i, R),
            P;
            function L(e) {
                w && w(e / B)
            }
        }
        function Q(e, t) {
            const n = e.geometry;
            t.indirect && (e._indirectBuffer = function(e, t) {
                const n = (e.index ? e.index.count : e.attributes.position.count) / 3
                  , i = n > 65536
                  , r = i ? 4 : 2
                  , s = t ? new SharedArrayBuffer(n * r) : new ArrayBuffer(n * r)
                  , a = i ? new Uint32Array(s) : new Uint16Array(s);
                for (let e = 0, t = a.length; e < t; e++)
                    a[e] = e;
                return a
            }(n, t.useSharedArrayBuffer),
            function(e) {
                if (0 === e.groups.length)
                    return !1;
                const t = a(e)
                  , n = c(e).sort(( (e, t) => e.offset - t.offset))
                  , i = n[n.length - 1];
                i.count = Math.min(t - i.offset, i.count);
                let r = 0;
                return n.forEach(( ({count: e}) => r += e)),
                t !== r
            }(n) && !t.verbose && console.warn('MeshBVH: Provided geometry contains groups that do not fully span the vertex contents while using the "indirect" option. BVH may incorrectly report intersections on unrendered portions of the geometry.')),
            e._indirectBuffer || o(n, t);
            const i = t.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer
              , r = function(e, t=null, n=null, i=null) {
                const r = e.attributes.position
                  , o = e.index ? e.index.array : null
                  , l = a(e)
                  , c = r.normalized;
                let u;
                null === t ? (u = new Float32Array(6 * l * 4),
                n = 0,
                i = l) : (u = t,
                n = n || 0,
                i = i || l);
                const h = r.array
                  , d = r.offset || 0;
                let p = 3;
                r.isInterleavedBufferAttribute && (p = r.data.stride);
                const f = ["getX", "getY", "getZ"];
                for (let e = n; e < n + i; e++) {
                    const t = 3 * e
                      , n = 6 * e;
                    let i = t + 0
                      , a = t + 1
                      , l = t + 2;
                    o && (i = o[i],
                    a = o[a],
                    l = o[l]),
                    c || (i = i * p + d,
                    a = a * p + d,
                    l = l * p + d);
                    for (let e = 0; e < 3; e++) {
                        let t, o, d;
                        c ? (t = r[f[e]](i),
                        o = r[f[e]](a),
                        d = r[f[e]](l)) : (t = h[i + e],
                        o = h[a + e],
                        d = h[l + e]);
                        let p = t;
                        o < p && (p = o),
                        d < p && (p = d);
                        let A = t;
                        o > A && (A = o),
                        d > A && (A = d);
                        const g = (A - p) / 2
                          , m = 2 * e;
                        u[n + m + 0] = p + g,
                        u[n + m + 1] = g + (Math.abs(p) + g) * s.bf
                    }
                }
                return u
            }(n)
              , u = t.indirect ? l(n) : c(n);
            e._roots = u.map((n => {
                const a = O(e, r, n.offset, n.count, t)
                  , o = U(a)
                  , l = new i(s.Ne * o);
                return F(0, a, l),
                l
            }
            ))
        }
        class k {
            constructor() {
                this.min = 1 / 0,
                this.max = -1 / 0
            }
            setFromPointsField(e, t) {
                let n = 1 / 0
                  , i = -1 / 0;
                for (let r = 0, s = e.length; r < s; r++) {
                    const s = e[r][t];
                    n = s < n ? s : n,
                    i = s > i ? s : i
                }
                this.min = n,
                this.max = i
            }
            setFromPoints(e, t) {
                let n = 1 / 0
                  , i = -1 / 0;
                for (let r = 0, s = t.length; r < s; r++) {
                    const s = t[r]
                      , a = e.dot(s);
                    n = a < n ? a : n,
                    i = a > i ? a : i
                }
                this.min = n,
                this.max = i
            }
            isSeparated(e) {
                return this.min > e.max || e.min > this.max
            }
        }
        k.prototype.setFromBox = function() {
            const e = new i.Pq0;
            return function(t, n) {
                const i = n.min
                  , r = n.max;
                let s = 1 / 0
                  , a = -1 / 0;
                for (let n = 0; n <= 1; n++)
                    for (let o = 0; o <= 1; o++)
                        for (let l = 0; l <= 1; l++) {
                            e.x = i.x * n + r.x * (1 - n),
                            e.y = i.y * o + r.y * (1 - o),
                            e.z = i.z * l + r.z * (1 - l);
                            const c = t.dot(e);
                            s = Math.min(c, s),
                            a = Math.max(c, a)
                        }
                this.min = s,
                this.max = a
            }
        }();
        !function() {
            const e = new k
        }();
        const G = function() {
            const e = new i.Pq0
              , t = new i.Pq0
              , n = new i.Pq0;
            return function(i, r, s) {
                const a = i.start
                  , o = e
                  , l = r.start
                  , c = t;
                n.subVectors(a, l),
                e.subVectors(i.end, i.start),
                t.subVectors(r.end, r.start);
                const u = n.dot(c)
                  , h = c.dot(o)
                  , d = c.dot(c)
                  , p = n.dot(o)
                  , f = o.dot(o) * d - h * h;
                let A, g;
                A = 0 !== f ? (u * h - p * d) / f : 0,
                g = (u + A * h) / d,
                s.x = A,
                s.y = g
            }
        }()
          , H = function() {
            const e = new i.I9Y
              , t = new i.Pq0
              , n = new i.Pq0;
            return function(i, r, s, a) {
                G(i, r, e);
                let o = e.x
                  , l = e.y;
                if (o >= 0 && o <= 1 && l >= 0 && l <= 1)
                    return i.at(o, s),
                    void r.at(l, a);
                if (o >= 0 && o <= 1)
                    return l < 0 ? r.at(0, a) : r.at(1, a),
                    void i.closestPointToPoint(a, !0, s);
                if (l >= 0 && l <= 1)
                    return o < 0 ? i.at(0, s) : i.at(1, s),
                    void r.closestPointToPoint(s, !0, a);
                {
                    let e, c;
                    e = o < 0 ? i.start : i.end,
                    c = l < 0 ? r.start : r.end;
                    const u = t
                      , h = n;
                    return i.closestPointToPoint(c, !0, t),
                    r.closestPointToPoint(e, !0, n),
                    u.distanceToSquared(c) <= h.distanceToSquared(e) ? (s.copy(u),
                    void a.copy(c)) : (s.copy(e),
                    void a.copy(h))
                }
            }
        }()
          , z = function() {
            const e = new i.Pq0
              , t = new i.Pq0
              , n = new i.Zcv
              , r = new i.cZY;
            return function(i, s) {
                const {radius: a, center: o} = i
                  , {a: l, b: c, c: u} = s;
                r.start = l,
                r.end = c;
                if (r.closestPointToPoint(o, !0, e).distanceTo(o) <= a)
                    return !0;
                r.start = l,
                r.end = u;
                if (r.closestPointToPoint(o, !0, e).distanceTo(o) <= a)
                    return !0;
                r.start = c,
                r.end = u;
                if (r.closestPointToPoint(o, !0, e).distanceTo(o) <= a)
                    return !0;
                const h = s.getPlane(n);
                if (Math.abs(h.distanceToPoint(o)) <= a) {
                    const e = h.projectPoint(o, t);
                    if (s.containsPoint(e))
                        return !0
                }
                return !1
            }
        }();
        function V(e) {
            return Math.abs(e) < 1e-15
        }
        class W extends i.lMl {
            constructor(...e) {
                super(...e),
                this.isExtendedTriangle = !0,
                this.satAxes = new Array(4).fill().map(( () => new i.Pq0)),
                this.satBounds = new Array(4).fill().map(( () => new k)),
                this.points = [this.a, this.b, this.c],
                this.sphere = new i.iyt,
                this.plane = new i.Zcv,
                this.needsUpdate = !0
            }
            intersectsSphere(e) {
                return z(e, this)
            }
            update() {
                const e = this.a
                  , t = this.b
                  , n = this.c
                  , i = this.points
                  , r = this.satAxes
                  , s = this.satBounds
                  , a = r[0]
                  , o = s[0];
                this.getNormal(a),
                o.setFromPoints(a, i);
                const l = r[1]
                  , c = s[1];
                l.subVectors(e, t),
                c.setFromPoints(l, i);
                const u = r[2]
                  , h = s[2];
                u.subVectors(t, n),
                h.setFromPoints(u, i);
                const d = r[3]
                  , p = s[3];
                d.subVectors(n, e),
                p.setFromPoints(d, i),
                this.sphere.setFromPoints(this.points),
                this.plane.setFromNormalAndCoplanarPoint(a, e),
                this.needsUpdate = !1
            }
        }
        W.prototype.closestPointToSegment = function() {
            const e = new i.Pq0
              , t = new i.Pq0
              , n = new i.cZY;
            return function(i, r=null, s=null) {
                const {start: a, end: o} = i
                  , l = this.points;
                let c, u = 1 / 0;
                for (let a = 0; a < 3; a++) {
                    const o = (a + 1) % 3;
                    n.start.copy(l[a]),
                    n.end.copy(l[o]),
                    H(n, i, e, t),
                    c = e.distanceToSquared(t),
                    c < u && (u = c,
                    r && r.copy(e),
                    s && s.copy(t))
                }
                return this.closestPointToPoint(a, e),
                c = a.distanceToSquared(e),
                c < u && (u = c,
                r && r.copy(e),
                s && s.copy(a)),
                this.closestPointToPoint(o, e),
                c = o.distanceToSquared(e),
                c < u && (u = c,
                r && r.copy(e),
                s && s.copy(o)),
                Math.sqrt(u)
            }
        }(),
        W.prototype.intersectsTriangle = function() {
            const e = new W
              , t = new Array(3)
              , n = new Array(3)
              , r = new k
              , s = new k
              , a = new i.Pq0
              , o = new i.Pq0
              , l = new i.Pq0
              , c = new i.Pq0
              , u = new i.Pq0
              , h = new i.cZY
              , d = new i.cZY
              , p = new i.cZY
              , f = new i.Pq0;
            function A(e, t, n) {
                const i = e.points;
                let r = 0
                  , s = -1;
                for (let e = 0; e < 3; e++) {
                    const {start: a, end: l} = h;
                    a.copy(i[e]),
                    l.copy(i[(e + 1) % 3]),
                    h.delta(o);
                    const c = V(t.distanceToPoint(a));
                    if (V(t.normal.dot(o)) && c) {
                        n.copy(h),
                        r = 2;
                        break
                    }
                    const u = t.intersectLine(h, f);
                    if (!u && c && f.copy(a),
                    (u || c) && !V(f.distanceTo(l))) {
                        if (r <= 1) {
                            (1 === r ? n.start : n.end).copy(f),
                            c && (s = r)
                        } else if (r >= 2) {
                            (1 === s ? n.start : n.end).copy(f),
                            r = 2;
                            break
                        }
                        if (r++,
                        2 === r && -1 === s)
                            break
                    }
                }
                return r
            }
            return function(i, o=null, h=!1) {
                this.needsUpdate && this.update(),
                i.isExtendedTriangle ? i.needsUpdate && i.update() : (e.copy(i),
                e.update(),
                i = e);
                const f = this.plane
                  , g = i.plane;
                if (Math.abs(f.normal.dot(g.normal)) > 1 - 1e-10) {
                    const e = this.satBounds
                      , l = this.satAxes;
                    n[0] = i.a,
                    n[1] = i.b,
                    n[2] = i.c;
                    for (let t = 0; t < 4; t++) {
                        const i = e[t]
                          , s = l[t];
                        if (r.setFromPoints(s, n),
                        i.isSeparated(r))
                            return !1
                    }
                    const c = i.satBounds
                      , u = i.satAxes;
                    t[0] = this.a,
                    t[1] = this.b,
                    t[2] = this.c;
                    for (let e = 0; e < 4; e++) {
                        const n = c[e]
                          , i = u[e];
                        if (r.setFromPoints(i, t),
                        n.isSeparated(r))
                            return !1
                    }
                    for (let e = 0; e < 4; e++) {
                        const i = l[e];
                        for (let e = 0; e < 4; e++) {
                            const o = u[e];
                            if (a.crossVectors(i, o),
                            r.setFromPoints(a, t),
                            s.setFromPoints(a, n),
                            r.isSeparated(s))
                                return !1
                        }
                    }
                    return o && (h || console.warn("ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0."),
                    o.start.set(0, 0, 0),
                    o.end.set(0, 0, 0)),
                    !0
                }
                {
                    const e = A(this, g, d);
                    if (1 === e && i.containsPoint(d.end))
                        return o && (o.start.copy(d.end),
                        o.end.copy(d.end)),
                        !0;
                    if (2 !== e)
                        return !1;
                    const t = A(i, f, p);
                    if (1 === t && this.containsPoint(p.end))
                        return o && (o.start.copy(p.end),
                        o.end.copy(p.end)),
                        !0;
                    if (2 !== t)
                        return !1;
                    if (d.delta(l),
                    p.delta(c),
                    l.dot(c) < 0) {
                        let e = p.start;
                        p.start = p.end,
                        p.end = e
                    }
                    const n = d.start.dot(l)
                      , r = d.end.dot(l)
                      , s = p.start.dot(l)
                      , a = p.end.dot(l);
                    return (n === a || s === r || r < s !== n < a) && (o && (u.subVectors(d.start, p.start),
                    u.dot(l) > 0 ? o.start.copy(d.start) : o.start.copy(p.start),
                    u.subVectors(d.end, p.end),
                    u.dot(l) < 0 ? o.end.copy(d.end) : o.end.copy(p.end)),
                    !0)
                }
            }
        }(),
        W.prototype.distanceToPoint = function() {
            const e = new i.Pq0;
            return function(t) {
                return this.closestPointToPoint(t, e),
                t.distanceTo(e)
            }
        }(),
        W.prototype.distanceToTriangle = function() {
            const e = new i.Pq0
              , t = new i.Pq0
              , n = ["a", "b", "c"]
              , r = new i.cZY
              , s = new i.cZY;
            return function(i, a=null, o=null) {
                const l = a || o ? r : null;
                if (this.intersectsTriangle(i, l))
                    return (a || o) && (a && l.getCenter(a),
                    o && l.getCenter(o)),
                    0;
                let c = 1 / 0;
                for (let t = 0; t < 3; t++) {
                    let r;
                    const s = n[t]
                      , l = i[s];
                    this.closestPointToPoint(l, e),
                    r = l.distanceToSquared(e),
                    r < c && (c = r,
                    a && a.copy(e),
                    o && o.copy(l));
                    const u = this[s];
                    i.closestPointToPoint(u, e),
                    r = u.distanceToSquared(e),
                    r < c && (c = r,
                    a && a.copy(u),
                    o && o.copy(e))
                }
                for (let l = 0; l < 3; l++) {
                    const u = n[l]
                      , h = n[(l + 1) % 3];
                    r.set(this[u], this[h]);
                    for (let l = 0; l < 3; l++) {
                        const u = n[l]
                          , h = n[(l + 1) % 3];
                        s.set(i[u], i[h]),
                        H(r, s, e, t);
                        const d = e.distanceToSquared(t);
                        d < c && (c = d,
                        a && a.copy(e),
                        o && o.copy(t))
                    }
                }
                return Math.sqrt(c)
            }
        }();
        class j {
            constructor(e, t, n) {
                this.isOrientedBox = !0,
                this.min = new i.Pq0,
                this.max = new i.Pq0,
                this.matrix = new i.kn4,
                this.invMatrix = new i.kn4,
                this.points = new Array(8).fill().map(( () => new i.Pq0)),
                this.satAxes = new Array(3).fill().map(( () => new i.Pq0)),
                this.satBounds = new Array(3).fill().map(( () => new k)),
                this.alignedSatBounds = new Array(3).fill().map(( () => new k)),
                this.needsUpdate = !1,
                e && this.min.copy(e),
                t && this.max.copy(t),
                n && this.matrix.copy(n)
            }
            set(e, t, n) {
                this.min.copy(e),
                this.max.copy(t),
                this.matrix.copy(n),
                this.needsUpdate = !0
            }
            copy(e) {
                this.min.copy(e.min),
                this.max.copy(e.max),
                this.matrix.copy(e.matrix),
                this.needsUpdate = !0
            }
        }
        j.prototype.update = function() {
            const e = this.matrix
              , t = this.min
              , n = this.max
              , i = this.points;
            for (let r = 0; r <= 1; r++)
                for (let s = 0; s <= 1; s++)
                    for (let a = 0; a <= 1; a++) {
                        const o = i[1 * r | 2 * s | 4 * a];
                        o.x = r ? n.x : t.x,
                        o.y = s ? n.y : t.y,
                        o.z = a ? n.z : t.z,
                        o.applyMatrix4(e)
                    }
            const r = this.satBounds
              , s = this.satAxes
              , a = i[0];
            for (let e = 0; e < 3; e++) {
                const t = s[e]
                  , n = r[e]
                  , o = i[1 << e];
                t.subVectors(a, o),
                n.setFromPoints(t, i)
            }
            const o = this.alignedSatBounds;
            o[0].setFromPointsField(i, "x"),
            o[1].setFromPointsField(i, "y"),
            o[2].setFromPointsField(i, "z"),
            this.invMatrix.copy(this.matrix).invert(),
            this.needsUpdate = !1
        }
        ,
        j.prototype.intersectsBox = function() {
            const e = new k;
            return function(t) {
                this.needsUpdate && this.update();
                const n = t.min
                  , i = t.max
                  , r = this.satBounds
                  , s = this.satAxes
                  , a = this.alignedSatBounds;
                if (e.min = n.x,
                e.max = i.x,
                a[0].isSeparated(e))
                    return !1;
                if (e.min = n.y,
                e.max = i.y,
                a[1].isSeparated(e))
                    return !1;
                if (e.min = n.z,
                e.max = i.z,
                a[2].isSeparated(e))
                    return !1;
                for (let n = 0; n < 3; n++) {
                    const i = s[n]
                      , a = r[n];
                    if (e.setFromBox(i, t),
                    a.isSeparated(e))
                        return !1
                }
                return !0
            }
        }(),
        j.prototype.intersectsTriangle = function() {
            const e = new W
              , t = new Array(3)
              , n = new k
              , r = new k
              , s = new i.Pq0;
            return function(i) {
                this.needsUpdate && this.update(),
                i.isExtendedTriangle ? i.needsUpdate && i.update() : (e.copy(i),
                e.update(),
                i = e);
                const a = this.satBounds
                  , o = this.satAxes;
                t[0] = i.a,
                t[1] = i.b,
                t[2] = i.c;
                for (let e = 0; e < 3; e++) {
                    const i = a[e]
                      , r = o[e];
                    if (n.setFromPoints(r, t),
                    i.isSeparated(n))
                        return !1
                }
                const l = i.satBounds
                  , c = i.satAxes
                  , u = this.points;
                for (let e = 0; e < 3; e++) {
                    const t = l[e]
                      , i = c[e];
                    if (n.setFromPoints(i, u),
                    t.isSeparated(n))
                        return !1
                }
                for (let e = 0; e < 3; e++) {
                    const i = o[e];
                    for (let e = 0; e < 4; e++) {
                        const a = c[e];
                        if (s.crossVectors(i, a),
                        n.setFromPoints(s, t),
                        r.setFromPoints(s, u),
                        n.isSeparated(r))
                            return !1
                    }
                }
                return !0
            }
        }(),
        j.prototype.closestPointToPoint = function(e, t) {
            return this.needsUpdate && this.update(),
            t.copy(e).applyMatrix4(this.invMatrix).clamp(this.min, this.max).applyMatrix4(this.matrix),
            t
        }
        ,
        j.prototype.distanceToPoint = function() {
            const e = new i.Pq0;
            return function(t) {
                return this.closestPointToPoint(t, e),
                t.distanceTo(e)
            }
        }(),
        j.prototype.distanceToBox = function() {
            const e = ["x", "y", "z"]
              , t = new Array(12).fill().map(( () => new i.cZY))
              , n = new Array(12).fill().map(( () => new i.cZY))
              , r = new i.Pq0
              , s = new i.Pq0;
            return function(i, a=0, o=null, l=null) {
                if (this.needsUpdate && this.update(),
                this.intersectsBox(i))
                    return (o || l) && (i.getCenter(s),
                    this.closestPointToPoint(s, r),
                    i.closestPointToPoint(r, s),
                    o && o.copy(r),
                    l && l.copy(s)),
                    0;
                const c = a * a
                  , u = i.min
                  , h = i.max
                  , d = this.points;
                let p = 1 / 0;
                for (let e = 0; e < 8; e++) {
                    const t = d[e];
                    s.copy(t).clamp(u, h);
                    const n = t.distanceToSquared(s);
                    if (n < p && (p = n,
                    o && o.copy(t),
                    l && l.copy(s),
                    n < c))
                        return Math.sqrt(n)
                }
                let f = 0;
                for (let i = 0; i < 3; i++)
                    for (let r = 0; r <= 1; r++)
                        for (let s = 0; s <= 1; s++) {
                            const a = (i + 1) % 3
                              , o = (i + 2) % 3
                              , l = 1 << i | r << a | s << o
                              , c = d[r << a | s << o]
                              , p = d[l];
                            t[f].set(c, p);
                            const A = e[i]
                              , g = e[a]
                              , m = e[o]
                              , v = n[f]
                              , y = v.start
                              , x = v.end;
                            y[A] = u[A],
                            y[g] = r ? u[g] : h[g],
                            y[m] = s ? u[m] : h[g],
                            x[A] = h[A],
                            x[g] = r ? u[g] : h[g],
                            x[m] = s ? u[m] : h[g],
                            f++
                        }
                for (let e = 0; e <= 1; e++)
                    for (let t = 0; t <= 1; t++)
                        for (let n = 0; n <= 1; n++) {
                            s.x = e ? h.x : u.x,
                            s.y = t ? h.y : u.y,
                            s.z = n ? h.z : u.z,
                            this.closestPointToPoint(s, r);
                            const i = s.distanceToSquared(r);
                            if (i < p && (p = i,
                            o && o.copy(r),
                            l && l.copy(s),
                            i < c))
                                return Math.sqrt(i)
                        }
                for (let e = 0; e < 12; e++) {
                    const i = t[e];
                    for (let e = 0; e < 12; e++) {
                        const t = n[e];
                        H(i, t, r, s);
                        const a = r.distanceToSquared(s);
                        if (a < p && (p = a,
                        o && o.copy(r),
                        l && l.copy(s),
                        a < c))
                            return Math.sqrt(a)
                    }
                }
                return Math.sqrt(p)
            }
        }();
        class q {
            constructor(e) {
                this._getNewPrimitive = e,
                this._primitives = []
            }
            getPrimitive() {
                const e = this._primitives;
                return 0 === e.length ? this._getNewPrimitive() : e.pop()
            }
            releasePrimitive(e) {
                this._primitives.push(e)
            }
        }
        class Y extends q {
            constructor() {
                super(( () => new W))
            }
        }
        const X = new Y;
        const K = new class {
            constructor() {
                this.float32Array = null,
                this.uint16Array = null,
                this.uint32Array = null;
                const e = [];
                let t = null;
                this.setBuffer = n => {
                    t && e.push(t),
                    t = n,
                    this.float32Array = new Float32Array(n),
                    this.uint16Array = new Uint16Array(n),
                    this.uint32Array = new Uint32Array(n)
                }
                ,
                this.clearBuffer = () => {
                    t = null,
                    this.float32Array = null,
                    this.uint16Array = null,
                    this.uint32Array = null,
                    0 !== e.length && this.setBuffer(e.pop())
                }
            }
        }
        ;
        let J, Z;
        const $ = []
          , ee = new q(( () => new i.NRn));
        function te(e, t, n, i, r, s) {
            J = ee.getPrimitive(),
            Z = ee.getPrimitive(),
            $.push(J, Z),
            K.setBuffer(e._roots[t]);
            const a = ne(0, e.geometry, n, i, r, s);
            K.clearBuffer(),
            ee.releasePrimitive(J),
            ee.releasePrimitive(Z),
            $.pop(),
            $.pop();
            const o = $.length;
            return o > 0 && (Z = $[o - 1],
            J = $[o - 2]),
            a
        }
        function ne(e, t, n, i, r=null, a=0, o=0) {
            const {float32Array: l, uint16Array: c, uint32Array: u} = K;
            let d = 2 * e;
            if (w(d, c)) {
                const p = C(e, u)
                  , f = I(d, c);
                return h(e, l, J),
                i(p, f, !1, o, a + e, J)
            }
            {
                const A = S(e)
                  , g = M(e, u);
                let m, v, y, x, _ = A, b = g;
                if (r && (y = J,
                x = Z,
                h(_, l, y),
                h(b, l, x),
                m = r(y),
                v = r(x),
                v < m)) {
                    _ = g,
                    b = A;
                    const L = m;
                    m = v,
                    v = L,
                    y = x
                }
                y || (y = J,
                h(_, l, y));
                const E = n(y, w(2 * _, c), m, o + 1, a + _);
                let T;
                if (E === s.yj) {
                    const U = D(_);
                    T = i(U, P(_) - U, !0, o + 1, a + _, y)
                } else
                    T = E && ne(_, t, n, i, r, a, o + 1);
                if (T)
                    return !0;
                x = Z,
                h(b, l, x);
                const B = n(x, w(2 * b, c), v, o + 1, a + b);
                let R;
                if (B === s.yj) {
                    const F = D(b);
                    R = i(F, P(b) - F, !0, o + 1, a + b, x)
                } else
                    R = B && ne(b, t, n, i, r, a, o + 1);
                return !!R;
                function D(e) {
                    const {uint16Array: t, uint32Array: n} = K;
                    let i = 2 * e;
                    for (; !w(i, t); )
                        i = 2 * (e = S(e));
                    return C(e, n)
                }
                function P(e) {
                    const {uint16Array: t, uint32Array: n} = K;
                    let i = 2 * e;
                    for (; !w(i, t); )
                        i = 2 * (e = M(e, n));
                    return C(e, n) + I(i, t)
                }
            }
        }
        const ie = new i.Pq0
          , re = new i.Pq0;
        const se = new i.Pq0
          , ae = new i.Pq0
          , oe = new i.Pq0
          , le = new i.I9Y
          , ce = new i.I9Y
          , ue = new i.I9Y
          , he = new i.Pq0
          , de = new i.Pq0
          , pe = new i.Pq0
          , fe = new i.Pq0;
        function Ae(e, t, n, r, s, a, o, l, c) {
            se.fromBufferAttribute(t, a),
            ae.fromBufferAttribute(t, o),
            oe.fromBufferAttribute(t, l);
            const u = function(e, t, n, r, s, a) {
                let o;
                return o = a === i.hsX ? e.intersectTriangle(r, n, t, !0, s) : e.intersectTriangle(t, n, r, a !== i.$EB, s),
                null === o ? null : {
                    distance: e.origin.distanceTo(s),
                    point: s.clone()
                }
            }(e, se, ae, oe, fe, c);
            if (u) {
                r && (le.fromBufferAttribute(r, a),
                ce.fromBufferAttribute(r, o),
                ue.fromBufferAttribute(r, l),
                u.uv = i.lMl.getInterpolation(fe, se, ae, oe, le, ce, ue, new i.I9Y)),
                s && (le.fromBufferAttribute(s, a),
                ce.fromBufferAttribute(s, o),
                ue.fromBufferAttribute(s, l),
                u.uv1 = i.lMl.getInterpolation(fe, se, ae, oe, le, ce, ue, new i.I9Y)),
                n && (he.fromBufferAttribute(n, a),
                de.fromBufferAttribute(n, o),
                pe.fromBufferAttribute(n, l),
                u.normal = i.lMl.getInterpolation(fe, se, ae, oe, he, de, pe, new i.Pq0),
                u.normal.dot(e.direction) > 0 && u.normal.multiplyScalar(-1));
                const t = {
                    a,
                    b: o,
                    c: l,
                    normal: new i.Pq0,
                    materialIndex: 0
                };
                i.lMl.getNormal(se, ae, oe, t.normal),
                u.face = t,
                u.faceIndex = a
            }
            return u
        }
        function ge(e, t, n, i, r) {
            const s = 3 * i;
            let a = s + 0
              , o = s + 1
              , l = s + 2;
            const c = e.index;
            e.index && (a = c.getX(a),
            o = c.getX(o),
            l = c.getX(l));
            const {position: u, normal: h, uv: d, uv1: p} = e.attributes
              , f = Ae(n, u, h, d, p, a, o, l, t);
            return f ? (f.faceIndex = i,
            r && r.push(f),
            f) : null
        }
        function me(e, t, n, i) {
            const r = e.a
              , s = e.b
              , a = e.c;
            let o = t
              , l = t + 1
              , c = t + 2;
            n && (o = n.getX(o),
            l = n.getX(l),
            c = n.getX(c)),
            r.x = i.getX(o),
            r.y = i.getY(o),
            r.z = i.getZ(o),
            s.x = i.getX(l),
            s.y = i.getY(l),
            s.z = i.getZ(l),
            a.x = i.getX(c),
            a.y = i.getY(c),
            a.z = i.getZ(c)
        }
        function ve(e, t, n, i, r, s, a) {
            const {geometry: o} = n
              , {index: l} = o
              , c = o.attributes.position;
            for (let n = e, o = t + e; n < o; n++) {
                let e;
                if (e = n,
                me(a, 3 * e, l, c),
                a.needsUpdate = !0,
                i(a, e, r, s))
                    return !0
            }
            return !1
        }
        function ye(e, t=null) {
            t && Array.isArray(t) && (t = new Set(t));
            const n = e.geometry
              , i = n.index ? n.index.array : null
              , r = n.attributes.position;
            let a, o, l, c, u = 0;
            const h = e._roots;
            for (let e = 0, t = h.length; e < t; e++)
                a = h[e],
                o = new Uint32Array(a),
                l = new Uint16Array(a),
                c = new Float32Array(a),
                d(0, u),
                u += a.byteLength;
            function d(e, n, a=!1) {
                const u = 2 * e;
                if (l[u + 15] === s.BE) {
                    const t = o[e + 6];
                    let n = 1 / 0
                      , s = 1 / 0
                      , a = 1 / 0
                      , h = -1 / 0
                      , d = -1 / 0
                      , p = -1 / 0;
                    for (let e = 3 * t, o = 3 * (t + l[u + 14]); e < o; e++) {
                        let t = i[e];
                        const o = r.getX(t)
                          , l = r.getY(t)
                          , c = r.getZ(t);
                        o < n && (n = o),
                        o > h && (h = o),
                        l < s && (s = l),
                        l > d && (d = l),
                        c < a && (a = c),
                        c > p && (p = c)
                    }
                    return (c[e + 0] !== n || c[e + 1] !== s || c[e + 2] !== a || c[e + 3] !== h || c[e + 4] !== d || c[e + 5] !== p) && (c[e + 0] = n,
                    c[e + 1] = s,
                    c[e + 2] = a,
                    c[e + 3] = h,
                    c[e + 4] = d,
                    c[e + 5] = p,
                    !0)
                }
                {
                    const i = e + 8
                      , r = o[e + 6]
                      , s = i + n
                      , l = r + n;
                    let u = a
                      , h = !1
                      , p = !1;
                    t ? u || (h = t.has(s),
                    p = t.has(l),
                    u = !h && !p) : (h = !0,
                    p = !0);
                    const f = u || p;
                    let A = !1;
                    (u || h) && (A = d(i, n, u));
                    let g = !1;
                    f && (g = d(r, n, u));
                    const m = A || g;
                    if (m)
                        for (let t = 0; t < 3; t++) {
                            const n = i + t
                              , s = r + t
                              , a = c[n]
                              , o = c[n + 3]
                              , l = c[s]
                              , u = c[s + 3];
                            c[e + t] = a < l ? a : l,
                            c[e + t + 3] = o > u ? o : u
                        }
                    return m
                }
            }
        }
        const xe = new i.NRn;
        function _e(e, t, n, i) {
            return h(e, t, xe),
            n.intersectBox(xe, i)
        }
        const be = new i.Pq0;
        function Ee(e, t, n, i, r) {
            K.setBuffer(e._roots[t]),
            we(0, e, n, i, r),
            K.clearBuffer()
        }
        function we(e, t, n, i, r) {
            const {float32Array: s, uint16Array: a, uint32Array: o} = K
              , l = 2 * e;
            if (w(l, a)) {
                !function(e, t, n, i, r, s) {
                    const {geometry: a, _indirectBuffer: o} = e;
                    for (let e = i, o = i + r; e < o; e++)
                        ge(a, t, n, e, s)
                }(t, n, i, C(e, o), I(l, a), r)
            } else {
                const a = S(e);
                _e(a, s, i, be) && we(a, t, n, i, r);
                const l = M(e, o);
                _e(l, s, i, be) && we(l, t, n, i, r)
            }
        }
        const Ce = new i.Pq0
          , Ie = ["x", "y", "z"];
        function Se(e, t, n, i) {
            K.setBuffer(e._roots[t]);
            const r = Me(0, e, n, i);
            return K.clearBuffer(),
            r
        }
        function Me(e, t, n, i) {
            const {float32Array: r, uint16Array: s, uint32Array: a} = K;
            let o = 2 * e;
            if (w(o, s)) {
                return function(e, t, n, i, r) {
                    const {geometry: s, _indirectBuffer: a} = e;
                    let o = 1 / 0
                      , l = null;
                    for (let e = i, a = i + r; e < a; e++) {
                        let i;
                        i = ge(s, t, n, e),
                        i && i.distance < o && (l = i,
                        o = i.distance)
                    }
                    return l
                }(t, n, i, C(e, a), I(o, s))
            }
            {
                const s = T(e, a)
                  , o = Ie[s]
                  , l = i.direction[o] >= 0;
                let c, u;
                l ? (c = S(e),
                u = M(e, a)) : (c = M(e, a),
                u = S(e));
                const h = _e(c, r, i, Ce) ? Me(c, t, n, i) : null;
                if (h) {
                    const e = h.point[o];
                    if (l ? e <= r[u + s] : e >= r[u + s + 3])
                        return h
                }
                const d = _e(u, r, i, Ce) ? Me(u, t, n, i) : null;
                return h && d ? h.distance <= d.distance ? h : d : h || d || null
            }
        }
        const Te = new i.NRn
          , Be = new W
          , Re = new W
          , De = new i.kn4
          , Pe = new j
          , Le = new j;
        function Ue(e, t, n, i) {
            K.setBuffer(e._roots[t]);
            const r = Fe(0, e, n, i);
            return K.clearBuffer(),
            r
        }
        function Fe(e, t, n, i, r=null) {
            const {float32Array: s, uint16Array: a, uint32Array: o} = K;
            let l = 2 * e;
            null === r && (n.boundingBox || n.computeBoundingBox(),
            Pe.set(n.boundingBox.min, n.boundingBox.max, i),
            r = Pe);
            if (!w(l, a)) {
                const a = e + 8
                  , l = o[e + 6];
                h(a, s, Te);
                if (r.intersectsBox(Te) && Fe(a, t, n, i, r))
                    return !0;
                h(l, s, Te);
                return !!(r.intersectsBox(Te) && Fe(l, t, n, i, r))
            }
            {
                const r = t.geometry
                  , c = r.index
                  , u = r.attributes.position
                  , d = n.index
                  , p = n.attributes.position
                  , f = C(e, o)
                  , A = I(l, a);
                if (De.copy(i).invert(),
                n.boundsTree) {
                    h(e, s, Le),
                    Le.matrix.copy(De),
                    Le.needsUpdate = !0;
                    return n.boundsTree.shapecast({
                        intersectsBounds: e => Le.intersectsBox(e),
                        intersectsTriangle: e => {
                            e.a.applyMatrix4(i),
                            e.b.applyMatrix4(i),
                            e.c.applyMatrix4(i),
                            e.needsUpdate = !0;
                            for (let t = 3 * f, n = 3 * (A + f); t < n; t += 3)
                                if (me(Re, t, c, u),
                                Re.needsUpdate = !0,
                                e.intersectsTriangle(Re))
                                    return !0;
                            return !1
                        }
                    })
                }
                for (let e = 3 * f, t = 3 * (A + f); e < t; e += 3) {
                    me(Be, e, c, u),
                    Be.a.applyMatrix4(De),
                    Be.b.applyMatrix4(De),
                    Be.c.applyMatrix4(De),
                    Be.needsUpdate = !0;
                    for (let e = 0, t = d.count; e < t; e += 3)
                        if (me(Re, e, d, p),
                        Re.needsUpdate = !0,
                        Be.intersectsTriangle(Re))
                            return !0
                }
            }
        }
        const Ne = new i.kn4
          , Oe = new j
          , Qe = new j
          , ke = new i.Pq0
          , Ge = new i.Pq0
          , He = new i.Pq0
          , ze = new i.Pq0;
        function Ve(e, t, n, i={}, r={}, s=0, o=1 / 0) {
            t.boundingBox || t.computeBoundingBox(),
            Oe.set(t.boundingBox.min, t.boundingBox.max, n),
            Oe.needsUpdate = !0;
            const l = e.geometry
              , c = l.attributes.position
              , u = l.index
              , h = t.attributes.position
              , d = t.index
              , p = X.getPrimitive()
              , f = X.getPrimitive();
            let A = ke
              , g = Ge
              , m = null
              , v = null;
            r && (m = He,
            v = ze);
            let y = 1 / 0
              , x = null
              , _ = null;
            return Ne.copy(n).invert(),
            Qe.matrix.copy(Ne),
            e.shapecast({
                boundsTraverseOrder: e => Oe.distanceToBox(e),
                intersectsBounds: (e, t, n) => n < y && n < o && (t && (Qe.min.copy(e.min),
                Qe.max.copy(e.max),
                Qe.needsUpdate = !0),
                !0),
                intersectsRange: (e, i) => {
                    if (t.boundsTree) {
                        return t.boundsTree.shapecast({
                            boundsTraverseOrder: e => Qe.distanceToBox(e),
                            intersectsBounds: (e, t, n) => n < y && n < o,
                            intersectsRange: (t, r) => {
                                for (let a = t, o = t + r; a < o; a++) {
                                    me(f, 3 * a, d, h),
                                    f.a.applyMatrix4(n),
                                    f.b.applyMatrix4(n),
                                    f.c.applyMatrix4(n),
                                    f.needsUpdate = !0;
                                    for (let t = e, n = e + i; t < n; t++) {
                                        me(p, 3 * t, u, c),
                                        p.needsUpdate = !0;
                                        const e = p.distanceToTriangle(f, A, m);
                                        if (e < y && (g.copy(A),
                                        v && v.copy(m),
                                        y = e,
                                        x = t,
                                        _ = a),
                                        e < s)
                                            return !0
                                    }
                                }
                            }
                        })
                    }
                    for (let r = 0, o = a(t); r < o; r++) {
                        me(f, 3 * r, d, h),
                        f.a.applyMatrix4(n),
                        f.b.applyMatrix4(n),
                        f.c.applyMatrix4(n),
                        f.needsUpdate = !0;
                        for (let t = e, n = e + i; t < n; t++) {
                            me(p, 3 * t, u, c),
                            p.needsUpdate = !0;
                            const e = p.distanceToTriangle(f, A, m);
                            if (e < y && (g.copy(A),
                            v && v.copy(m),
                            y = e,
                            x = t,
                            _ = r),
                            e < s)
                                return !0
                        }
                    }
                }
            }),
            X.releasePrimitive(p),
            X.releasePrimitive(f),
            y === 1 / 0 ? null : (i.point ? i.point.copy(g) : i.point = g.clone(),
            i.distance = y,
            i.faceIndex = x,
            r && (r.point ? r.point.copy(v) : r.point = v.clone(),
            r.point.applyMatrix4(Ne),
            g.applyMatrix4(Ne),
            r.distance = g.sub(r.point).length(),
            r.faceIndex = _),
            i)
        }
        function We(e, t, n, i, r, s, a) {
            const {geometry: o} = n
              , {index: l} = o
              , c = o.attributes.position;
            for (let o = e, u = t + e; o < u; o++) {
                let e;
                if (e = n.resolveTriangleIndex(o),
                me(a, 3 * e, l, c),
                a.needsUpdate = !0,
                i(a, e, r, s))
                    return !0
            }
            return !1
        }
        function je(e, t=null) {
            t && Array.isArray(t) && (t = new Set(t));
            const n = e.geometry
              , i = n.index ? n.index.array : null
              , r = n.attributes.position;
            let a, o, l, c, u = 0;
            const h = e._roots;
            for (let e = 0, t = h.length; e < t; e++)
                a = h[e],
                o = new Uint32Array(a),
                l = new Uint16Array(a),
                c = new Float32Array(a),
                d(0, u),
                u += a.byteLength;
            function d(n, a, u=!1) {
                const h = 2 * n;
                if (l[h + 15] === s.BE) {
                    const t = o[n + 6];
                    let s = 1 / 0
                      , a = 1 / 0
                      , u = 1 / 0
                      , d = -1 / 0
                      , p = -1 / 0
                      , f = -1 / 0;
                    for (let n = t, o = t + l[h + 14]; n < o; n++) {
                        const t = 3 * e.resolveTriangleIndex(n);
                        for (let e = 0; e < 3; e++) {
                            let n = t + e;
                            n = i ? i[n] : n;
                            const o = r.getX(n)
                              , l = r.getY(n)
                              , c = r.getZ(n);
                            o < s && (s = o),
                            o > d && (d = o),
                            l < a && (a = l),
                            l > p && (p = l),
                            c < u && (u = c),
                            c > f && (f = c)
                        }
                    }
                    return (c[n + 0] !== s || c[n + 1] !== a || c[n + 2] !== u || c[n + 3] !== d || c[n + 4] !== p || c[n + 5] !== f) && (c[n + 0] = s,
                    c[n + 1] = a,
                    c[n + 2] = u,
                    c[n + 3] = d,
                    c[n + 4] = p,
                    c[n + 5] = f,
                    !0)
                }
                {
                    const e = n + 8
                      , i = o[n + 6]
                      , r = e + a
                      , s = i + a;
                    let l = u
                      , h = !1
                      , p = !1;
                    t ? l || (h = t.has(r),
                    p = t.has(s),
                    l = !h && !p) : (h = !0,
                    p = !0);
                    const f = l || p;
                    let A = !1;
                    (l || h) && (A = d(e, a, l));
                    let g = !1;
                    f && (g = d(i, a, l));
                    const m = A || g;
                    if (m)
                        for (let t = 0; t < 3; t++) {
                            const r = e + t
                              , s = i + t
                              , a = c[r]
                              , o = c[r + 3]
                              , l = c[s]
                              , u = c[s + 3];
                            c[n + t] = a < l ? a : l,
                            c[n + t + 3] = o > u ? o : u
                        }
                    return m
                }
            }
        }
        const qe = new i.Pq0;
        function Ye(e, t, n, i, r) {
            K.setBuffer(e._roots[t]),
            Xe(0, e, n, i, r),
            K.clearBuffer()
        }
        function Xe(e, t, n, i, r) {
            const {float32Array: s, uint16Array: a, uint32Array: o} = K
              , l = 2 * e;
            if (w(l, a)) {
                !function(e, t, n, i, r, s) {
                    const {geometry: a, _indirectBuffer: o} = e;
                    for (let e = i, l = i + r; e < l; e++)
                        ge(a, t, n, o ? o[e] : e, s)
                }(t, n, i, C(e, o), I(l, a), r)
            } else {
                const a = S(e);
                _e(a, s, i, qe) && Xe(a, t, n, i, r);
                const l = M(e, o);
                _e(l, s, i, qe) && Xe(l, t, n, i, r)
            }
        }
        const Ke = new i.Pq0
          , Je = ["x", "y", "z"];
        function Ze(e, t, n, i) {
            K.setBuffer(e._roots[t]);
            const r = $e(0, e, n, i);
            return K.clearBuffer(),
            r
        }
        function $e(e, t, n, i) {
            const {float32Array: r, uint16Array: s, uint32Array: a} = K;
            let o = 2 * e;
            if (w(o, s)) {
                return function(e, t, n, i, r) {
                    const {geometry: s, _indirectBuffer: a} = e;
                    let o = 1 / 0
                      , l = null;
                    for (let e = i, c = i + r; e < c; e++) {
                        let i;
                        i = ge(s, t, n, a ? a[e] : e),
                        i && i.distance < o && (l = i,
                        o = i.distance)
                    }
                    return l
                }(t, n, i, C(e, a), I(o, s))
            }
            {
                const s = T(e, a)
                  , o = Je[s]
                  , l = i.direction[o] >= 0;
                let c, u;
                l ? (c = S(e),
                u = M(e, a)) : (c = M(e, a),
                u = S(e));
                const h = _e(c, r, i, Ke) ? $e(c, t, n, i) : null;
                if (h) {
                    const e = h.point[o];
                    if (l ? e <= r[u + s] : e >= r[u + s + 3])
                        return h
                }
                const d = _e(u, r, i, Ke) ? $e(u, t, n, i) : null;
                return h && d ? h.distance <= d.distance ? h : d : h || d || null
            }
        }
        const et = new i.NRn
          , tt = new W
          , nt = new W
          , it = new i.kn4
          , rt = new j
          , st = new j;
        function at(e, t, n, i) {
            K.setBuffer(e._roots[t]);
            const r = ot(0, e, n, i);
            return K.clearBuffer(),
            r
        }
        function ot(e, t, n, i, r=null) {
            const {float32Array: s, uint16Array: a, uint32Array: o} = K;
            let l = 2 * e;
            null === r && (n.boundingBox || n.computeBoundingBox(),
            rt.set(n.boundingBox.min, n.boundingBox.max, i),
            r = rt);
            if (!w(l, a)) {
                const a = e + 8
                  , l = o[e + 6];
                h(a, s, et);
                if (r.intersectsBox(et) && ot(a, t, n, i, r))
                    return !0;
                h(l, s, et);
                return !!(r.intersectsBox(et) && ot(l, t, n, i, r))
            }
            {
                const r = t.geometry
                  , c = r.index
                  , u = r.attributes.position
                  , d = n.index
                  , p = n.attributes.position
                  , f = C(e, o)
                  , A = I(l, a);
                if (it.copy(i).invert(),
                n.boundsTree) {
                    h(e, s, st),
                    st.matrix.copy(it),
                    st.needsUpdate = !0;
                    return n.boundsTree.shapecast({
                        intersectsBounds: e => st.intersectsBox(e),
                        intersectsTriangle: e => {
                            e.a.applyMatrix4(i),
                            e.b.applyMatrix4(i),
                            e.c.applyMatrix4(i),
                            e.needsUpdate = !0;
                            for (let n = f, i = A + f; n < i; n++)
                                if (me(nt, 3 * t.resolveTriangleIndex(n), c, u),
                                nt.needsUpdate = !0,
                                e.intersectsTriangle(nt))
                                    return !0;
                            return !1
                        }
                    })
                }
                for (let e = f, n = A + f; e < n; e++) {
                    const n = t.resolveTriangleIndex(e);
                    me(tt, 3 * n, c, u),
                    tt.a.applyMatrix4(it),
                    tt.b.applyMatrix4(it),
                    tt.c.applyMatrix4(it),
                    tt.needsUpdate = !0;
                    for (let e = 0, t = d.count; e < t; e += 3)
                        if (me(nt, e, d, p),
                        nt.needsUpdate = !0,
                        tt.intersectsTriangle(nt))
                            return !0
                }
            }
        }
        const lt = new i.kn4
          , ct = new j
          , ut = new j
          , ht = new i.Pq0
          , dt = new i.Pq0
          , pt = new i.Pq0
          , ft = new i.Pq0;
        function At(e, t, n, i={}, r={}, s=0, o=1 / 0) {
            t.boundingBox || t.computeBoundingBox(),
            ct.set(t.boundingBox.min, t.boundingBox.max, n),
            ct.needsUpdate = !0;
            const l = e.geometry
              , c = l.attributes.position
              , u = l.index
              , h = t.attributes.position
              , d = t.index
              , p = X.getPrimitive()
              , f = X.getPrimitive();
            let A = ht
              , g = dt
              , m = null
              , v = null;
            r && (m = pt,
            v = ft);
            let y = 1 / 0
              , x = null
              , _ = null;
            return lt.copy(n).invert(),
            ut.matrix.copy(lt),
            e.shapecast({
                boundsTraverseOrder: e => ct.distanceToBox(e),
                intersectsBounds: (e, t, n) => n < y && n < o && (t && (ut.min.copy(e.min),
                ut.max.copy(e.max),
                ut.needsUpdate = !0),
                !0),
                intersectsRange: (i, r) => {
                    if (t.boundsTree) {
                        const a = t.boundsTree;
                        return a.shapecast({
                            boundsTraverseOrder: e => ut.distanceToBox(e),
                            intersectsBounds: (e, t, n) => n < y && n < o,
                            intersectsRange: (t, o) => {
                                for (let l = t, b = t + o; l < b; l++) {
                                    const t = a.resolveTriangleIndex(l);
                                    me(f, 3 * t, d, h),
                                    f.a.applyMatrix4(n),
                                    f.b.applyMatrix4(n),
                                    f.c.applyMatrix4(n),
                                    f.needsUpdate = !0;
                                    for (let t = i, n = i + r; t < n; t++) {
                                        const n = e.resolveTriangleIndex(t);
                                        me(p, 3 * n, u, c),
                                        p.needsUpdate = !0;
                                        const i = p.distanceToTriangle(f, A, m);
                                        if (i < y && (g.copy(A),
                                        v && v.copy(m),
                                        y = i,
                                        x = t,
                                        _ = l),
                                        i < s)
                                            return !0
                                    }
                                }
                            }
                        })
                    }
                    for (let o = 0, l = a(t); o < l; o++) {
                        me(f, 3 * o, d, h),
                        f.a.applyMatrix4(n),
                        f.b.applyMatrix4(n),
                        f.c.applyMatrix4(n),
                        f.needsUpdate = !0;
                        for (let t = i, n = i + r; t < n; t++) {
                            const n = e.resolveTriangleIndex(t);
                            me(p, 3 * n, u, c),
                            p.needsUpdate = !0;
                            const i = p.distanceToTriangle(f, A, m);
                            if (i < y && (g.copy(A),
                            v && v.copy(m),
                            y = i,
                            x = t,
                            _ = o),
                            i < s)
                                return !0
                        }
                    }
                }
            }),
            X.releasePrimitive(p),
            X.releasePrimitive(f),
            y === 1 / 0 ? null : (i.point ? i.point.copy(g) : i.point = g.clone(),
            i.distance = y,
            i.faceIndex = x,
            r && (r.point ? r.point.copy(v) : r.point = v.clone(),
            r.point.applyMatrix4(lt),
            g.applyMatrix4(lt),
            r.distance = g.sub(r.point).length(),
            r.faceIndex = _),
            i)
        }
        const gt = new K.constructor
          , mt = new K.constructor
          , vt = new q(( () => new i.NRn))
          , yt = new i.NRn
          , xt = new i.NRn
          , _t = new i.NRn
          , bt = new i.NRn;
        let Et = !1;
        function wt(e, t, n, i, r, s=0, a=0, o=0, l=0, c=null, u=!1) {
            let d, p;
            u ? (d = mt,
            p = gt) : (d = gt,
            p = mt);
            const f = d.float32Array
              , A = d.uint32Array
              , g = d.uint16Array
              , m = p.float32Array
              , v = p.uint32Array
              , y = p.uint16Array
              , x = 2 * t
              , _ = w(2 * e, g)
              , b = w(x, y);
            let E = !1;
            if (b && _)
                E = u ? r(C(t, v), I(2 * t, y), C(e, A), I(2 * e, g), l, a + t, o, s + e) : r(C(e, A), I(2 * e, g), C(t, v), I(2 * t, y), o, s + e, l, a + t);
            else if (b) {
                const c = vt.getPrimitive();
                h(t, m, c),
                c.applyMatrix4(n);
                const d = S(e)
                  , p = M(e, A);
                h(d, f, yt),
                h(p, f, xt);
                const g = c.intersectsBox(yt)
                  , v = c.intersectsBox(xt);
                E = g && wt(t, d, i, n, r, a, s, l, o + 1, c, !u) || v && wt(t, p, i, n, r, a, s, l, o + 1, c, !u),
                vt.releasePrimitive(c)
            } else {
                const d = S(t)
                  , p = M(t, v);
                h(d, m, _t),
                h(p, m, bt);
                const g = c.intersectsBox(_t)
                  , y = c.intersectsBox(bt);
                if (g && y)
                    E = wt(e, d, n, i, r, s, a, o, l + 1, c, u) || wt(e, p, n, i, r, s, a, o, l + 1, c, u);
                else if (g)
                    if (_)
                        E = wt(e, d, n, i, r, s, a, o, l + 1, c, u);
                    else {
                        const t = vt.getPrimitive();
                        t.copy(_t).applyMatrix4(n);
                        const c = S(e)
                          , p = M(e, A);
                        h(c, f, yt),
                        h(p, f, xt);
                        const g = t.intersectsBox(yt)
                          , m = t.intersectsBox(xt);
                        E = g && wt(d, c, i, n, r, a, s, l, o + 1, t, !u) || m && wt(d, p, i, n, r, a, s, l, o + 1, t, !u),
                        vt.releasePrimitive(t)
                    }
                else if (y)
                    if (_)
                        E = wt(e, p, n, i, r, s, a, o, l + 1, c, u);
                    else {
                        const t = vt.getPrimitive();
                        t.copy(bt).applyMatrix4(n);
                        const c = S(e)
                          , d = M(e, A);
                        h(c, f, yt),
                        h(d, f, xt);
                        const g = t.intersectsBox(yt)
                          , m = t.intersectsBox(xt);
                        E = g && wt(p, c, i, n, r, a, s, l, o + 1, t, !u) || m && wt(p, d, i, n, r, a, s, l, o + 1, t, !u),
                        vt.releasePrimitive(t)
                    }
            }
            return E
        }
        const Ct = new j
          , It = new i.NRn
          , St = {
            strategy: s.Q7,
            maxDepth: 40,
            maxLeafTris: 10,
            useSharedArrayBuffer: !1,
            setBoundingBox: !0,
            onProgress: null,
            indirect: !1,
            verbose: !0
        };
        class Mt {
            static serialize(e, t={}) {
                t = {
                    cloneBuffers: !0,
                    ...t
                };
                const n = e.geometry
                  , i = e._roots
                  , r = e._indirectBuffer
                  , s = n.getIndex();
                let a;
                return a = t.cloneBuffers ? {
                    roots: i.map((e => e.slice())),
                    index: s.array.slice(),
                    indirectBuffer: r ? r.slice() : null
                } : {
                    roots: i,
                    index: s.array,
                    indirectBuffer: r
                },
                a
            }
            static deserialize(e, t, n={}) {
                n = {
                    setIndex: !0,
                    indirect: Boolean(e.indirectBuffer),
                    ...n
                };
                const {index: r, roots: a, indirectBuffer: o} = e
                  , l = new Mt(t,{
                    ...n,
                    [s.vl]: !0
                });
                if (l._roots = a,
                l._indirectBuffer = o || null,
                n.setIndex) {
                    const n = t.getIndex();
                    if (null === n) {
                        const n = new i.THS(e.index,1,!1);
                        t.setIndex(n)
                    } else
                        n.array !== r && (n.array.set(r),
                        n.needsUpdate = !0)
                }
                return l
            }
            get indirect() {
                return !!this._indirectBuffer
            }
            constructor(e, t={}) {
                if (!e.isBufferGeometry)
                    throw new Error("MeshBVH: Only BufferGeometries are supported.");
                if (e.index && e.index.isInterleavedBufferAttribute)
                    throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.");
                if ((t = Object.assign({
                    ...St,
                    [s.vl]: !1
                }, t)).useSharedArrayBuffer && "undefined" == typeof SharedArrayBuffer)
                    throw new Error("MeshBVH: SharedArrayBuffer is not available.");
                this.geometry = e,
                this._roots = null,
                this._indirectBuffer = null,
                t[s.vl] || (Q(this, t),
                !e.boundingBox && t.setBoundingBox && (e.boundingBox = this.getBoundingBox(new i.NRn)));
                const {_indirectBuffer: n} = this;
                this.resolveTriangleIndex = t.indirect ? e => n[e] : e => e
            }
            refit(e=null) {
                return (this.indirect ? je : ye)(this, e)
            }
            traverse(e, t=0) {
                const n = this._roots[t]
                  , i = new Uint32Array(n)
                  , r = new Uint16Array(n);
                !function t(a, o=0) {
                    const l = 2 * a
                      , c = r[l + 15] === s.BE;
                    if (c) {
                        const t = i[a + 6]
                          , s = r[l + 14];
                        e(o, c, new Float32Array(n,4 * a,6), t, s)
                    } else {
                        const r = a + s.Ne / 4
                          , l = i[a + 6]
                          , u = i[a + 7];
                        e(o, c, new Float32Array(n,4 * a,6), u) || (t(r, o + 1),
                        t(l, o + 1))
                    }
                }(0)
            }
            raycast(e, t=i.hB5) {
                const n = this._roots
                  , r = this.geometry
                  , s = []
                  , a = t.isMaterial
                  , o = Array.isArray(t)
                  , l = r.groups
                  , c = a ? t.side : t
                  , u = this.indirect ? Ye : Ee;
                for (let i = 0, r = n.length; i < r; i++) {
                    const n = o ? t[l[i].materialIndex].side : c
                      , r = s.length;
                    if (u(this, i, n, e, s),
                    o) {
                        const e = l[i].materialIndex;
                        for (let t = r, n = s.length; t < n; t++)
                            s[t].face.materialIndex = e
                    }
                }
                return s
            }
            raycastFirst(e, t=i.hB5) {
                const n = this._roots
                  , r = this.geometry
                  , s = t.isMaterial
                  , a = Array.isArray(t);
                let o = null;
                const l = r.groups
                  , c = s ? t.side : t
                  , u = this.indirect ? Ze : Se;
                for (let i = 0, r = n.length; i < r; i++) {
                    const n = u(this, i, a ? t[l[i].materialIndex].side : c, e);
                    null != n && (null == o || n.distance < o.distance) && (o = n,
                    a && (n.face.materialIndex = l[i].materialIndex))
                }
                return o
            }
            intersectsGeometry(e, t) {
                let n = !1;
                const i = this._roots
                  , r = this.indirect ? at : Ue;
                for (let s = 0, a = i.length; s < a && (n = r(this, s, e, t),
                !n); s++)
                    ;
                return n
            }
            shapecast(e) {
                const t = X.getPrimitive()
                  , n = this.indirect ? We : ve;
                let {boundsTraverseOrder: i, intersectsBounds: r, intersectsRange: s, intersectsTriangle: a} = e;
                if (s && a) {
                    const e = s;
                    s = (i, r, s, o, l) => !!e(i, r, s, o, l) || n(i, r, this, a, s, o, t)
                } else
                    s || (s = a ? (e, i, r, s) => n(e, i, this, a, r, s, t) : (e, t, n) => n);
                let o = !1
                  , l = 0;
                const c = this._roots;
                for (let e = 0, t = c.length; e < t; e++) {
                    const t = c[e];
                    if (o = te(this, e, r, s, i, l),
                    o)
                        break;
                    l += t.byteLength
                }
                return X.releasePrimitive(t),
                o
            }
            bvhcast(e, t, n) {
                let {intersectsRanges: r, intersectsTriangles: s} = n;
                const a = X.getPrimitive()
                  , o = this.geometry.index
                  , l = this.geometry.attributes.position
                  , c = this.indirect ? e => {
                    const t = this.resolveTriangleIndex(e);
                    me(a, 3 * t, o, l)
                }
                : e => {
                    me(a, 3 * e, o, l)
                }
                  , u = X.getPrimitive()
                  , d = e.geometry.index
                  , p = e.geometry.attributes.position
                  , f = e.indirect ? t => {
                    const n = e.resolveTriangleIndex(t);
                    me(u, 3 * n, d, p)
                }
                : e => {
                    me(u, 3 * e, d, p)
                }
                ;
                if (s) {
                    const e = (e, n, i, r, o, l, h, d) => {
                        for (let p = i, A = i + r; p < A; p++) {
                            f(p),
                            u.a.applyMatrix4(t),
                            u.b.applyMatrix4(t),
                            u.c.applyMatrix4(t),
                            u.needsUpdate = !0;
                            for (let t = e, i = e + n; t < i; t++)
                                if (c(t),
                                a.needsUpdate = !0,
                                s(a, u, t, p, o, l, h, d))
                                    return !0
                        }
                        return !1
                    }
                    ;
                    if (r) {
                        const t = r;
                        r = function(n, i, r, s, a, o, l, c) {
                            return !!t(n, i, r, s, a, o, l, c) || e(n, i, r, s, a, o, l, c)
                        }
                    } else
                        r = e
                }
                return function(e, t, n, r) {
                    if (Et)
                        throw new Error("MeshBVH: Recursive calls to bvhcast not supported.");
                    Et = !0;
                    const s = e._roots
                      , a = t._roots;
                    let o, l = 0, c = 0;
                    const u = (new i.kn4).copy(n).invert();
                    for (let e = 0, t = s.length; e < t; e++) {
                        gt.setBuffer(s[e]),
                        c = 0;
                        const t = vt.getPrimitive();
                        h(0, gt.float32Array, t),
                        t.applyMatrix4(u);
                        for (let i = 0, s = a.length; i < s && (mt.setBuffer(a[e]),
                        o = wt(0, 0, n, u, r, l, c, 0, 0, t),
                        mt.clearBuffer(),
                        c += a[i].length,
                        !o); i++)
                            ;
                        if (vt.releasePrimitive(t),
                        gt.clearBuffer(),
                        l += s[e].length,
                        o)
                            break
                    }
                    return Et = !1,
                    o
                }(this, e, t, r)
            }
            intersectsBox(e, t) {
                return Ct.set(e.min, e.max, t),
                Ct.needsUpdate = !0,
                this.shapecast({
                    intersectsBounds: e => Ct.intersectsBox(e),
                    intersectsTriangle: e => Ct.intersectsTriangle(e)
                })
            }
            intersectsSphere(e) {
                return this.shapecast({
                    intersectsBounds: t => e.intersectsBox(t),
                    intersectsTriangle: t => t.intersectsSphere(e)
                })
            }
            closestPointToGeometry(e, t, n={}, i={}, r=0, s=1 / 0) {
                return (this.indirect ? At : Ve)(this, e, t, n, i, r, s)
            }
            closestPointToPoint(e, t={}, n=0, i=1 / 0) {
                return function(e, t, n={}, i=0, r=1 / 0) {
                    const s = i * i
                      , a = r * r;
                    let o = 1 / 0
                      , l = null;
                    if (e.shapecast({
                        boundsTraverseOrder: e => (ie.copy(t).clamp(e.min, e.max),
                        ie.distanceToSquared(t)),
                        intersectsBounds: (e, t, n) => n < o && n < a,
                        intersectsTriangle: (e, n) => {
                            e.closestPointToPoint(t, ie);
                            const i = t.distanceToSquared(ie);
                            return i < o && (re.copy(ie),
                            o = i,
                            l = n),
                            i < s
                        }
                    }),
                    o === 1 / 0)
                        return null;
                    const c = Math.sqrt(o);
                    return n.point ? n.point.copy(re) : n.point = re.clone(),
                    n.distance = c,
                    n.faceIndex = l,
                    n
                }(this, e, t, n, i)
            }
            getBoundingBox(e) {
                e.makeEmpty();
                return this._roots.forEach((t => {
                    h(0, new Float32Array(t), It),
                    e.union(It)
                }
                )),
                e
            }
        }
        const Tt = new i.RlV
          , Bt = new i.kn4
          , Rt = i.eaF.prototype.raycast;
        function Dt(e, t) {
            if (this.geometry.boundsTree) {
                if (void 0 === this.material)
                    return;
                Bt.copy(this.matrixWorld).invert(),
                Tt.copy(e.ray).applyMatrix4(Bt);
                const n = this.geometry.boundsTree;
                if (!0 === e.firstHitOnly) {
                    const i = r(n.raycastFirst(Tt, this.material), this, e);
                    i && t.push(i)
                } else {
                    const i = n.raycast(Tt, this.material);
                    for (let n = 0, s = i.length; n < s; n++) {
                        const s = r(i[n], this, e);
                        s && t.push(s)
                    }
                }
            } else
                Rt.call(this, e, t)
        }
        function Pt(e) {
            return this.boundsTree = new Mt(this,e),
            this.boundsTree
        }
        function Lt() {
            this.boundsTree = null
        }
    }
    ,
    5062: (e, t, n) => {
        "use strict";
        n.d(t, {
            $EB: () => c,
            $Kf: () => zo,
            $_I: () => W,
            $p8: () => tu,
            A$4: () => Hi,
            B69: () => ui,
            BH$: () => ml,
            BKk: () => mr,
            BRH: () => Qc,
            BXX: () => ye,
            BdL: () => os,
            CSG: () => lo,
            CVz: () => we,
            Cfg: () => H,
            DXC: () => Al,
            EAD: () => qo,
            FCc: () => gl,
            Fn: () => Ge,
            FvD: () => Cl,
            G3T: () => Ye,
            GJx: () => N,
            GWd: () => ae,
            GYF: () => Vo,
            G_z: () => hc,
            Gu$: () => sc,
            Gwm: () => m,
            GxU: () => Oi,
            HXV: () => be,
            HiM: () => Zc,
            Hit: () => wc,
            Ho_: () => Tl,
            I46: () => Ho,
            I9Y: () => Rt,
            IUQ: () => en,
            Ipv: () => Ml,
            Iw4: () => gu,
            JeP: () => So,
            K52: () => v,
            KDk: () => Ie,
            KLL: () => dt,
            KPJ: () => Dc,
            Ke9: () => nt,
            Kzg: () => iu,
            Kzv: () => oe,
            LlO: () => gr,
            LoY: () => Zi,
            MBL: () => Ic,
            N1A: () => hl,
            N5j: () => ot,
            NRn: () => un,
            Nv2: () => wl,
            Nwf: () => pu,
            Nz6: () => me,
            O3Y: () => ac,
            O49: () => rt,
            O9p: () => qn,
            ONl: () => bl,
            OUM: () => j,
            PJ3: () => Je,
            PPD: () => Pr,
            PTz: () => an,
            Pq0: () => on,
            Q1f: () => Ti,
            Qev: () => yt,
            Qrf: () => Re,
            RJ4: () => it,
            RQf: () => Z,
            RiT: () => Mc,
            Riy: () => Ce,
            Rkk: () => at,
            RlV: () => Fn,
            THS: () => Gi,
            Tap: () => kc,
            U3G: () => g,
            UtB: () => Eu,
            V3x: () => ne,
            V9B: () => Pi,
            VCu: () => xs,
            VT0: () => he,
            VxR: () => ht,
            W9U: () => ze,
            Wk7: () => s,
            XIg: () => u,
            Y9S: () => Nc,
            YJl: () => vo,
            Z58: () => To,
            ZLX: () => nl,
            Zcv: () => Br,
            Zr2: () => ut,
            ZyN: () => eu,
            _4j: () => oc,
            aHM: () => Lc,
            aMy: () => Xe,
            bdM: () => Fr,
            bkx: () => J,
            brA: () => f,
            bw0: () => y,
            c5h: () => Sl,
            cZY: () => Iu,
            cj9: () => Bt,
            dYF: () => sn,
            dcC: () => ue,
            dwI: () => Dt,
            eB$: () => Bo,
            eHc: () => d,
            eHs: () => Do,
            eaF: () => ur,
            er$: () => ct,
            fCn: () => Or,
            gPd: () => $t,
            ghU: () => O,
            hB5: () => o,
            hsX: () => l,
            hxR: () => k,
            i7d: () => vr,
            iNn: () => dr,
            iOZ: () => Il,
            imn: () => Di,
            ix0: () => $,
            iyt: () => Mn,
            jUj: () => Mo,
            jf0: () => lt,
            k6Q: () => xe,
            k6q: () => z,
            kRr: () => V,
            kTW: () => Q,
            kn4: () => Nn,
            lGu: () => p,
            lGw: () => mc,
            lMl: () => wi,
            ljd: () => Ke,
            mrM: () => il,
            nCl: () => qc,
            nWS: () => nn,
            nc$: () => mu,
            pHI: () => G,
            paN: () => pe,
            ppV: () => Qt,
            qBx: () => uc,
            qFE: () => Bl,
            qUd: () => Xr,
            qa3: () => Se,
            qtW: () => Vi,
            r6x: () => nu,
            rYR: () => st,
            sPf: () => i,
            tBo: () => yu,
            tXL: () => cc,
            tz3: () => Tc,
            uSd: () => lc,
            uV5: () => U,
            uWO: () => Yo,
            ubm: () => br,
            wfO: () => L,
            xJ6: () => nc,
            xSv: () => A,
            zD7: () => ru
        });
        const i = "170"
          , r = 1
          , s = 2
          , a = 3
          , o = 0
          , l = 1
          , c = 2
          , u = 0
          , h = 100
          , d = 0
          , p = 1
          , f = 2
          , A = 3
          , g = 4
          , m = 5
          , v = 6
          , y = 7
          , x = 0
          , _ = 1
          , b = 2
          , E = 0
          , w = 1
          , C = 2
          , I = 3
          , S = 4
          , M = 5
          , T = 6
          , B = 7
          , R = "attached"
          , D = 301
          , P = 302
          , L = 303
          , U = 304
          , F = 306
          , N = 1e3
          , O = 1001
          , Q = 1002
          , k = 1003
          , G = 1004
          , H = 1005
          , z = 1006
          , V = 1007
          , W = 1008
          , j = 1009
          , q = 1010
          , Y = 1011
          , X = 1012
          , K = 1013
          , J = 1014
          , Z = 1015
          , $ = 1016
          , ee = 1017
          , te = 1018
          , ne = 1020
          , ie = 35902
          , re = 1021
          , se = 1022
          , ae = 1023
          , oe = 1024
          , le = 1025
          , ce = 1026
          , ue = 1027
          , he = 1028
          , de = 1029
          , pe = 1030
          , fe = 1031
          , Ae = 1033
          , ge = 33776
          , me = 33777
          , ve = 33778
          , ye = 33779
          , xe = 35840
          , _e = 35841
          , be = 35842
          , Ee = 35843
          , we = 36196
          , Ce = 37492
          , Ie = 37496
          , Se = 37808
          , Me = 37809
          , Te = 37810
          , Be = 37811
          , Re = 37812
          , De = 37813
          , Pe = 37814
          , Le = 37815
          , Ue = 37816
          , Fe = 37817
          , Ne = 37818
          , Oe = 37819
          , Qe = 37820
          , ke = 37821
          , Ge = 36492
          , He = 36494
          , ze = 36495
          , Ve = 36283
          , We = 36284
          , je = 36285
          , qe = 36286
          , Ye = 2200
          , Xe = 2201
          , Ke = 2300
          , Je = 2301
          , Ze = 2302
          , $e = 2400
          , et = 2401
          , tt = 2402
          , nt = 2500
          , it = 0
          , rt = 1
          , st = 2
          , at = 3200
          , ot = 3201
          , lt = ""
          , ct = "srgb"
          , ut = "srgb-linear"
          , ht = "linear"
          , dt = "srgb"
          , pt = 7680
          , ft = 515
          , At = 35044
          , gt = "300 es"
          , mt = 2e3
          , vt = 2001;
        class yt {
            addEventListener(e, t) {
                void 0 === this._listeners && (this._listeners = {});
                const n = this._listeners;
                void 0 === n[e] && (n[e] = []),
                -1 === n[e].indexOf(t) && n[e].push(t)
            }
            hasEventListener(e, t) {
                if (void 0 === this._listeners)
                    return !1;
                const n = this._listeners;
                return void 0 !== n[e] && -1 !== n[e].indexOf(t)
            }
            removeEventListener(e, t) {
                if (void 0 === this._listeners)
                    return;
                const n = this._listeners[e];
                if (void 0 !== n) {
                    const e = n.indexOf(t);
                    -1 !== e && n.splice(e, 1)
                }
            }
            dispatchEvent(e) {
                if (void 0 === this._listeners)
                    return;
                const t = this._listeners[e.type];
                if (void 0 !== t) {
                    e.target = this;
                    const n = t.slice(0);
                    for (let t = 0, i = n.length; t < i; t++)
                        n[t].call(this, e);
                    e.target = null
                }
            }
        }
        const xt = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
        let _t = 1234567;
        const bt = Math.PI / 180
          , Et = 180 / Math.PI;
        function wt() {
            const e = 4294967295 * Math.random() | 0
              , t = 4294967295 * Math.random() | 0
              , n = 4294967295 * Math.random() | 0
              , i = 4294967295 * Math.random() | 0;
            return (xt[255 & e] + xt[e >> 8 & 255] + xt[e >> 16 & 255] + xt[e >> 24 & 255] + "-" + xt[255 & t] + xt[t >> 8 & 255] + "-" + xt[t >> 16 & 15 | 64] + xt[t >> 24 & 255] + "-" + xt[63 & n | 128] + xt[n >> 8 & 255] + "-" + xt[n >> 16 & 255] + xt[n >> 24 & 255] + xt[255 & i] + xt[i >> 8 & 255] + xt[i >> 16 & 255] + xt[i >> 24 & 255]).toLowerCase()
        }
        function Ct(e, t, n) {
            return Math.max(t, Math.min(n, e))
        }
        function It(e, t) {
            return (e % t + t) % t
        }
        function St(e, t, n) {
            return (1 - n) * e + n * t
        }
        function Mt(e, t) {
            switch (t.constructor) {
            case Float32Array:
                return e;
            case Uint32Array:
                return e / 4294967295;
            case Uint16Array:
                return e / 65535;
            case Uint8Array:
                return e / 255;
            case Int32Array:
                return Math.max(e / 2147483647, -1);
            case Int16Array:
                return Math.max(e / 32767, -1);
            case Int8Array:
                return Math.max(e / 127, -1);
            default:
                throw new Error("Invalid component type.")
            }
        }
        function Tt(e, t) {
            switch (t.constructor) {
            case Float32Array:
                return e;
            case Uint32Array:
                return Math.round(4294967295 * e);
            case Uint16Array:
                return Math.round(65535 * e);
            case Uint8Array:
                return Math.round(255 * e);
            case Int32Array:
                return Math.round(2147483647 * e);
            case Int16Array:
                return Math.round(32767 * e);
            case Int8Array:
                return Math.round(127 * e);
            default:
                throw new Error("Invalid component type.")
            }
        }
        const Bt = {
            DEG2RAD: bt,
            RAD2DEG: Et,
            generateUUID: wt,
            clamp: Ct,
            euclideanModulo: It,
            mapLinear: function(e, t, n, i, r) {
                return i + (e - t) * (r - i) / (n - t)
            },
            inverseLerp: function(e, t, n) {
                return e !== t ? (n - e) / (t - e) : 0
            },
            lerp: St,
            damp: function(e, t, n, i) {
                return St(e, t, 1 - Math.exp(-n * i))
            },
            pingpong: function(e, t=1) {
                return t - Math.abs(It(e, 2 * t) - t)
            },
            smoothstep: function(e, t, n) {
                return e <= t ? 0 : e >= n ? 1 : (e = (e - t) / (n - t)) * e * (3 - 2 * e)
            },
            smootherstep: function(e, t, n) {
                return e <= t ? 0 : e >= n ? 1 : (e = (e - t) / (n - t)) * e * e * (e * (6 * e - 15) + 10)
            },
            randInt: function(e, t) {
                return e + Math.floor(Math.random() * (t - e + 1))
            },
            randFloat: function(e, t) {
                return e + Math.random() * (t - e)
            },
            randFloatSpread: function(e) {
                return e * (.5 - Math.random())
            },
            seededRandom: function(e) {
                void 0 !== e && (_t = e);
                let t = _t += 1831565813;
                return t = Math.imul(t ^ t >>> 15, 1 | t),
                t ^= t + Math.imul(t ^ t >>> 7, 61 | t),
                ((t ^ t >>> 14) >>> 0) / 4294967296
            },
            degToRad: function(e) {
                return e * bt
            },
            radToDeg: function(e) {
                return e * Et
            },
            isPowerOfTwo: function(e) {
                return !(e & e - 1) && 0 !== e
            },
            ceilPowerOfTwo: function(e) {
                return Math.pow(2, Math.ceil(Math.log(e) / Math.LN2))
            },
            floorPowerOfTwo: function(e) {
                return Math.pow(2, Math.floor(Math.log(e) / Math.LN2))
            },
            setQuaternionFromProperEuler: function(e, t, n, i, r) {
                const s = Math.cos
                  , a = Math.sin
                  , o = s(n / 2)
                  , l = a(n / 2)
                  , c = s((t + i) / 2)
                  , u = a((t + i) / 2)
                  , h = s((t - i) / 2)
                  , d = a((t - i) / 2)
                  , p = s((i - t) / 2)
                  , f = a((i - t) / 2);
                switch (r) {
                case "XYX":
                    e.set(o * u, l * h, l * d, o * c);
                    break;
                case "YZY":
                    e.set(l * d, o * u, l * h, o * c);
                    break;
                case "ZXZ":
                    e.set(l * h, l * d, o * u, o * c);
                    break;
                case "XZX":
                    e.set(o * u, l * f, l * p, o * c);
                    break;
                case "YXY":
                    e.set(l * p, o * u, l * f, o * c);
                    break;
                case "ZYZ":
                    e.set(l * f, l * p, o * u, o * c);
                    break;
                default:
                    console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + r)
                }
            },
            normalize: Tt,
            denormalize: Mt
        };
        class Rt {
            constructor(e=0, t=0) {
                Rt.prototype.isVector2 = !0,
                this.x = e,
                this.y = t
            }
            get width() {
                return this.x
            }
            set width(e) {
                this.x = e
            }
            get height() {
                return this.y
            }
            set height(e) {
                this.y = e
            }
            set(e, t) {
                return this.x = e,
                this.y = t,
                this
            }
            setScalar(e) {
                return this.x = e,
                this.y = e,
                this
            }
            setX(e) {
                return this.x = e,
                this
            }
            setY(e) {
                return this.y = e,
                this
            }
            setComponent(e, t) {
                switch (e) {
                case 0:
                    this.x = t;
                    break;
                case 1:
                    this.y = t;
                    break;
                default:
                    throw new Error("index is out of range: " + e)
                }
                return this
            }
            getComponent(e) {
                switch (e) {
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                default:
                    throw new Error("index is out of range: " + e)
                }
            }
            clone() {
                return new this.constructor(this.x,this.y)
            }
            copy(e) {
                return this.x = e.x,
                this.y = e.y,
                this
            }
            add(e) {
                return this.x += e.x,
                this.y += e.y,
                this
            }
            addScalar(e) {
                return this.x += e,
                this.y += e,
                this
            }
            addVectors(e, t) {
                return this.x = e.x + t.x,
                this.y = e.y + t.y,
                this
            }
            addScaledVector(e, t) {
                return this.x += e.x * t,
                this.y += e.y * t,
                this
            }
            sub(e) {
                return this.x -= e.x,
                this.y -= e.y,
                this
            }
            subScalar(e) {
                return this.x -= e,
                this.y -= e,
                this
            }
            subVectors(e, t) {
                return this.x = e.x - t.x,
                this.y = e.y - t.y,
                this
            }
            multiply(e) {
                return this.x *= e.x,
                this.y *= e.y,
                this
            }
            multiplyScalar(e) {
                return this.x *= e,
                this.y *= e,
                this
            }
            divide(e) {
                return this.x /= e.x,
                this.y /= e.y,
                this
            }
            divideScalar(e) {
                return this.multiplyScalar(1 / e)
            }
            applyMatrix3(e) {
                const t = this.x
                  , n = this.y
                  , i = e.elements;
                return this.x = i[0] * t + i[3] * n + i[6],
                this.y = i[1] * t + i[4] * n + i[7],
                this
            }
            min(e) {
                return this.x = Math.min(this.x, e.x),
                this.y = Math.min(this.y, e.y),
                this
            }
            max(e) {
                return this.x = Math.max(this.x, e.x),
                this.y = Math.max(this.y, e.y),
                this
            }
            clamp(e, t) {
                return this.x = Math.max(e.x, Math.min(t.x, this.x)),
                this.y = Math.max(e.y, Math.min(t.y, this.y)),
                this
            }
            clampScalar(e, t) {
                return this.x = Math.max(e, Math.min(t, this.x)),
                this.y = Math.max(e, Math.min(t, this.y)),
                this
            }
            clampLength(e, t) {
                const n = this.length();
                return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)))
            }
            floor() {
                return this.x = Math.floor(this.x),
                this.y = Math.floor(this.y),
                this
            }
            ceil() {
                return this.x = Math.ceil(this.x),
                this.y = Math.ceil(this.y),
                this
            }
            round() {
                return this.x = Math.round(this.x),
                this.y = Math.round(this.y),
                this
            }
            roundToZero() {
                return this.x = Math.trunc(this.x),
                this.y = Math.trunc(this.y),
                this
            }
            negate() {
                return this.x = -this.x,
                this.y = -this.y,
                this
            }
            dot(e) {
                return this.x * e.x + this.y * e.y
            }
            cross(e) {
                return this.x * e.y - this.y * e.x
            }
            lengthSq() {
                return this.x * this.x + this.y * this.y
            }
            length() {
                return Math.sqrt(this.x * this.x + this.y * this.y)
            }
            manhattanLength() {
                return Math.abs(this.x) + Math.abs(this.y)
            }
            normalize() {
                return this.divideScalar(this.length() || 1)
            }
            angle() {
                return Math.atan2(-this.y, -this.x) + Math.PI
            }
            angleTo(e) {
                const t = Math.sqrt(this.lengthSq() * e.lengthSq());
                if (0 === t)
                    return Math.PI / 2;
                const n = this.dot(e) / t;
                return Math.acos(Ct(n, -1, 1))
            }
            distanceTo(e) {
                return Math.sqrt(this.distanceToSquared(e))
            }
            distanceToSquared(e) {
                const t = this.x - e.x
                  , n = this.y - e.y;
                return t * t + n * n
            }
            manhattanDistanceTo(e) {
                return Math.abs(this.x - e.x) + Math.abs(this.y - e.y)
            }
            setLength(e) {
                return this.normalize().multiplyScalar(e)
            }
            lerp(e, t) {
                return this.x += (e.x - this.x) * t,
                this.y += (e.y - this.y) * t,
                this
            }
            lerpVectors(e, t, n) {
                return this.x = e.x + (t.x - e.x) * n,
                this.y = e.y + (t.y - e.y) * n,
                this
            }
            equals(e) {
                return e.x === this.x && e.y === this.y
            }
            fromArray(e, t=0) {
                return this.x = e[t],
                this.y = e[t + 1],
                this
            }
            toArray(e=[], t=0) {
                return e[t] = this.x,
                e[t + 1] = this.y,
                e
            }
            fromBufferAttribute(e, t) {
                return this.x = e.getX(t),
                this.y = e.getY(t),
                this
            }
            rotateAround(e, t) {
                const n = Math.cos(t)
                  , i = Math.sin(t)
                  , r = this.x - e.x
                  , s = this.y - e.y;
                return this.x = r * n - s * i + e.x,
                this.y = r * i + s * n + e.y,
                this
            }
            random() {
                return this.x = Math.random(),
                this.y = Math.random(),
                this
            }
            *[Symbol.iterator]() {
                yield this.x,
                yield this.y
            }
        }
        class Dt {
            constructor(e, t, n, i, r, s, a, o, l) {
                Dt.prototype.isMatrix3 = !0,
                this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1],
                void 0 !== e && this.set(e, t, n, i, r, s, a, o, l)
            }
            set(e, t, n, i, r, s, a, o, l) {
                const c = this.elements;
                return c[0] = e,
                c[1] = i,
                c[2] = a,
                c[3] = t,
                c[4] = r,
                c[5] = o,
                c[6] = n,
                c[7] = s,
                c[8] = l,
                this
            }
            identity() {
                return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1),
                this
            }
            copy(e) {
                const t = this.elements
                  , n = e.elements;
                return t[0] = n[0],
                t[1] = n[1],
                t[2] = n[2],
                t[3] = n[3],
                t[4] = n[4],
                t[5] = n[5],
                t[6] = n[6],
                t[7] = n[7],
                t[8] = n[8],
                this
            }
            extractBasis(e, t, n) {
                return e.setFromMatrix3Column(this, 0),
                t.setFromMatrix3Column(this, 1),
                n.setFromMatrix3Column(this, 2),
                this
            }
            setFromMatrix4(e) {
                const t = e.elements;
                return this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]),
                this
            }
            multiply(e) {
                return this.multiplyMatrices(this, e)
            }
            premultiply(e) {
                return this.multiplyMatrices(e, this)
            }
            multiplyMatrices(e, t) {
                const n = e.elements
                  , i = t.elements
                  , r = this.elements
                  , s = n[0]
                  , a = n[3]
                  , o = n[6]
                  , l = n[1]
                  , c = n[4]
                  , u = n[7]
                  , h = n[2]
                  , d = n[5]
                  , p = n[8]
                  , f = i[0]
                  , A = i[3]
                  , g = i[6]
                  , m = i[1]
                  , v = i[4]
                  , y = i[7]
                  , x = i[2]
                  , _ = i[5]
                  , b = i[8];
                return r[0] = s * f + a * m + o * x,
                r[3] = s * A + a * v + o * _,
                r[6] = s * g + a * y + o * b,
                r[1] = l * f + c * m + u * x,
                r[4] = l * A + c * v + u * _,
                r[7] = l * g + c * y + u * b,
                r[2] = h * f + d * m + p * x,
                r[5] = h * A + d * v + p * _,
                r[8] = h * g + d * y + p * b,
                this
            }
            multiplyScalar(e) {
                const t = this.elements;
                return t[0] *= e,
                t[3] *= e,
                t[6] *= e,
                t[1] *= e,
                t[4] *= e,
                t[7] *= e,
                t[2] *= e,
                t[5] *= e,
                t[8] *= e,
                this
            }
            determinant() {
                const e = this.elements
                  , t = e[0]
                  , n = e[1]
                  , i = e[2]
                  , r = e[3]
                  , s = e[4]
                  , a = e[5]
                  , o = e[6]
                  , l = e[7]
                  , c = e[8];
                return t * s * c - t * a * l - n * r * c + n * a * o + i * r * l - i * s * o
            }
            invert() {
                const e = this.elements
                  , t = e[0]
                  , n = e[1]
                  , i = e[2]
                  , r = e[3]
                  , s = e[4]
                  , a = e[5]
                  , o = e[6]
                  , l = e[7]
                  , c = e[8]
                  , u = c * s - a * l
                  , h = a * o - c * r
                  , d = l * r - s * o
                  , p = t * u + n * h + i * d;
                if (0 === p)
                    return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
                const f = 1 / p;
                return e[0] = u * f,
                e[1] = (i * l - c * n) * f,
                e[2] = (a * n - i * s) * f,
                e[3] = h * f,
                e[4] = (c * t - i * o) * f,
                e[5] = (i * r - a * t) * f,
                e[6] = d * f,
                e[7] = (n * o - l * t) * f,
                e[8] = (s * t - n * r) * f,
                this
            }
            transpose() {
                let e;
                const t = this.elements;
                return e = t[1],
                t[1] = t[3],
                t[3] = e,
                e = t[2],
                t[2] = t[6],
                t[6] = e,
                e = t[5],
                t[5] = t[7],
                t[7] = e,
                this
            }
            getNormalMatrix(e) {
                return this.setFromMatrix4(e).invert().transpose()
            }
            transposeIntoArray(e) {
                const t = this.elements;
                return e[0] = t[0],
                e[1] = t[3],
                e[2] = t[6],
                e[3] = t[1],
                e[4] = t[4],
                e[5] = t[7],
                e[6] = t[2],
                e[7] = t[5],
                e[8] = t[8],
                this
            }
            setUvTransform(e, t, n, i, r, s, a) {
                const o = Math.cos(r)
                  , l = Math.sin(r);
                return this.set(n * o, n * l, -n * (o * s + l * a) + s + e, -i * l, i * o, -i * (-l * s + o * a) + a + t, 0, 0, 1),
                this
            }
            scale(e, t) {
                return this.premultiply(Pt.makeScale(e, t)),
                this
            }
            rotate(e) {
                return this.premultiply(Pt.makeRotation(-e)),
                this
            }
            translate(e, t) {
                return this.premultiply(Pt.makeTranslation(e, t)),
                this
            }
            makeTranslation(e, t) {
                return e.isVector2 ? this.set(1, 0, e.x, 0, 1, e.y, 0, 0, 1) : this.set(1, 0, e, 0, 1, t, 0, 0, 1),
                this
            }
            makeRotation(e) {
                const t = Math.cos(e)
                  , n = Math.sin(e);
                return this.set(t, -n, 0, n, t, 0, 0, 0, 1),
                this
            }
            makeScale(e, t) {
                return this.set(e, 0, 0, 0, t, 0, 0, 0, 1),
                this
            }
            equals(e) {
                const t = this.elements
                  , n = e.elements;
                for (let e = 0; e < 9; e++)
                    if (t[e] !== n[e])
                        return !1;
                return !0
            }
            fromArray(e, t=0) {
                for (let n = 0; n < 9; n++)
                    this.elements[n] = e[n + t];
                return this
            }
            toArray(e=[], t=0) {
                const n = this.elements;
                return e[t] = n[0],
                e[t + 1] = n[1],
                e[t + 2] = n[2],
                e[t + 3] = n[3],
                e[t + 4] = n[4],
                e[t + 5] = n[5],
                e[t + 6] = n[6],
                e[t + 7] = n[7],
                e[t + 8] = n[8],
                e
            }
            clone() {
                return (new this.constructor).fromArray(this.elements)
            }
        }
        const Pt = new Dt;
        function Lt(e) {
            for (let t = e.length - 1; t >= 0; --t)
                if (e[t] >= 65535)
                    return !0;
            return !1
        }
        Int8Array,
        Uint8Array,
        Uint8ClampedArray,
        Int16Array,
        Uint16Array,
        Int32Array,
        Uint32Array,
        Float32Array,
        Float64Array;
        function Ut(e) {
            return document.createElementNS("http://www.w3.org/1999/xhtml", e)
        }
        function Ft() {
            const e = Ut("canvas");
            return e.style.display = "block",
            e
        }
        const Nt = {};
        function Ot(e) {
            e in Nt || (Nt[e] = !0,
            console.warn(e))
        }
        const Qt = {
            enabled: !0,
            workingColorSpace: ut,
            spaces: {},
            convert: function(e, t, n) {
                return !1 !== this.enabled && t !== n && t && n ? (this.spaces[t].transfer === dt && (e.r = kt(e.r),
                e.g = kt(e.g),
                e.b = kt(e.b)),
                this.spaces[t].primaries !== this.spaces[n].primaries && (e.applyMatrix3(this.spaces[t].toXYZ),
                e.applyMatrix3(this.spaces[n].fromXYZ)),
                this.spaces[n].transfer === dt && (e.r = Gt(e.r),
                e.g = Gt(e.g),
                e.b = Gt(e.b)),
                e) : e
            },
            fromWorkingColorSpace: function(e, t) {
                return this.convert(e, this.workingColorSpace, t)
            },
            toWorkingColorSpace: function(e, t) {
                return this.convert(e, t, this.workingColorSpace)
            },
            getPrimaries: function(e) {
                return this.spaces[e].primaries
            },
            getTransfer: function(e) {
                return e === lt ? ht : this.spaces[e].transfer
            },
            getLuminanceCoefficients: function(e, t=this.workingColorSpace) {
                return e.fromArray(this.spaces[t].luminanceCoefficients)
            },
            define: function(e) {
                Object.assign(this.spaces, e)
            },
            _getMatrix: function(e, t, n) {
                return e.copy(this.spaces[t].toXYZ).multiply(this.spaces[n].fromXYZ)
            },
            _getDrawingBufferColorSpace: function(e) {
                return this.spaces[e].outputColorSpaceConfig.drawingBufferColorSpace
            },
            _getUnpackColorSpace: function(e=this.workingColorSpace) {
                return this.spaces[e].workingColorSpaceConfig.unpackColorSpace
            }
        };
        function kt(e) {
            return e < .04045 ? .0773993808 * e : Math.pow(.9478672986 * e + .0521327014, 2.4)
        }
        function Gt(e) {
            return e < .0031308 ? 12.92 * e : 1.055 * Math.pow(e, .41666) - .055
        }
        const Ht = [.64, .33, .3, .6, .15, .06]
          , zt = [.2126, .7152, .0722]
          , Vt = [.3127, .329]
          , Wt = (new Dt).set(.4123908, .3575843, .1804808, .212639, .7151687, .0721923, .0193308, .1191948, .9505322)
          , jt = (new Dt).set(3.2409699, -1.5373832, -.4986108, -.9692436, 1.8759675, .0415551, .0556301, -.203977, 1.0569715);
        let qt;
        Qt.define({
            [ut]: {
                primaries: Ht,
                whitePoint: Vt,
                transfer: ht,
                toXYZ: Wt,
                fromXYZ: jt,
                luminanceCoefficients: zt,
                workingColorSpaceConfig: {
                    unpackColorSpace: ct
                },
                outputColorSpaceConfig: {
                    drawingBufferColorSpace: ct
                }
            },
            [ct]: {
                primaries: Ht,
                whitePoint: Vt,
                transfer: dt,
                toXYZ: Wt,
                fromXYZ: jt,
                luminanceCoefficients: zt,
                outputColorSpaceConfig: {
                    drawingBufferColorSpace: ct
                }
            }
        });
        class Yt {
            static getDataURL(e) {
                if (/^data:/i.test(e.src))
                    return e.src;
                if ("undefined" == typeof HTMLCanvasElement)
                    return e.src;
                let t;
                if (e instanceof HTMLCanvasElement)
                    t = e;
                else {
                    void 0 === qt && (qt = Ut("canvas")),
                    qt.width = e.width,
                    qt.height = e.height;
                    const n = qt.getContext("2d");
                    e instanceof ImageData ? n.putImageData(e, 0, 0) : n.drawImage(e, 0, 0, e.width, e.height),
                    t = qt
                }
                return t.width > 2048 || t.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", e),
                t.toDataURL("image/jpeg", .6)) : t.toDataURL("image/png")
            }
            static sRGBToLinear(e) {
                if ("undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap) {
                    const t = Ut("canvas");
                    t.width = e.width,
                    t.height = e.height;
                    const n = t.getContext("2d");
                    n.drawImage(e, 0, 0, e.width, e.height);
                    const i = n.getImageData(0, 0, e.width, e.height)
                      , r = i.data;
                    for (let e = 0; e < r.length; e++)
                        r[e] = 255 * kt(r[e] / 255);
                    return n.putImageData(i, 0, 0),
                    t
                }
                if (e.data) {
                    const t = e.data.slice(0);
                    for (let e = 0; e < t.length; e++)
                        t instanceof Uint8Array || t instanceof Uint8ClampedArray ? t[e] = Math.floor(255 * kt(t[e] / 255)) : t[e] = kt(t[e]);
                    return {
                        data: t,
                        width: e.width,
                        height: e.height
                    }
                }
                return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."),
                e
            }
        }
        let Xt = 0;
        class Kt {
            constructor(e=null) {
                this.isSource = !0,
                Object.defineProperty(this, "id", {
                    value: Xt++
                }),
                this.uuid = wt(),
                this.data = e,
                this.dataReady = !0,
                this.version = 0
            }
            set needsUpdate(e) {
                !0 === e && this.version++
            }
            toJSON(e) {
                const t = void 0 === e || "string" == typeof e;
                if (!t && void 0 !== e.images[this.uuid])
                    return e.images[this.uuid];
                const n = {
                    uuid: this.uuid,
                    url: ""
                }
                  , i = this.data;
                if (null !== i) {
                    let e;
                    if (Array.isArray(i)) {
                        e = [];
                        for (let t = 0, n = i.length; t < n; t++)
                            i[t].isDataTexture ? e.push(Jt(i[t].image)) : e.push(Jt(i[t]))
                    } else
                        e = Jt(i);
                    n.url = e
                }
                return t || (e.images[this.uuid] = n),
                n
            }
        }
        function Jt(e) {
            return "undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap ? Yt.getDataURL(e) : e.data ? {
                data: Array.from(e.data),
                width: e.width,
                height: e.height,
                type: e.data.constructor.name
            } : (console.warn("THREE.Texture: Unable to serialize Texture."),
            {})
        }
        let Zt = 0;
        class $t extends yt {
            constructor(e=$t.DEFAULT_IMAGE, t=$t.DEFAULT_MAPPING, n=O, i=O, r=z, s=W, a=ae, o=j, l=$t.DEFAULT_ANISOTROPY, c=lt) {
                super(),
                this.isTexture = !0,
                Object.defineProperty(this, "id", {
                    value: Zt++
                }),
                this.uuid = wt(),
                this.name = "",
                this.source = new Kt(e),
                this.mipmaps = [],
                this.mapping = t,
                this.channel = 0,
                this.wrapS = n,
                this.wrapT = i,
                this.magFilter = r,
                this.minFilter = s,
                this.anisotropy = l,
                this.format = a,
                this.internalFormat = null,
                this.type = o,
                this.offset = new Rt(0,0),
                this.repeat = new Rt(1,1),
                this.center = new Rt(0,0),
                this.rotation = 0,
                this.matrixAutoUpdate = !0,
                this.matrix = new Dt,
                this.generateMipmaps = !0,
                this.premultiplyAlpha = !1,
                this.flipY = !0,
                this.unpackAlignment = 4,
                this.colorSpace = c,
                this.userData = {},
                this.version = 0,
                this.onUpdate = null,
                this.isRenderTargetTexture = !1,
                this.pmremVersion = 0
            }
            get image() {
                return this.source.data
            }
            set image(e=null) {
                this.source.data = e
            }
            updateMatrix() {
                this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            copy(e) {
                return this.name = e.name,
                this.source = e.source,
                this.mipmaps = e.mipmaps.slice(0),
                this.mapping = e.mapping,
                this.channel = e.channel,
                this.wrapS = e.wrapS,
                this.wrapT = e.wrapT,
                this.magFilter = e.magFilter,
                this.minFilter = e.minFilter,
                this.anisotropy = e.anisotropy,
                this.format = e.format,
                this.internalFormat = e.internalFormat,
                this.type = e.type,
                this.offset.copy(e.offset),
                this.repeat.copy(e.repeat),
                this.center.copy(e.center),
                this.rotation = e.rotation,
                this.matrixAutoUpdate = e.matrixAutoUpdate,
                this.matrix.copy(e.matrix),
                this.generateMipmaps = e.generateMipmaps,
                this.premultiplyAlpha = e.premultiplyAlpha,
                this.flipY = e.flipY,
                this.unpackAlignment = e.unpackAlignment,
                this.colorSpace = e.colorSpace,
                this.userData = JSON.parse(JSON.stringify(e.userData)),
                this.needsUpdate = !0,
                this
            }
            toJSON(e) {
                const t = void 0 === e || "string" == typeof e;
                if (!t && void 0 !== e.textures[this.uuid])
                    return e.textures[this.uuid];
                const n = {
                    metadata: {
                        version: 4.6,
                        type: "Texture",
                        generator: "Texture.toJSON"
                    },
                    uuid: this.uuid,
                    name: this.name,
                    image: this.source.toJSON(e).uuid,
                    mapping: this.mapping,
                    channel: this.channel,
                    repeat: [this.repeat.x, this.repeat.y],
                    offset: [this.offset.x, this.offset.y],
                    center: [this.center.x, this.center.y],
                    rotation: this.rotation,
                    wrap: [this.wrapS, this.wrapT],
                    format: this.format,
                    internalFormat: this.internalFormat,
                    type: this.type,
                    colorSpace: this.colorSpace,
                    minFilter: this.minFilter,
                    magFilter: this.magFilter,
                    anisotropy: this.anisotropy,
                    flipY: this.flipY,
                    generateMipmaps: this.generateMipmaps,
                    premultiplyAlpha: this.premultiplyAlpha,
                    unpackAlignment: this.unpackAlignment
                };
                return Object.keys(this.userData).length > 0 && (n.userData = this.userData),
                t || (e.textures[this.uuid] = n),
                n
            }
            dispose() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
            transformUv(e) {
                if (300 !== this.mapping)
                    return e;
                if (e.applyMatrix3(this.matrix),
                e.x < 0 || e.x > 1)
                    switch (this.wrapS) {
                    case N:
                        e.x = e.x - Math.floor(e.x);
                        break;
                    case O:
                        e.x = e.x < 0 ? 0 : 1;
                        break;
                    case Q:
                        1 === Math.abs(Math.floor(e.x) % 2) ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x)
                    }
                if (e.y < 0 || e.y > 1)
                    switch (this.wrapT) {
                    case N:
                        e.y = e.y - Math.floor(e.y);
                        break;
                    case O:
                        e.y = e.y < 0 ? 0 : 1;
                        break;
                    case Q:
                        1 === Math.abs(Math.floor(e.y) % 2) ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y)
                    }
                return this.flipY && (e.y = 1 - e.y),
                e
            }
            set needsUpdate(e) {
                !0 === e && (this.version++,
                this.source.needsUpdate = !0)
            }
            set needsPMREMUpdate(e) {
                !0 === e && this.pmremVersion++
            }
        }
        $t.DEFAULT_IMAGE = null,
        $t.DEFAULT_MAPPING = 300,
        $t.DEFAULT_ANISOTROPY = 1;
        class en {
            constructor(e=0, t=0, n=0, i=1) {
                en.prototype.isVector4 = !0,
                this.x = e,
                this.y = t,
                this.z = n,
                this.w = i
            }
            get width() {
                return this.z
            }
            set width(e) {
                this.z = e
            }
            get height() {
                return this.w
            }
            set height(e) {
                this.w = e
            }
            set(e, t, n, i) {
                return this.x = e,
                this.y = t,
                this.z = n,
                this.w = i,
                this
            }
            setScalar(e) {
                return this.x = e,
                this.y = e,
                this.z = e,
                this.w = e,
                this
            }
            setX(e) {
                return this.x = e,
                this
            }
            setY(e) {
                return this.y = e,
                this
            }
            setZ(e) {
                return this.z = e,
                this
            }
            setW(e) {
                return this.w = e,
                this
            }
            setComponent(e, t) {
                switch (e) {
                case 0:
                    this.x = t;
                    break;
                case 1:
                    this.y = t;
                    break;
                case 2:
                    this.z = t;
                    break;
                case 3:
                    this.w = t;
                    break;
                default:
                    throw new Error("index is out of range: " + e)
                }
                return this
            }
            getComponent(e) {
                switch (e) {
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                case 2:
                    return this.z;
                case 3:
                    return this.w;
                default:
                    throw new Error("index is out of range: " + e)
                }
            }
            clone() {
                return new this.constructor(this.x,this.y,this.z,this.w)
            }
            copy(e) {
                return this.x = e.x,
                this.y = e.y,
                this.z = e.z,
                this.w = void 0 !== e.w ? e.w : 1,
                this
            }
            add(e) {
                return this.x += e.x,
                this.y += e.y,
                this.z += e.z,
                this.w += e.w,
                this
            }
            addScalar(e) {
                return this.x += e,
                this.y += e,
                this.z += e,
                this.w += e,
                this
            }
            addVectors(e, t) {
                return this.x = e.x + t.x,
                this.y = e.y + t.y,
                this.z = e.z + t.z,
                this.w = e.w + t.w,
                this
            }
            addScaledVector(e, t) {
                return this.x += e.x * t,
                this.y += e.y * t,
                this.z += e.z * t,
                this.w += e.w * t,
                this
            }
            sub(e) {
                return this.x -= e.x,
                this.y -= e.y,
                this.z -= e.z,
                this.w -= e.w,
                this
            }
            subScalar(e) {
                return this.x -= e,
                this.y -= e,
                this.z -= e,
                this.w -= e,
                this
            }
            subVectors(e, t) {
                return this.x = e.x - t.x,
                this.y = e.y - t.y,
                this.z = e.z - t.z,
                this.w = e.w - t.w,
                this
            }
            multiply(e) {
                return this.x *= e.x,
                this.y *= e.y,
                this.z *= e.z,
                this.w *= e.w,
                this
            }
            multiplyScalar(e) {
                return this.x *= e,
                this.y *= e,
                this.z *= e,
                this.w *= e,
                this
            }
            applyMatrix4(e) {
                const t = this.x
                  , n = this.y
                  , i = this.z
                  , r = this.w
                  , s = e.elements;
                return this.x = s[0] * t + s[4] * n + s[8] * i + s[12] * r,
                this.y = s[1] * t + s[5] * n + s[9] * i + s[13] * r,
                this.z = s[2] * t + s[6] * n + s[10] * i + s[14] * r,
                this.w = s[3] * t + s[7] * n + s[11] * i + s[15] * r,
                this
            }
            divide(e) {
                return this.x /= e.x,
                this.y /= e.y,
                this.z /= e.z,
                this.w /= e.w,
                this
            }
            divideScalar(e) {
                return this.multiplyScalar(1 / e)
            }
            setAxisAngleFromQuaternion(e) {
                this.w = 2 * Math.acos(e.w);
                const t = Math.sqrt(1 - e.w * e.w);
                return t < 1e-4 ? (this.x = 1,
                this.y = 0,
                this.z = 0) : (this.x = e.x / t,
                this.y = e.y / t,
                this.z = e.z / t),
                this
            }
            setAxisAngleFromRotationMatrix(e) {
                let t, n, i, r;
                const s = .01
                  , a = .1
                  , o = e.elements
                  , l = o[0]
                  , c = o[4]
                  , u = o[8]
                  , h = o[1]
                  , d = o[5]
                  , p = o[9]
                  , f = o[2]
                  , A = o[6]
                  , g = o[10];
                if (Math.abs(c - h) < s && Math.abs(u - f) < s && Math.abs(p - A) < s) {
                    if (Math.abs(c + h) < a && Math.abs(u + f) < a && Math.abs(p + A) < a && Math.abs(l + d + g - 3) < a)
                        return this.set(1, 0, 0, 0),
                        this;
                    t = Math.PI;
                    const e = (l + 1) / 2
                      , o = (d + 1) / 2
                      , m = (g + 1) / 2
                      , v = (c + h) / 4
                      , y = (u + f) / 4
                      , x = (p + A) / 4;
                    return e > o && e > m ? e < s ? (n = 0,
                    i = .707106781,
                    r = .707106781) : (n = Math.sqrt(e),
                    i = v / n,
                    r = y / n) : o > m ? o < s ? (n = .707106781,
                    i = 0,
                    r = .707106781) : (i = Math.sqrt(o),
                    n = v / i,
                    r = x / i) : m < s ? (n = .707106781,
                    i = .707106781,
                    r = 0) : (r = Math.sqrt(m),
                    n = y / r,
                    i = x / r),
                    this.set(n, i, r, t),
                    this
                }
                let m = Math.sqrt((A - p) * (A - p) + (u - f) * (u - f) + (h - c) * (h - c));
                return Math.abs(m) < .001 && (m = 1),
                this.x = (A - p) / m,
                this.y = (u - f) / m,
                this.z = (h - c) / m,
                this.w = Math.acos((l + d + g - 1) / 2),
                this
            }
            setFromMatrixPosition(e) {
                const t = e.elements;
                return this.x = t[12],
                this.y = t[13],
                this.z = t[14],
                this.w = t[15],
                this
            }
            min(e) {
                return this.x = Math.min(this.x, e.x),
                this.y = Math.min(this.y, e.y),
                this.z = Math.min(this.z, e.z),
                this.w = Math.min(this.w, e.w),
                this
            }
            max(e) {
                return this.x = Math.max(this.x, e.x),
                this.y = Math.max(this.y, e.y),
                this.z = Math.max(this.z, e.z),
                this.w = Math.max(this.w, e.w),
                this
            }
            clamp(e, t) {
                return this.x = Math.max(e.x, Math.min(t.x, this.x)),
                this.y = Math.max(e.y, Math.min(t.y, this.y)),
                this.z = Math.max(e.z, Math.min(t.z, this.z)),
                this.w = Math.max(e.w, Math.min(t.w, this.w)),
                this
            }
            clampScalar(e, t) {
                return this.x = Math.max(e, Math.min(t, this.x)),
                this.y = Math.max(e, Math.min(t, this.y)),
                this.z = Math.max(e, Math.min(t, this.z)),
                this.w = Math.max(e, Math.min(t, this.w)),
                this
            }
            clampLength(e, t) {
                const n = this.length();
                return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)))
            }
            floor() {
                return this.x = Math.floor(this.x),
                this.y = Math.floor(this.y),
                this.z = Math.floor(this.z),
                this.w = Math.floor(this.w),
                this
            }
            ceil() {
                return this.x = Math.ceil(this.x),
                this.y = Math.ceil(this.y),
                this.z = Math.ceil(this.z),
                this.w = Math.ceil(this.w),
                this
            }
            round() {
                return this.x = Math.round(this.x),
                this.y = Math.round(this.y),
                this.z = Math.round(this.z),
                this.w = Math.round(this.w),
                this
            }
            roundToZero() {
                return this.x = Math.trunc(this.x),
                this.y = Math.trunc(this.y),
                this.z = Math.trunc(this.z),
                this.w = Math.trunc(this.w),
                this
            }
            negate() {
                return this.x = -this.x,
                this.y = -this.y,
                this.z = -this.z,
                this.w = -this.w,
                this
            }
            dot(e) {
                return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w
            }
            lengthSq() {
                return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
            }
            length() {
                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
            }
            manhattanLength() {
                return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
            }
            normalize() {
                return this.divideScalar(this.length() || 1)
            }
            setLength(e) {
                return this.normalize().multiplyScalar(e)
            }
            lerp(e, t) {
                return this.x += (e.x - this.x) * t,
                this.y += (e.y - this.y) * t,
                this.z += (e.z - this.z) * t,
                this.w += (e.w - this.w) * t,
                this
            }
            lerpVectors(e, t, n) {
                return this.x = e.x + (t.x - e.x) * n,
                this.y = e.y + (t.y - e.y) * n,
                this.z = e.z + (t.z - e.z) * n,
                this.w = e.w + (t.w - e.w) * n,
                this
            }
            equals(e) {
                return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w
            }
            fromArray(e, t=0) {
                return this.x = e[t],
                this.y = e[t + 1],
                this.z = e[t + 2],
                this.w = e[t + 3],
                this
            }
            toArray(e=[], t=0) {
                return e[t] = this.x,
                e[t + 1] = this.y,
                e[t + 2] = this.z,
                e[t + 3] = this.w,
                e
            }
            fromBufferAttribute(e, t) {
                return this.x = e.getX(t),
                this.y = e.getY(t),
                this.z = e.getZ(t),
                this.w = e.getW(t),
                this
            }
            random() {
                return this.x = Math.random(),
                this.y = Math.random(),
                this.z = Math.random(),
                this.w = Math.random(),
                this
            }
            *[Symbol.iterator]() {
                yield this.x,
                yield this.y,
                yield this.z,
                yield this.w
            }
        }
        class tn extends yt {
            constructor(e=1, t=1, n={}) {
                super(),
                this.isRenderTarget = !0,
                this.width = e,
                this.height = t,
                this.depth = 1,
                this.scissor = new en(0,0,e,t),
                this.scissorTest = !1,
                this.viewport = new en(0,0,e,t);
                const i = {
                    width: e,
                    height: t,
                    depth: 1
                };
                n = Object.assign({
                    generateMipmaps: !1,
                    internalFormat: null,
                    minFilter: z,
                    depthBuffer: !0,
                    stencilBuffer: !1,
                    resolveDepthBuffer: !0,
                    resolveStencilBuffer: !0,
                    depthTexture: null,
                    samples: 0,
                    count: 1
                }, n);
                const r = new $t(i,n.mapping,n.wrapS,n.wrapT,n.magFilter,n.minFilter,n.format,n.type,n.anisotropy,n.colorSpace);
                r.flipY = !1,
                r.generateMipmaps = n.generateMipmaps,
                r.internalFormat = n.internalFormat,
                this.textures = [];
                const s = n.count;
                for (let e = 0; e < s; e++)
                    this.textures[e] = r.clone(),
                    this.textures[e].isRenderTargetTexture = !0;
                this.depthBuffer = n.depthBuffer,
                this.stencilBuffer = n.stencilBuffer,
                this.resolveDepthBuffer = n.resolveDepthBuffer,
                this.resolveStencilBuffer = n.resolveStencilBuffer,
                this.depthTexture = n.depthTexture,
                this.samples = n.samples
            }
            get texture() {
                return this.textures[0]
            }
            set texture(e) {
                this.textures[0] = e
            }
            setSize(e, t, n=1) {
                if (this.width !== e || this.height !== t || this.depth !== n) {
                    this.width = e,
                    this.height = t,
                    this.depth = n;
                    for (let i = 0, r = this.textures.length; i < r; i++)
                        this.textures[i].image.width = e,
                        this.textures[i].image.height = t,
                        this.textures[i].image.depth = n;
                    this.dispose()
                }
                this.viewport.set(0, 0, e, t),
                this.scissor.set(0, 0, e, t)
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            copy(e) {
                this.width = e.width,
                this.height = e.height,
                this.depth = e.depth,
                this.scissor.copy(e.scissor),
                this.scissorTest = e.scissorTest,
                this.viewport.copy(e.viewport),
                this.textures.length = 0;
                for (let t = 0, n = e.textures.length; t < n; t++)
                    this.textures[t] = e.textures[t].clone(),
                    this.textures[t].isRenderTargetTexture = !0;
                const t = Object.assign({}, e.texture.image);
                return this.texture.source = new Kt(t),
                this.depthBuffer = e.depthBuffer,
                this.stencilBuffer = e.stencilBuffer,
                this.resolveDepthBuffer = e.resolveDepthBuffer,
                this.resolveStencilBuffer = e.resolveStencilBuffer,
                null !== e.depthTexture && (this.depthTexture = e.depthTexture.clone()),
                this.samples = e.samples,
                this
            }
            dispose() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
        }
        class nn extends tn {
            constructor(e=1, t=1, n={}) {
                super(e, t, n),
                this.isWebGLRenderTarget = !0
            }
        }
        class rn extends $t {
            constructor(e=null, t=1, n=1, i=1) {
                super(null),
                this.isDataArrayTexture = !0,
                this.image = {
                    data: e,
                    width: t,
                    height: n,
                    depth: i
                },
                this.magFilter = k,
                this.minFilter = k,
                this.wrapR = O,
                this.generateMipmaps = !1,
                this.flipY = !1,
                this.unpackAlignment = 1,
                this.layerUpdates = new Set
            }
            addLayerUpdate(e) {
                this.layerUpdates.add(e)
            }
            clearLayerUpdates() {
                this.layerUpdates.clear()
            }
        }
        class sn extends $t {
            constructor(e=null, t=1, n=1, i=1) {
                super(null),
                this.isData3DTexture = !0,
                this.image = {
                    data: e,
                    width: t,
                    height: n,
                    depth: i
                },
                this.magFilter = k,
                this.minFilter = k,
                this.wrapR = O,
                this.generateMipmaps = !1,
                this.flipY = !1,
                this.unpackAlignment = 1
            }
        }
        class an {
            constructor(e=0, t=0, n=0, i=1) {
                this.isQuaternion = !0,
                this._x = e,
                this._y = t,
                this._z = n,
                this._w = i
            }
            static slerpFlat(e, t, n, i, r, s, a) {
                let o = n[i + 0]
                  , l = n[i + 1]
                  , c = n[i + 2]
                  , u = n[i + 3];
                const h = r[s + 0]
                  , d = r[s + 1]
                  , p = r[s + 2]
                  , f = r[s + 3];
                if (0 === a)
                    return e[t + 0] = o,
                    e[t + 1] = l,
                    e[t + 2] = c,
                    void (e[t + 3] = u);
                if (1 === a)
                    return e[t + 0] = h,
                    e[t + 1] = d,
                    e[t + 2] = p,
                    void (e[t + 3] = f);
                if (u !== f || o !== h || l !== d || c !== p) {
                    let e = 1 - a;
                    const t = o * h + l * d + c * p + u * f
                      , n = t >= 0 ? 1 : -1
                      , i = 1 - t * t;
                    if (i > Number.EPSILON) {
                        const r = Math.sqrt(i)
                          , s = Math.atan2(r, t * n);
                        e = Math.sin(e * s) / r,
                        a = Math.sin(a * s) / r
                    }
                    const r = a * n;
                    if (o = o * e + h * r,
                    l = l * e + d * r,
                    c = c * e + p * r,
                    u = u * e + f * r,
                    e === 1 - a) {
                        const e = 1 / Math.sqrt(o * o + l * l + c * c + u * u);
                        o *= e,
                        l *= e,
                        c *= e,
                        u *= e
                    }
                }
                e[t] = o,
                e[t + 1] = l,
                e[t + 2] = c,
                e[t + 3] = u
            }
            static multiplyQuaternionsFlat(e, t, n, i, r, s) {
                const a = n[i]
                  , o = n[i + 1]
                  , l = n[i + 2]
                  , c = n[i + 3]
                  , u = r[s]
                  , h = r[s + 1]
                  , d = r[s + 2]
                  , p = r[s + 3];
                return e[t] = a * p + c * u + o * d - l * h,
                e[t + 1] = o * p + c * h + l * u - a * d,
                e[t + 2] = l * p + c * d + a * h - o * u,
                e[t + 3] = c * p - a * u - o * h - l * d,
                e
            }
            get x() {
                return this._x
            }
            set x(e) {
                this._x = e,
                this._onChangeCallback()
            }
            get y() {
                return this._y
            }
            set y(e) {
                this._y = e,
                this._onChangeCallback()
            }
            get z() {
                return this._z
            }
            set z(e) {
                this._z = e,
                this._onChangeCallback()
            }
            get w() {
                return this._w
            }
            set w(e) {
                this._w = e,
                this._onChangeCallback()
            }
            set(e, t, n, i) {
                return this._x = e,
                this._y = t,
                this._z = n,
                this._w = i,
                this._onChangeCallback(),
                this
            }
            clone() {
                return new this.constructor(this._x,this._y,this._z,this._w)
            }
            copy(e) {
                return this._x = e.x,
                this._y = e.y,
                this._z = e.z,
                this._w = e.w,
                this._onChangeCallback(),
                this
            }
            setFromEuler(e, t=!0) {
                const n = e._x
                  , i = e._y
                  , r = e._z
                  , s = e._order
                  , a = Math.cos
                  , o = Math.sin
                  , l = a(n / 2)
                  , c = a(i / 2)
                  , u = a(r / 2)
                  , h = o(n / 2)
                  , d = o(i / 2)
                  , p = o(r / 2);
                switch (s) {
                case "XYZ":
                    this._x = h * c * u + l * d * p,
                    this._y = l * d * u - h * c * p,
                    this._z = l * c * p + h * d * u,
                    this._w = l * c * u - h * d * p;
                    break;
                case "YXZ":
                    this._x = h * c * u + l * d * p,
                    this._y = l * d * u - h * c * p,
                    this._z = l * c * p - h * d * u,
                    this._w = l * c * u + h * d * p;
                    break;
                case "ZXY":
                    this._x = h * c * u - l * d * p,
                    this._y = l * d * u + h * c * p,
                    this._z = l * c * p + h * d * u,
                    this._w = l * c * u - h * d * p;
                    break;
                case "ZYX":
                    this._x = h * c * u - l * d * p,
                    this._y = l * d * u + h * c * p,
                    this._z = l * c * p - h * d * u,
                    this._w = l * c * u + h * d * p;
                    break;
                case "YZX":
                    this._x = h * c * u + l * d * p,
                    this._y = l * d * u + h * c * p,
                    this._z = l * c * p - h * d * u,
                    this._w = l * c * u - h * d * p;
                    break;
                case "XZY":
                    this._x = h * c * u - l * d * p,
                    this._y = l * d * u - h * c * p,
                    this._z = l * c * p + h * d * u,
                    this._w = l * c * u + h * d * p;
                    break;
                default:
                    console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + s)
                }
                return !0 === t && this._onChangeCallback(),
                this
            }
            setFromAxisAngle(e, t) {
                const n = t / 2
                  , i = Math.sin(n);
                return this._x = e.x * i,
                this._y = e.y * i,
                this._z = e.z * i,
                this._w = Math.cos(n),
                this._onChangeCallback(),
                this
            }
            setFromRotationMatrix(e) {
                const t = e.elements
                  , n = t[0]
                  , i = t[4]
                  , r = t[8]
                  , s = t[1]
                  , a = t[5]
                  , o = t[9]
                  , l = t[2]
                  , c = t[6]
                  , u = t[10]
                  , h = n + a + u;
                if (h > 0) {
                    const e = .5 / Math.sqrt(h + 1);
                    this._w = .25 / e,
                    this._x = (c - o) * e,
                    this._y = (r - l) * e,
                    this._z = (s - i) * e
                } else if (n > a && n > u) {
                    const e = 2 * Math.sqrt(1 + n - a - u);
                    this._w = (c - o) / e,
                    this._x = .25 * e,
                    this._y = (i + s) / e,
                    this._z = (r + l) / e
                } else if (a > u) {
                    const e = 2 * Math.sqrt(1 + a - n - u);
                    this._w = (r - l) / e,
                    this._x = (i + s) / e,
                    this._y = .25 * e,
                    this._z = (o + c) / e
                } else {
                    const e = 2 * Math.sqrt(1 + u - n - a);
                    this._w = (s - i) / e,
                    this._x = (r + l) / e,
                    this._y = (o + c) / e,
                    this._z = .25 * e
                }
                return this._onChangeCallback(),
                this
            }
            setFromUnitVectors(e, t) {
                let n = e.dot(t) + 1;
                return n < Number.EPSILON ? (n = 0,
                Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y,
                this._y = e.x,
                this._z = 0,
                this._w = n) : (this._x = 0,
                this._y = -e.z,
                this._z = e.y,
                this._w = n)) : (this._x = e.y * t.z - e.z * t.y,
                this._y = e.z * t.x - e.x * t.z,
                this._z = e.x * t.y - e.y * t.x,
                this._w = n),
                this.normalize()
            }
            angleTo(e) {
                return 2 * Math.acos(Math.abs(Ct(this.dot(e), -1, 1)))
            }
            rotateTowards(e, t) {
                const n = this.angleTo(e);
                if (0 === n)
                    return this;
                const i = Math.min(1, t / n);
                return this.slerp(e, i),
                this
            }
            identity() {
                return this.set(0, 0, 0, 1)
            }
            invert() {
                return this.conjugate()
            }
            conjugate() {
                return this._x *= -1,
                this._y *= -1,
                this._z *= -1,
                this._onChangeCallback(),
                this
            }
            dot(e) {
                return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w
            }
            lengthSq() {
                return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
            }
            length() {
                return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
            }
            normalize() {
                let e = this.length();
                return 0 === e ? (this._x = 0,
                this._y = 0,
                this._z = 0,
                this._w = 1) : (e = 1 / e,
                this._x = this._x * e,
                this._y = this._y * e,
                this._z = this._z * e,
                this._w = this._w * e),
                this._onChangeCallback(),
                this
            }
            multiply(e) {
                return this.multiplyQuaternions(this, e)
            }
            premultiply(e) {
                return this.multiplyQuaternions(e, this)
            }
            multiplyQuaternions(e, t) {
                const n = e._x
                  , i = e._y
                  , r = e._z
                  , s = e._w
                  , a = t._x
                  , o = t._y
                  , l = t._z
                  , c = t._w;
                return this._x = n * c + s * a + i * l - r * o,
                this._y = i * c + s * o + r * a - n * l,
                this._z = r * c + s * l + n * o - i * a,
                this._w = s * c - n * a - i * o - r * l,
                this._onChangeCallback(),
                this
            }
            slerp(e, t) {
                if (0 === t)
                    return this;
                if (1 === t)
                    return this.copy(e);
                const n = this._x
                  , i = this._y
                  , r = this._z
                  , s = this._w;
                let a = s * e._w + n * e._x + i * e._y + r * e._z;
                if (a < 0 ? (this._w = -e._w,
                this._x = -e._x,
                this._y = -e._y,
                this._z = -e._z,
                a = -a) : this.copy(e),
                a >= 1)
                    return this._w = s,
                    this._x = n,
                    this._y = i,
                    this._z = r,
                    this;
                const o = 1 - a * a;
                if (o <= Number.EPSILON) {
                    const e = 1 - t;
                    return this._w = e * s + t * this._w,
                    this._x = e * n + t * this._x,
                    this._y = e * i + t * this._y,
                    this._z = e * r + t * this._z,
                    this.normalize(),
                    this
                }
                const l = Math.sqrt(o)
                  , c = Math.atan2(l, a)
                  , u = Math.sin((1 - t) * c) / l
                  , h = Math.sin(t * c) / l;
                return this._w = s * u + this._w * h,
                this._x = n * u + this._x * h,
                this._y = i * u + this._y * h,
                this._z = r * u + this._z * h,
                this._onChangeCallback(),
                this
            }
            slerpQuaternions(e, t, n) {
                return this.copy(e).slerp(t, n)
            }
            random() {
                const e = 2 * Math.PI * Math.random()
                  , t = 2 * Math.PI * Math.random()
                  , n = Math.random()
                  , i = Math.sqrt(1 - n)
                  , r = Math.sqrt(n);
                return this.set(i * Math.sin(e), i * Math.cos(e), r * Math.sin(t), r * Math.cos(t))
            }
            equals(e) {
                return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w
            }
            fromArray(e, t=0) {
                return this._x = e[t],
                this._y = e[t + 1],
                this._z = e[t + 2],
                this._w = e[t + 3],
                this._onChangeCallback(),
                this
            }
            toArray(e=[], t=0) {
                return e[t] = this._x,
                e[t + 1] = this._y,
                e[t + 2] = this._z,
                e[t + 3] = this._w,
                e
            }
            fromBufferAttribute(e, t) {
                return this._x = e.getX(t),
                this._y = e.getY(t),
                this._z = e.getZ(t),
                this._w = e.getW(t),
                this._onChangeCallback(),
                this
            }
            toJSON() {
                return this.toArray()
            }
            _onChange(e) {
                return this._onChangeCallback = e,
                this
            }
            _onChangeCallback() {}
            *[Symbol.iterator]() {
                yield this._x,
                yield this._y,
                yield this._z,
                yield this._w
            }
        }
        class on {
            constructor(e=0, t=0, n=0) {
                on.prototype.isVector3 = !0,
                this.x = e,
                this.y = t,
                this.z = n
            }
            set(e, t, n) {
                return void 0 === n && (n = this.z),
                this.x = e,
                this.y = t,
                this.z = n,
                this
            }
            setScalar(e) {
                return this.x = e,
                this.y = e,
                this.z = e,
                this
            }
            setX(e) {
                return this.x = e,
                this
            }
            setY(e) {
                return this.y = e,
                this
            }
            setZ(e) {
                return this.z = e,
                this
            }
            setComponent(e, t) {
                switch (e) {
                case 0:
                    this.x = t;
                    break;
                case 1:
                    this.y = t;
                    break;
                case 2:
                    this.z = t;
                    break;
                default:
                    throw new Error("index is out of range: " + e)
                }
                return this
            }
            getComponent(e) {
                switch (e) {
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                case 2:
                    return this.z;
                default:
                    throw new Error("index is out of range: " + e)
                }
            }
            clone() {
                return new this.constructor(this.x,this.y,this.z)
            }
            copy(e) {
                return this.x = e.x,
                this.y = e.y,
                this.z = e.z,
                this
            }
            add(e) {
                return this.x += e.x,
                this.y += e.y,
                this.z += e.z,
                this
            }
            addScalar(e) {
                return this.x += e,
                this.y += e,
                this.z += e,
                this
            }
            addVectors(e, t) {
                return this.x = e.x + t.x,
                this.y = e.y + t.y,
                this.z = e.z + t.z,
                this
            }
            addScaledVector(e, t) {
                return this.x += e.x * t,
                this.y += e.y * t,
                this.z += e.z * t,
                this
            }
            sub(e) {
                return this.x -= e.x,
                this.y -= e.y,
                this.z -= e.z,
                this
            }
            subScalar(e) {
                return this.x -= e,
                this.y -= e,
                this.z -= e,
                this
            }
            subVectors(e, t) {
                return this.x = e.x - t.x,
                this.y = e.y - t.y,
                this.z = e.z - t.z,
                this
            }
            multiply(e) {
                return this.x *= e.x,
                this.y *= e.y,
                this.z *= e.z,
                this
            }
            multiplyScalar(e) {
                return this.x *= e,
                this.y *= e,
                this.z *= e,
                this
            }
            multiplyVectors(e, t) {
                return this.x = e.x * t.x,
                this.y = e.y * t.y,
                this.z = e.z * t.z,
                this
            }
            applyEuler(e) {
                return this.applyQuaternion(cn.setFromEuler(e))
            }
            applyAxisAngle(e, t) {
                return this.applyQuaternion(cn.setFromAxisAngle(e, t))
            }
            applyMatrix3(e) {
                const t = this.x
                  , n = this.y
                  , i = this.z
                  , r = e.elements;
                return this.x = r[0] * t + r[3] * n + r[6] * i,
                this.y = r[1] * t + r[4] * n + r[7] * i,
                this.z = r[2] * t + r[5] * n + r[8] * i,
                this
            }
            applyNormalMatrix(e) {
                return this.applyMatrix3(e).normalize()
            }
            applyMatrix4(e) {
                const t = this.x
                  , n = this.y
                  , i = this.z
                  , r = e.elements
                  , s = 1 / (r[3] * t + r[7] * n + r[11] * i + r[15]);
                return this.x = (r[0] * t + r[4] * n + r[8] * i + r[12]) * s,
                this.y = (r[1] * t + r[5] * n + r[9] * i + r[13]) * s,
                this.z = (r[2] * t + r[6] * n + r[10] * i + r[14]) * s,
                this
            }
            applyQuaternion(e) {
                const t = this.x
                  , n = this.y
                  , i = this.z
                  , r = e.x
                  , s = e.y
                  , a = e.z
                  , o = e.w
                  , l = 2 * (s * i - a * n)
                  , c = 2 * (a * t - r * i)
                  , u = 2 * (r * n - s * t);
                return this.x = t + o * l + s * u - a * c,
                this.y = n + o * c + a * l - r * u,
                this.z = i + o * u + r * c - s * l,
                this
            }
            project(e) {
                return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)
            }
            unproject(e) {
                return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)
            }
            transformDirection(e) {
                const t = this.x
                  , n = this.y
                  , i = this.z
                  , r = e.elements;
                return this.x = r[0] * t + r[4] * n + r[8] * i,
                this.y = r[1] * t + r[5] * n + r[9] * i,
                this.z = r[2] * t + r[6] * n + r[10] * i,
                this.normalize()
            }
            divide(e) {
                return this.x /= e.x,
                this.y /= e.y,
                this.z /= e.z,
                this
            }
            divideScalar(e) {
                return this.multiplyScalar(1 / e)
            }
            min(e) {
                return this.x = Math.min(this.x, e.x),
                this.y = Math.min(this.y, e.y),
                this.z = Math.min(this.z, e.z),
                this
            }
            max(e) {
                return this.x = Math.max(this.x, e.x),
                this.y = Math.max(this.y, e.y),
                this.z = Math.max(this.z, e.z),
                this
            }
            clamp(e, t) {
                return this.x = Math.max(e.x, Math.min(t.x, this.x)),
                this.y = Math.max(e.y, Math.min(t.y, this.y)),
                this.z = Math.max(e.z, Math.min(t.z, this.z)),
                this
            }
            clampScalar(e, t) {
                return this.x = Math.max(e, Math.min(t, this.x)),
                this.y = Math.max(e, Math.min(t, this.y)),
                this.z = Math.max(e, Math.min(t, this.z)),
                this
            }
            clampLength(e, t) {
                const n = this.length();
                return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)))
            }
            floor() {
                return this.x = Math.floor(this.x),
                this.y = Math.floor(this.y),
                this.z = Math.floor(this.z),
                this
            }
            ceil() {
                return this.x = Math.ceil(this.x),
                this.y = Math.ceil(this.y),
                this.z = Math.ceil(this.z),
                this
            }
            round() {
                return this.x = Math.round(this.x),
                this.y = Math.round(this.y),
                this.z = Math.round(this.z),
                this
            }
            roundToZero() {
                return this.x = Math.trunc(this.x),
                this.y = Math.trunc(this.y),
                this.z = Math.trunc(this.z),
                this
            }
            negate() {
                return this.x = -this.x,
                this.y = -this.y,
                this.z = -this.z,
                this
            }
            dot(e) {
                return this.x * e.x + this.y * e.y + this.z * e.z
            }
            lengthSq() {
                return this.x * this.x + this.y * this.y + this.z * this.z
            }
            length() {
                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
            }
            manhattanLength() {
                return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
            }
            normalize() {
                return this.divideScalar(this.length() || 1)
            }
            setLength(e) {
                return this.normalize().multiplyScalar(e)
            }
            lerp(e, t) {
                return this.x += (e.x - this.x) * t,
                this.y += (e.y - this.y) * t,
                this.z += (e.z - this.z) * t,
                this
            }
            lerpVectors(e, t, n) {
                return this.x = e.x + (t.x - e.x) * n,
                this.y = e.y + (t.y - e.y) * n,
                this.z = e.z + (t.z - e.z) * n,
                this
            }
            cross(e) {
                return this.crossVectors(this, e)
            }
            crossVectors(e, t) {
                const n = e.x
                  , i = e.y
                  , r = e.z
                  , s = t.x
                  , a = t.y
                  , o = t.z;
                return this.x = i * o - r * a,
                this.y = r * s - n * o,
                this.z = n * a - i * s,
                this
            }
            projectOnVector(e) {
                const t = e.lengthSq();
                if (0 === t)
                    return this.set(0, 0, 0);
                const n = e.dot(this) / t;
                return this.copy(e).multiplyScalar(n)
            }
            projectOnPlane(e) {
                return ln.copy(this).projectOnVector(e),
                this.sub(ln)
            }
            reflect(e) {
                return this.sub(ln.copy(e).multiplyScalar(2 * this.dot(e)))
            }
            angleTo(e) {
                const t = Math.sqrt(this.lengthSq() * e.lengthSq());
                if (0 === t)
                    return Math.PI / 2;
                const n = this.dot(e) / t;
                return Math.acos(Ct(n, -1, 1))
            }
            distanceTo(e) {
                return Math.sqrt(this.distanceToSquared(e))
            }
            distanceToSquared(e) {
                const t = this.x - e.x
                  , n = this.y - e.y
                  , i = this.z - e.z;
                return t * t + n * n + i * i
            }
            manhattanDistanceTo(e) {
                return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z)
            }
            setFromSpherical(e) {
                return this.setFromSphericalCoords(e.radius, e.phi, e.theta)
            }
            setFromSphericalCoords(e, t, n) {
                const i = Math.sin(t) * e;
                return this.x = i * Math.sin(n),
                this.y = Math.cos(t) * e,
                this.z = i * Math.cos(n),
                this
            }
            setFromCylindrical(e) {
                return this.setFromCylindricalCoords(e.radius, e.theta, e.y)
            }
            setFromCylindricalCoords(e, t, n) {
                return this.x = e * Math.sin(t),
                this.y = n,
                this.z = e * Math.cos(t),
                this
            }
            setFromMatrixPosition(e) {
                const t = e.elements;
                return this.x = t[12],
                this.y = t[13],
                this.z = t[14],
                this
            }
            setFromMatrixScale(e) {
                const t = this.setFromMatrixColumn(e, 0).length()
                  , n = this.setFromMatrixColumn(e, 1).length()
                  , i = this.setFromMatrixColumn(e, 2).length();
                return this.x = t,
                this.y = n,
                this.z = i,
                this
            }
            setFromMatrixColumn(e, t) {
                return this.fromArray(e.elements, 4 * t)
            }
            setFromMatrix3Column(e, t) {
                return this.fromArray(e.elements, 3 * t)
            }
            setFromEuler(e) {
                return this.x = e._x,
                this.y = e._y,
                this.z = e._z,
                this
            }
            setFromColor(e) {
                return this.x = e.r,
                this.y = e.g,
                this.z = e.b,
                this
            }
            equals(e) {
                return e.x === this.x && e.y === this.y && e.z === this.z
            }
            fromArray(e, t=0) {
                return this.x = e[t],
                this.y = e[t + 1],
                this.z = e[t + 2],
                this
            }
            toArray(e=[], t=0) {
                return e[t] = this.x,
                e[t + 1] = this.y,
                e[t + 2] = this.z,
                e
            }
            fromBufferAttribute(e, t) {
                return this.x = e.getX(t),
                this.y = e.getY(t),
                this.z = e.getZ(t),
                this
            }
            random() {
                return this.x = Math.random(),
                this.y = Math.random(),
                this.z = Math.random(),
                this
            }
            randomDirection() {
                const e = Math.random() * Math.PI * 2
                  , t = 2 * Math.random() - 1
                  , n = Math.sqrt(1 - t * t);
                return this.x = n * Math.cos(e),
                this.y = t,
                this.z = n * Math.sin(e),
                this
            }
            *[Symbol.iterator]() {
                yield this.x,
                yield this.y,
                yield this.z
            }
        }
        const ln = new on
          , cn = new an;
        class un {
            constructor(e=new on(1 / 0,1 / 0,1 / 0), t=new on(-1 / 0,-1 / 0,-1 / 0)) {
                this.isBox3 = !0,
                this.min = e,
                this.max = t
            }
            set(e, t) {
                return this.min.copy(e),
                this.max.copy(t),
                this
            }
            setFromArray(e) {
                this.makeEmpty();
                for (let t = 0, n = e.length; t < n; t += 3)
                    this.expandByPoint(dn.fromArray(e, t));
                return this
            }
            setFromBufferAttribute(e) {
                this.makeEmpty();
                for (let t = 0, n = e.count; t < n; t++)
                    this.expandByPoint(dn.fromBufferAttribute(e, t));
                return this
            }
            setFromPoints(e) {
                this.makeEmpty();
                for (let t = 0, n = e.length; t < n; t++)
                    this.expandByPoint(e[t]);
                return this
            }
            setFromCenterAndSize(e, t) {
                const n = dn.copy(t).multiplyScalar(.5);
                return this.min.copy(e).sub(n),
                this.max.copy(e).add(n),
                this
            }
            setFromObject(e, t=!1) {
                return this.makeEmpty(),
                this.expandByObject(e, t)
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            copy(e) {
                return this.min.copy(e.min),
                this.max.copy(e.max),
                this
            }
            makeEmpty() {
                return this.min.x = this.min.y = this.min.z = 1 / 0,
                this.max.x = this.max.y = this.max.z = -1 / 0,
                this
            }
            isEmpty() {
                return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
            }
            getCenter(e) {
                return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
            }
            getSize(e) {
                return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min)
            }
            expandByPoint(e) {
                return this.min.min(e),
                this.max.max(e),
                this
            }
            expandByVector(e) {
                return this.min.sub(e),
                this.max.add(e),
                this
            }
            expandByScalar(e) {
                return this.min.addScalar(-e),
                this.max.addScalar(e),
                this
            }
            expandByObject(e, t=!1) {
                e.updateWorldMatrix(!1, !1);
                const n = e.geometry;
                if (void 0 !== n) {
                    const i = n.getAttribute("position");
                    if (!0 === t && void 0 !== i && !0 !== e.isInstancedMesh)
                        for (let t = 0, n = i.count; t < n; t++)
                            !0 === e.isMesh ? e.getVertexPosition(t, dn) : dn.fromBufferAttribute(i, t),
                            dn.applyMatrix4(e.matrixWorld),
                            this.expandByPoint(dn);
                    else
                        void 0 !== e.boundingBox ? (null === e.boundingBox && e.computeBoundingBox(),
                        pn.copy(e.boundingBox)) : (null === n.boundingBox && n.computeBoundingBox(),
                        pn.copy(n.boundingBox)),
                        pn.applyMatrix4(e.matrixWorld),
                        this.union(pn)
                }
                const i = e.children;
                for (let e = 0, n = i.length; e < n; e++)
                    this.expandByObject(i[e], t);
                return this
            }
            containsPoint(e) {
                return e.x >= this.min.x && e.x <= this.max.x && e.y >= this.min.y && e.y <= this.max.y && e.z >= this.min.z && e.z <= this.max.z
            }
            containsBox(e) {
                return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z
            }
            getParameter(e, t) {
                return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z))
            }
            intersectsBox(e) {
                return e.max.x >= this.min.x && e.min.x <= this.max.x && e.max.y >= this.min.y && e.min.y <= this.max.y && e.max.z >= this.min.z && e.min.z <= this.max.z
            }
            intersectsSphere(e) {
                return this.clampPoint(e.center, dn),
                dn.distanceToSquared(e.center) <= e.radius * e.radius
            }
            intersectsPlane(e) {
                let t, n;
                return e.normal.x > 0 ? (t = e.normal.x * this.min.x,
                n = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x,
                n = e.normal.x * this.min.x),
                e.normal.y > 0 ? (t += e.normal.y * this.min.y,
                n += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y,
                n += e.normal.y * this.min.y),
                e.normal.z > 0 ? (t += e.normal.z * this.min.z,
                n += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z,
                n += e.normal.z * this.min.z),
                t <= -e.constant && n >= -e.constant
            }
            intersectsTriangle(e) {
                if (this.isEmpty())
                    return !1;
                this.getCenter(xn),
                _n.subVectors(this.max, xn),
                fn.subVectors(e.a, xn),
                An.subVectors(e.b, xn),
                gn.subVectors(e.c, xn),
                mn.subVectors(An, fn),
                vn.subVectors(gn, An),
                yn.subVectors(fn, gn);
                let t = [0, -mn.z, mn.y, 0, -vn.z, vn.y, 0, -yn.z, yn.y, mn.z, 0, -mn.x, vn.z, 0, -vn.x, yn.z, 0, -yn.x, -mn.y, mn.x, 0, -vn.y, vn.x, 0, -yn.y, yn.x, 0];
                return !!wn(t, fn, An, gn, _n) && (t = [1, 0, 0, 0, 1, 0, 0, 0, 1],
                !!wn(t, fn, An, gn, _n) && (bn.crossVectors(mn, vn),
                t = [bn.x, bn.y, bn.z],
                wn(t, fn, An, gn, _n)))
            }
            clampPoint(e, t) {
                return t.copy(e).clamp(this.min, this.max)
            }
            distanceToPoint(e) {
                return this.clampPoint(e, dn).distanceTo(e)
            }
            getBoundingSphere(e) {
                return this.isEmpty() ? e.makeEmpty() : (this.getCenter(e.center),
                e.radius = .5 * this.getSize(dn).length()),
                e
            }
            intersect(e) {
                return this.min.max(e.min),
                this.max.min(e.max),
                this.isEmpty() && this.makeEmpty(),
                this
            }
            union(e) {
                return this.min.min(e.min),
                this.max.max(e.max),
                this
            }
            applyMatrix4(e) {
                return this.isEmpty() || (hn[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e),
                hn[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e),
                hn[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e),
                hn[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e),
                hn[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e),
                hn[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e),
                hn[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e),
                hn[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e),
                this.setFromPoints(hn)),
                this
            }
            translate(e) {
                return this.min.add(e),
                this.max.add(e),
                this
            }
            equals(e) {
                return e.min.equals(this.min) && e.max.equals(this.max)
            }
        }
        const hn = [new on, new on, new on, new on, new on, new on, new on, new on]
          , dn = new on
          , pn = new un
          , fn = new on
          , An = new on
          , gn = new on
          , mn = new on
          , vn = new on
          , yn = new on
          , xn = new on
          , _n = new on
          , bn = new on
          , En = new on;
        function wn(e, t, n, i, r) {
            for (let s = 0, a = e.length - 3; s <= a; s += 3) {
                En.fromArray(e, s);
                const a = r.x * Math.abs(En.x) + r.y * Math.abs(En.y) + r.z * Math.abs(En.z)
                  , o = t.dot(En)
                  , l = n.dot(En)
                  , c = i.dot(En);
                if (Math.max(-Math.max(o, l, c), Math.min(o, l, c)) > a)
                    return !1
            }
            return !0
        }
        const Cn = new un
          , In = new on
          , Sn = new on;
        class Mn {
            constructor(e=new on, t=-1) {
                this.isSphere = !0,
                this.center = e,
                this.radius = t
            }
            set(e, t) {
                return this.center.copy(e),
                this.radius = t,
                this
            }
            setFromPoints(e, t) {
                const n = this.center;
                void 0 !== t ? n.copy(t) : Cn.setFromPoints(e).getCenter(n);
                let i = 0;
                for (let t = 0, r = e.length; t < r; t++)
                    i = Math.max(i, n.distanceToSquared(e[t]));
                return this.radius = Math.sqrt(i),
                this
            }
            copy(e) {
                return this.center.copy(e.center),
                this.radius = e.radius,
                this
            }
            isEmpty() {
                return this.radius < 0
            }
            makeEmpty() {
                return this.center.set(0, 0, 0),
                this.radius = -1,
                this
            }
            containsPoint(e) {
                return e.distanceToSquared(this.center) <= this.radius * this.radius
            }
            distanceToPoint(e) {
                return e.distanceTo(this.center) - this.radius
            }
            intersectsSphere(e) {
                const t = this.radius + e.radius;
                return e.center.distanceToSquared(this.center) <= t * t
            }
            intersectsBox(e) {
                return e.intersectsSphere(this)
            }
            intersectsPlane(e) {
                return Math.abs(e.distanceToPoint(this.center)) <= this.radius
            }
            clampPoint(e, t) {
                const n = this.center.distanceToSquared(e);
                return t.copy(e),
                n > this.radius * this.radius && (t.sub(this.center).normalize(),
                t.multiplyScalar(this.radius).add(this.center)),
                t
            }
            getBoundingBox(e) {
                return this.isEmpty() ? (e.makeEmpty(),
                e) : (e.set(this.center, this.center),
                e.expandByScalar(this.radius),
                e)
            }
            applyMatrix4(e) {
                return this.center.applyMatrix4(e),
                this.radius = this.radius * e.getMaxScaleOnAxis(),
                this
            }
            translate(e) {
                return this.center.add(e),
                this
            }
            expandByPoint(e) {
                if (this.isEmpty())
                    return this.center.copy(e),
                    this.radius = 0,
                    this;
                In.subVectors(e, this.center);
                const t = In.lengthSq();
                if (t > this.radius * this.radius) {
                    const e = Math.sqrt(t)
                      , n = .5 * (e - this.radius);
                    this.center.addScaledVector(In, n / e),
                    this.radius += n
                }
                return this
            }
            union(e) {
                return e.isEmpty() ? this : this.isEmpty() ? (this.copy(e),
                this) : (!0 === this.center.equals(e.center) ? this.radius = Math.max(this.radius, e.radius) : (Sn.subVectors(e.center, this.center).setLength(e.radius),
                this.expandByPoint(In.copy(e.center).add(Sn)),
                this.expandByPoint(In.copy(e.center).sub(Sn))),
                this)
            }
            equals(e) {
                return e.center.equals(this.center) && e.radius === this.radius
            }
            clone() {
                return (new this.constructor).copy(this)
            }
        }
        const Tn = new on
          , Bn = new on
          , Rn = new on
          , Dn = new on
          , Pn = new on
          , Ln = new on
          , Un = new on;
        class Fn {
            constructor(e=new on, t=new on(0,0,-1)) {
                this.origin = e,
                this.direction = t
            }
            set(e, t) {
                return this.origin.copy(e),
                this.direction.copy(t),
                this
            }
            copy(e) {
                return this.origin.copy(e.origin),
                this.direction.copy(e.direction),
                this
            }
            at(e, t) {
                return t.copy(this.origin).addScaledVector(this.direction, e)
            }
            lookAt(e) {
                return this.direction.copy(e).sub(this.origin).normalize(),
                this
            }
            recast(e) {
                return this.origin.copy(this.at(e, Tn)),
                this
            }
            closestPointToPoint(e, t) {
                t.subVectors(e, this.origin);
                const n = t.dot(this.direction);
                return n < 0 ? t.copy(this.origin) : t.copy(this.origin).addScaledVector(this.direction, n)
            }
            distanceToPoint(e) {
                return Math.sqrt(this.distanceSqToPoint(e))
            }
            distanceSqToPoint(e) {
                const t = Tn.subVectors(e, this.origin).dot(this.direction);
                return t < 0 ? this.origin.distanceToSquared(e) : (Tn.copy(this.origin).addScaledVector(this.direction, t),
                Tn.distanceToSquared(e))
            }
            distanceSqToSegment(e, t, n, i) {
                Bn.copy(e).add(t).multiplyScalar(.5),
                Rn.copy(t).sub(e).normalize(),
                Dn.copy(this.origin).sub(Bn);
                const r = .5 * e.distanceTo(t)
                  , s = -this.direction.dot(Rn)
                  , a = Dn.dot(this.direction)
                  , o = -Dn.dot(Rn)
                  , l = Dn.lengthSq()
                  , c = Math.abs(1 - s * s);
                let u, h, d, p;
                if (c > 0)
                    if (u = s * o - a,
                    h = s * a - o,
                    p = r * c,
                    u >= 0)
                        if (h >= -p)
                            if (h <= p) {
                                const e = 1 / c;
                                u *= e,
                                h *= e,
                                d = u * (u + s * h + 2 * a) + h * (s * u + h + 2 * o) + l
                            } else
                                h = r,
                                u = Math.max(0, -(s * h + a)),
                                d = -u * u + h * (h + 2 * o) + l;
                        else
                            h = -r,
                            u = Math.max(0, -(s * h + a)),
                            d = -u * u + h * (h + 2 * o) + l;
                    else
                        h <= -p ? (u = Math.max(0, -(-s * r + a)),
                        h = u > 0 ? -r : Math.min(Math.max(-r, -o), r),
                        d = -u * u + h * (h + 2 * o) + l) : h <= p ? (u = 0,
                        h = Math.min(Math.max(-r, -o), r),
                        d = h * (h + 2 * o) + l) : (u = Math.max(0, -(s * r + a)),
                        h = u > 0 ? r : Math.min(Math.max(-r, -o), r),
                        d = -u * u + h * (h + 2 * o) + l);
                else
                    h = s > 0 ? -r : r,
                    u = Math.max(0, -(s * h + a)),
                    d = -u * u + h * (h + 2 * o) + l;
                return n && n.copy(this.origin).addScaledVector(this.direction, u),
                i && i.copy(Bn).addScaledVector(Rn, h),
                d
            }
            intersectSphere(e, t) {
                Tn.subVectors(e.center, this.origin);
                const n = Tn.dot(this.direction)
                  , i = Tn.dot(Tn) - n * n
                  , r = e.radius * e.radius;
                if (i > r)
                    return null;
                const s = Math.sqrt(r - i)
                  , a = n - s
                  , o = n + s;
                return o < 0 ? null : a < 0 ? this.at(o, t) : this.at(a, t)
            }
            intersectsSphere(e) {
                return this.distanceSqToPoint(e.center) <= e.radius * e.radius
            }
            distanceToPlane(e) {
                const t = e.normal.dot(this.direction);
                if (0 === t)
                    return 0 === e.distanceToPoint(this.origin) ? 0 : null;
                const n = -(this.origin.dot(e.normal) + e.constant) / t;
                return n >= 0 ? n : null
            }
            intersectPlane(e, t) {
                const n = this.distanceToPlane(e);
                return null === n ? null : this.at(n, t)
            }
            intersectsPlane(e) {
                const t = e.distanceToPoint(this.origin);
                if (0 === t)
                    return !0;
                return e.normal.dot(this.direction) * t < 0
            }
            intersectBox(e, t) {
                let n, i, r, s, a, o;
                const l = 1 / this.direction.x
                  , c = 1 / this.direction.y
                  , u = 1 / this.direction.z
                  , h = this.origin;
                return l >= 0 ? (n = (e.min.x - h.x) * l,
                i = (e.max.x - h.x) * l) : (n = (e.max.x - h.x) * l,
                i = (e.min.x - h.x) * l),
                c >= 0 ? (r = (e.min.y - h.y) * c,
                s = (e.max.y - h.y) * c) : (r = (e.max.y - h.y) * c,
                s = (e.min.y - h.y) * c),
                n > s || r > i ? null : ((r > n || isNaN(n)) && (n = r),
                (s < i || isNaN(i)) && (i = s),
                u >= 0 ? (a = (e.min.z - h.z) * u,
                o = (e.max.z - h.z) * u) : (a = (e.max.z - h.z) * u,
                o = (e.min.z - h.z) * u),
                n > o || a > i ? null : ((a > n || n != n) && (n = a),
                (o < i || i != i) && (i = o),
                i < 0 ? null : this.at(n >= 0 ? n : i, t)))
            }
            intersectsBox(e) {
                return null !== this.intersectBox(e, Tn)
            }
            intersectTriangle(e, t, n, i, r) {
                Pn.subVectors(t, e),
                Ln.subVectors(n, e),
                Un.crossVectors(Pn, Ln);
                let s, a = this.direction.dot(Un);
                if (a > 0) {
                    if (i)
                        return null;
                    s = 1
                } else {
                    if (!(a < 0))
                        return null;
                    s = -1,
                    a = -a
                }
                Dn.subVectors(this.origin, e);
                const o = s * this.direction.dot(Ln.crossVectors(Dn, Ln));
                if (o < 0)
                    return null;
                const l = s * this.direction.dot(Pn.cross(Dn));
                if (l < 0)
                    return null;
                if (o + l > a)
                    return null;
                const c = -s * Dn.dot(Un);
                return c < 0 ? null : this.at(c / a, r)
            }
            applyMatrix4(e) {
                return this.origin.applyMatrix4(e),
                this.direction.transformDirection(e),
                this
            }
            equals(e) {
                return e.origin.equals(this.origin) && e.direction.equals(this.direction)
            }
            clone() {
                return (new this.constructor).copy(this)
            }
        }
        class Nn {
            constructor(e, t, n, i, r, s, a, o, l, c, u, h, d, p, f, A) {
                Nn.prototype.isMatrix4 = !0,
                this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
                void 0 !== e && this.set(e, t, n, i, r, s, a, o, l, c, u, h, d, p, f, A)
            }
            set(e, t, n, i, r, s, a, o, l, c, u, h, d, p, f, A) {
                const g = this.elements;
                return g[0] = e,
                g[4] = t,
                g[8] = n,
                g[12] = i,
                g[1] = r,
                g[5] = s,
                g[9] = a,
                g[13] = o,
                g[2] = l,
                g[6] = c,
                g[10] = u,
                g[14] = h,
                g[3] = d,
                g[7] = p,
                g[11] = f,
                g[15] = A,
                this
            }
            identity() {
                return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
                this
            }
            clone() {
                return (new Nn).fromArray(this.elements)
            }
            copy(e) {
                const t = this.elements
                  , n = e.elements;
                return t[0] = n[0],
                t[1] = n[1],
                t[2] = n[2],
                t[3] = n[3],
                t[4] = n[4],
                t[5] = n[5],
                t[6] = n[6],
                t[7] = n[7],
                t[8] = n[8],
                t[9] = n[9],
                t[10] = n[10],
                t[11] = n[11],
                t[12] = n[12],
                t[13] = n[13],
                t[14] = n[14],
                t[15] = n[15],
                this
            }
            copyPosition(e) {
                const t = this.elements
                  , n = e.elements;
                return t[12] = n[12],
                t[13] = n[13],
                t[14] = n[14],
                this
            }
            setFromMatrix3(e) {
                const t = e.elements;
                return this.set(t[0], t[3], t[6], 0, t[1], t[4], t[7], 0, t[2], t[5], t[8], 0, 0, 0, 0, 1),
                this
            }
            extractBasis(e, t, n) {
                return e.setFromMatrixColumn(this, 0),
                t.setFromMatrixColumn(this, 1),
                n.setFromMatrixColumn(this, 2),
                this
            }
            makeBasis(e, t, n) {
                return this.set(e.x, t.x, n.x, 0, e.y, t.y, n.y, 0, e.z, t.z, n.z, 0, 0, 0, 0, 1),
                this
            }
            extractRotation(e) {
                const t = this.elements
                  , n = e.elements
                  , i = 1 / On.setFromMatrixColumn(e, 0).length()
                  , r = 1 / On.setFromMatrixColumn(e, 1).length()
                  , s = 1 / On.setFromMatrixColumn(e, 2).length();
                return t[0] = n[0] * i,
                t[1] = n[1] * i,
                t[2] = n[2] * i,
                t[3] = 0,
                t[4] = n[4] * r,
                t[5] = n[5] * r,
                t[6] = n[6] * r,
                t[7] = 0,
                t[8] = n[8] * s,
                t[9] = n[9] * s,
                t[10] = n[10] * s,
                t[11] = 0,
                t[12] = 0,
                t[13] = 0,
                t[14] = 0,
                t[15] = 1,
                this
            }
            makeRotationFromEuler(e) {
                const t = this.elements
                  , n = e.x
                  , i = e.y
                  , r = e.z
                  , s = Math.cos(n)
                  , a = Math.sin(n)
                  , o = Math.cos(i)
                  , l = Math.sin(i)
                  , c = Math.cos(r)
                  , u = Math.sin(r);
                if ("XYZ" === e.order) {
                    const e = s * c
                      , n = s * u
                      , i = a * c
                      , r = a * u;
                    t[0] = o * c,
                    t[4] = -o * u,
                    t[8] = l,
                    t[1] = n + i * l,
                    t[5] = e - r * l,
                    t[9] = -a * o,
                    t[2] = r - e * l,
                    t[6] = i + n * l,
                    t[10] = s * o
                } else if ("YXZ" === e.order) {
                    const e = o * c
                      , n = o * u
                      , i = l * c
                      , r = l * u;
                    t[0] = e + r * a,
                    t[4] = i * a - n,
                    t[8] = s * l,
                    t[1] = s * u,
                    t[5] = s * c,
                    t[9] = -a,
                    t[2] = n * a - i,
                    t[6] = r + e * a,
                    t[10] = s * o
                } else if ("ZXY" === e.order) {
                    const e = o * c
                      , n = o * u
                      , i = l * c
                      , r = l * u;
                    t[0] = e - r * a,
                    t[4] = -s * u,
                    t[8] = i + n * a,
                    t[1] = n + i * a,
                    t[5] = s * c,
                    t[9] = r - e * a,
                    t[2] = -s * l,
                    t[6] = a,
                    t[10] = s * o
                } else if ("ZYX" === e.order) {
                    const e = s * c
                      , n = s * u
                      , i = a * c
                      , r = a * u;
                    t[0] = o * c,
                    t[4] = i * l - n,
                    t[8] = e * l + r,
                    t[1] = o * u,
                    t[5] = r * l + e,
                    t[9] = n * l - i,
                    t[2] = -l,
                    t[6] = a * o,
                    t[10] = s * o
                } else if ("YZX" === e.order) {
                    const e = s * o
                      , n = s * l
                      , i = a * o
                      , r = a * l;
                    t[0] = o * c,
                    t[4] = r - e * u,
                    t[8] = i * u + n,
                    t[1] = u,
                    t[5] = s * c,
                    t[9] = -a * c,
                    t[2] = -l * c,
                    t[6] = n * u + i,
                    t[10] = e - r * u
                } else if ("XZY" === e.order) {
                    const e = s * o
                      , n = s * l
                      , i = a * o
                      , r = a * l;
                    t[0] = o * c,
                    t[4] = -u,
                    t[8] = l * c,
                    t[1] = e * u + r,
                    t[5] = s * c,
                    t[9] = n * u - i,
                    t[2] = i * u - n,
                    t[6] = a * c,
                    t[10] = r * u + e
                }
                return t[3] = 0,
                t[7] = 0,
                t[11] = 0,
                t[12] = 0,
                t[13] = 0,
                t[14] = 0,
                t[15] = 1,
                this
            }
            makeRotationFromQuaternion(e) {
                return this.compose(kn, e, Gn)
            }
            lookAt(e, t, n) {
                const i = this.elements;
                return Vn.subVectors(e, t),
                0 === Vn.lengthSq() && (Vn.z = 1),
                Vn.normalize(),
                Hn.crossVectors(n, Vn),
                0 === Hn.lengthSq() && (1 === Math.abs(n.z) ? Vn.x += 1e-4 : Vn.z += 1e-4,
                Vn.normalize(),
                Hn.crossVectors(n, Vn)),
                Hn.normalize(),
                zn.crossVectors(Vn, Hn),
                i[0] = Hn.x,
                i[4] = zn.x,
                i[8] = Vn.x,
                i[1] = Hn.y,
                i[5] = zn.y,
                i[9] = Vn.y,
                i[2] = Hn.z,
                i[6] = zn.z,
                i[10] = Vn.z,
                this
            }
            multiply(e) {
                return this.multiplyMatrices(this, e)
            }
            premultiply(e) {
                return this.multiplyMatrices(e, this)
            }
            multiplyMatrices(e, t) {
                const n = e.elements
                  , i = t.elements
                  , r = this.elements
                  , s = n[0]
                  , a = n[4]
                  , o = n[8]
                  , l = n[12]
                  , c = n[1]
                  , u = n[5]
                  , h = n[9]
                  , d = n[13]
                  , p = n[2]
                  , f = n[6]
                  , A = n[10]
                  , g = n[14]
                  , m = n[3]
                  , v = n[7]
                  , y = n[11]
                  , x = n[15]
                  , _ = i[0]
                  , b = i[4]
                  , E = i[8]
                  , w = i[12]
                  , C = i[1]
                  , I = i[5]
                  , S = i[9]
                  , M = i[13]
                  , T = i[2]
                  , B = i[6]
                  , R = i[10]
                  , D = i[14]
                  , P = i[3]
                  , L = i[7]
                  , U = i[11]
                  , F = i[15];
                return r[0] = s * _ + a * C + o * T + l * P,
                r[4] = s * b + a * I + o * B + l * L,
                r[8] = s * E + a * S + o * R + l * U,
                r[12] = s * w + a * M + o * D + l * F,
                r[1] = c * _ + u * C + h * T + d * P,
                r[5] = c * b + u * I + h * B + d * L,
                r[9] = c * E + u * S + h * R + d * U,
                r[13] = c * w + u * M + h * D + d * F,
                r[2] = p * _ + f * C + A * T + g * P,
                r[6] = p * b + f * I + A * B + g * L,
                r[10] = p * E + f * S + A * R + g * U,
                r[14] = p * w + f * M + A * D + g * F,
                r[3] = m * _ + v * C + y * T + x * P,
                r[7] = m * b + v * I + y * B + x * L,
                r[11] = m * E + v * S + y * R + x * U,
                r[15] = m * w + v * M + y * D + x * F,
                this
            }
            multiplyScalar(e) {
                const t = this.elements;
                return t[0] *= e,
                t[4] *= e,
                t[8] *= e,
                t[12] *= e,
                t[1] *= e,
                t[5] *= e,
                t[9] *= e,
                t[13] *= e,
                t[2] *= e,
                t[6] *= e,
                t[10] *= e,
                t[14] *= e,
                t[3] *= e,
                t[7] *= e,
                t[11] *= e,
                t[15] *= e,
                this
            }
            determinant() {
                const e = this.elements
                  , t = e[0]
                  , n = e[4]
                  , i = e[8]
                  , r = e[12]
                  , s = e[1]
                  , a = e[5]
                  , o = e[9]
                  , l = e[13]
                  , c = e[2]
                  , u = e[6]
                  , h = e[10]
                  , d = e[14];
                return e[3] * (+r * o * u - i * l * u - r * a * h + n * l * h + i * a * d - n * o * d) + e[7] * (+t * o * d - t * l * h + r * s * h - i * s * d + i * l * c - r * o * c) + e[11] * (+t * l * u - t * a * d - r * s * u + n * s * d + r * a * c - n * l * c) + e[15] * (-i * a * c - t * o * u + t * a * h + i * s * u - n * s * h + n * o * c)
            }
            transpose() {
                const e = this.elements;
                let t;
                return t = e[1],
                e[1] = e[4],
                e[4] = t,
                t = e[2],
                e[2] = e[8],
                e[8] = t,
                t = e[6],
                e[6] = e[9],
                e[9] = t,
                t = e[3],
                e[3] = e[12],
                e[12] = t,
                t = e[7],
                e[7] = e[13],
                e[13] = t,
                t = e[11],
                e[11] = e[14],
                e[14] = t,
                this
            }
            setPosition(e, t, n) {
                const i = this.elements;
                return e.isVector3 ? (i[12] = e.x,
                i[13] = e.y,
                i[14] = e.z) : (i[12] = e,
                i[13] = t,
                i[14] = n),
                this
            }
            invert() {
                const e = this.elements
                  , t = e[0]
                  , n = e[1]
                  , i = e[2]
                  , r = e[3]
                  , s = e[4]
                  , a = e[5]
                  , o = e[6]
                  , l = e[7]
                  , c = e[8]
                  , u = e[9]
                  , h = e[10]
                  , d = e[11]
                  , p = e[12]
                  , f = e[13]
                  , A = e[14]
                  , g = e[15]
                  , m = u * A * l - f * h * l + f * o * d - a * A * d - u * o * g + a * h * g
                  , v = p * h * l - c * A * l - p * o * d + s * A * d + c * o * g - s * h * g
                  , y = c * f * l - p * u * l + p * a * d - s * f * d - c * a * g + s * u * g
                  , x = p * u * o - c * f * o - p * a * h + s * f * h + c * a * A - s * u * A
                  , _ = t * m + n * v + i * y + r * x;
                if (0 === _)
                    return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
                const b = 1 / _;
                return e[0] = m * b,
                e[1] = (f * h * r - u * A * r - f * i * d + n * A * d + u * i * g - n * h * g) * b,
                e[2] = (a * A * r - f * o * r + f * i * l - n * A * l - a * i * g + n * o * g) * b,
                e[3] = (u * o * r - a * h * r - u * i * l + n * h * l + a * i * d - n * o * d) * b,
                e[4] = v * b,
                e[5] = (c * A * r - p * h * r + p * i * d - t * A * d - c * i * g + t * h * g) * b,
                e[6] = (p * o * r - s * A * r - p * i * l + t * A * l + s * i * g - t * o * g) * b,
                e[7] = (s * h * r - c * o * r + c * i * l - t * h * l - s * i * d + t * o * d) * b,
                e[8] = y * b,
                e[9] = (p * u * r - c * f * r - p * n * d + t * f * d + c * n * g - t * u * g) * b,
                e[10] = (s * f * r - p * a * r + p * n * l - t * f * l - s * n * g + t * a * g) * b,
                e[11] = (c * a * r - s * u * r - c * n * l + t * u * l + s * n * d - t * a * d) * b,
                e[12] = x * b,
                e[13] = (c * f * i - p * u * i + p * n * h - t * f * h - c * n * A + t * u * A) * b,
                e[14] = (p * a * i - s * f * i - p * n * o + t * f * o + s * n * A - t * a * A) * b,
                e[15] = (s * u * i - c * a * i + c * n * o - t * u * o - s * n * h + t * a * h) * b,
                this
            }
            scale(e) {
                const t = this.elements
                  , n = e.x
                  , i = e.y
                  , r = e.z;
                return t[0] *= n,
                t[4] *= i,
                t[8] *= r,
                t[1] *= n,
                t[5] *= i,
                t[9] *= r,
                t[2] *= n,
                t[6] *= i,
                t[10] *= r,
                t[3] *= n,
                t[7] *= i,
                t[11] *= r,
                this
            }
            getMaxScaleOnAxis() {
                const e = this.elements
                  , t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2]
                  , n = e[4] * e[4] + e[5] * e[5] + e[6] * e[6]
                  , i = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
                return Math.sqrt(Math.max(t, n, i))
            }
            makeTranslation(e, t, n) {
                return e.isVector3 ? this.set(1, 0, 0, e.x, 0, 1, 0, e.y, 0, 0, 1, e.z, 0, 0, 0, 1) : this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, n, 0, 0, 0, 1),
                this
            }
            makeRotationX(e) {
                const t = Math.cos(e)
                  , n = Math.sin(e);
                return this.set(1, 0, 0, 0, 0, t, -n, 0, 0, n, t, 0, 0, 0, 0, 1),
                this
            }
            makeRotationY(e) {
                const t = Math.cos(e)
                  , n = Math.sin(e);
                return this.set(t, 0, n, 0, 0, 1, 0, 0, -n, 0, t, 0, 0, 0, 0, 1),
                this
            }
            makeRotationZ(e) {
                const t = Math.cos(e)
                  , n = Math.sin(e);
                return this.set(t, -n, 0, 0, n, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
                this
            }
            makeRotationAxis(e, t) {
                const n = Math.cos(t)
                  , i = Math.sin(t)
                  , r = 1 - n
                  , s = e.x
                  , a = e.y
                  , o = e.z
                  , l = r * s
                  , c = r * a;
                return this.set(l * s + n, l * a - i * o, l * o + i * a, 0, l * a + i * o, c * a + n, c * o - i * s, 0, l * o - i * a, c * o + i * s, r * o * o + n, 0, 0, 0, 0, 1),
                this
            }
            makeScale(e, t, n) {
                return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, n, 0, 0, 0, 0, 1),
                this
            }
            makeShear(e, t, n, i, r, s) {
                return this.set(1, n, r, 0, e, 1, s, 0, t, i, 1, 0, 0, 0, 0, 1),
                this
            }
            compose(e, t, n) {
                const i = this.elements
                  , r = t._x
                  , s = t._y
                  , a = t._z
                  , o = t._w
                  , l = r + r
                  , c = s + s
                  , u = a + a
                  , h = r * l
                  , d = r * c
                  , p = r * u
                  , f = s * c
                  , A = s * u
                  , g = a * u
                  , m = o * l
                  , v = o * c
                  , y = o * u
                  , x = n.x
                  , _ = n.y
                  , b = n.z;
                return i[0] = (1 - (f + g)) * x,
                i[1] = (d + y) * x,
                i[2] = (p - v) * x,
                i[3] = 0,
                i[4] = (d - y) * _,
                i[5] = (1 - (h + g)) * _,
                i[6] = (A + m) * _,
                i[7] = 0,
                i[8] = (p + v) * b,
                i[9] = (A - m) * b,
                i[10] = (1 - (h + f)) * b,
                i[11] = 0,
                i[12] = e.x,
                i[13] = e.y,
                i[14] = e.z,
                i[15] = 1,
                this
            }
            decompose(e, t, n) {
                const i = this.elements;
                let r = On.set(i[0], i[1], i[2]).length();
                const s = On.set(i[4], i[5], i[6]).length()
                  , a = On.set(i[8], i[9], i[10]).length();
                this.determinant() < 0 && (r = -r),
                e.x = i[12],
                e.y = i[13],
                e.z = i[14],
                Qn.copy(this);
                const o = 1 / r
                  , l = 1 / s
                  , c = 1 / a;
                return Qn.elements[0] *= o,
                Qn.elements[1] *= o,
                Qn.elements[2] *= o,
                Qn.elements[4] *= l,
                Qn.elements[5] *= l,
                Qn.elements[6] *= l,
                Qn.elements[8] *= c,
                Qn.elements[9] *= c,
                Qn.elements[10] *= c,
                t.setFromRotationMatrix(Qn),
                n.x = r,
                n.y = s,
                n.z = a,
                this
            }
            makePerspective(e, t, n, i, r, s, a=2e3) {
                const o = this.elements
                  , l = 2 * r / (t - e)
                  , c = 2 * r / (n - i)
                  , u = (t + e) / (t - e)
                  , h = (n + i) / (n - i);
                let d, p;
                if (a === mt)
                    d = -(s + r) / (s - r),
                    p = -2 * s * r / (s - r);
                else {
                    if (a !== vt)
                        throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + a);
                    d = -s / (s - r),
                    p = -s * r / (s - r)
                }
                return o[0] = l,
                o[4] = 0,
                o[8] = u,
                o[12] = 0,
                o[1] = 0,
                o[5] = c,
                o[9] = h,
                o[13] = 0,
                o[2] = 0,
                o[6] = 0,
                o[10] = d,
                o[14] = p,
                o[3] = 0,
                o[7] = 0,
                o[11] = -1,
                o[15] = 0,
                this
            }
            makeOrthographic(e, t, n, i, r, s, a=2e3) {
                const o = this.elements
                  , l = 1 / (t - e)
                  , c = 1 / (n - i)
                  , u = 1 / (s - r)
                  , h = (t + e) * l
                  , d = (n + i) * c;
                let p, f;
                if (a === mt)
                    p = (s + r) * u,
                    f = -2 * u;
                else {
                    if (a !== vt)
                        throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + a);
                    p = r * u,
                    f = -1 * u
                }
                return o[0] = 2 * l,
                o[4] = 0,
                o[8] = 0,
                o[12] = -h,
                o[1] = 0,
                o[5] = 2 * c,
                o[9] = 0,
                o[13] = -d,
                o[2] = 0,
                o[6] = 0,
                o[10] = f,
                o[14] = -p,
                o[3] = 0,
                o[7] = 0,
                o[11] = 0,
                o[15] = 1,
                this
            }
            equals(e) {
                const t = this.elements
                  , n = e.elements;
                for (let e = 0; e < 16; e++)
                    if (t[e] !== n[e])
                        return !1;
                return !0
            }
            fromArray(e, t=0) {
                for (let n = 0; n < 16; n++)
                    this.elements[n] = e[n + t];
                return this
            }
            toArray(e=[], t=0) {
                const n = this.elements;
                return e[t] = n[0],
                e[t + 1] = n[1],
                e[t + 2] = n[2],
                e[t + 3] = n[3],
                e[t + 4] = n[4],
                e[t + 5] = n[5],
                e[t + 6] = n[6],
                e[t + 7] = n[7],
                e[t + 8] = n[8],
                e[t + 9] = n[9],
                e[t + 10] = n[10],
                e[t + 11] = n[11],
                e[t + 12] = n[12],
                e[t + 13] = n[13],
                e[t + 14] = n[14],
                e[t + 15] = n[15],
                e
            }
        }
        const On = new on
          , Qn = new Nn
          , kn = new on(0,0,0)
          , Gn = new on(1,1,1)
          , Hn = new on
          , zn = new on
          , Vn = new on
          , Wn = new Nn
          , jn = new an;
        class qn {
            constructor(e=0, t=0, n=0, i=qn.DEFAULT_ORDER) {
                this.isEuler = !0,
                this._x = e,
                this._y = t,
                this._z = n,
                this._order = i
            }
            get x() {
                return this._x
            }
            set x(e) {
                this._x = e,
                this._onChangeCallback()
            }
            get y() {
                return this._y
            }
            set y(e) {
                this._y = e,
                this._onChangeCallback()
            }
            get z() {
                return this._z
            }
            set z(e) {
                this._z = e,
                this._onChangeCallback()
            }
            get order() {
                return this._order
            }
            set order(e) {
                this._order = e,
                this._onChangeCallback()
            }
            set(e, t, n, i=this._order) {
                return this._x = e,
                this._y = t,
                this._z = n,
                this._order = i,
                this._onChangeCallback(),
                this
            }
            clone() {
                return new this.constructor(this._x,this._y,this._z,this._order)
            }
            copy(e) {
                return this._x = e._x,
                this._y = e._y,
                this._z = e._z,
                this._order = e._order,
                this._onChangeCallback(),
                this
            }
            setFromRotationMatrix(e, t=this._order, n=!0) {
                const i = e.elements
                  , r = i[0]
                  , s = i[4]
                  , a = i[8]
                  , o = i[1]
                  , l = i[5]
                  , c = i[9]
                  , u = i[2]
                  , h = i[6]
                  , d = i[10];
                switch (t) {
                case "XYZ":
                    this._y = Math.asin(Ct(a, -1, 1)),
                    Math.abs(a) < .9999999 ? (this._x = Math.atan2(-c, d),
                    this._z = Math.atan2(-s, r)) : (this._x = Math.atan2(h, l),
                    this._z = 0);
                    break;
                case "YXZ":
                    this._x = Math.asin(-Ct(c, -1, 1)),
                    Math.abs(c) < .9999999 ? (this._y = Math.atan2(a, d),
                    this._z = Math.atan2(o, l)) : (this._y = Math.atan2(-u, r),
                    this._z = 0);
                    break;
                case "ZXY":
                    this._x = Math.asin(Ct(h, -1, 1)),
                    Math.abs(h) < .9999999 ? (this._y = Math.atan2(-u, d),
                    this._z = Math.atan2(-s, l)) : (this._y = 0,
                    this._z = Math.atan2(o, r));
                    break;
                case "ZYX":
                    this._y = Math.asin(-Ct(u, -1, 1)),
                    Math.abs(u) < .9999999 ? (this._x = Math.atan2(h, d),
                    this._z = Math.atan2(o, r)) : (this._x = 0,
                    this._z = Math.atan2(-s, l));
                    break;
                case "YZX":
                    this._z = Math.asin(Ct(o, -1, 1)),
                    Math.abs(o) < .9999999 ? (this._x = Math.atan2(-c, l),
                    this._y = Math.atan2(-u, r)) : (this._x = 0,
                    this._y = Math.atan2(a, d));
                    break;
                case "XZY":
                    this._z = Math.asin(-Ct(s, -1, 1)),
                    Math.abs(s) < .9999999 ? (this._x = Math.atan2(h, l),
                    this._y = Math.atan2(a, r)) : (this._x = Math.atan2(-c, d),
                    this._y = 0);
                    break;
                default:
                    console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + t)
                }
                return this._order = t,
                !0 === n && this._onChangeCallback(),
                this
            }
            setFromQuaternion(e, t, n) {
                return Wn.makeRotationFromQuaternion(e),
                this.setFromRotationMatrix(Wn, t, n)
            }
            setFromVector3(e, t=this._order) {
                return this.set(e.x, e.y, e.z, t)
            }
            reorder(e) {
                return jn.setFromEuler(this),
                this.setFromQuaternion(jn, e)
            }
            equals(e) {
                return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order
            }
            fromArray(e) {
                return this._x = e[0],
                this._y = e[1],
                this._z = e[2],
                void 0 !== e[3] && (this._order = e[3]),
                this._onChangeCallback(),
                this
            }
            toArray(e=[], t=0) {
                return e[t] = this._x,
                e[t + 1] = this._y,
                e[t + 2] = this._z,
                e[t + 3] = this._order,
                e
            }
            _onChange(e) {
                return this._onChangeCallback = e,
                this
            }
            _onChangeCallback() {}
            *[Symbol.iterator]() {
                yield this._x,
                yield this._y,
                yield this._z,
                yield this._order
            }
        }
        qn.DEFAULT_ORDER = "XYZ";
        class Yn {
            constructor() {
                this.mask = 1
            }
            set(e) {
                this.mask = 1 << e >>> 0
            }
            enable(e) {
                this.mask |= 1 << e
            }
            enableAll() {
                this.mask = -1
            }
            toggle(e) {
                this.mask ^= 1 << e
            }
            disable(e) {
                this.mask &= ~(1 << e)
            }
            disableAll() {
                this.mask = 0
            }
            test(e) {
                return !!(this.mask & e.mask)
            }
            isEnabled(e) {
                return !!(this.mask & 1 << e)
            }
        }
        let Xn = 0;
        const Kn = new on
          , Jn = new an
          , Zn = new Nn
          , $n = new on
          , ei = new on
          , ti = new on
          , ni = new an
          , ii = new on(1,0,0)
          , ri = new on(0,1,0)
          , si = new on(0,0,1)
          , ai = {
            type: "added"
        }
          , oi = {
            type: "removed"
        }
          , li = {
            type: "childadded",
            child: null
        }
          , ci = {
            type: "childremoved",
            child: null
        };
        class ui extends yt {
            constructor() {
                super(),
                this.isObject3D = !0,
                Object.defineProperty(this, "id", {
                    value: Xn++
                }),
                this.uuid = wt(),
                this.name = "",
                this.type = "Object3D",
                this.parent = null,
                this.children = [],
                this.up = ui.DEFAULT_UP.clone();
                const e = new on
                  , t = new qn
                  , n = new an
                  , i = new on(1,1,1);
                t._onChange((function() {
                    n.setFromEuler(t, !1)
                }
                )),
                n._onChange((function() {
                    t.setFromQuaternion(n, void 0, !1)
                }
                )),
                Object.defineProperties(this, {
                    position: {
                        configurable: !0,
                        enumerable: !0,
                        value: e
                    },
                    rotation: {
                        configurable: !0,
                        enumerable: !0,
                        value: t
                    },
                    quaternion: {
                        configurable: !0,
                        enumerable: !0,
                        value: n
                    },
                    scale: {
                        configurable: !0,
                        enumerable: !0,
                        value: i
                    },
                    modelViewMatrix: {
                        value: new Nn
                    },
                    normalMatrix: {
                        value: new Dt
                    }
                }),
                this.matrix = new Nn,
                this.matrixWorld = new Nn,
                this.matrixAutoUpdate = ui.DEFAULT_MATRIX_AUTO_UPDATE,
                this.matrixWorldAutoUpdate = ui.DEFAULT_MATRIX_WORLD_AUTO_UPDATE,
                this.matrixWorldNeedsUpdate = !1,
                this.layers = new Yn,
                this.visible = !0,
                this.castShadow = !1,
                this.receiveShadow = !1,
                this.frustumCulled = !0,
                this.renderOrder = 0,
                this.animations = [],
                this.userData = {}
            }
            onBeforeShadow() {}
            onAfterShadow() {}
            onBeforeRender() {}
            onAfterRender() {}
            applyMatrix4(e) {
                this.matrixAutoUpdate && this.updateMatrix(),
                this.matrix.premultiply(e),
                this.matrix.decompose(this.position, this.quaternion, this.scale)
            }
            applyQuaternion(e) {
                return this.quaternion.premultiply(e),
                this
            }
            setRotationFromAxisAngle(e, t) {
                this.quaternion.setFromAxisAngle(e, t)
            }
            setRotationFromEuler(e) {
                this.quaternion.setFromEuler(e, !0)
            }
            setRotationFromMatrix(e) {
                this.quaternion.setFromRotationMatrix(e)
            }
            setRotationFromQuaternion(e) {
                this.quaternion.copy(e)
            }
            rotateOnAxis(e, t) {
                return Jn.setFromAxisAngle(e, t),
                this.quaternion.multiply(Jn),
                this
            }
            rotateOnWorldAxis(e, t) {
                return Jn.setFromAxisAngle(e, t),
                this.quaternion.premultiply(Jn),
                this
            }
            rotateX(e) {
                return this.rotateOnAxis(ii, e)
            }
            rotateY(e) {
                return this.rotateOnAxis(ri, e)
            }
            rotateZ(e) {
                return this.rotateOnAxis(si, e)
            }
            translateOnAxis(e, t) {
                return Kn.copy(e).applyQuaternion(this.quaternion),
                this.position.add(Kn.multiplyScalar(t)),
                this
            }
            translateX(e) {
                return this.translateOnAxis(ii, e)
            }
            translateY(e) {
                return this.translateOnAxis(ri, e)
            }
            translateZ(e) {
                return this.translateOnAxis(si, e)
            }
            localToWorld(e) {
                return this.updateWorldMatrix(!0, !1),
                e.applyMatrix4(this.matrixWorld)
            }
            worldToLocal(e) {
                return this.updateWorldMatrix(!0, !1),
                e.applyMatrix4(Zn.copy(this.matrixWorld).invert())
            }
            lookAt(e, t, n) {
                e.isVector3 ? $n.copy(e) : $n.set(e, t, n);
                const i = this.parent;
                this.updateWorldMatrix(!0, !1),
                ei.setFromMatrixPosition(this.matrixWorld),
                this.isCamera || this.isLight ? Zn.lookAt(ei, $n, this.up) : Zn.lookAt($n, ei, this.up),
                this.quaternion.setFromRotationMatrix(Zn),
                i && (Zn.extractRotation(i.matrixWorld),
                Jn.setFromRotationMatrix(Zn),
                this.quaternion.premultiply(Jn.invert()))
            }
            add(e) {
                if (arguments.length > 1) {
                    for (let e = 0; e < arguments.length; e++)
                        this.add(arguments[e]);
                    return this
                }
                return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e),
                this) : (e && e.isObject3D ? (e.removeFromParent(),
                e.parent = this,
                this.children.push(e),
                e.dispatchEvent(ai),
                li.child = e,
                this.dispatchEvent(li),
                li.child = null) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e),
                this)
            }
            remove(e) {
                if (arguments.length > 1) {
                    for (let e = 0; e < arguments.length; e++)
                        this.remove(arguments[e]);
                    return this
                }
                const t = this.children.indexOf(e);
                return -1 !== t && (e.parent = null,
                this.children.splice(t, 1),
                e.dispatchEvent(oi),
                ci.child = e,
                this.dispatchEvent(ci),
                ci.child = null),
                this
            }
            removeFromParent() {
                const e = this.parent;
                return null !== e && e.remove(this),
                this
            }
            clear() {
                return this.remove(...this.children)
            }
            attach(e) {
                return this.updateWorldMatrix(!0, !1),
                Zn.copy(this.matrixWorld).invert(),
                null !== e.parent && (e.parent.updateWorldMatrix(!0, !1),
                Zn.multiply(e.parent.matrixWorld)),
                e.applyMatrix4(Zn),
                e.removeFromParent(),
                e.parent = this,
                this.children.push(e),
                e.updateWorldMatrix(!1, !0),
                e.dispatchEvent(ai),
                li.child = e,
                this.dispatchEvent(li),
                li.child = null,
                this
            }
            getObjectById(e) {
                return this.getObjectByProperty("id", e)
            }
            getObjectByName(e) {
                return this.getObjectByProperty("name", e)
            }
            getObjectByProperty(e, t) {
                if (this[e] === t)
                    return this;
                for (let n = 0, i = this.children.length; n < i; n++) {
                    const i = this.children[n].getObjectByProperty(e, t);
                    if (void 0 !== i)
                        return i
                }
            }
            getObjectsByProperty(e, t, n=[]) {
                this[e] === t && n.push(this);
                const i = this.children;
                for (let r = 0, s = i.length; r < s; r++)
                    i[r].getObjectsByProperty(e, t, n);
                return n
            }
            getWorldPosition(e) {
                return this.updateWorldMatrix(!0, !1),
                e.setFromMatrixPosition(this.matrixWorld)
            }
            getWorldQuaternion(e) {
                return this.updateWorldMatrix(!0, !1),
                this.matrixWorld.decompose(ei, e, ti),
                e
            }
            getWorldScale(e) {
                return this.updateWorldMatrix(!0, !1),
                this.matrixWorld.decompose(ei, ni, e),
                e
            }
            getWorldDirection(e) {
                this.updateWorldMatrix(!0, !1);
                const t = this.matrixWorld.elements;
                return e.set(t[8], t[9], t[10]).normalize()
            }
            raycast() {}
            traverse(e) {
                e(this);
                const t = this.children;
                for (let n = 0, i = t.length; n < i; n++)
                    t[n].traverse(e)
            }
            traverseVisible(e) {
                if (!1 === this.visible)
                    return;
                e(this);
                const t = this.children;
                for (let n = 0, i = t.length; n < i; n++)
                    t[n].traverseVisible(e)
            }
            traverseAncestors(e) {
                const t = this.parent;
                null !== t && (e(t),
                t.traverseAncestors(e))
            }
            updateMatrix() {
                this.matrix.compose(this.position, this.quaternion, this.scale),
                this.matrixWorldNeedsUpdate = !0
            }
            updateMatrixWorld(e) {
                this.matrixAutoUpdate && this.updateMatrix(),
                (this.matrixWorldNeedsUpdate || e) && (!0 === this.matrixWorldAutoUpdate && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)),
                this.matrixWorldNeedsUpdate = !1,
                e = !0);
                const t = this.children;
                for (let n = 0, i = t.length; n < i; n++) {
                    t[n].updateMatrixWorld(e)
                }
            }
            updateWorldMatrix(e, t) {
                const n = this.parent;
                if (!0 === e && null !== n && n.updateWorldMatrix(!0, !1),
                this.matrixAutoUpdate && this.updateMatrix(),
                !0 === this.matrixWorldAutoUpdate && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)),
                !0 === t) {
                    const e = this.children;
                    for (let t = 0, n = e.length; t < n; t++) {
                        e[t].updateWorldMatrix(!1, !0)
                    }
                }
            }
            toJSON(e) {
                const t = void 0 === e || "string" == typeof e
                  , n = {};
                t && (e = {
                    geometries: {},
                    materials: {},
                    textures: {},
                    images: {},
                    shapes: {},
                    skeletons: {},
                    animations: {},
                    nodes: {}
                },
                n.metadata = {
                    version: 4.6,
                    type: "Object",
                    generator: "Object3D.toJSON"
                });
                const i = {};
                function r(t, n) {
                    return void 0 === t[n.uuid] && (t[n.uuid] = n.toJSON(e)),
                    n.uuid
                }
                if (i.uuid = this.uuid,
                i.type = this.type,
                "" !== this.name && (i.name = this.name),
                !0 === this.castShadow && (i.castShadow = !0),
                !0 === this.receiveShadow && (i.receiveShadow = !0),
                !1 === this.visible && (i.visible = !1),
                !1 === this.frustumCulled && (i.frustumCulled = !1),
                0 !== this.renderOrder && (i.renderOrder = this.renderOrder),
                Object.keys(this.userData).length > 0 && (i.userData = this.userData),
                i.layers = this.layers.mask,
                i.matrix = this.matrix.toArray(),
                i.up = this.up.toArray(),
                !1 === this.matrixAutoUpdate && (i.matrixAutoUpdate = !1),
                this.isInstancedMesh && (i.type = "InstancedMesh",
                i.count = this.count,
                i.instanceMatrix = this.instanceMatrix.toJSON(),
                null !== this.instanceColor && (i.instanceColor = this.instanceColor.toJSON())),
                this.isBatchedMesh && (i.type = "BatchedMesh",
                i.perObjectFrustumCulled = this.perObjectFrustumCulled,
                i.sortObjects = this.sortObjects,
                i.drawRanges = this._drawRanges,
                i.reservedRanges = this._reservedRanges,
                i.visibility = this._visibility,
                i.active = this._active,
                i.bounds = this._bounds.map((e => ({
                    boxInitialized: e.boxInitialized,
                    boxMin: e.box.min.toArray(),
                    boxMax: e.box.max.toArray(),
                    sphereInitialized: e.sphereInitialized,
                    sphereRadius: e.sphere.radius,
                    sphereCenter: e.sphere.center.toArray()
                }))),
                i.maxInstanceCount = this._maxInstanceCount,
                i.maxVertexCount = this._maxVertexCount,
                i.maxIndexCount = this._maxIndexCount,
                i.geometryInitialized = this._geometryInitialized,
                i.geometryCount = this._geometryCount,
                i.matricesTexture = this._matricesTexture.toJSON(e),
                null !== this._colorsTexture && (i.colorsTexture = this._colorsTexture.toJSON(e)),
                null !== this.boundingSphere && (i.boundingSphere = {
                    center: i.boundingSphere.center.toArray(),
                    radius: i.boundingSphere.radius
                }),
                null !== this.boundingBox && (i.boundingBox = {
                    min: i.boundingBox.min.toArray(),
                    max: i.boundingBox.max.toArray()
                })),
                this.isScene)
                    this.background && (this.background.isColor ? i.background = this.background.toJSON() : this.background.isTexture && (i.background = this.background.toJSON(e).uuid)),
                    this.environment && this.environment.isTexture && !0 !== this.environment.isRenderTargetTexture && (i.environment = this.environment.toJSON(e).uuid);
                else if (this.isMesh || this.isLine || this.isPoints) {
                    i.geometry = r(e.geometries, this.geometry);
                    const t = this.geometry.parameters;
                    if (void 0 !== t && void 0 !== t.shapes) {
                        const n = t.shapes;
                        if (Array.isArray(n))
                            for (let t = 0, i = n.length; t < i; t++) {
                                const i = n[t];
                                r(e.shapes, i)
                            }
                        else
                            r(e.shapes, n)
                    }
                }
                if (this.isSkinnedMesh && (i.bindMode = this.bindMode,
                i.bindMatrix = this.bindMatrix.toArray(),
                void 0 !== this.skeleton && (r(e.skeletons, this.skeleton),
                i.skeleton = this.skeleton.uuid)),
                void 0 !== this.material)
                    if (Array.isArray(this.material)) {
                        const t = [];
                        for (let n = 0, i = this.material.length; n < i; n++)
                            t.push(r(e.materials, this.material[n]));
                        i.material = t
                    } else
                        i.material = r(e.materials, this.material);
                if (this.children.length > 0) {
                    i.children = [];
                    for (let t = 0; t < this.children.length; t++)
                        i.children.push(this.children[t].toJSON(e).object)
                }
                if (this.animations.length > 0) {
                    i.animations = [];
                    for (let t = 0; t < this.animations.length; t++) {
                        const n = this.animations[t];
                        i.animations.push(r(e.animations, n))
                    }
                }
                if (t) {
                    const t = s(e.geometries)
                      , i = s(e.materials)
                      , r = s(e.textures)
                      , a = s(e.images)
                      , o = s(e.shapes)
                      , l = s(e.skeletons)
                      , c = s(e.animations)
                      , u = s(e.nodes);
                    t.length > 0 && (n.geometries = t),
                    i.length > 0 && (n.materials = i),
                    r.length > 0 && (n.textures = r),
                    a.length > 0 && (n.images = a),
                    o.length > 0 && (n.shapes = o),
                    l.length > 0 && (n.skeletons = l),
                    c.length > 0 && (n.animations = c),
                    u.length > 0 && (n.nodes = u)
                }
                return n.object = i,
                n;
                function s(e) {
                    const t = [];
                    for (const n in e) {
                        const i = e[n];
                        delete i.metadata,
                        t.push(i)
                    }
                    return t
                }
            }
            clone(e) {
                return (new this.constructor).copy(this, e)
            }
            copy(e, t=!0) {
                if (this.name = e.name,
                this.up.copy(e.up),
                this.position.copy(e.position),
                this.rotation.order = e.rotation.order,
                this.quaternion.copy(e.quaternion),
                this.scale.copy(e.scale),
                this.matrix.copy(e.matrix),
                this.matrixWorld.copy(e.matrixWorld),
                this.matrixAutoUpdate = e.matrixAutoUpdate,
                this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate,
                this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate,
                this.layers.mask = e.layers.mask,
                this.visible = e.visible,
                this.castShadow = e.castShadow,
                this.receiveShadow = e.receiveShadow,
                this.frustumCulled = e.frustumCulled,
                this.renderOrder = e.renderOrder,
                this.animations = e.animations.slice(),
                this.userData = JSON.parse(JSON.stringify(e.userData)),
                !0 === t)
                    for (let t = 0; t < e.children.length; t++) {
                        const n = e.children[t];
                        this.add(n.clone())
                    }
                return this
            }
        }
        ui.DEFAULT_UP = new on(0,1,0),
        ui.DEFAULT_MATRIX_AUTO_UPDATE = !0,
        ui.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
        const hi = new on
          , di = new on
          , pi = new on
          , fi = new on
          , Ai = new on
          , gi = new on
          , mi = new on
          , vi = new on
          , yi = new on
          , xi = new on
          , _i = new en
          , bi = new en
          , Ei = new en;
        class wi {
            constructor(e=new on, t=new on, n=new on) {
                this.a = e,
                this.b = t,
                this.c = n
            }
            static getNormal(e, t, n, i) {
                i.subVectors(n, t),
                hi.subVectors(e, t),
                i.cross(hi);
                const r = i.lengthSq();
                return r > 0 ? i.multiplyScalar(1 / Math.sqrt(r)) : i.set(0, 0, 0)
            }
            static getBarycoord(e, t, n, i, r) {
                hi.subVectors(i, t),
                di.subVectors(n, t),
                pi.subVectors(e, t);
                const s = hi.dot(hi)
                  , a = hi.dot(di)
                  , o = hi.dot(pi)
                  , l = di.dot(di)
                  , c = di.dot(pi)
                  , u = s * l - a * a;
                if (0 === u)
                    return r.set(0, 0, 0),
                    null;
                const h = 1 / u
                  , d = (l * o - a * c) * h
                  , p = (s * c - a * o) * h;
                return r.set(1 - d - p, p, d)
            }
            static containsPoint(e, t, n, i) {
                return null !== this.getBarycoord(e, t, n, i, fi) && (fi.x >= 0 && fi.y >= 0 && fi.x + fi.y <= 1)
            }
            static getInterpolation(e, t, n, i, r, s, a, o) {
                return null === this.getBarycoord(e, t, n, i, fi) ? (o.x = 0,
                o.y = 0,
                "z"in o && (o.z = 0),
                "w"in o && (o.w = 0),
                null) : (o.setScalar(0),
                o.addScaledVector(r, fi.x),
                o.addScaledVector(s, fi.y),
                o.addScaledVector(a, fi.z),
                o)
            }
            static getInterpolatedAttribute(e, t, n, i, r, s) {
                return _i.setScalar(0),
                bi.setScalar(0),
                Ei.setScalar(0),
                _i.fromBufferAttribute(e, t),
                bi.fromBufferAttribute(e, n),
                Ei.fromBufferAttribute(e, i),
                s.setScalar(0),
                s.addScaledVector(_i, r.x),
                s.addScaledVector(bi, r.y),
                s.addScaledVector(Ei, r.z),
                s
            }
            static isFrontFacing(e, t, n, i) {
                return hi.subVectors(n, t),
                di.subVectors(e, t),
                hi.cross(di).dot(i) < 0
            }
            set(e, t, n) {
                return this.a.copy(e),
                this.b.copy(t),
                this.c.copy(n),
                this
            }
            setFromPointsAndIndices(e, t, n, i) {
                return this.a.copy(e[t]),
                this.b.copy(e[n]),
                this.c.copy(e[i]),
                this
            }
            setFromAttributeAndIndices(e, t, n, i) {
                return this.a.fromBufferAttribute(e, t),
                this.b.fromBufferAttribute(e, n),
                this.c.fromBufferAttribute(e, i),
                this
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            copy(e) {
                return this.a.copy(e.a),
                this.b.copy(e.b),
                this.c.copy(e.c),
                this
            }
            getArea() {
                return hi.subVectors(this.c, this.b),
                di.subVectors(this.a, this.b),
                .5 * hi.cross(di).length()
            }
            getMidpoint(e) {
                return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
            }
            getNormal(e) {
                return wi.getNormal(this.a, this.b, this.c, e)
            }
            getPlane(e) {
                return e.setFromCoplanarPoints(this.a, this.b, this.c)
            }
            getBarycoord(e, t) {
                return wi.getBarycoord(e, this.a, this.b, this.c, t)
            }
            getInterpolation(e, t, n, i, r) {
                return wi.getInterpolation(e, this.a, this.b, this.c, t, n, i, r)
            }
            containsPoint(e) {
                return wi.containsPoint(e, this.a, this.b, this.c)
            }
            isFrontFacing(e) {
                return wi.isFrontFacing(this.a, this.b, this.c, e)
            }
            intersectsBox(e) {
                return e.intersectsTriangle(this)
            }
            closestPointToPoint(e, t) {
                const n = this.a
                  , i = this.b
                  , r = this.c;
                let s, a;
                Ai.subVectors(i, n),
                gi.subVectors(r, n),
                vi.subVectors(e, n);
                const o = Ai.dot(vi)
                  , l = gi.dot(vi);
                if (o <= 0 && l <= 0)
                    return t.copy(n);
                yi.subVectors(e, i);
                const c = Ai.dot(yi)
                  , u = gi.dot(yi);
                if (c >= 0 && u <= c)
                    return t.copy(i);
                const h = o * u - c * l;
                if (h <= 0 && o >= 0 && c <= 0)
                    return s = o / (o - c),
                    t.copy(n).addScaledVector(Ai, s);
                xi.subVectors(e, r);
                const d = Ai.dot(xi)
                  , p = gi.dot(xi);
                if (p >= 0 && d <= p)
                    return t.copy(r);
                const f = d * l - o * p;
                if (f <= 0 && l >= 0 && p <= 0)
                    return a = l / (l - p),
                    t.copy(n).addScaledVector(gi, a);
                const A = c * p - d * u;
                if (A <= 0 && u - c >= 0 && d - p >= 0)
                    return mi.subVectors(r, i),
                    a = (u - c) / (u - c + (d - p)),
                    t.copy(i).addScaledVector(mi, a);
                const g = 1 / (A + f + h);
                return s = f * g,
                a = h * g,
                t.copy(n).addScaledVector(Ai, s).addScaledVector(gi, a)
            }
            equals(e) {
                return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c)
            }
        }
        const Ci = {
            aliceblue: 15792383,
            antiquewhite: 16444375,
            aqua: 65535,
            aquamarine: 8388564,
            azure: 15794175,
            beige: 16119260,
            bisque: 16770244,
            black: 0,
            blanchedalmond: 16772045,
            blue: 255,
            blueviolet: 9055202,
            brown: 10824234,
            burlywood: 14596231,
            cadetblue: 6266528,
            chartreuse: 8388352,
            chocolate: 13789470,
            coral: 16744272,
            cornflowerblue: 6591981,
            cornsilk: 16775388,
            crimson: 14423100,
            cyan: 65535,
            darkblue: 139,
            darkcyan: 35723,
            darkgoldenrod: 12092939,
            darkgray: 11119017,
            darkgreen: 25600,
            darkgrey: 11119017,
            darkkhaki: 12433259,
            darkmagenta: 9109643,
            darkolivegreen: 5597999,
            darkorange: 16747520,
            darkorchid: 10040012,
            darkred: 9109504,
            darksalmon: 15308410,
            darkseagreen: 9419919,
            darkslateblue: 4734347,
            darkslategray: 3100495,
            darkslategrey: 3100495,
            darkturquoise: 52945,
            darkviolet: 9699539,
            deeppink: 16716947,
            deepskyblue: 49151,
            dimgray: 6908265,
            dimgrey: 6908265,
            dodgerblue: 2003199,
            firebrick: 11674146,
            floralwhite: 16775920,
            forestgreen: 2263842,
            fuchsia: 16711935,
            gainsboro: 14474460,
            ghostwhite: 16316671,
            gold: 16766720,
            goldenrod: 14329120,
            gray: 8421504,
            green: 32768,
            greenyellow: 11403055,
            grey: 8421504,
            honeydew: 15794160,
            hotpink: 16738740,
            indianred: 13458524,
            indigo: 4915330,
            ivory: 16777200,
            khaki: 15787660,
            lavender: 15132410,
            lavenderblush: 16773365,
            lawngreen: 8190976,
            lemonchiffon: 16775885,
            lightblue: 11393254,
            lightcoral: 15761536,
            lightcyan: 14745599,
            lightgoldenrodyellow: 16448210,
            lightgray: 13882323,
            lightgreen: 9498256,
            lightgrey: 13882323,
            lightpink: 16758465,
            lightsalmon: 16752762,
            lightseagreen: 2142890,
            lightskyblue: 8900346,
            lightslategray: 7833753,
            lightslategrey: 7833753,
            lightsteelblue: 11584734,
            lightyellow: 16777184,
            lime: 65280,
            limegreen: 3329330,
            linen: 16445670,
            magenta: 16711935,
            maroon: 8388608,
            mediumaquamarine: 6737322,
            mediumblue: 205,
            mediumorchid: 12211667,
            mediumpurple: 9662683,
            mediumseagreen: 3978097,
            mediumslateblue: 8087790,
            mediumspringgreen: 64154,
            mediumturquoise: 4772300,
            mediumvioletred: 13047173,
            midnightblue: 1644912,
            mintcream: 16121850,
            mistyrose: 16770273,
            moccasin: 16770229,
            navajowhite: 16768685,
            navy: 128,
            oldlace: 16643558,
            olive: 8421376,
            olivedrab: 7048739,
            orange: 16753920,
            orangered: 16729344,
            orchid: 14315734,
            palegoldenrod: 15657130,
            palegreen: 10025880,
            paleturquoise: 11529966,
            palevioletred: 14381203,
            papayawhip: 16773077,
            peachpuff: 16767673,
            peru: 13468991,
            pink: 16761035,
            plum: 14524637,
            powderblue: 11591910,
            purple: 8388736,
            rebeccapurple: 6697881,
            red: 16711680,
            rosybrown: 12357519,
            royalblue: 4286945,
            saddlebrown: 9127187,
            salmon: 16416882,
            sandybrown: 16032864,
            seagreen: 3050327,
            seashell: 16774638,
            sienna: 10506797,
            silver: 12632256,
            skyblue: 8900331,
            slateblue: 6970061,
            slategray: 7372944,
            slategrey: 7372944,
            snow: 16775930,
            springgreen: 65407,
            steelblue: 4620980,
            tan: 13808780,
            teal: 32896,
            thistle: 14204888,
            tomato: 16737095,
            turquoise: 4251856,
            violet: 15631086,
            wheat: 16113331,
            white: 16777215,
            whitesmoke: 16119285,
            yellow: 16776960,
            yellowgreen: 10145074
        }
          , Ii = {
            h: 0,
            s: 0,
            l: 0
        }
          , Si = {
            h: 0,
            s: 0,
            l: 0
        };
        function Mi(e, t, n) {
            return n < 0 && (n += 1),
            n > 1 && (n -= 1),
            n < 1 / 6 ? e + 6 * (t - e) * n : n < .5 ? t : n < 2 / 3 ? e + 6 * (t - e) * (2 / 3 - n) : e
        }
        class Ti {
            constructor(e, t, n) {
                return this.isColor = !0,
                this.r = 1,
                this.g = 1,
                this.b = 1,
                this.set(e, t, n)
            }
            set(e, t, n) {
                if (void 0 === t && void 0 === n) {
                    const t = e;
                    t && t.isColor ? this.copy(t) : "number" == typeof t ? this.setHex(t) : "string" == typeof t && this.setStyle(t)
                } else
                    this.setRGB(e, t, n);
                return this
            }
            setScalar(e) {
                return this.r = e,
                this.g = e,
                this.b = e,
                this
            }
            setHex(e, t=ct) {
                return e = Math.floor(e),
                this.r = (e >> 16 & 255) / 255,
                this.g = (e >> 8 & 255) / 255,
                this.b = (255 & e) / 255,
                Qt.toWorkingColorSpace(this, t),
                this
            }
            setRGB(e, t, n, i=Qt.workingColorSpace) {
                return this.r = e,
                this.g = t,
                this.b = n,
                Qt.toWorkingColorSpace(this, i),
                this
            }
            setHSL(e, t, n, i=Qt.workingColorSpace) {
                if (e = It(e, 1),
                t = Ct(t, 0, 1),
                n = Ct(n, 0, 1),
                0 === t)
                    this.r = this.g = this.b = n;
                else {
                    const i = n <= .5 ? n * (1 + t) : n + t - n * t
                      , r = 2 * n - i;
                    this.r = Mi(r, i, e + 1 / 3),
                    this.g = Mi(r, i, e),
                    this.b = Mi(r, i, e - 1 / 3)
                }
                return Qt.toWorkingColorSpace(this, i),
                this
            }
            setStyle(e, t=ct) {
                function n(t) {
                    void 0 !== t && parseFloat(t) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.")
                }
                let i;
                if (i = /^(\w+)\(([^\)]*)\)/.exec(e)) {
                    let r;
                    const s = i[1]
                      , a = i[2];
                    switch (s) {
                    case "rgb":
                    case "rgba":
                        if (r = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))
                            return n(r[4]),
                            this.setRGB(Math.min(255, parseInt(r[1], 10)) / 255, Math.min(255, parseInt(r[2], 10)) / 255, Math.min(255, parseInt(r[3], 10)) / 255, t);
                        if (r = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))
                            return n(r[4]),
                            this.setRGB(Math.min(100, parseInt(r[1], 10)) / 100, Math.min(100, parseInt(r[2], 10)) / 100, Math.min(100, parseInt(r[3], 10)) / 100, t);
                        break;
                    case "hsl":
                    case "hsla":
                        if (r = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))
                            return n(r[4]),
                            this.setHSL(parseFloat(r[1]) / 360, parseFloat(r[2]) / 100, parseFloat(r[3]) / 100, t);
                        break;
                    default:
                        console.warn("THREE.Color: Unknown color model " + e)
                    }
                } else if (i = /^\#([A-Fa-f\d]+)$/.exec(e)) {
                    const n = i[1]
                      , r = n.length;
                    if (3 === r)
                        return this.setRGB(parseInt(n.charAt(0), 16) / 15, parseInt(n.charAt(1), 16) / 15, parseInt(n.charAt(2), 16) / 15, t);
                    if (6 === r)
                        return this.setHex(parseInt(n, 16), t);
                    console.warn("THREE.Color: Invalid hex color " + e)
                } else if (e && e.length > 0)
                    return this.setColorName(e, t);
                return this
            }
            setColorName(e, t=ct) {
                const n = Ci[e.toLowerCase()];
                return void 0 !== n ? this.setHex(n, t) : console.warn("THREE.Color: Unknown color " + e),
                this
            }
            clone() {
                return new this.constructor(this.r,this.g,this.b)
            }
            copy(e) {
                return this.r = e.r,
                this.g = e.g,
                this.b = e.b,
                this
            }
            copySRGBToLinear(e) {
                return this.r = kt(e.r),
                this.g = kt(e.g),
                this.b = kt(e.b),
                this
            }
            copyLinearToSRGB(e) {
                return this.r = Gt(e.r),
                this.g = Gt(e.g),
                this.b = Gt(e.b),
                this
            }
            convertSRGBToLinear() {
                return this.copySRGBToLinear(this),
                this
            }
            convertLinearToSRGB() {
                return this.copyLinearToSRGB(this),
                this
            }
            getHex(e=ct) {
                return Qt.fromWorkingColorSpace(Bi.copy(this), e),
                65536 * Math.round(Ct(255 * Bi.r, 0, 255)) + 256 * Math.round(Ct(255 * Bi.g, 0, 255)) + Math.round(Ct(255 * Bi.b, 0, 255))
            }
            getHexString(e=ct) {
                return ("000000" + this.getHex(e).toString(16)).slice(-6)
            }
            getHSL(e, t=Qt.workingColorSpace) {
                Qt.fromWorkingColorSpace(Bi.copy(this), t);
                const n = Bi.r
                  , i = Bi.g
                  , r = Bi.b
                  , s = Math.max(n, i, r)
                  , a = Math.min(n, i, r);
                let o, l;
                const c = (a + s) / 2;
                if (a === s)
                    o = 0,
                    l = 0;
                else {
                    const e = s - a;
                    switch (l = c <= .5 ? e / (s + a) : e / (2 - s - a),
                    s) {
                    case n:
                        o = (i - r) / e + (i < r ? 6 : 0);
                        break;
                    case i:
                        o = (r - n) / e + 2;
                        break;
                    case r:
                        o = (n - i) / e + 4
                    }
                    o /= 6
                }
                return e.h = o,
                e.s = l,
                e.l = c,
                e
            }
            getRGB(e, t=Qt.workingColorSpace) {
                return Qt.fromWorkingColorSpace(Bi.copy(this), t),
                e.r = Bi.r,
                e.g = Bi.g,
                e.b = Bi.b,
                e
            }
            getStyle(e=ct) {
                Qt.fromWorkingColorSpace(Bi.copy(this), e);
                const t = Bi.r
                  , n = Bi.g
                  , i = Bi.b;
                return e !== ct ? `color(${e} ${t.toFixed(3)} ${n.toFixed(3)} ${i.toFixed(3)})` : `rgb(${Math.round(255 * t)},${Math.round(255 * n)},${Math.round(255 * i)})`
            }
            offsetHSL(e, t, n) {
                return this.getHSL(Ii),
                this.setHSL(Ii.h + e, Ii.s + t, Ii.l + n)
            }
            add(e) {
                return this.r += e.r,
                this.g += e.g,
                this.b += e.b,
                this
            }
            addColors(e, t) {
                return this.r = e.r + t.r,
                this.g = e.g + t.g,
                this.b = e.b + t.b,
                this
            }
            addScalar(e) {
                return this.r += e,
                this.g += e,
                this.b += e,
                this
            }
            sub(e) {
                return this.r = Math.max(0, this.r - e.r),
                this.g = Math.max(0, this.g - e.g),
                this.b = Math.max(0, this.b - e.b),
                this
            }
            multiply(e) {
                return this.r *= e.r,
                this.g *= e.g,
                this.b *= e.b,
                this
            }
            multiplyScalar(e) {
                return this.r *= e,
                this.g *= e,
                this.b *= e,
                this
            }
            lerp(e, t) {
                return this.r += (e.r - this.r) * t,
                this.g += (e.g - this.g) * t,
                this.b += (e.b - this.b) * t,
                this
            }
            lerpColors(e, t, n) {
                return this.r = e.r + (t.r - e.r) * n,
                this.g = e.g + (t.g - e.g) * n,
                this.b = e.b + (t.b - e.b) * n,
                this
            }
            lerpHSL(e, t) {
                this.getHSL(Ii),
                e.getHSL(Si);
                const n = St(Ii.h, Si.h, t)
                  , i = St(Ii.s, Si.s, t)
                  , r = St(Ii.l, Si.l, t);
                return this.setHSL(n, i, r),
                this
            }
            setFromVector3(e) {
                return this.r = e.x,
                this.g = e.y,
                this.b = e.z,
                this
            }
            applyMatrix3(e) {
                const t = this.r
                  , n = this.g
                  , i = this.b
                  , r = e.elements;
                return this.r = r[0] * t + r[3] * n + r[6] * i,
                this.g = r[1] * t + r[4] * n + r[7] * i,
                this.b = r[2] * t + r[5] * n + r[8] * i,
                this
            }
            equals(e) {
                return e.r === this.r && e.g === this.g && e.b === this.b
            }
            fromArray(e, t=0) {
                return this.r = e[t],
                this.g = e[t + 1],
                this.b = e[t + 2],
                this
            }
            toArray(e=[], t=0) {
                return e[t] = this.r,
                e[t + 1] = this.g,
                e[t + 2] = this.b,
                e
            }
            fromBufferAttribute(e, t) {
                return this.r = e.getX(t),
                this.g = e.getY(t),
                this.b = e.getZ(t),
                this
            }
            toJSON() {
                return this.getHex()
            }
            *[Symbol.iterator]() {
                yield this.r,
                yield this.g,
                yield this.b
            }
        }
        const Bi = new Ti;
        Ti.NAMES = Ci;
        let Ri = 0;
        class Di extends yt {
            static get type() {
                return "Material"
            }
            get type() {
                return this.constructor.type
            }
            set type(e) {}
            constructor() {
                super(),
                this.isMaterial = !0,
                Object.defineProperty(this, "id", {
                    value: Ri++
                }),
                this.uuid = wt(),
                this.name = "",
                this.blending = 1,
                this.side = o,
                this.vertexColors = !1,
                this.opacity = 1,
                this.transparent = !1,
                this.alphaHash = !1,
                this.blendSrc = 204,
                this.blendDst = 205,
                this.blendEquation = h,
                this.blendSrcAlpha = null,
                this.blendDstAlpha = null,
                this.blendEquationAlpha = null,
                this.blendColor = new Ti(0,0,0),
                this.blendAlpha = 0,
                this.depthFunc = A,
                this.depthTest = !0,
                this.depthWrite = !0,
                this.stencilWriteMask = 255,
                this.stencilFunc = 519,
                this.stencilRef = 0,
                this.stencilFuncMask = 255,
                this.stencilFail = pt,
                this.stencilZFail = pt,
                this.stencilZPass = pt,
                this.stencilWrite = !1,
                this.clippingPlanes = null,
                this.clipIntersection = !1,
                this.clipShadows = !1,
                this.shadowSide = null,
                this.colorWrite = !0,
                this.precision = null,
                this.polygonOffset = !1,
                this.polygonOffsetFactor = 0,
                this.polygonOffsetUnits = 0,
                this.dithering = !1,
                this.alphaToCoverage = !1,
                this.premultipliedAlpha = !1,
                this.forceSinglePass = !1,
                this.visible = !0,
                this.toneMapped = !0,
                this.userData = {},
                this.version = 0,
                this._alphaTest = 0
            }
            get alphaTest() {
                return this._alphaTest
            }
            set alphaTest(e) {
                this._alphaTest > 0 != e > 0 && this.version++,
                this._alphaTest = e
            }
            onBeforeRender() {}
            onBeforeCompile() {}
            customProgramCacheKey() {
                return this.onBeforeCompile.toString()
            }
            setValues(e) {
                if (void 0 !== e)
                    for (const t in e) {
                        const n = e[t];
                        if (void 0 === n) {
                            console.warn(`THREE.Material: parameter '${t}' has value of undefined.`);
                            continue
                        }
                        const i = this[t];
                        void 0 !== i ? i && i.isColor ? i.set(n) : i && i.isVector3 && n && n.isVector3 ? i.copy(n) : this[t] = n : console.warn(`THREE.Material: '${t}' is not a property of THREE.${this.type}.`)
                    }
            }
            toJSON(e) {
                const t = void 0 === e || "string" == typeof e;
                t && (e = {
                    textures: {},
                    images: {}
                });
                const n = {
                    metadata: {
                        version: 4.6,
                        type: "Material",
                        generator: "Material.toJSON"
                    }
                };
                function i(e) {
                    const t = [];
                    for (const n in e) {
                        const i = e[n];
                        delete i.metadata,
                        t.push(i)
                    }
                    return t
                }
                if (n.uuid = this.uuid,
                n.type = this.type,
                "" !== this.name && (n.name = this.name),
                this.color && this.color.isColor && (n.color = this.color.getHex()),
                void 0 !== this.roughness && (n.roughness = this.roughness),
                void 0 !== this.metalness && (n.metalness = this.metalness),
                void 0 !== this.sheen && (n.sheen = this.sheen),
                this.sheenColor && this.sheenColor.isColor && (n.sheenColor = this.sheenColor.getHex()),
                void 0 !== this.sheenRoughness && (n.sheenRoughness = this.sheenRoughness),
                this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()),
                void 0 !== this.emissiveIntensity && 1 !== this.emissiveIntensity && (n.emissiveIntensity = this.emissiveIntensity),
                this.specular && this.specular.isColor && (n.specular = this.specular.getHex()),
                void 0 !== this.specularIntensity && (n.specularIntensity = this.specularIntensity),
                this.specularColor && this.specularColor.isColor && (n.specularColor = this.specularColor.getHex()),
                void 0 !== this.shininess && (n.shininess = this.shininess),
                void 0 !== this.clearcoat && (n.clearcoat = this.clearcoat),
                void 0 !== this.clearcoatRoughness && (n.clearcoatRoughness = this.clearcoatRoughness),
                this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(e).uuid),
                this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid),
                this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid,
                n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()),
                void 0 !== this.dispersion && (n.dispersion = this.dispersion),
                void 0 !== this.iridescence && (n.iridescence = this.iridescence),
                void 0 !== this.iridescenceIOR && (n.iridescenceIOR = this.iridescenceIOR),
                void 0 !== this.iridescenceThicknessRange && (n.iridescenceThicknessRange = this.iridescenceThicknessRange),
                this.iridescenceMap && this.iridescenceMap.isTexture && (n.iridescenceMap = this.iridescenceMap.toJSON(e).uuid),
                this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (n.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(e).uuid),
                void 0 !== this.anisotropy && (n.anisotropy = this.anisotropy),
                void 0 !== this.anisotropyRotation && (n.anisotropyRotation = this.anisotropyRotation),
                this.anisotropyMap && this.anisotropyMap.isTexture && (n.anisotropyMap = this.anisotropyMap.toJSON(e).uuid),
                this.map && this.map.isTexture && (n.map = this.map.toJSON(e).uuid),
                this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(e).uuid),
                this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(e).uuid),
                this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(e).uuid,
                n.lightMapIntensity = this.lightMapIntensity),
                this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(e).uuid,
                n.aoMapIntensity = this.aoMapIntensity),
                this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(e).uuid,
                n.bumpScale = this.bumpScale),
                this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(e).uuid,
                n.normalMapType = this.normalMapType,
                n.normalScale = this.normalScale.toArray()),
                this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(e).uuid,
                n.displacementScale = this.displacementScale,
                n.displacementBias = this.displacementBias),
                this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(e).uuid),
                this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(e).uuid),
                this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(e).uuid),
                this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(e).uuid),
                this.specularIntensityMap && this.specularIntensityMap.isTexture && (n.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid),
                this.specularColorMap && this.specularColorMap.isTexture && (n.specularColorMap = this.specularColorMap.toJSON(e).uuid),
                this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(e).uuid,
                void 0 !== this.combine && (n.combine = this.combine)),
                void 0 !== this.envMapRotation && (n.envMapRotation = this.envMapRotation.toArray()),
                void 0 !== this.envMapIntensity && (n.envMapIntensity = this.envMapIntensity),
                void 0 !== this.reflectivity && (n.reflectivity = this.reflectivity),
                void 0 !== this.refractionRatio && (n.refractionRatio = this.refractionRatio),
                this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(e).uuid),
                void 0 !== this.transmission && (n.transmission = this.transmission),
                this.transmissionMap && this.transmissionMap.isTexture && (n.transmissionMap = this.transmissionMap.toJSON(e).uuid),
                void 0 !== this.thickness && (n.thickness = this.thickness),
                this.thicknessMap && this.thicknessMap.isTexture && (n.thicknessMap = this.thicknessMap.toJSON(e).uuid),
                void 0 !== this.attenuationDistance && this.attenuationDistance !== 1 / 0 && (n.attenuationDistance = this.attenuationDistance),
                void 0 !== this.attenuationColor && (n.attenuationColor = this.attenuationColor.getHex()),
                void 0 !== this.size && (n.size = this.size),
                null !== this.shadowSide && (n.shadowSide = this.shadowSide),
                void 0 !== this.sizeAttenuation && (n.sizeAttenuation = this.sizeAttenuation),
                1 !== this.blending && (n.blending = this.blending),
                this.side !== o && (n.side = this.side),
                !0 === this.vertexColors && (n.vertexColors = !0),
                this.opacity < 1 && (n.opacity = this.opacity),
                !0 === this.transparent && (n.transparent = !0),
                204 !== this.blendSrc && (n.blendSrc = this.blendSrc),
                205 !== this.blendDst && (n.blendDst = this.blendDst),
                this.blendEquation !== h && (n.blendEquation = this.blendEquation),
                null !== this.blendSrcAlpha && (n.blendSrcAlpha = this.blendSrcAlpha),
                null !== this.blendDstAlpha && (n.blendDstAlpha = this.blendDstAlpha),
                null !== this.blendEquationAlpha && (n.blendEquationAlpha = this.blendEquationAlpha),
                this.blendColor && this.blendColor.isColor && (n.blendColor = this.blendColor.getHex()),
                0 !== this.blendAlpha && (n.blendAlpha = this.blendAlpha),
                this.depthFunc !== A && (n.depthFunc = this.depthFunc),
                !1 === this.depthTest && (n.depthTest = this.depthTest),
                !1 === this.depthWrite && (n.depthWrite = this.depthWrite),
                !1 === this.colorWrite && (n.colorWrite = this.colorWrite),
                255 !== this.stencilWriteMask && (n.stencilWriteMask = this.stencilWriteMask),
                519 !== this.stencilFunc && (n.stencilFunc = this.stencilFunc),
                0 !== this.stencilRef && (n.stencilRef = this.stencilRef),
                255 !== this.stencilFuncMask && (n.stencilFuncMask = this.stencilFuncMask),
                this.stencilFail !== pt && (n.stencilFail = this.stencilFail),
                this.stencilZFail !== pt && (n.stencilZFail = this.stencilZFail),
                this.stencilZPass !== pt && (n.stencilZPass = this.stencilZPass),
                !0 === this.stencilWrite && (n.stencilWrite = this.stencilWrite),
                void 0 !== this.rotation && 0 !== this.rotation && (n.rotation = this.rotation),
                !0 === this.polygonOffset && (n.polygonOffset = !0),
                0 !== this.polygonOffsetFactor && (n.polygonOffsetFactor = this.polygonOffsetFactor),
                0 !== this.polygonOffsetUnits && (n.polygonOffsetUnits = this.polygonOffsetUnits),
                void 0 !== this.linewidth && 1 !== this.linewidth && (n.linewidth = this.linewidth),
                void 0 !== this.dashSize && (n.dashSize = this.dashSize),
                void 0 !== this.gapSize && (n.gapSize = this.gapSize),
                void 0 !== this.scale && (n.scale = this.scale),
                !0 === this.dithering && (n.dithering = !0),
                this.alphaTest > 0 && (n.alphaTest = this.alphaTest),
                !0 === this.alphaHash && (n.alphaHash = !0),
                !0 === this.alphaToCoverage && (n.alphaToCoverage = !0),
                !0 === this.premultipliedAlpha && (n.premultipliedAlpha = !0),
                !0 === this.forceSinglePass && (n.forceSinglePass = !0),
                !0 === this.wireframe && (n.wireframe = !0),
                this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth),
                "round" !== this.wireframeLinecap && (n.wireframeLinecap = this.wireframeLinecap),
                "round" !== this.wireframeLinejoin && (n.wireframeLinejoin = this.wireframeLinejoin),
                !0 === this.flatShading && (n.flatShading = !0),
                !1 === this.visible && (n.visible = !1),
                !1 === this.toneMapped && (n.toneMapped = !1),
                !1 === this.fog && (n.fog = !1),
                Object.keys(this.userData).length > 0 && (n.userData = this.userData),
                t) {
                    const t = i(e.textures)
                      , r = i(e.images);
                    t.length > 0 && (n.textures = t),
                    r.length > 0 && (n.images = r)
                }
                return n
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            copy(e) {
                this.name = e.name,
                this.blending = e.blending,
                this.side = e.side,
                this.vertexColors = e.vertexColors,
                this.opacity = e.opacity,
                this.transparent = e.transparent,
                this.blendSrc = e.blendSrc,
                this.blendDst = e.blendDst,
                this.blendEquation = e.blendEquation,
                this.blendSrcAlpha = e.blendSrcAlpha,
                this.blendDstAlpha = e.blendDstAlpha,
                this.blendEquationAlpha = e.blendEquationAlpha,
                this.blendColor.copy(e.blendColor),
                this.blendAlpha = e.blendAlpha,
                this.depthFunc = e.depthFunc,
                this.depthTest = e.depthTest,
                this.depthWrite = e.depthWrite,
                this.stencilWriteMask = e.stencilWriteMask,
                this.stencilFunc = e.stencilFunc,
                this.stencilRef = e.stencilRef,
                this.stencilFuncMask = e.stencilFuncMask,
                this.stencilFail = e.stencilFail,
                this.stencilZFail = e.stencilZFail,
                this.stencilZPass = e.stencilZPass,
                this.stencilWrite = e.stencilWrite;
                const t = e.clippingPlanes;
                let n = null;
                if (null !== t) {
                    const e = t.length;
                    n = new Array(e);
                    for (let i = 0; i !== e; ++i)
                        n[i] = t[i].clone()
                }
                return this.clippingPlanes = n,
                this.clipIntersection = e.clipIntersection,
                this.clipShadows = e.clipShadows,
                this.shadowSide = e.shadowSide,
                this.colorWrite = e.colorWrite,
                this.precision = e.precision,
                this.polygonOffset = e.polygonOffset,
                this.polygonOffsetFactor = e.polygonOffsetFactor,
                this.polygonOffsetUnits = e.polygonOffsetUnits,
                this.dithering = e.dithering,
                this.alphaTest = e.alphaTest,
                this.alphaHash = e.alphaHash,
                this.alphaToCoverage = e.alphaToCoverage,
                this.premultipliedAlpha = e.premultipliedAlpha,
                this.forceSinglePass = e.forceSinglePass,
                this.visible = e.visible,
                this.toneMapped = e.toneMapped,
                this.userData = JSON.parse(JSON.stringify(e.userData)),
                this
            }
            dispose() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
            set needsUpdate(e) {
                !0 === e && this.version++
            }
            onBuild() {
                console.warn("Material: onBuild() has been removed.")
            }
        }
        class Pi extends Di {
            static get type() {
                return "MeshBasicMaterial"
            }
            constructor(e) {
                super(),
                this.isMeshBasicMaterial = !0,
                this.color = new Ti(16777215),
                this.map = null,
                this.lightMap = null,
                this.lightMapIntensity = 1,
                this.aoMap = null,
                this.aoMapIntensity = 1,
                this.specularMap = null,
                this.alphaMap = null,
                this.envMap = null,
                this.envMapRotation = new qn,
                this.combine = x,
                this.reflectivity = 1,
                this.refractionRatio = .98,
                this.wireframe = !1,
                this.wireframeLinewidth = 1,
                this.wireframeLinecap = "round",
                this.wireframeLinejoin = "round",
                this.fog = !0,
                this.setValues(e)
            }
            copy(e) {
                return super.copy(e),
                this.color.copy(e.color),
                this.map = e.map,
                this.lightMap = e.lightMap,
                this.lightMapIntensity = e.lightMapIntensity,
                this.aoMap = e.aoMap,
                this.aoMapIntensity = e.aoMapIntensity,
                this.specularMap = e.specularMap,
                this.alphaMap = e.alphaMap,
                this.envMap = e.envMap,
                this.envMapRotation.copy(e.envMapRotation),
                this.combine = e.combine,
                this.reflectivity = e.reflectivity,
                this.refractionRatio = e.refractionRatio,
                this.wireframe = e.wireframe,
                this.wireframeLinewidth = e.wireframeLinewidth,
                this.wireframeLinecap = e.wireframeLinecap,
                this.wireframeLinejoin = e.wireframeLinejoin,
                this.fog = e.fog,
                this
            }
        }
        const Li = Ui();
        function Ui() {
            const e = new ArrayBuffer(4)
              , t = new Float32Array(e)
              , n = new Uint32Array(e)
              , i = new Uint32Array(512)
              , r = new Uint32Array(512);
            for (let e = 0; e < 256; ++e) {
                const t = e - 127;
                t < -27 ? (i[e] = 0,
                i[256 | e] = 32768,
                r[e] = 24,
                r[256 | e] = 24) : t < -14 ? (i[e] = 1024 >> -t - 14,
                i[256 | e] = 1024 >> -t - 14 | 32768,
                r[e] = -t - 1,
                r[256 | e] = -t - 1) : t <= 15 ? (i[e] = t + 15 << 10,
                i[256 | e] = t + 15 << 10 | 32768,
                r[e] = 13,
                r[256 | e] = 13) : t < 128 ? (i[e] = 31744,
                i[256 | e] = 64512,
                r[e] = 24,
                r[256 | e] = 24) : (i[e] = 31744,
                i[256 | e] = 64512,
                r[e] = 13,
                r[256 | e] = 13)
            }
            const s = new Uint32Array(2048)
              , a = new Uint32Array(64)
              , o = new Uint32Array(64);
            for (let e = 1; e < 1024; ++e) {
                let t = e << 13
                  , n = 0;
                for (; !(8388608 & t); )
                    t <<= 1,
                    n -= 8388608;
                t &= -8388609,
                n += 947912704,
                s[e] = t | n
            }
            for (let e = 1024; e < 2048; ++e)
                s[e] = 939524096 + (e - 1024 << 13);
            for (let e = 1; e < 31; ++e)
                a[e] = e << 23;
            a[31] = 1199570944,
            a[32] = 2147483648;
            for (let e = 33; e < 63; ++e)
                a[e] = 2147483648 + (e - 32 << 23);
            a[63] = 3347054592;
            for (let e = 1; e < 64; ++e)
                32 !== e && (o[e] = 1024);
            return {
                floatView: t,
                uint32View: n,
                baseTable: i,
                shiftTable: r,
                mantissaTable: s,
                exponentTable: a,
                offsetTable: o
            }
        }
        function Fi(e) {
            Math.abs(e) > 65504 && console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."),
            e = Ct(e, -65504, 65504),
            Li.floatView[0] = e;
            const t = Li.uint32View[0]
              , n = t >> 23 & 511;
            return Li.baseTable[n] + ((8388607 & t) >> Li.shiftTable[n])
        }
        function Ni(e) {
            const t = e >> 10;
            return Li.uint32View[0] = Li.mantissaTable[Li.offsetTable[t] + (1023 & e)] + Li.exponentTable[t],
            Li.floatView[0]
        }
        const Oi = {
            toHalfFloat: Fi,
            fromHalfFloat: Ni
        }
          , Qi = new on
          , ki = new Rt;
        class Gi {
            constructor(e, t, n=!1) {
                if (Array.isArray(e))
                    throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
                this.isBufferAttribute = !0,
                this.name = "",
                this.array = e,
                this.itemSize = t,
                this.count = void 0 !== e ? e.length / t : 0,
                this.normalized = n,
                this.usage = At,
                this.updateRanges = [],
                this.gpuType = Z,
                this.version = 0
            }
            onUploadCallback() {}
            set needsUpdate(e) {
                !0 === e && this.version++
            }
            setUsage(e) {
                return this.usage = e,
                this
            }
            addUpdateRange(e, t) {
                this.updateRanges.push({
                    start: e,
                    count: t
                })
            }
            clearUpdateRanges() {
                this.updateRanges.length = 0
            }
            copy(e) {
                return this.name = e.name,
                this.array = new e.array.constructor(e.array),
                this.itemSize = e.itemSize,
                this.count = e.count,
                this.normalized = e.normalized,
                this.usage = e.usage,
                this.gpuType = e.gpuType,
                this
            }
            copyAt(e, t, n) {
                e *= this.itemSize,
                n *= t.itemSize;
                for (let i = 0, r = this.itemSize; i < r; i++)
                    this.array[e + i] = t.array[n + i];
                return this
            }
            copyArray(e) {
                return this.array.set(e),
                this
            }
            applyMatrix3(e) {
                if (2 === this.itemSize)
                    for (let t = 0, n = this.count; t < n; t++)
                        ki.fromBufferAttribute(this, t),
                        ki.applyMatrix3(e),
                        this.setXY(t, ki.x, ki.y);
                else if (3 === this.itemSize)
                    for (let t = 0, n = this.count; t < n; t++)
                        Qi.fromBufferAttribute(this, t),
                        Qi.applyMatrix3(e),
                        this.setXYZ(t, Qi.x, Qi.y, Qi.z);
                return this
            }
            applyMatrix4(e) {
                for (let t = 0, n = this.count; t < n; t++)
                    Qi.fromBufferAttribute(this, t),
                    Qi.applyMatrix4(e),
                    this.setXYZ(t, Qi.x, Qi.y, Qi.z);
                return this
            }
            applyNormalMatrix(e) {
                for (let t = 0, n = this.count; t < n; t++)
                    Qi.fromBufferAttribute(this, t),
                    Qi.applyNormalMatrix(e),
                    this.setXYZ(t, Qi.x, Qi.y, Qi.z);
                return this
            }
            transformDirection(e) {
                for (let t = 0, n = this.count; t < n; t++)
                    Qi.fromBufferAttribute(this, t),
                    Qi.transformDirection(e),
                    this.setXYZ(t, Qi.x, Qi.y, Qi.z);
                return this
            }
            set(e, t=0) {
                return this.array.set(e, t),
                this
            }
            getComponent(e, t) {
                let n = this.array[e * this.itemSize + t];
                return this.normalized && (n = Mt(n, this.array)),
                n
            }
            setComponent(e, t, n) {
                return this.normalized && (n = Tt(n, this.array)),
                this.array[e * this.itemSize + t] = n,
                this
            }
            getX(e) {
                let t = this.array[e * this.itemSize];
                return this.normalized && (t = Mt(t, this.array)),
                t
            }
            setX(e, t) {
                return this.normalized && (t = Tt(t, this.array)),
                this.array[e * this.itemSize] = t,
                this
            }
            getY(e) {
                let t = this.array[e * this.itemSize + 1];
                return this.normalized && (t = Mt(t, this.array)),
                t
            }
            setY(e, t) {
                return this.normalized && (t = Tt(t, this.array)),
                this.array[e * this.itemSize + 1] = t,
                this
            }
            getZ(e) {
                let t = this.array[e * this.itemSize + 2];
                return this.normalized && (t = Mt(t, this.array)),
                t
            }
            setZ(e, t) {
                return this.normalized && (t = Tt(t, this.array)),
                this.array[e * this.itemSize + 2] = t,
                this
            }
            getW(e) {
                let t = this.array[e * this.itemSize + 3];
                return this.normalized && (t = Mt(t, this.array)),
                t
            }
            setW(e, t) {
                return this.normalized && (t = Tt(t, this.array)),
                this.array[e * this.itemSize + 3] = t,
                this
            }
            setXY(e, t, n) {
                return e *= this.itemSize,
                this.normalized && (t = Tt(t, this.array),
                n = Tt(n, this.array)),
                this.array[e + 0] = t,
                this.array[e + 1] = n,
                this
            }
            setXYZ(e, t, n, i) {
                return e *= this.itemSize,
                this.normalized && (t = Tt(t, this.array),
                n = Tt(n, this.array),
                i = Tt(i, this.array)),
                this.array[e + 0] = t,
                this.array[e + 1] = n,
                this.array[e + 2] = i,
                this
            }
            setXYZW(e, t, n, i, r) {
                return e *= this.itemSize,
                this.normalized && (t = Tt(t, this.array),
                n = Tt(n, this.array),
                i = Tt(i, this.array),
                r = Tt(r, this.array)),
                this.array[e + 0] = t,
                this.array[e + 1] = n,
                this.array[e + 2] = i,
                this.array[e + 3] = r,
                this
            }
            onUpload(e) {
                return this.onUploadCallback = e,
                this
            }
            clone() {
                return new this.constructor(this.array,this.itemSize).copy(this)
            }
            toJSON() {
                const e = {
                    itemSize: this.itemSize,
                    type: this.array.constructor.name,
                    array: Array.from(this.array),
                    normalized: this.normalized
                };
                return "" !== this.name && (e.name = this.name),
                this.usage !== At && (e.usage = this.usage),
                e
            }
        }
        class Hi extends Gi {
            constructor(e, t, n) {
                super(new Uint16Array(e), t, n)
            }
        }
        class zi extends Gi {
            constructor(e, t, n) {
                super(new Uint32Array(e), t, n)
            }
        }
        class Vi extends Gi {
            constructor(e, t, n) {
                super(new Float32Array(e), t, n)
            }
        }
        let Wi = 0;
        const ji = new Nn
          , qi = new ui
          , Yi = new on
          , Xi = new un
          , Ki = new un
          , Ji = new on;
        class Zi extends yt {
            constructor() {
                super(),
                this.isBufferGeometry = !0,
                Object.defineProperty(this, "id", {
                    value: Wi++
                }),
                this.uuid = wt(),
                this.name = "",
                this.type = "BufferGeometry",
                this.index = null,
                this.indirect = null,
                this.attributes = {},
                this.morphAttributes = {},
                this.morphTargetsRelative = !1,
                this.groups = [],
                this.boundingBox = null,
                this.boundingSphere = null,
                this.drawRange = {
                    start: 0,
                    count: 1 / 0
                },
                this.userData = {}
            }
            getIndex() {
                return this.index
            }
            setIndex(e) {
                return Array.isArray(e) ? this.index = new (Lt(e) ? zi : Hi)(e,1) : this.index = e,
                this
            }
            setIndirect(e) {
                return this.indirect = e,
                this
            }
            getIndirect() {
                return this.indirect
            }
            getAttribute(e) {
                return this.attributes[e]
            }
            setAttribute(e, t) {
                return this.attributes[e] = t,
                this
            }
            deleteAttribute(e) {
                return delete this.attributes[e],
                this
            }
            hasAttribute(e) {
                return void 0 !== this.attributes[e]
            }
            addGroup(e, t, n=0) {
                this.groups.push({
                    start: e,
                    count: t,
                    materialIndex: n
                })
            }
            clearGroups() {
                this.groups = []
            }
            setDrawRange(e, t) {
                this.drawRange.start = e,
                this.drawRange.count = t
            }
            applyMatrix4(e) {
                const t = this.attributes.position;
                void 0 !== t && (t.applyMatrix4(e),
                t.needsUpdate = !0);
                const n = this.attributes.normal;
                if (void 0 !== n) {
                    const t = (new Dt).getNormalMatrix(e);
                    n.applyNormalMatrix(t),
                    n.needsUpdate = !0
                }
                const i = this.attributes.tangent;
                return void 0 !== i && (i.transformDirection(e),
                i.needsUpdate = !0),
                null !== this.boundingBox && this.computeBoundingBox(),
                null !== this.boundingSphere && this.computeBoundingSphere(),
                this
            }
            applyQuaternion(e) {
                return ji.makeRotationFromQuaternion(e),
                this.applyMatrix4(ji),
                this
            }
            rotateX(e) {
                return ji.makeRotationX(e),
                this.applyMatrix4(ji),
                this
            }
            rotateY(e) {
                return ji.makeRotationY(e),
                this.applyMatrix4(ji),
                this
            }
            rotateZ(e) {
                return ji.makeRotationZ(e),
                this.applyMatrix4(ji),
                this
            }
            translate(e, t, n) {
                return ji.makeTranslation(e, t, n),
                this.applyMatrix4(ji),
                this
            }
            scale(e, t, n) {
                return ji.makeScale(e, t, n),
                this.applyMatrix4(ji),
                this
            }
            lookAt(e) {
                return qi.lookAt(e),
                qi.updateMatrix(),
                this.applyMatrix4(qi.matrix),
                this
            }
            center() {
                return this.computeBoundingBox(),
                this.boundingBox.getCenter(Yi).negate(),
                this.translate(Yi.x, Yi.y, Yi.z),
                this
            }
            setFromPoints(e) {
                const t = this.getAttribute("position");
                if (void 0 === t) {
                    const t = [];
                    for (let n = 0, i = e.length; n < i; n++) {
                        const i = e[n];
                        t.push(i.x, i.y, i.z || 0)
                    }
                    this.setAttribute("position", new Vi(t,3))
                } else {
                    for (let n = 0, i = t.count; n < i; n++) {
                        const i = e[n];
                        t.setXYZ(n, i.x, i.y, i.z || 0)
                    }
                    e.length > t.count && console.warn("THREE.BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry."),
                    t.needsUpdate = !0
                }
                return this
            }
            computeBoundingBox() {
                null === this.boundingBox && (this.boundingBox = new un);
                const e = this.attributes.position
                  , t = this.morphAttributes.position;
                if (e && e.isGLBufferAttribute)
                    return console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.", this),
                    void this.boundingBox.set(new on(-1 / 0,-1 / 0,-1 / 0), new on(1 / 0,1 / 0,1 / 0));
                if (void 0 !== e) {
                    if (this.boundingBox.setFromBufferAttribute(e),
                    t)
                        for (let e = 0, n = t.length; e < n; e++) {
                            const n = t[e];
                            Xi.setFromBufferAttribute(n),
                            this.morphTargetsRelative ? (Ji.addVectors(this.boundingBox.min, Xi.min),
                            this.boundingBox.expandByPoint(Ji),
                            Ji.addVectors(this.boundingBox.max, Xi.max),
                            this.boundingBox.expandByPoint(Ji)) : (this.boundingBox.expandByPoint(Xi.min),
                            this.boundingBox.expandByPoint(Xi.max))
                        }
                } else
                    this.boundingBox.makeEmpty();
                (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
            }
            computeBoundingSphere() {
                null === this.boundingSphere && (this.boundingSphere = new Mn);
                const e = this.attributes.position
                  , t = this.morphAttributes.position;
                if (e && e.isGLBufferAttribute)
                    return console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.", this),
                    void this.boundingSphere.set(new on, 1 / 0);
                if (e) {
                    const n = this.boundingSphere.center;
                    if (Xi.setFromBufferAttribute(e),
                    t)
                        for (let e = 0, n = t.length; e < n; e++) {
                            const n = t[e];
                            Ki.setFromBufferAttribute(n),
                            this.morphTargetsRelative ? (Ji.addVectors(Xi.min, Ki.min),
                            Xi.expandByPoint(Ji),
                            Ji.addVectors(Xi.max, Ki.max),
                            Xi.expandByPoint(Ji)) : (Xi.expandByPoint(Ki.min),
                            Xi.expandByPoint(Ki.max))
                        }
                    Xi.getCenter(n);
                    let i = 0;
                    for (let t = 0, r = e.count; t < r; t++)
                        Ji.fromBufferAttribute(e, t),
                        i = Math.max(i, n.distanceToSquared(Ji));
                    if (t)
                        for (let r = 0, s = t.length; r < s; r++) {
                            const s = t[r]
                              , a = this.morphTargetsRelative;
                            for (let t = 0, r = s.count; t < r; t++)
                                Ji.fromBufferAttribute(s, t),
                                a && (Yi.fromBufferAttribute(e, t),
                                Ji.add(Yi)),
                                i = Math.max(i, n.distanceToSquared(Ji))
                        }
                    this.boundingSphere.radius = Math.sqrt(i),
                    isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
                }
            }
            computeTangents() {
                const e = this.index
                  , t = this.attributes;
                if (null === e || void 0 === t.position || void 0 === t.normal || void 0 === t.uv)
                    return void console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
                const n = t.position
                  , i = t.normal
                  , r = t.uv;
                !1 === this.hasAttribute("tangent") && this.setAttribute("tangent", new Gi(new Float32Array(4 * n.count),4));
                const s = this.getAttribute("tangent")
                  , a = []
                  , o = [];
                for (let e = 0; e < n.count; e++)
                    a[e] = new on,
                    o[e] = new on;
                const l = new on
                  , c = new on
                  , u = new on
                  , h = new Rt
                  , d = new Rt
                  , p = new Rt
                  , f = new on
                  , A = new on;
                function g(e, t, i) {
                    l.fromBufferAttribute(n, e),
                    c.fromBufferAttribute(n, t),
                    u.fromBufferAttribute(n, i),
                    h.fromBufferAttribute(r, e),
                    d.fromBufferAttribute(r, t),
                    p.fromBufferAttribute(r, i),
                    c.sub(l),
                    u.sub(l),
                    d.sub(h),
                    p.sub(h);
                    const s = 1 / (d.x * p.y - p.x * d.y);
                    isFinite(s) && (f.copy(c).multiplyScalar(p.y).addScaledVector(u, -d.y).multiplyScalar(s),
                    A.copy(u).multiplyScalar(d.x).addScaledVector(c, -p.x).multiplyScalar(s),
                    a[e].add(f),
                    a[t].add(f),
                    a[i].add(f),
                    o[e].add(A),
                    o[t].add(A),
                    o[i].add(A))
                }
                let m = this.groups;
                0 === m.length && (m = [{
                    start: 0,
                    count: e.count
                }]);
                for (let t = 0, n = m.length; t < n; ++t) {
                    const n = m[t]
                      , i = n.start;
                    for (let t = i, r = i + n.count; t < r; t += 3)
                        g(e.getX(t + 0), e.getX(t + 1), e.getX(t + 2))
                }
                const v = new on
                  , y = new on
                  , x = new on
                  , _ = new on;
                function b(e) {
                    x.fromBufferAttribute(i, e),
                    _.copy(x);
                    const t = a[e];
                    v.copy(t),
                    v.sub(x.multiplyScalar(x.dot(t))).normalize(),
                    y.crossVectors(_, t);
                    const n = y.dot(o[e]) < 0 ? -1 : 1;
                    s.setXYZW(e, v.x, v.y, v.z, n)
                }
                for (let t = 0, n = m.length; t < n; ++t) {
                    const n = m[t]
                      , i = n.start;
                    for (let t = i, r = i + n.count; t < r; t += 3)
                        b(e.getX(t + 0)),
                        b(e.getX(t + 1)),
                        b(e.getX(t + 2))
                }
            }
            computeVertexNormals() {
                const e = this.index
                  , t = this.getAttribute("position");
                if (void 0 !== t) {
                    let n = this.getAttribute("normal");
                    if (void 0 === n)
                        n = new Gi(new Float32Array(3 * t.count),3),
                        this.setAttribute("normal", n);
                    else
                        for (let e = 0, t = n.count; e < t; e++)
                            n.setXYZ(e, 0, 0, 0);
                    const i = new on
                      , r = new on
                      , s = new on
                      , a = new on
                      , o = new on
                      , l = new on
                      , c = new on
                      , u = new on;
                    if (e)
                        for (let h = 0, d = e.count; h < d; h += 3) {
                            const d = e.getX(h + 0)
                              , p = e.getX(h + 1)
                              , f = e.getX(h + 2);
                            i.fromBufferAttribute(t, d),
                            r.fromBufferAttribute(t, p),
                            s.fromBufferAttribute(t, f),
                            c.subVectors(s, r),
                            u.subVectors(i, r),
                            c.cross(u),
                            a.fromBufferAttribute(n, d),
                            o.fromBufferAttribute(n, p),
                            l.fromBufferAttribute(n, f),
                            a.add(c),
                            o.add(c),
                            l.add(c),
                            n.setXYZ(d, a.x, a.y, a.z),
                            n.setXYZ(p, o.x, o.y, o.z),
                            n.setXYZ(f, l.x, l.y, l.z)
                        }
                    else
                        for (let e = 0, a = t.count; e < a; e += 3)
                            i.fromBufferAttribute(t, e + 0),
                            r.fromBufferAttribute(t, e + 1),
                            s.fromBufferAttribute(t, e + 2),
                            c.subVectors(s, r),
                            u.subVectors(i, r),
                            c.cross(u),
                            n.setXYZ(e + 0, c.x, c.y, c.z),
                            n.setXYZ(e + 1, c.x, c.y, c.z),
                            n.setXYZ(e + 2, c.x, c.y, c.z);
                    this.normalizeNormals(),
                    n.needsUpdate = !0
                }
            }
            normalizeNormals() {
                const e = this.attributes.normal;
                for (let t = 0, n = e.count; t < n; t++)
                    Ji.fromBufferAttribute(e, t),
                    Ji.normalize(),
                    e.setXYZ(t, Ji.x, Ji.y, Ji.z)
            }
            toNonIndexed() {
                function e(e, t) {
                    const n = e.array
                      , i = e.itemSize
                      , r = e.normalized
                      , s = new n.constructor(t.length * i);
                    let a = 0
                      , o = 0;
                    for (let r = 0, l = t.length; r < l; r++) {
                        a = e.isInterleavedBufferAttribute ? t[r] * e.data.stride + e.offset : t[r] * i;
                        for (let e = 0; e < i; e++)
                            s[o++] = n[a++]
                    }
                    return new Gi(s,i,r)
                }
                if (null === this.index)
                    return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),
                    this;
                const t = new Zi
                  , n = this.index.array
                  , i = this.attributes;
                for (const r in i) {
                    const s = e(i[r], n);
                    t.setAttribute(r, s)
                }
                const r = this.morphAttributes;
                for (const i in r) {
                    const s = []
                      , a = r[i];
                    for (let t = 0, i = a.length; t < i; t++) {
                        const i = e(a[t], n);
                        s.push(i)
                    }
                    t.morphAttributes[i] = s
                }
                t.morphTargetsRelative = this.morphTargetsRelative;
                const s = this.groups;
                for (let e = 0, n = s.length; e < n; e++) {
                    const n = s[e];
                    t.addGroup(n.start, n.count, n.materialIndex)
                }
                return t
            }
            toJSON() {
                const e = {
                    metadata: {
                        version: 4.6,
                        type: "BufferGeometry",
                        generator: "BufferGeometry.toJSON"
                    }
                };
                if (e.uuid = this.uuid,
                e.type = this.type,
                "" !== this.name && (e.name = this.name),
                Object.keys(this.userData).length > 0 && (e.userData = this.userData),
                void 0 !== this.parameters) {
                    const t = this.parameters;
                    for (const n in t)
                        void 0 !== t[n] && (e[n] = t[n]);
                    return e
                }
                e.data = {
                    attributes: {}
                };
                const t = this.index;
                null !== t && (e.data.index = {
                    type: t.array.constructor.name,
                    array: Array.prototype.slice.call(t.array)
                });
                const n = this.attributes;
                for (const t in n) {
                    const i = n[t];
                    e.data.attributes[t] = i.toJSON(e.data)
                }
                const i = {};
                let r = !1;
                for (const t in this.morphAttributes) {
                    const n = this.morphAttributes[t]
                      , s = [];
                    for (let t = 0, i = n.length; t < i; t++) {
                        const i = n[t];
                        s.push(i.toJSON(e.data))
                    }
                    s.length > 0 && (i[t] = s,
                    r = !0)
                }
                r && (e.data.morphAttributes = i,
                e.data.morphTargetsRelative = this.morphTargetsRelative);
                const s = this.groups;
                s.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(s)));
                const a = this.boundingSphere;
                return null !== a && (e.data.boundingSphere = {
                    center: a.center.toArray(),
                    radius: a.radius
                }),
                e
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            copy(e) {
                this.index = null,
                this.attributes = {},
                this.morphAttributes = {},
                this.groups = [],
                this.boundingBox = null,
                this.boundingSphere = null;
                const t = {};
                this.name = e.name;
                const n = e.index;
                null !== n && this.setIndex(n.clone(t));
                const i = e.attributes;
                for (const e in i) {
                    const n = i[e];
                    this.setAttribute(e, n.clone(t))
                }
                const r = e.morphAttributes;
                for (const e in r) {
                    const n = []
                      , i = r[e];
                    for (let e = 0, r = i.length; e < r; e++)
                        n.push(i[e].clone(t));
                    this.morphAttributes[e] = n
                }
                this.morphTargetsRelative = e.morphTargetsRelative;
                const s = e.groups;
                for (let e = 0, t = s.length; e < t; e++) {
                    const t = s[e];
                    this.addGroup(t.start, t.count, t.materialIndex)
                }
                const a = e.boundingBox;
                null !== a && (this.boundingBox = a.clone());
                const o = e.boundingSphere;
                return null !== o && (this.boundingSphere = o.clone()),
                this.drawRange.start = e.drawRange.start,
                this.drawRange.count = e.drawRange.count,
                this.userData = e.userData,
                this
            }
            dispose() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
        }
        const $i = new Nn
          , er = new Fn
          , tr = new Mn
          , nr = new on
          , ir = new on
          , rr = new on
          , sr = new on
          , ar = new on
          , or = new on
          , lr = new on
          , cr = new on;
        class ur extends ui {
            constructor(e=new Zi, t=new Pi) {
                super(),
                this.isMesh = !0,
                this.type = "Mesh",
                this.geometry = e,
                this.material = t,
                this.updateMorphTargets()
            }
            copy(e, t) {
                return super.copy(e, t),
                void 0 !== e.morphTargetInfluences && (this.morphTargetInfluences = e.morphTargetInfluences.slice()),
                void 0 !== e.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)),
                this.material = Array.isArray(e.material) ? e.material.slice() : e.material,
                this.geometry = e.geometry,
                this
            }
            updateMorphTargets() {
                const e = this.geometry.morphAttributes
                  , t = Object.keys(e);
                if (t.length > 0) {
                    const n = e[t[0]];
                    if (void 0 !== n) {
                        this.morphTargetInfluences = [],
                        this.morphTargetDictionary = {};
                        for (let e = 0, t = n.length; e < t; e++) {
                            const t = n[e].name || String(e);
                            this.morphTargetInfluences.push(0),
                            this.morphTargetDictionary[t] = e
                        }
                    }
                }
            }
            getVertexPosition(e, t) {
                const n = this.geometry
                  , i = n.attributes.position
                  , r = n.morphAttributes.position
                  , s = n.morphTargetsRelative;
                t.fromBufferAttribute(i, e);
                const a = this.morphTargetInfluences;
                if (r && a) {
                    or.set(0, 0, 0);
                    for (let n = 0, i = r.length; n < i; n++) {
                        const i = a[n]
                          , o = r[n];
                        0 !== i && (ar.fromBufferAttribute(o, e),
                        s ? or.addScaledVector(ar, i) : or.addScaledVector(ar.sub(t), i))
                    }
                    t.add(or)
                }
                return t
            }
            raycast(e, t) {
                const n = this.geometry
                  , i = this.material
                  , r = this.matrixWorld;
                if (void 0 !== i) {
                    if (null === n.boundingSphere && n.computeBoundingSphere(),
                    tr.copy(n.boundingSphere),
                    tr.applyMatrix4(r),
                    er.copy(e.ray).recast(e.near),
                    !1 === tr.containsPoint(er.origin)) {
                        if (null === er.intersectSphere(tr, nr))
                            return;
                        if (er.origin.distanceToSquared(nr) > (e.far - e.near) ** 2)
                            return
                    }
                    $i.copy(r).invert(),
                    er.copy(e.ray).applyMatrix4($i),
                    null !== n.boundingBox && !1 === er.intersectsBox(n.boundingBox) || this._computeIntersections(e, t, er)
                }
            }
            _computeIntersections(e, t, n) {
                let i;
                const r = this.geometry
                  , s = this.material
                  , a = r.index
                  , o = r.attributes.position
                  , l = r.attributes.uv
                  , c = r.attributes.uv1
                  , u = r.attributes.normal
                  , h = r.groups
                  , d = r.drawRange;
                if (null !== a)
                    if (Array.isArray(s))
                        for (let r = 0, o = h.length; r < o; r++) {
                            const o = h[r]
                              , p = s[o.materialIndex];
                            for (let r = Math.max(o.start, d.start), s = Math.min(a.count, Math.min(o.start + o.count, d.start + d.count)); r < s; r += 3) {
                                i = hr(this, p, e, n, l, c, u, a.getX(r), a.getX(r + 1), a.getX(r + 2)),
                                i && (i.faceIndex = Math.floor(r / 3),
                                i.face.materialIndex = o.materialIndex,
                                t.push(i))
                            }
                        }
                    else {
                        for (let r = Math.max(0, d.start), o = Math.min(a.count, d.start + d.count); r < o; r += 3) {
                            i = hr(this, s, e, n, l, c, u, a.getX(r), a.getX(r + 1), a.getX(r + 2)),
                            i && (i.faceIndex = Math.floor(r / 3),
                            t.push(i))
                        }
                    }
                else if (void 0 !== o)
                    if (Array.isArray(s))
                        for (let r = 0, a = h.length; r < a; r++) {
                            const a = h[r]
                              , p = s[a.materialIndex];
                            for (let r = Math.max(a.start, d.start), s = Math.min(o.count, Math.min(a.start + a.count, d.start + d.count)); r < s; r += 3) {
                                i = hr(this, p, e, n, l, c, u, r, r + 1, r + 2),
                                i && (i.faceIndex = Math.floor(r / 3),
                                i.face.materialIndex = a.materialIndex,
                                t.push(i))
                            }
                        }
                    else {
                        for (let r = Math.max(0, d.start), a = Math.min(o.count, d.start + d.count); r < a; r += 3) {
                            i = hr(this, s, e, n, l, c, u, r, r + 1, r + 2),
                            i && (i.faceIndex = Math.floor(r / 3),
                            t.push(i))
                        }
                    }
            }
        }
        function hr(e, t, n, i, r, s, a, c, u, h) {
            e.getVertexPosition(c, ir),
            e.getVertexPosition(u, rr),
            e.getVertexPosition(h, sr);
            const d = function(e, t, n, i, r, s, a, c) {
                let u;
                if (u = t.side === l ? i.intersectTriangle(a, s, r, !0, c) : i.intersectTriangle(r, s, a, t.side === o, c),
                null === u)
                    return null;
                cr.copy(c),
                cr.applyMatrix4(e.matrixWorld);
                const h = n.ray.origin.distanceTo(cr);
                return h < n.near || h > n.far ? null : {
                    distance: h,
                    point: cr.clone(),
                    object: e
                }
            }(e, t, n, i, ir, rr, sr, lr);
            if (d) {
                const e = new on;
                wi.getBarycoord(lr, ir, rr, sr, e),
                r && (d.uv = wi.getInterpolatedAttribute(r, c, u, h, e, new Rt)),
                s && (d.uv1 = wi.getInterpolatedAttribute(s, c, u, h, e, new Rt)),
                a && (d.normal = wi.getInterpolatedAttribute(a, c, u, h, e, new on),
                d.normal.dot(i.direction) > 0 && d.normal.multiplyScalar(-1));
                const t = {
                    a: c,
                    b: u,
                    c: h,
                    normal: new on,
                    materialIndex: 0
                };
                wi.getNormal(ir, rr, sr, t.normal),
                d.face = t,
                d.barycoord = e
            }
            return d
        }
        class dr extends Zi {
            constructor(e=1, t=1, n=1, i=1, r=1, s=1) {
                super(),
                this.type = "BoxGeometry",
                this.parameters = {
                    width: e,
                    height: t,
                    depth: n,
                    widthSegments: i,
                    heightSegments: r,
                    depthSegments: s
                };
                const a = this;
                i = Math.floor(i),
                r = Math.floor(r),
                s = Math.floor(s);
                const o = []
                  , l = []
                  , c = []
                  , u = [];
                let h = 0
                  , d = 0;
                function p(e, t, n, i, r, s, p, f, A, g, m) {
                    const v = s / A
                      , y = p / g
                      , x = s / 2
                      , _ = p / 2
                      , b = f / 2
                      , E = A + 1
                      , w = g + 1;
                    let C = 0
                      , I = 0;
                    const S = new on;
                    for (let s = 0; s < w; s++) {
                        const a = s * y - _;
                        for (let o = 0; o < E; o++) {
                            const h = o * v - x;
                            S[e] = h * i,
                            S[t] = a * r,
                            S[n] = b,
                            l.push(S.x, S.y, S.z),
                            S[e] = 0,
                            S[t] = 0,
                            S[n] = f > 0 ? 1 : -1,
                            c.push(S.x, S.y, S.z),
                            u.push(o / A),
                            u.push(1 - s / g),
                            C += 1
                        }
                    }
                    for (let e = 0; e < g; e++)
                        for (let t = 0; t < A; t++) {
                            const n = h + t + E * e
                              , i = h + t + E * (e + 1)
                              , r = h + (t + 1) + E * (e + 1)
                              , s = h + (t + 1) + E * e;
                            o.push(n, i, s),
                            o.push(i, r, s),
                            I += 6
                        }
                    a.addGroup(d, I, m),
                    d += I,
                    h += C
                }
                p("z", "y", "x", -1, -1, n, t, e, s, r, 0),
                p("z", "y", "x", 1, -1, n, t, -e, s, r, 1),
                p("x", "z", "y", 1, 1, e, n, t, i, s, 2),
                p("x", "z", "y", 1, -1, e, n, -t, i, s, 3),
                p("x", "y", "z", 1, -1, e, t, n, i, r, 4),
                p("x", "y", "z", -1, -1, e, t, -n, i, r, 5),
                this.setIndex(o),
                this.setAttribute("position", new Vi(l,3)),
                this.setAttribute("normal", new Vi(c,3)),
                this.setAttribute("uv", new Vi(u,2))
            }
            copy(e) {
                return super.copy(e),
                this.parameters = Object.assign({}, e.parameters),
                this
            }
            static fromJSON(e) {
                return new dr(e.width,e.height,e.depth,e.widthSegments,e.heightSegments,e.depthSegments)
            }
        }
        function pr(e) {
            const t = {};
            for (const n in e) {
                t[n] = {};
                for (const i in e[n]) {
                    const r = e[n][i];
                    r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture || r.isQuaternion) ? r.isRenderTargetTexture ? (console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."),
                    t[n][i] = null) : t[n][i] = r.clone() : Array.isArray(r) ? t[n][i] = r.slice() : t[n][i] = r
                }
            }
            return t
        }
        function fr(e) {
            const t = {};
            for (let n = 0; n < e.length; n++) {
                const i = pr(e[n]);
                for (const e in i)
                    t[e] = i[e]
            }
            return t
        }
        function Ar(e) {
            const t = e.getRenderTarget();
            return null === t ? e.outputColorSpace : !0 === t.isXRRenderTarget ? t.texture.colorSpace : Qt.workingColorSpace
        }
        const gr = {
            clone: pr,
            merge: fr
        };
        class mr extends Di {
            static get type() {
                return "ShaderMaterial"
            }
            constructor(e) {
                super(),
                this.isShaderMaterial = !0,
                this.defines = {},
                this.uniforms = {},
                this.uniformsGroups = [],
                this.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",
                this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}",
                this.linewidth = 1,
                this.wireframe = !1,
                this.wireframeLinewidth = 1,
                this.fog = !1,
                this.lights = !1,
                this.clipping = !1,
                this.forceSinglePass = !0,
                this.extensions = {
                    clipCullDistance: !1,
                    multiDraw: !1
                },
                this.defaultAttributeValues = {
                    color: [1, 1, 1],
                    uv: [0, 0],
                    uv1: [0, 0]
                },
                this.index0AttributeName = void 0,
                this.uniformsNeedUpdate = !1,
                this.glslVersion = null,
                void 0 !== e && this.setValues(e)
            }
            copy(e) {
                return super.copy(e),
                this.fragmentShader = e.fragmentShader,
                this.vertexShader = e.vertexShader,
                this.uniforms = pr(e.uniforms),
                this.uniformsGroups = function(e) {
                    const t = [];
                    for (let n = 0; n < e.length; n++)
                        t.push(e[n].clone());
                    return t
                }(e.uniformsGroups),
                this.defines = Object.assign({}, e.defines),
                this.wireframe = e.wireframe,
                this.wireframeLinewidth = e.wireframeLinewidth,
                this.fog = e.fog,
                this.lights = e.lights,
                this.clipping = e.clipping,
                this.extensions = Object.assign({}, e.extensions),
                this.glslVersion = e.glslVersion,
                this
            }
            toJSON(e) {
                const t = super.toJSON(e);
                t.glslVersion = this.glslVersion,
                t.uniforms = {};
                for (const n in this.uniforms) {
                    const i = this.uniforms[n].value;
                    i && i.isTexture ? t.uniforms[n] = {
                        type: "t",
                        value: i.toJSON(e).uuid
                    } : i && i.isColor ? t.uniforms[n] = {
                        type: "c",
                        value: i.getHex()
                    } : i && i.isVector2 ? t.uniforms[n] = {
                        type: "v2",
                        value: i.toArray()
                    } : i && i.isVector3 ? t.uniforms[n] = {
                        type: "v3",
                        value: i.toArray()
                    } : i && i.isVector4 ? t.uniforms[n] = {
                        type: "v4",
                        value: i.toArray()
                    } : i && i.isMatrix3 ? t.uniforms[n] = {
                        type: "m3",
                        value: i.toArray()
                    } : i && i.isMatrix4 ? t.uniforms[n] = {
                        type: "m4",
                        value: i.toArray()
                    } : t.uniforms[n] = {
                        value: i
                    }
                }
                Object.keys(this.defines).length > 0 && (t.defines = this.defines),
                t.vertexShader = this.vertexShader,
                t.fragmentShader = this.fragmentShader,
                t.lights = this.lights,
                t.clipping = this.clipping;
                const n = {};
                for (const e in this.extensions)
                    !0 === this.extensions[e] && (n[e] = !0);
                return Object.keys(n).length > 0 && (t.extensions = n),
                t
            }
        }
        class vr extends ui {
            constructor() {
                super(),
                this.isCamera = !0,
                this.type = "Camera",
                this.matrixWorldInverse = new Nn,
                this.projectionMatrix = new Nn,
                this.projectionMatrixInverse = new Nn,
                this.coordinateSystem = mt
            }
            copy(e, t) {
                return super.copy(e, t),
                this.matrixWorldInverse.copy(e.matrixWorldInverse),
                this.projectionMatrix.copy(e.projectionMatrix),
                this.projectionMatrixInverse.copy(e.projectionMatrixInverse),
                this.coordinateSystem = e.coordinateSystem,
                this
            }
            getWorldDirection(e) {
                return super.getWorldDirection(e).negate()
            }
            updateMatrixWorld(e) {
                super.updateMatrixWorld(e),
                this.matrixWorldInverse.copy(this.matrixWorld).invert()
            }
            updateWorldMatrix(e, t) {
                super.updateWorldMatrix(e, t),
                this.matrixWorldInverse.copy(this.matrixWorld).invert()
            }
            clone() {
                return (new this.constructor).copy(this)
            }
        }
        const yr = new on
          , xr = new Rt
          , _r = new Rt;
        class br extends vr {
            constructor(e=50, t=1, n=.1, i=2e3) {
                super(),
                this.isPerspectiveCamera = !0,
                this.type = "PerspectiveCamera",
                this.fov = e,
                this.zoom = 1,
                this.near = n,
                this.far = i,
                this.focus = 10,
                this.aspect = t,
                this.view = null,
                this.filmGauge = 35,
                this.filmOffset = 0,
                this.updateProjectionMatrix()
            }
            copy(e, t) {
                return super.copy(e, t),
                this.fov = e.fov,
                this.zoom = e.zoom,
                this.near = e.near,
                this.far = e.far,
                this.focus = e.focus,
                this.aspect = e.aspect,
                this.view = null === e.view ? null : Object.assign({}, e.view),
                this.filmGauge = e.filmGauge,
                this.filmOffset = e.filmOffset,
                this
            }
            setFocalLength(e) {
                const t = .5 * this.getFilmHeight() / e;
                this.fov = 2 * Et * Math.atan(t),
                this.updateProjectionMatrix()
            }
            getFocalLength() {
                const e = Math.tan(.5 * bt * this.fov);
                return .5 * this.getFilmHeight() / e
            }
            getEffectiveFOV() {
                return 2 * Et * Math.atan(Math.tan(.5 * bt * this.fov) / this.zoom)
            }
            getFilmWidth() {
                return this.filmGauge * Math.min(this.aspect, 1)
            }
            getFilmHeight() {
                return this.filmGauge / Math.max(this.aspect, 1)
            }
            getViewBounds(e, t, n) {
                yr.set(-1, -1, .5).applyMatrix4(this.projectionMatrixInverse),
                t.set(yr.x, yr.y).multiplyScalar(-e / yr.z),
                yr.set(1, 1, .5).applyMatrix4(this.projectionMatrixInverse),
                n.set(yr.x, yr.y).multiplyScalar(-e / yr.z)
            }
            getViewSize(e, t) {
                return this.getViewBounds(e, xr, _r),
                t.subVectors(_r, xr)
            }
            setViewOffset(e, t, n, i, r, s) {
                this.aspect = e / t,
                null === this.view && (this.view = {
                    enabled: !0,
                    fullWidth: 1,
                    fullHeight: 1,
                    offsetX: 0,
                    offsetY: 0,
                    width: 1,
                    height: 1
                }),
                this.view.enabled = !0,
                this.view.fullWidth = e,
                this.view.fullHeight = t,
                this.view.offsetX = n,
                this.view.offsetY = i,
                this.view.width = r,
                this.view.height = s,
                this.updateProjectionMatrix()
            }
            clearViewOffset() {
                null !== this.view && (this.view.enabled = !1),
                this.updateProjectionMatrix()
            }
            updateProjectionMatrix() {
                const e = this.near;
                let t = e * Math.tan(.5 * bt * this.fov) / this.zoom
                  , n = 2 * t
                  , i = this.aspect * n
                  , r = -.5 * i;
                const s = this.view;
                if (null !== this.view && this.view.enabled) {
                    const e = s.fullWidth
                      , a = s.fullHeight;
                    r += s.offsetX * i / e,
                    t -= s.offsetY * n / a,
                    i *= s.width / e,
                    n *= s.height / a
                }
                const a = this.filmOffset;
                0 !== a && (r += e * a / this.getFilmWidth()),
                this.projectionMatrix.makePerspective(r, r + i, t, t - n, e, this.far, this.coordinateSystem),
                this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
            }
            toJSON(e) {
                const t = super.toJSON(e);
                return t.object.fov = this.fov,
                t.object.zoom = this.zoom,
                t.object.near = this.near,
                t.object.far = this.far,
                t.object.focus = this.focus,
                t.object.aspect = this.aspect,
                null !== this.view && (t.object.view = Object.assign({}, this.view)),
                t.object.filmGauge = this.filmGauge,
                t.object.filmOffset = this.filmOffset,
                t
            }
        }
        const Er = -90;
        class wr extends ui {
            constructor(e, t, n) {
                super(),
                this.type = "CubeCamera",
                this.renderTarget = n,
                this.coordinateSystem = null,
                this.activeMipmapLevel = 0;
                const i = new br(Er,1,e,t);
                i.layers = this.layers,
                this.add(i);
                const r = new br(Er,1,e,t);
                r.layers = this.layers,
                this.add(r);
                const s = new br(Er,1,e,t);
                s.layers = this.layers,
                this.add(s);
                const a = new br(Er,1,e,t);
                a.layers = this.layers,
                this.add(a);
                const o = new br(Er,1,e,t);
                o.layers = this.layers,
                this.add(o);
                const l = new br(Er,1,e,t);
                l.layers = this.layers,
                this.add(l)
            }
            updateCoordinateSystem() {
                const e = this.coordinateSystem
                  , t = this.children.concat()
                  , [n,i,r,s,a,o] = t;
                for (const e of t)
                    this.remove(e);
                if (e === mt)
                    n.up.set(0, 1, 0),
                    n.lookAt(1, 0, 0),
                    i.up.set(0, 1, 0),
                    i.lookAt(-1, 0, 0),
                    r.up.set(0, 0, -1),
                    r.lookAt(0, 1, 0),
                    s.up.set(0, 0, 1),
                    s.lookAt(0, -1, 0),
                    a.up.set(0, 1, 0),
                    a.lookAt(0, 0, 1),
                    o.up.set(0, 1, 0),
                    o.lookAt(0, 0, -1);
                else {
                    if (e !== vt)
                        throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + e);
                    n.up.set(0, -1, 0),
                    n.lookAt(-1, 0, 0),
                    i.up.set(0, -1, 0),
                    i.lookAt(1, 0, 0),
                    r.up.set(0, 0, 1),
                    r.lookAt(0, 1, 0),
                    s.up.set(0, 0, -1),
                    s.lookAt(0, -1, 0),
                    a.up.set(0, -1, 0),
                    a.lookAt(0, 0, 1),
                    o.up.set(0, -1, 0),
                    o.lookAt(0, 0, -1)
                }
                for (const e of t)
                    this.add(e),
                    e.updateMatrixWorld()
            }
            update(e, t) {
                null === this.parent && this.updateMatrixWorld();
                const {renderTarget: n, activeMipmapLevel: i} = this;
                this.coordinateSystem !== e.coordinateSystem && (this.coordinateSystem = e.coordinateSystem,
                this.updateCoordinateSystem());
                const [r,s,a,o,l,c] = this.children
                  , u = e.getRenderTarget()
                  , h = e.getActiveCubeFace()
                  , d = e.getActiveMipmapLevel()
                  , p = e.xr.enabled;
                e.xr.enabled = !1;
                const f = n.texture.generateMipmaps;
                n.texture.generateMipmaps = !1,
                e.setRenderTarget(n, 0, i),
                e.render(t, r),
                e.setRenderTarget(n, 1, i),
                e.render(t, s),
                e.setRenderTarget(n, 2, i),
                e.render(t, a),
                e.setRenderTarget(n, 3, i),
                e.render(t, o),
                e.setRenderTarget(n, 4, i),
                e.render(t, l),
                n.texture.generateMipmaps = f,
                e.setRenderTarget(n, 5, i),
                e.render(t, c),
                e.setRenderTarget(u, h, d),
                e.xr.enabled = p,
                n.texture.needsPMREMUpdate = !0
            }
        }
        class Cr extends $t {
            constructor(e, t, n, i, r, s, a, o, l, c) {
                super(e = void 0 !== e ? e : [], t = void 0 !== t ? t : D, n, i, r, s, a, o, l, c),
                this.isCubeTexture = !0,
                this.flipY = !1
            }
            get images() {
                return this.image
            }
            set images(e) {
                this.image = e
            }
        }
        class Ir extends nn {
            constructor(e=1, t={}) {
                super(e, e, t),
                this.isWebGLCubeRenderTarget = !0;
                const n = {
                    width: e,
                    height: e,
                    depth: 1
                }
                  , i = [n, n, n, n, n, n];
                this.texture = new Cr(i,t.mapping,t.wrapS,t.wrapT,t.magFilter,t.minFilter,t.format,t.type,t.anisotropy,t.colorSpace),
                this.texture.isRenderTargetTexture = !0,
                this.texture.generateMipmaps = void 0 !== t.generateMipmaps && t.generateMipmaps,
                this.texture.minFilter = void 0 !== t.minFilter ? t.minFilter : z
            }
            fromEquirectangularTexture(e, t) {
                this.texture.type = t.type,
                this.texture.colorSpace = t.colorSpace,
                this.texture.generateMipmaps = t.generateMipmaps,
                this.texture.minFilter = t.minFilter,
                this.texture.magFilter = t.magFilter;
                const n = {
                    uniforms: {
                        tEquirect: {
                            value: null
                        }
                    },
                    vertexShader: "\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t",
                    fragmentShader: "\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t"
                }
                  , i = new dr(5,5,5)
                  , r = new mr({
                    name: "CubemapFromEquirect",
                    uniforms: pr(n.uniforms),
                    vertexShader: n.vertexShader,
                    fragmentShader: n.fragmentShader,
                    side: l,
                    blending: u
                });
                r.uniforms.tEquirect.value = t;
                const s = new ur(i,r)
                  , a = t.minFilter;
                t.minFilter === W && (t.minFilter = z);
                return new wr(1,10,this).update(e, s),
                t.minFilter = a,
                s.geometry.dispose(),
                s.material.dispose(),
                this
            }
            clear(e, t, n, i) {
                const r = e.getRenderTarget();
                for (let r = 0; r < 6; r++)
                    e.setRenderTarget(this, r),
                    e.clear(t, n, i);
                e.setRenderTarget(r)
            }
        }
        const Sr = new on
          , Mr = new on
          , Tr = new Dt;
        class Br {
            constructor(e=new on(1,0,0), t=0) {
                this.isPlane = !0,
                this.normal = e,
                this.constant = t
            }
            set(e, t) {
                return this.normal.copy(e),
                this.constant = t,
                this
            }
            setComponents(e, t, n, i) {
                return this.normal.set(e, t, n),
                this.constant = i,
                this
            }
            setFromNormalAndCoplanarPoint(e, t) {
                return this.normal.copy(e),
                this.constant = -t.dot(this.normal),
                this
            }
            setFromCoplanarPoints(e, t, n) {
                const i = Sr.subVectors(n, t).cross(Mr.subVectors(e, t)).normalize();
                return this.setFromNormalAndCoplanarPoint(i, e),
                this
            }
            copy(e) {
                return this.normal.copy(e.normal),
                this.constant = e.constant,
                this
            }
            normalize() {
                const e = 1 / this.normal.length();
                return this.normal.multiplyScalar(e),
                this.constant *= e,
                this
            }
            negate() {
                return this.constant *= -1,
                this.normal.negate(),
                this
            }
            distanceToPoint(e) {
                return this.normal.dot(e) + this.constant
            }
            distanceToSphere(e) {
                return this.distanceToPoint(e.center) - e.radius
            }
            projectPoint(e, t) {
                return t.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e))
            }
            intersectLine(e, t) {
                const n = e.delta(Sr)
                  , i = this.normal.dot(n);
                if (0 === i)
                    return 0 === this.distanceToPoint(e.start) ? t.copy(e.start) : null;
                const r = -(e.start.dot(this.normal) + this.constant) / i;
                return r < 0 || r > 1 ? null : t.copy(e.start).addScaledVector(n, r)
            }
            intersectsLine(e) {
                const t = this.distanceToPoint(e.start)
                  , n = this.distanceToPoint(e.end);
                return t < 0 && n > 0 || n < 0 && t > 0
            }
            intersectsBox(e) {
                return e.intersectsPlane(this)
            }
            intersectsSphere(e) {
                return e.intersectsPlane(this)
            }
            coplanarPoint(e) {
                return e.copy(this.normal).multiplyScalar(-this.constant)
            }
            applyMatrix4(e, t) {
                const n = t || Tr.getNormalMatrix(e)
                  , i = this.coplanarPoint(Sr).applyMatrix4(e)
                  , r = this.normal.applyMatrix3(n).normalize();
                return this.constant = -i.dot(r),
                this
            }
            translate(e) {
                return this.constant -= e.dot(this.normal),
                this
            }
            equals(e) {
                return e.normal.equals(this.normal) && e.constant === this.constant
            }
            clone() {
                return (new this.constructor).copy(this)
            }
        }
        const Rr = new Mn
          , Dr = new on;
        class Pr {
            constructor(e=new Br, t=new Br, n=new Br, i=new Br, r=new Br, s=new Br) {
                this.planes = [e, t, n, i, r, s]
            }
            set(e, t, n, i, r, s) {
                const a = this.planes;
                return a[0].copy(e),
                a[1].copy(t),
                a[2].copy(n),
                a[3].copy(i),
                a[4].copy(r),
                a[5].copy(s),
                this
            }
            copy(e) {
                const t = this.planes;
                for (let n = 0; n < 6; n++)
                    t[n].copy(e.planes[n]);
                return this
            }
            setFromProjectionMatrix(e, t=2e3) {
                const n = this.planes
                  , i = e.elements
                  , r = i[0]
                  , s = i[1]
                  , a = i[2]
                  , o = i[3]
                  , l = i[4]
                  , c = i[5]
                  , u = i[6]
                  , h = i[7]
                  , d = i[8]
                  , p = i[9]
                  , f = i[10]
                  , A = i[11]
                  , g = i[12]
                  , m = i[13]
                  , v = i[14]
                  , y = i[15];
                if (n[0].setComponents(o - r, h - l, A - d, y - g).normalize(),
                n[1].setComponents(o + r, h + l, A + d, y + g).normalize(),
                n[2].setComponents(o + s, h + c, A + p, y + m).normalize(),
                n[3].setComponents(o - s, h - c, A - p, y - m).normalize(),
                n[4].setComponents(o - a, h - u, A - f, y - v).normalize(),
                t === mt)
                    n[5].setComponents(o + a, h + u, A + f, y + v).normalize();
                else {
                    if (t !== vt)
                        throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + t);
                    n[5].setComponents(a, u, f, v).normalize()
                }
                return this
            }
            intersectsObject(e) {
                if (void 0 !== e.boundingSphere)
                    null === e.boundingSphere && e.computeBoundingSphere(),
                    Rr.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);
                else {
                    const t = e.geometry;
                    null === t.boundingSphere && t.computeBoundingSphere(),
                    Rr.copy(t.boundingSphere).applyMatrix4(e.matrixWorld)
                }
                return this.intersectsSphere(Rr)
            }
            intersectsSprite(e) {
                return Rr.center.set(0, 0, 0),
                Rr.radius = .7071067811865476,
                Rr.applyMatrix4(e.matrixWorld),
                this.intersectsSphere(Rr)
            }
            intersectsSphere(e) {
                const t = this.planes
                  , n = e.center
                  , i = -e.radius;
                for (let e = 0; e < 6; e++) {
                    if (t[e].distanceToPoint(n) < i)
                        return !1
                }
                return !0
            }
            intersectsBox(e) {
                const t = this.planes;
                for (let n = 0; n < 6; n++) {
                    const i = t[n];
                    if (Dr.x = i.normal.x > 0 ? e.max.x : e.min.x,
                    Dr.y = i.normal.y > 0 ? e.max.y : e.min.y,
                    Dr.z = i.normal.z > 0 ? e.max.z : e.min.z,
                    i.distanceToPoint(Dr) < 0)
                        return !1
                }
                return !0
            }
            containsPoint(e) {
                const t = this.planes;
                for (let n = 0; n < 6; n++)
                    if (t[n].distanceToPoint(e) < 0)
                        return !1;
                return !0
            }
            clone() {
                return (new this.constructor).copy(this)
            }
        }
        function Lr() {
            let e = null
              , t = !1
              , n = null
              , i = null;
            function r(t, s) {
                n(t, s),
                i = e.requestAnimationFrame(r)
            }
            return {
                start: function() {
                    !0 !== t && null !== n && (i = e.requestAnimationFrame(r),
                    t = !0)
                },
                stop: function() {
                    e.cancelAnimationFrame(i),
                    t = !1
                },
                setAnimationLoop: function(e) {
                    n = e
                },
                setContext: function(t) {
                    e = t
                }
            }
        }
        function Ur(e) {
            const t = new WeakMap;
            return {
                get: function(e) {
                    return e.isInterleavedBufferAttribute && (e = e.data),
                    t.get(e)
                },
                remove: function(n) {
                    n.isInterleavedBufferAttribute && (n = n.data);
                    const i = t.get(n);
                    i && (e.deleteBuffer(i.buffer),
                    t.delete(n))
                },
                update: function(n, i) {
                    if (n.isInterleavedBufferAttribute && (n = n.data),
                    n.isGLBufferAttribute) {
                        const e = t.get(n);
                        return void ((!e || e.version < n.version) && t.set(n, {
                            buffer: n.buffer,
                            type: n.type,
                            bytesPerElement: n.elementSize,
                            version: n.version
                        }))
                    }
                    const r = t.get(n);
                    if (void 0 === r)
                        t.set(n, function(t, n) {
                            const i = t.array
                              , r = t.usage
                              , s = i.byteLength
                              , a = e.createBuffer();
                            let o;
                            if (e.bindBuffer(n, a),
                            e.bufferData(n, i, r),
                            t.onUploadCallback(),
                            i instanceof Float32Array)
                                o = e.FLOAT;
                            else if (i instanceof Uint16Array)
                                o = t.isFloat16BufferAttribute ? e.HALF_FLOAT : e.UNSIGNED_SHORT;
                            else if (i instanceof Int16Array)
                                o = e.SHORT;
                            else if (i instanceof Uint32Array)
                                o = e.UNSIGNED_INT;
                            else if (i instanceof Int32Array)
                                o = e.INT;
                            else if (i instanceof Int8Array)
                                o = e.BYTE;
                            else if (i instanceof Uint8Array)
                                o = e.UNSIGNED_BYTE;
                            else {
                                if (!(i instanceof Uint8ClampedArray))
                                    throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + i);
                                o = e.UNSIGNED_BYTE
                            }
                            return {
                                buffer: a,
                                type: o,
                                bytesPerElement: i.BYTES_PER_ELEMENT,
                                version: t.version,
                                size: s
                            }
                        }(n, i));
                    else if (r.version < n.version) {
                        if (r.size !== n.array.byteLength)
                            throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");
                        !function(t, n, i) {
                            const r = n.array
                              , s = n.updateRanges;
                            if (e.bindBuffer(i, t),
                            0 === s.length)
                                e.bufferSubData(i, 0, r);
                            else {
                                s.sort(( (e, t) => e.start - t.start));
                                let t = 0;
                                for (let e = 1; e < s.length; e++) {
                                    const n = s[t]
                                      , i = s[e];
                                    i.start <= n.start + n.count + 1 ? n.count = Math.max(n.count, i.start + i.count - n.start) : (++t,
                                    s[t] = i)
                                }
                                s.length = t + 1;
                                for (let t = 0, n = s.length; t < n; t++) {
                                    const n = s[t];
                                    e.bufferSubData(i, n.start * r.BYTES_PER_ELEMENT, r, n.start, n.count)
                                }
                                n.clearUpdateRanges()
                            }
                            n.onUploadCallback()
                        }(r.buffer, n, i),
                        r.version = n.version
                    }
                }
            }
        }
        class Fr extends Zi {
            constructor(e=1, t=1, n=1, i=1) {
                super(),
                this.type = "PlaneGeometry",
                this.parameters = {
                    width: e,
                    height: t,
                    widthSegments: n,
                    heightSegments: i
                };
                const r = e / 2
                  , s = t / 2
                  , a = Math.floor(n)
                  , o = Math.floor(i)
                  , l = a + 1
                  , c = o + 1
                  , u = e / a
                  , h = t / o
                  , d = []
                  , p = []
                  , f = []
                  , A = [];
                for (let e = 0; e < c; e++) {
                    const t = e * h - s;
                    for (let n = 0; n < l; n++) {
                        const i = n * u - r;
                        p.push(i, -t, 0),
                        f.push(0, 0, 1),
                        A.push(n / a),
                        A.push(1 - e / o)
                    }
                }
                for (let e = 0; e < o; e++)
                    for (let t = 0; t < a; t++) {
                        const n = t + l * e
                          , i = t + l * (e + 1)
                          , r = t + 1 + l * (e + 1)
                          , s = t + 1 + l * e;
                        d.push(n, i, s),
                        d.push(i, r, s)
                    }
                this.setIndex(d),
                this.setAttribute("position", new Vi(p,3)),
                this.setAttribute("normal", new Vi(f,3)),
                this.setAttribute("uv", new Vi(A,2))
            }
            copy(e) {
                return super.copy(e),
                this.parameters = Object.assign({}, e.parameters),
                this
            }
            static fromJSON(e) {
                return new Fr(e.width,e.height,e.widthSegments,e.heightSegments)
            }
        }
        const Nr = {
            alphahash_fragment: "#ifdef USE_ALPHAHASH\n\tif ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;\n#endif",
            alphahash_pars_fragment: "#ifdef USE_ALPHAHASH\n\tconst float ALPHA_HASH_SCALE = 0.05;\n\tfloat hash2D( vec2 value ) {\n\t\treturn fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );\n\t}\n\tfloat hash3D( vec3 value ) {\n\t\treturn hash2D( vec2( hash2D( value.xy ), value.z ) );\n\t}\n\tfloat getAlphaHashThreshold( vec3 position ) {\n\t\tfloat maxDeriv = max(\n\t\t\tlength( dFdx( position.xyz ) ),\n\t\t\tlength( dFdy( position.xyz ) )\n\t\t);\n\t\tfloat pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );\n\t\tvec2 pixScales = vec2(\n\t\t\texp2( floor( log2( pixScale ) ) ),\n\t\t\texp2( ceil( log2( pixScale ) ) )\n\t\t);\n\t\tvec2 alpha = vec2(\n\t\t\thash3D( floor( pixScales.x * position.xyz ) ),\n\t\t\thash3D( floor( pixScales.y * position.xyz ) )\n\t\t);\n\t\tfloat lerpFactor = fract( log2( pixScale ) );\n\t\tfloat x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;\n\t\tfloat a = min( lerpFactor, 1.0 - lerpFactor );\n\t\tvec3 cases = vec3(\n\t\t\tx * x / ( 2.0 * a * ( 1.0 - a ) ),\n\t\t\t( x - 0.5 * a ) / ( 1.0 - a ),\n\t\t\t1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )\n\t\t);\n\t\tfloat threshold = ( x < ( 1.0 - a ) )\n\t\t\t? ( ( x < a ) ? cases.x : cases.y )\n\t\t\t: cases.z;\n\t\treturn clamp( threshold , 1.0e-6, 1.0 );\n\t}\n#endif",
            alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;\n#endif",
            alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
            alphatest_fragment: "#ifdef USE_ALPHATEST\n\t#ifdef ALPHA_TO_COVERAGE\n\tdiffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );\n\tif ( diffuseColor.a == 0.0 ) discard;\n\t#else\n\tif ( diffuseColor.a < alphaTest ) discard;\n\t#endif\n#endif",
            alphatest_pars_fragment: "#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif",
            aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_CLEARCOAT ) \n\t\tclearcoatSpecularIndirect *= ambientOcclusion;\n\t#endif\n\t#if defined( USE_SHEEN ) \n\t\tsheenSpecularIndirect *= ambientOcclusion;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometryNormal, geometryViewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif",
            aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
            batching_pars_vertex: "#ifdef USE_BATCHING\n\t#if ! defined( GL_ANGLE_multi_draw )\n\t#define gl_DrawID _gl_DrawID\n\tuniform int _gl_DrawID;\n\t#endif\n\tuniform highp sampler2D batchingTexture;\n\tuniform highp usampler2D batchingIdTexture;\n\tmat4 getBatchingMatrix( const in float i ) {\n\t\tint size = textureSize( batchingTexture, 0 ).x;\n\t\tint j = int( i ) * 4;\n\t\tint x = j % size;\n\t\tint y = j / size;\n\t\tvec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );\n\t\tvec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );\n\t\tvec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );\n\t\tvec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );\n\t\treturn mat4( v1, v2, v3, v4 );\n\t}\n\tfloat getIndirectIndex( const in int i ) {\n\t\tint size = textureSize( batchingIdTexture, 0 ).x;\n\t\tint x = i % size;\n\t\tint y = i / size;\n\t\treturn float( texelFetch( batchingIdTexture, ivec2( x, y ), 0 ).r );\n\t}\n#endif\n#ifdef USE_BATCHING_COLOR\n\tuniform sampler2D batchingColorTexture;\n\tvec3 getBatchingColor( const in float i ) {\n\t\tint size = textureSize( batchingColorTexture, 0 ).x;\n\t\tint j = int( i );\n\t\tint x = j % size;\n\t\tint y = j / size;\n\t\treturn texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;\n\t}\n#endif",
            batching_vertex: "#ifdef USE_BATCHING\n\tmat4 batchingMatrix = getBatchingMatrix( getIndirectIndex( gl_DrawID ) );\n#endif",
            begin_vertex: "vec3 transformed = vec3( position );\n#ifdef USE_ALPHAHASH\n\tvPosition = vec3( position );\n#endif",
            beginnormal_vertex: "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",
            bsdfs: "float G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n} // validated",
            iridescence_fragment: "#ifdef USE_IRIDESCENCE\n\tconst mat3 XYZ_TO_REC709 = mat3(\n\t\t 3.2404542, -0.9692660,  0.0556434,\n\t\t-1.5371385,  1.8760108, -0.2040259,\n\t\t-0.4985314,  0.0415560,  1.0572252\n\t);\n\tvec3 Fresnel0ToIor( vec3 fresnel0 ) {\n\t\tvec3 sqrtF0 = sqrt( fresnel0 );\n\t\treturn ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n\t}\n\tvec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n\t}\n\tfloat IorToFresnel0( float transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));\n\t}\n\tvec3 evalSensitivity( float OPD, vec3 shift ) {\n\t\tfloat phase = 2.0 * PI * OPD * 1.0e-9;\n\t\tvec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n\t\tvec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n\t\tvec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n\t\tvec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );\n\t\txyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );\n\t\txyz /= 1.0685e-7;\n\t\tvec3 rgb = XYZ_TO_REC709 * xyz;\n\t\treturn rgb;\n\t}\n\tvec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n\t\tvec3 I;\n\t\tfloat iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n\t\tfloat sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\n\t\tfloat cosTheta2Sq = 1.0 - sinTheta2Sq;\n\t\tif ( cosTheta2Sq < 0.0 ) {\n\t\t\treturn vec3( 1.0 );\n\t\t}\n\t\tfloat cosTheta2 = sqrt( cosTheta2Sq );\n\t\tfloat R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\n\t\tfloat R12 = F_Schlick( R0, 1.0, cosTheta1 );\n\t\tfloat T121 = 1.0 - R12;\n\t\tfloat phi12 = 0.0;\n\t\tif ( iridescenceIOR < outsideIOR ) phi12 = PI;\n\t\tfloat phi21 = PI - phi12;\n\t\tvec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );\t\tvec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );\n\t\tvec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );\n\t\tvec3 phi23 = vec3( 0.0 );\n\t\tif ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;\n\t\tif ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;\n\t\tif ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;\n\t\tfloat OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\n\t\tvec3 phi = vec3( phi21 ) + phi23;\n\t\tvec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\n\t\tvec3 r123 = sqrt( R123 );\n\t\tvec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n\t\tvec3 C0 = R12 + Rs;\n\t\tI = C0;\n\t\tvec3 Cm = Rs - T121;\n\t\tfor ( int m = 1; m <= 2; ++ m ) {\n\t\t\tCm *= r123;\n\t\t\tvec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n\t\t\tI += Cm * Sm;\n\t\t}\n\t\treturn max( I, vec3( 0.0 ) );\n\t}\n#endif",
            bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vBumpMapUv );\n\t\tvec2 dSTdy = dFdy( vBumpMapUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );\n\t\tvec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",
            clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#ifdef ALPHA_TO_COVERAGE\n\t\tfloat distanceToPlane, distanceGradient;\n\t\tfloat clipOpacity = 1.0;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tdistanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;\n\t\t\tdistanceGradient = fwidth( distanceToPlane ) / 2.0;\n\t\t\tclipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );\n\t\t\tif ( clipOpacity == 0.0 ) discard;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\t\tfloat unionClipOpacity = 1.0;\n\t\t\t#pragma unroll_loop_start\n\t\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\t\tplane = clippingPlanes[ i ];\n\t\t\t\tdistanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;\n\t\t\t\tdistanceGradient = fwidth( distanceToPlane ) / 2.0;\n\t\t\t\tunionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );\n\t\t\t}\n\t\t\t#pragma unroll_loop_end\n\t\t\tclipOpacity *= 1.0 - unionClipOpacity;\n\t\t#endif\n\t\tdiffuseColor.a *= clipOpacity;\n\t\tif ( diffuseColor.a == 0.0 ) discard;\n\t#else\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\t\tbool clipped = true;\n\t\t\t#pragma unroll_loop_start\n\t\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\t\tplane = clippingPlanes[ i ];\n\t\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t\t}\n\t\t\t#pragma unroll_loop_end\n\t\t\tif ( clipped ) discard;\n\t\t#endif\n\t#endif\n#endif",
            clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
            clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif",
            clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif",
            color_fragment: "#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif",
            color_pars_fragment: "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif",
            color_pars_vertex: "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )\n\tvarying vec3 vColor;\n#endif",
            color_vertex: "#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif\n#ifdef USE_BATCHING_COLOR\n\tvec3 batchingColor = getBatchingColor( getIndirectIndex( gl_DrawID ) );\n\tvColor.xyz *= batchingColor.xyz;\n#endif",
            common: "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\n#ifdef USE_ALPHAHASH\n\tvarying vec3 vPosition;\n#endif\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\nvec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n} // validated",
            cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\thighp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tuv.x += filterInt * 3.0 * cubeUV_minTileSize;\n\t\tuv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n\t\tuv.x *= CUBEUV_TEXEL_WIDTH;\n\t\tuv.y *= CUBEUV_TEXEL_HEIGHT;\n\t\t#ifdef texture2DGradEXT\n\t\t\treturn texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n\t\t#else\n\t\t\treturn texture2D( envMap, uv ).rgb;\n\t\t#endif\n\t}\n\t#define cubeUV_r0 1.0\n\t#define cubeUV_m0 - 2.0\n\t#define cubeUV_r1 0.8\n\t#define cubeUV_m1 - 1.0\n\t#define cubeUV_r4 0.4\n\t#define cubeUV_m4 2.0\n\t#define cubeUV_r5 0.305\n\t#define cubeUV_m5 3.0\n\t#define cubeUV_r6 0.21\n\t#define cubeUV_m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= cubeUV_r1 ) {\n\t\t\tmip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;\n\t\t} else if ( roughness >= cubeUV_r4 ) {\n\t\t\tmip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;\n\t\t} else if ( roughness >= cubeUV_r5 ) {\n\t\t\tmip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;\n\t\t} else if ( roughness >= cubeUV_r6 ) {\n\t\t\tmip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif",
            defaultnormal_vertex: "vec3 transformedNormal = objectNormal;\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = objectTangent;\n#endif\n#ifdef USE_BATCHING\n\tmat3 bm = mat3( batchingMatrix );\n\ttransformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );\n\ttransformedNormal = bm * transformedNormal;\n\t#ifdef USE_TANGENT\n\t\ttransformedTangent = bm * transformedTangent;\n\t#endif\n#endif\n#ifdef USE_INSTANCING\n\tmat3 im = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );\n\ttransformedNormal = im * transformedNormal;\n\t#ifdef USE_TANGENT\n\t\ttransformedTangent = im * transformedTangent;\n\t#endif\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\ttransformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",
            displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",
            displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );\n#endif",
            emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );\n\t#ifdef DECODE_VIDEO_TEXTURE_EMISSIVE\n\t\temissiveColor = sRGBTransferEOTF( emissiveColor );\n\t#endif\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
            emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",
            colorspace_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );",
            colorspace_pars_fragment: "vec4 LinearTransferOETF( in vec4 value ) {\n\treturn value;\n}\nvec4 sRGBTransferEOTF( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 sRGBTransferOETF( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}",
            envmap_fragment: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",
            envmap_common_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform mat3 envMapRotation;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",
            envmap_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",
            envmap_pars_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",
            envmap_physical_pars_fragment: "#ifdef USE_ENVMAP\n\tvec3 getIBLIrradiance( const in vec3 normal ) {\n\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\tvec3 reflectVec = reflect( - viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\t#ifdef USE_ANISOTROPY\n\t\tvec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {\n\t\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\t\tvec3 bentNormal = cross( bitangent, viewDir );\n\t\t\t\tbentNormal = normalize( cross( bentNormal, bitangent ) );\n\t\t\t\tbentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );\n\t\t\t\treturn getIBLRadiance( viewDir, bentNormal, roughness );\n\t\t\t#else\n\t\t\t\treturn vec3( 0.0 );\n\t\t\t#endif\n\t\t}\n\t#endif\n#endif",
            envmap_vertex: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",
            fog_vertex: "#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif",
            fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif",
            fog_fragment: "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
            fog_pars_fragment: "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
            gradientmap_pars_fragment: "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn vec3( texture2D( gradientMap, coord ).r );\n\t#else\n\t\tvec2 fw = fwidth( coord ) * 0.5;\n\t\treturn mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );\n\t#endif\n}",
            lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
            lights_lambert_fragment: "LambertMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularStrength = specularStrength;",
            lights_lambert_pars_fragment: "varying vec3 vViewPosition;\nstruct LambertMaterial {\n\tvec3 diffuseColor;\n\tfloat specularStrength;\n};\nvoid RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Lambert\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Lambert",
            lights_pars_begin: "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\n#if defined( USE_LIGHT_PROBES )\n\tuniform vec3 lightProbe[ 9 ];\n#endif\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif ( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometryPosition;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometryPosition;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif",
            lights_toon_fragment: "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",
            lights_toon_pars_fragment: "varying vec3 vViewPosition;\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon",
            lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
            lights_phong_pars_fragment: "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong",
            lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n\tmaterial.ior = ior;\n\t#ifdef USE_SPECULAR\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularColorFactor = specularColor;\n\t\t#ifdef USE_SPECULAR_COLORMAP\n\t\t\tspecularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;\n\t\t#endif\n\t\t#ifdef USE_SPECULAR_INTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;\n\t\t#endif\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\t#else\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularColorFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\t#endif\n\tmaterial.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_DISPERSION\n\tmaterial.dispersion = dispersion;\n#endif\n#ifdef USE_IRIDESCENCE\n\tmaterial.iridescence = iridescence;\n\tmaterial.iridescenceIOR = iridescenceIOR;\n\t#ifdef USE_IRIDESCENCEMAP\n\t\tmaterial.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;\n\t#endif\n\t#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\t\tmaterial.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;\n\t#else\n\t\tmaterial.iridescenceThickness = iridescenceThicknessMaximum;\n\t#endif\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheenColor;\n\t#ifdef USE_SHEEN_COLORMAP\n\t\tmaterial.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;\n\t#endif\n\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n\t#ifdef USE_SHEEN_ROUGHNESSMAP\n\t\tmaterial.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;\n\t#endif\n#endif\n#ifdef USE_ANISOTROPY\n\t#ifdef USE_ANISOTROPYMAP\n\t\tmat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );\n\t\tvec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;\n\t\tvec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;\n\t#else\n\t\tvec2 anisotropyV = anisotropyVector;\n\t#endif\n\tmaterial.anisotropy = length( anisotropyV );\n\tif( material.anisotropy == 0.0 ) {\n\t\tanisotropyV = vec2( 1.0, 0.0 );\n\t} else {\n\t\tanisotropyV /= material.anisotropy;\n\t\tmaterial.anisotropy = saturate( material.anisotropy );\n\t}\n\tmaterial.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );\n\tmaterial.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;\n\tmaterial.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;\n#endif",
            lights_physical_pars_fragment: "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\tfloat dispersion;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_IRIDESCENCE\n\t\tfloat iridescence;\n\t\tfloat iridescenceIOR;\n\t\tfloat iridescenceThickness;\n\t\tvec3 iridescenceFresnel;\n\t\tvec3 iridescenceF0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\t#endif\n\t#ifdef IOR\n\t\tfloat ior;\n\t#endif\n\t#ifdef USE_TRANSMISSION\n\t\tfloat transmission;\n\t\tfloat transmissionAlpha;\n\t\tfloat thickness;\n\t\tfloat attenuationDistance;\n\t\tvec3 attenuationColor;\n\t#endif\n\t#ifdef USE_ANISOTROPY\n\t\tfloat anisotropy;\n\t\tfloat alphaT;\n\t\tvec3 anisotropyT;\n\t\tvec3 anisotropyB;\n\t#endif\n};\nvec3 clearcoatSpecularDirect = vec3( 0.0 );\nvec3 clearcoatSpecularIndirect = vec3( 0.0 );\nvec3 sheenSpecularDirect = vec3( 0.0 );\nvec3 sheenSpecularIndirect = vec3(0.0 );\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\n#ifdef USE_ANISOTROPY\n\tfloat V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {\n\t\tfloat gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );\n\t\tfloat gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );\n\t\tfloat v = 0.5 / ( gv + gl );\n\t\treturn saturate(v);\n\t}\n\tfloat D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {\n\t\tfloat a2 = alphaT * alphaB;\n\t\thighp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );\n\t\thighp float v2 = dot( v, v );\n\t\tfloat w2 = a2 / v2;\n\t\treturn RECIPROCAL_PI * a2 * pow2 ( w2 );\n\t}\n#endif\n#ifdef USE_CLEARCOAT\n\tvec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {\n\t\tvec3 f0 = material.clearcoatF0;\n\t\tfloat f90 = material.clearcoatF90;\n\t\tfloat roughness = material.clearcoatRoughness;\n\t\tfloat alpha = pow2( roughness );\n\t\tvec3 halfDir = normalize( lightDir + viewDir );\n\t\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\t\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\t\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\t\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\t\tvec3 F = F_Schlick( f0, f90, dotVH );\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t\treturn F * ( V * D );\n\t}\n#endif\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {\n\tvec3 f0 = material.specularColor;\n\tfloat f90 = material.specularF90;\n\tfloat roughness = material.roughness;\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\t#ifdef USE_IRIDESCENCE\n\t\tF = mix( F, material.iridescenceFresnel, material.iridescence );\n\t#endif\n\t#ifdef USE_ANISOTROPY\n\t\tfloat dotTL = dot( material.anisotropyT, lightDir );\n\t\tfloat dotTV = dot( material.anisotropyT, viewDir );\n\t\tfloat dotTH = dot( material.anisotropyT, halfDir );\n\t\tfloat dotBL = dot( material.anisotropyB, lightDir );\n\t\tfloat dotBV = dot( material.anisotropyB, viewDir );\n\t\tfloat dotBH = dot( material.anisotropyB, halfDir );\n\t\tfloat V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );\n\t\tfloat D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );\n\t#else\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t#endif\n\treturn F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat r2 = roughness * roughness;\n\tfloat a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n\tfloat b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n\tfloat DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n\treturn saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\treturn fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\n#ifdef USE_IRIDESCENCE\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#else\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#endif\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\t#ifdef USE_IRIDESCENCE\n\t\tvec3 Fr = mix( specularColor, iridescenceF0, iridescence );\n\t#else\n\t\tvec3 Fr = specularColor;\n\t#endif\n\tvec3 FssEss = Fr * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometryNormal;\n\t\tvec3 viewDir = geometryViewDir;\n\t\tvec3 position = geometryPosition;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );\n\t#endif\n\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\t#ifdef USE_IRIDESCENCE\n\t\tcomputeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );\n\t#else\n\t\tcomputeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\t#endif\n\tvec3 totalScattering = singleScattering + multiScattering;\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
            lights_fragment_begin: "\nvec3 geometryPosition = - vViewPosition;\nvec3 geometryNormal = normal;\nvec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\nvec3 geometryClearcoatNormal = vec3( 0.0 );\n#ifdef USE_CLEARCOAT\n\tgeometryClearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\n\tfloat dotNVi = saturate( dot( normal, geometryViewDir ) );\n\tif ( material.iridescenceThickness == 0.0 ) {\n\t\tmaterial.iridescence = 0.0;\n\t} else {\n\t\tmaterial.iridescence = saturate( material.iridescence );\n\t}\n\tif ( material.iridescence > 0.0 ) {\n\t\tmaterial.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n\t\tmaterial.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n\t}\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointLightInfo( pointLight, geometryPosition, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tvec4 spotColor;\n\tvec3 spotLightCoord;\n\tbool inSpotLightMap;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotLightInfo( spotLight, geometryPosition, directLight );\n\t\t#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX\n\t\t#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS\n\t\t#else\n\t\t#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#endif\n\t\t#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )\n\t\t\tspotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;\n\t\t\tinSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );\n\t\t\tspotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );\n\t\t\tdirectLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;\n\t\t#endif\n\t\t#undef SPOT_LIGHT_MAP_INDEX\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#if defined( USE_LIGHT_PROBES )\n\t\tirradiance += getLightProbeIrradiance( lightProbe, geometryNormal );\n\t#endif\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",
            lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\t\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometryNormal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\t#ifdef USE_ANISOTROPY\n\t\tradiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );\n\t#else\n\t\tradiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif",
            lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n#endif",
            logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF )\n\tgl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
            logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",
            logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",
            logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n\tvFragDepth = 1.0 + gl_Position.w;\n\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n#endif",
            map_fragment: "#ifdef USE_MAP\n\tvec4 sampledDiffuseColor = texture2D( map, vMapUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tsampledDiffuseColor = sRGBTransferEOTF( sampledDiffuseColor );\n\t#endif\n\tdiffuseColor *= sampledDiffuseColor;\n#endif",
            map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",
            map_particle_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\t#if defined( USE_POINTS_UV )\n\t\tvec2 uv = vUv;\n\t#else\n\t\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\t#endif\n#endif\n#ifdef USE_MAP\n\tdiffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",
            map_particle_pars_fragment: "#if defined( USE_POINTS_UV )\n\tvarying vec2 vUv;\n#else\n\t#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\t\tuniform mat3 uvTransform;\n\t#endif\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
            metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",
            metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
            morphinstance_vertex: "#ifdef USE_INSTANCING_MORPH\n\tfloat morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\tfloat morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\tmorphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;\n\t}\n#endif",
            morphcolor_vertex: "#if defined( USE_MORPHCOLORS )\n\tvColor *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t#if defined( USE_COLOR_ALPHA )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\t\t#elif defined( USE_COLOR )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\t\t#endif\n\t}\n#endif",
            morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\t}\n#endif",
            morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n\t#ifndef USE_INSTANCING_MORPH\n\t\tuniform float morphTargetBaseInfluence;\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t#endif\n\tuniform sampler2DArray morphTargetsTexture;\n\tuniform ivec2 morphTargetsTextureSize;\n\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\t\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n\t\tint y = texelIndex / morphTargetsTextureSize.x;\n\t\tint x = texelIndex - y * morphTargetsTextureSize.x;\n\t\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\n\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\n\t}\n#endif",
            morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\t}\n#endif",
            normal_fragment_begin: "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = dFdx( vViewPosition );\n\tvec3 fdy = dFdy( vViewPosition );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal *= faceDirection;\n\t#endif\n#endif\n#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )\n\t#ifdef USE_TANGENT\n\t\tmat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n\t#else\n\t\tmat3 tbn = getTangentFrame( - vViewPosition, normal,\n\t\t#if defined( USE_NORMALMAP )\n\t\t\tvNormalMapUv\n\t\t#elif defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tvClearcoatNormalMapUv\n\t\t#else\n\t\t\tvUv\n\t\t#endif\n\t\t);\n\t#endif\n\t#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n\t\ttbn[0] *= faceDirection;\n\t\ttbn[1] *= faceDirection;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\t#ifdef USE_TANGENT\n\t\tmat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n\t#else\n\t\tmat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );\n\t#endif\n\t#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n\t\ttbn2[0] *= faceDirection;\n\t\ttbn2[1] *= faceDirection;\n\t#endif\n#endif\nvec3 nonPerturbedNormal = normal;",
            normal_fragment_maps: "#ifdef USE_NORMALMAP_OBJECTSPACE\n\tnormal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( USE_NORMALMAP_TANGENTSPACE )\n\tvec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\tnormal = normalize( tbn * mapN );\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif",
            normal_pars_fragment: "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",
            normal_pars_vertex: "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",
            normal_vertex: "#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif",
            normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef USE_NORMALMAP_OBJECTSPACE\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )\n\tmat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( uv.st );\n\t\tvec2 st1 = dFdy( uv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );\n\t\treturn mat3( T * scale, B * scale, N );\n\t}\n#endif",
            clearcoat_normal_fragment_begin: "#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal = nonPerturbedNormal;\n#endif",
            clearcoat_normal_fragment_maps: "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\tclearcoatNormal = normalize( tbn2 * clearcoatMapN );\n#endif",
            clearcoat_pars_fragment: "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif",
            iridescence_pars_fragment: "#ifdef USE_IRIDESCENCEMAP\n\tuniform sampler2D iridescenceMap;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform sampler2D iridescenceThicknessMap;\n#endif",
            opaque_fragment: "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= material.transmissionAlpha;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );",
            packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;const float ShiftRight8 = 1. / 256.;\nconst float Inv255 = 1. / 255.;\nconst vec4 PackFactors = vec4( 1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0 );\nconst vec2 UnpackFactors2 = vec2( UnpackDownscale, 1.0 / PackFactors.g );\nconst vec3 UnpackFactors3 = vec3( UnpackDownscale / PackFactors.rg, 1.0 / PackFactors.b );\nconst vec4 UnpackFactors4 = vec4( UnpackDownscale / PackFactors.rgb, 1.0 / PackFactors.a );\nvec4 packDepthToRGBA( const in float v ) {\n\tif( v <= 0.0 )\n\t\treturn vec4( 0., 0., 0., 0. );\n\tif( v >= 1.0 )\n\t\treturn vec4( 1., 1., 1., 1. );\n\tfloat vuf;\n\tfloat af = modf( v * PackFactors.a, vuf );\n\tfloat bf = modf( vuf * ShiftRight8, vuf );\n\tfloat gf = modf( vuf * ShiftRight8, vuf );\n\treturn vec4( vuf * Inv255, gf * PackUpscale, bf * PackUpscale, af );\n}\nvec3 packDepthToRGB( const in float v ) {\n\tif( v <= 0.0 )\n\t\treturn vec3( 0., 0., 0. );\n\tif( v >= 1.0 )\n\t\treturn vec3( 1., 1., 1. );\n\tfloat vuf;\n\tfloat bf = modf( v * PackFactors.b, vuf );\n\tfloat gf = modf( vuf * ShiftRight8, vuf );\n\treturn vec3( vuf * Inv255, gf * PackUpscale, bf );\n}\nvec2 packDepthToRG( const in float v ) {\n\tif( v <= 0.0 )\n\t\treturn vec2( 0., 0. );\n\tif( v >= 1.0 )\n\t\treturn vec2( 1., 1. );\n\tfloat vuf;\n\tfloat gf = modf( v * 256., vuf );\n\treturn vec2( vuf * Inv255, gf );\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors4 );\n}\nfloat unpackRGBToDepth( const in vec3 v ) {\n\treturn dot( v, UnpackFactors3 );\n}\nfloat unpackRGToDepth( const in vec2 v ) {\n\treturn v.r * UnpackFactors2.r + v.g * UnpackFactors2.g;\n}\nvec4 pack2HalfToRGBA( const in vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( const in vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {\n\treturn depth * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * depth - far );\n}",
            premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",
            project_vertex: "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_BATCHING\n\tmvPosition = batchingMatrix * mvPosition;\n#endif\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",
            dithering_fragment: "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
            dithering_pars_fragment: "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",
            roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",
            roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
            shadowmap_pars_fragment: "#if NUM_SPOT_LIGHT_COORDS > 0\n\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#if NUM_SPOT_LIGHT_MAPS > 0\n\tuniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;\n\t\tbool frustumTest = inFrustum && shadowCoord.z <= 1.0;\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn mix( 1.0, shadow, shadowIntensity );\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tfloat shadow = 1.0;\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\t\n\t\tfloat lightToPositionLength = length( lightToPosition );\n\t\tif ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {\n\t\t\tfloat dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\t\tdp += shadowBias;\n\t\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\t\tshadow = (\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t\t) * ( 1.0 / 9.0 );\n\t\t\t#else\n\t\t\t\tshadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t\t#endif\n\t\t}\n\t\treturn mix( 1.0, shadow, shadowIntensity );\n\t}\n#endif",
            shadowmap_pars_vertex: "#if NUM_SPOT_LIGHT_COORDS > 0\n\tuniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];\n\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",
            shadowmap_vertex: "#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )\n\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\tvec4 shadowWorldPosition;\n#endif\n#if defined( USE_SHADOWMAP )\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if NUM_SPOT_LIGHT_COORDS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition;\n\t\t#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t\tshadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;\n\t\t#endif\n\t\tvSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n#endif",
            shadowmask_pars_fragment: "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowIntensity, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowIntensity, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowIntensity, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",
            skinbase_vertex: "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
            skinning_pars_vertex: "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\tuniform highp sampler2D boneTexture;\n\tmat4 getBoneMatrix( const in float i ) {\n\t\tint size = textureSize( boneTexture, 0 ).x;\n\t\tint j = int( i ) * 4;\n\t\tint x = j % size;\n\t\tint y = j / size;\n\t\tvec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );\n\t\tvec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );\n\t\tvec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );\n\t\tvec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );\n\t\treturn mat4( v1, v2, v3, v4 );\n\t}\n#endif",
            skinning_vertex: "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
            skinnormal_vertex: "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",
            specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
            specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
            tonemapping_fragment: "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
            tonemapping_pars_fragment: "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn saturate( toneMappingExposure * color );\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 CineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nconst mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(\n\tvec3( 1.6605, - 0.1246, - 0.0182 ),\n\tvec3( - 0.5876, 1.1329, - 0.1006 ),\n\tvec3( - 0.0728, - 0.0083, 1.1187 )\n);\nconst mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(\n\tvec3( 0.6274, 0.0691, 0.0164 ),\n\tvec3( 0.3293, 0.9195, 0.0880 ),\n\tvec3( 0.0433, 0.0113, 0.8956 )\n);\nvec3 agxDefaultContrastApprox( vec3 x ) {\n\tvec3 x2 = x * x;\n\tvec3 x4 = x2 * x2;\n\treturn + 15.5 * x4 * x2\n\t\t- 40.14 * x4 * x\n\t\t+ 31.96 * x4\n\t\t- 6.868 * x2 * x\n\t\t+ 0.4298 * x2\n\t\t+ 0.1191 * x\n\t\t- 0.00232;\n}\nvec3 AgXToneMapping( vec3 color ) {\n\tconst mat3 AgXInsetMatrix = mat3(\n\t\tvec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),\n\t\tvec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),\n\t\tvec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )\n\t);\n\tconst mat3 AgXOutsetMatrix = mat3(\n\t\tvec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),\n\t\tvec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),\n\t\tvec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )\n\t);\n\tconst float AgxMinEv = - 12.47393;\tconst float AgxMaxEv = 4.026069;\n\tcolor *= toneMappingExposure;\n\tcolor = LINEAR_SRGB_TO_LINEAR_REC2020 * color;\n\tcolor = AgXInsetMatrix * color;\n\tcolor = max( color, 1e-10 );\tcolor = log2( color );\n\tcolor = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );\n\tcolor = clamp( color, 0.0, 1.0 );\n\tcolor = agxDefaultContrastApprox( color );\n\tcolor = AgXOutsetMatrix * color;\n\tcolor = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );\n\tcolor = LINEAR_REC2020_TO_LINEAR_SRGB * color;\n\tcolor = clamp( color, 0.0, 1.0 );\n\treturn color;\n}\nvec3 NeutralToneMapping( vec3 color ) {\n\tconst float StartCompression = 0.8 - 0.04;\n\tconst float Desaturation = 0.15;\n\tcolor *= toneMappingExposure;\n\tfloat x = min( color.r, min( color.g, color.b ) );\n\tfloat offset = x < 0.08 ? x - 6.25 * x * x : 0.04;\n\tcolor -= offset;\n\tfloat peak = max( color.r, max( color.g, color.b ) );\n\tif ( peak < StartCompression ) return color;\n\tfloat d = 1. - StartCompression;\n\tfloat newPeak = 1. - d * d / ( peak + d - StartCompression );\n\tcolor *= newPeak / peak;\n\tfloat g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );\n\treturn mix( color, vec3( newPeak ), g );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",
            transmission_fragment: "#ifdef USE_TRANSMISSION\n\tmaterial.transmission = transmission;\n\tmaterial.transmissionAlpha = 1.0;\n\tmaterial.thickness = thickness;\n\tmaterial.attenuationDistance = attenuationDistance;\n\tmaterial.attenuationColor = attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tmaterial.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tmaterial.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tvec4 transmitted = getIBLVolumeRefraction(\n\t\tn, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,\n\t\tmaterial.attenuationColor, material.attenuationDistance );\n\tmaterial.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );\n\ttotalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );\n#endif",
            transmission_pars_fragment: "#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec3 vWorldPosition;\n\tfloat w0( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );\n\t}\n\tfloat w1( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );\n\t}\n\tfloat w2( float a ){\n\t\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );\n\t}\n\tfloat w3( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a * a * a );\n\t}\n\tfloat g0( float a ) {\n\t\treturn w0( a ) + w1( a );\n\t}\n\tfloat g1( float a ) {\n\t\treturn w2( a ) + w3( a );\n\t}\n\tfloat h0( float a ) {\n\t\treturn - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );\n\t}\n\tfloat h1( float a ) {\n\t\treturn 1.0 + w3( a ) / ( w2( a ) + w3( a ) );\n\t}\n\tvec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {\n\t\tuv = uv * texelSize.zw + 0.5;\n\t\tvec2 iuv = floor( uv );\n\t\tvec2 fuv = fract( uv );\n\t\tfloat g0x = g0( fuv.x );\n\t\tfloat g1x = g1( fuv.x );\n\t\tfloat h0x = h0( fuv.x );\n\t\tfloat h1x = h1( fuv.x );\n\t\tfloat h0y = h0( fuv.y );\n\t\tfloat h1y = h1( fuv.y );\n\t\tvec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n\t\treturn g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +\n\t\t\tg1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );\n\t}\n\tvec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {\n\t\tvec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );\n\t\tvec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );\n\t\tvec2 fLodSizeInv = 1.0 / fLodSize;\n\t\tvec2 cLodSizeInv = 1.0 / cLodSize;\n\t\tvec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );\n\t\tvec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );\n\t\treturn mix( fSample, cSample, fract( lod ) );\n\t}\n\tvec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness( const in float roughness, const in float ior ) {\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t}\n\tvec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n\t\tfloat lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\treturn textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );\n\t}\n\tvec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tif ( isinf( attenuationDistance ) ) {\n\t\t\treturn vec3( 1.0 );\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance;\n\t\t}\n\t}\n\tvec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n\t\tconst in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n\t\tconst in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,\n\t\tconst in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tvec4 transmittedLight;\n\t\tvec3 transmittance;\n\t\t#ifdef USE_DISPERSION\n\t\t\tfloat halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;\n\t\t\tvec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );\n\t\t\tfor ( int i = 0; i < 3; i ++ ) {\n\t\t\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );\n\t\t\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\t\n\t\t\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\t\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\t\t\trefractionCoords += 1.0;\n\t\t\t\trefractionCoords /= 2.0;\n\t\t\n\t\t\t\tvec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );\n\t\t\t\ttransmittedLight[ i ] = transmissionSample[ i ];\n\t\t\t\ttransmittedLight.a += transmissionSample.a;\n\t\t\t\ttransmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];\n\t\t\t}\n\t\t\ttransmittedLight.a /= 3.0;\n\t\t\n\t\t#else\n\t\t\n\t\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\t\trefractionCoords += 1.0;\n\t\t\trefractionCoords /= 2.0;\n\t\t\ttransmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\t\ttransmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\t\n\t\t#endif\n\t\tvec3 attenuatedColor = transmittance * transmittedLight.rgb;\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\t\tfloat transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );\n\t}\n#endif",
            uv_pars_fragment: "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvarying vec2 vUv;\n#endif\n#ifdef USE_MAP\n\tvarying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n\tvarying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n\tvarying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n\tvarying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n\tvarying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n\tvarying vec2 vNormalMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tvarying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n\tvarying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tvarying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tvarying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tvarying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tvarying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tvarying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tvarying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tvarying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tvarying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tvarying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n\tvarying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tvarying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tvarying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tuniform mat3 transmissionMapTransform;\n\tvarying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n\tuniform mat3 thicknessMapTransform;\n\tvarying vec2 vThicknessMapUv;\n#endif",
            uv_pars_vertex: "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvarying vec2 vUv;\n#endif\n#ifdef USE_MAP\n\tuniform mat3 mapTransform;\n\tvarying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform mat3 alphaMapTransform;\n\tvarying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n\tuniform mat3 lightMapTransform;\n\tvarying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n\tuniform mat3 aoMapTransform;\n\tvarying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n\tuniform mat3 bumpMapTransform;\n\tvarying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n\tuniform mat3 normalMapTransform;\n\tvarying vec2 vNormalMapUv;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\tuniform mat3 displacementMapTransform;\n\tvarying vec2 vDisplacementMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tuniform mat3 emissiveMapTransform;\n\tvarying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n\tuniform mat3 metalnessMapTransform;\n\tvarying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tuniform mat3 roughnessMapTransform;\n\tvarying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tuniform mat3 anisotropyMapTransform;\n\tvarying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tuniform mat3 clearcoatMapTransform;\n\tvarying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform mat3 clearcoatNormalMapTransform;\n\tvarying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform mat3 clearcoatRoughnessMapTransform;\n\tvarying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tuniform mat3 sheenColorMapTransform;\n\tvarying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tuniform mat3 sheenRoughnessMapTransform;\n\tvarying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tuniform mat3 iridescenceMapTransform;\n\tvarying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform mat3 iridescenceThicknessMapTransform;\n\tvarying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n\tuniform mat3 specularMapTransform;\n\tvarying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tuniform mat3 specularColorMapTransform;\n\tvarying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tuniform mat3 specularIntensityMapTransform;\n\tvarying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tuniform mat3 transmissionMapTransform;\n\tvarying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n\tuniform mat3 thicknessMapTransform;\n\tvarying vec2 vThicknessMapUv;\n#endif",
            uv_vertex: "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvUv = vec3( uv, 1 ).xy;\n#endif\n#ifdef USE_MAP\n\tvMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ALPHAMAP\n\tvAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_LIGHTMAP\n\tvLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_AOMAP\n\tvAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_BUMPMAP\n\tvBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_NORMALMAP\n\tvNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\tvDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tvEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_METALNESSMAP\n\tvMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tvRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tvAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tvClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tvClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tvClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tvIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tvIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tvSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tvSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULARMAP\n\tvSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tvSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tvSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tvTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_THICKNESSMAP\n\tvThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;\n#endif",
            worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_BATCHING\n\t\tworldPosition = batchingMatrix * worldPosition;\n\t#endif\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",
            background_vert: "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
            background_frag: "uniform sampler2D t2D;\nuniform float backgroundIntensity;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\ttexColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );\n\t#endif\n\ttexColor.rgb *= backgroundIntensity;\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
            backgroundCube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
            backgroundCube_frag: "#ifdef ENVMAP_TYPE_CUBE\n\tuniform samplerCube envMap;\n#elif defined( ENVMAP_TYPE_CUBE_UV )\n\tuniform sampler2D envMap;\n#endif\nuniform float flipEnvMap;\nuniform float backgroundBlurriness;\nuniform float backgroundIntensity;\nuniform mat3 backgroundRotation;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );\n\t#else\n\t\tvec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t#endif\n\ttexColor.rgb *= backgroundIntensity;\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
            cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
            cube_frag: "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n\tvec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n\tgl_FragColor = texColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
            depth_vert: "#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <skinbase_vertex>\n\t#include <morphinstance_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",
            depth_frag: "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <clipping_planes_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#elif DEPTH_PACKING == 3202\n\t\tgl_FragColor = vec4( packDepthToRGB( fragCoordZ ), 1.0 );\n\t#elif DEPTH_PACKING == 3203\n\t\tgl_FragColor = vec4( packDepthToRG( fragCoordZ ), 0.0, 1.0 );\n\t#endif\n}",
            distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <skinbase_vertex>\n\t#include <morphinstance_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",
            distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <clipping_planes_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",
            equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
            equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
            linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
            linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
            meshbasic_vert: "#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",
            meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
            meshlambert_vert: "#define LAMBERT\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
            meshlambert_frag: "#define LAMBERT\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_lambert_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_lambert_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
            meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",
            meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t#else\n\t\tvec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
            meshnormal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",
            meshnormal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );\n\t#ifdef OPAQUE\n\t\tgl_FragColor.a = 1.0;\n\t#endif\n}",
            meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
            meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
            meshphysical_vert: "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}",
            meshphysical_frag: "#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define USE_SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef USE_SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularColor;\n\t#ifdef USE_SPECULAR_COLORMAP\n\t\tuniform sampler2D specularColorMap;\n\t#endif\n\t#ifdef USE_SPECULAR_INTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_DISPERSION\n\tuniform float dispersion;\n#endif\n#ifdef USE_IRIDESCENCE\n\tuniform float iridescence;\n\tuniform float iridescenceIOR;\n\tuniform float iridescenceThicknessMinimum;\n\tuniform float iridescenceThicknessMaximum;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenColor;\n\tuniform float sheenRoughness;\n\t#ifdef USE_SHEEN_COLORMAP\n\t\tuniform sampler2D sheenColorMap;\n\t#endif\n\t#ifdef USE_SHEEN_ROUGHNESSMAP\n\t\tuniform sampler2D sheenRoughnessMap;\n\t#endif\n#endif\n#ifdef USE_ANISOTROPY\n\tuniform vec2 anisotropyVector;\n\t#ifdef USE_ANISOTROPYMAP\n\t\tuniform sampler2D anisotropyMap;\n\t#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_SHEEN\n\t\tfloat sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n\t\toutgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;\n\t#endif\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
            meshtoon_vert: "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
            meshtoon_frag: "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
            points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n#ifdef USE_POINTS_UV\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif\nvoid main() {\n\t#ifdef USE_POINTS_UV\n\t\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\t#endif\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
            points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
            shadow_vert: "#include <common>\n#include <batching_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
            shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <logdepthbuf_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n}",
            sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix[ 3 ];\n\tvec2 scale = vec2( length( modelMatrix[ 0 ].xyz ), length( modelMatrix[ 1 ].xyz ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
            sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n}"
        }
          , Or = {
            common: {
                diffuse: {
                    value: new Ti(16777215)
                },
                opacity: {
                    value: 1
                },
                map: {
                    value: null
                },
                mapTransform: {
                    value: new Dt
                },
                alphaMap: {
                    value: null
                },
                alphaMapTransform: {
                    value: new Dt
                },
                alphaTest: {
                    value: 0
                }
            },
            specularmap: {
                specularMap: {
                    value: null
                },
                specularMapTransform: {
                    value: new Dt
                }
            },
            envmap: {
                envMap: {
                    value: null
                },
                envMapRotation: {
                    value: new Dt
                },
                flipEnvMap: {
                    value: -1
                },
                reflectivity: {
                    value: 1
                },
                ior: {
                    value: 1.5
                },
                refractionRatio: {
                    value: .98
                }
            },
            aomap: {
                aoMap: {
                    value: null
                },
                aoMapIntensity: {
                    value: 1
                },
                aoMapTransform: {
                    value: new Dt
                }
            },
            lightmap: {
                lightMap: {
                    value: null
                },
                lightMapIntensity: {
                    value: 1
                },
                lightMapTransform: {
                    value: new Dt
                }
            },
            bumpmap: {
                bumpMap: {
                    value: null
                },
                bumpMapTransform: {
                    value: new Dt
                },
                bumpScale: {
                    value: 1
                }
            },
            normalmap: {
                normalMap: {
                    value: null
                },
                normalMapTransform: {
                    value: new Dt
                },
                normalScale: {
                    value: new Rt(1,1)
                }
            },
            displacementmap: {
                displacementMap: {
                    value: null
                },
                displacementMapTransform: {
                    value: new Dt
                },
                displacementScale: {
                    value: 1
                },
                displacementBias: {
                    value: 0
                }
            },
            emissivemap: {
                emissiveMap: {
                    value: null
                },
                emissiveMapTransform: {
                    value: new Dt
                }
            },
            metalnessmap: {
                metalnessMap: {
                    value: null
                },
                metalnessMapTransform: {
                    value: new Dt
                }
            },
            roughnessmap: {
                roughnessMap: {
                    value: null
                },
                roughnessMapTransform: {
                    value: new Dt
                }
            },
            gradientmap: {
                gradientMap: {
                    value: null
                }
            },
            fog: {
                fogDensity: {
                    value: 25e-5
                },
                fogNear: {
                    value: 1
                },
                fogFar: {
                    value: 2e3
                },
                fogColor: {
                    value: new Ti(16777215)
                }
            },
            lights: {
                ambientLightColor: {
                    value: []
                },
                lightProbe: {
                    value: []
                },
                directionalLights: {
                    value: [],
                    properties: {
                        direction: {},
                        color: {}
                    }
                },
                directionalLightShadows: {
                    value: [],
                    properties: {
                        shadowIntensity: 1,
                        shadowBias: {},
                        shadowNormalBias: {},
                        shadowRadius: {},
                        shadowMapSize: {}
                    }
                },
                directionalShadowMap: {
                    value: []
                },
                directionalShadowMatrix: {
                    value: []
                },
                spotLights: {
                    value: [],
                    properties: {
                        color: {},
                        position: {},
                        direction: {},
                        distance: {},
                        coneCos: {},
                        penumbraCos: {},
                        decay: {}
                    }
                },
                spotLightShadows: {
                    value: [],
                    properties: {
                        shadowIntensity: 1,
                        shadowBias: {},
                        shadowNormalBias: {},
                        shadowRadius: {},
                        shadowMapSize: {}
                    }
                },
                spotLightMap: {
                    value: []
                },
                spotShadowMap: {
                    value: []
                },
                spotLightMatrix: {
                    value: []
                },
                pointLights: {
                    value: [],
                    properties: {
                        color: {},
                        position: {},
                        decay: {},
                        distance: {}
                    }
                },
                pointLightShadows: {
                    value: [],
                    properties: {
                        shadowIntensity: 1,
                        shadowBias: {},
                        shadowNormalBias: {},
                        shadowRadius: {},
                        shadowMapSize: {},
                        shadowCameraNear: {},
                        shadowCameraFar: {}
                    }
                },
                pointShadowMap: {
                    value: []
                },
                pointShadowMatrix: {
                    value: []
                },
                hemisphereLights: {
                    value: [],
                    properties: {
                        direction: {},
                        skyColor: {},
                        groundColor: {}
                    }
                },
                rectAreaLights: {
                    value: [],
                    properties: {
                        color: {},
                        position: {},
                        width: {},
                        height: {}
                    }
                },
                ltc_1: {
                    value: null
                },
                ltc_2: {
                    value: null
                }
            },
            points: {
                diffuse: {
                    value: new Ti(16777215)
                },
                opacity: {
                    value: 1
                },
                size: {
                    value: 1
                },
                scale: {
                    value: 1
                },
                map: {
                    value: null
                },
                alphaMap: {
                    value: null
                },
                alphaMapTransform: {
                    value: new Dt
                },
                alphaTest: {
                    value: 0
                },
                uvTransform: {
                    value: new Dt
                }
            },
            sprite: {
                diffuse: {
                    value: new Ti(16777215)
                },
                opacity: {
                    value: 1
                },
                center: {
                    value: new Rt(.5,.5)
                },
                rotation: {
                    value: 0
                },
                map: {
                    value: null
                },
                mapTransform: {
                    value: new Dt
                },
                alphaMap: {
                    value: null
                },
                alphaMapTransform: {
                    value: new Dt
                },
                alphaTest: {
                    value: 0
                }
            }
        }
          , Qr = {
            basic: {
                uniforms: fr([Or.common, Or.specularmap, Or.envmap, Or.aomap, Or.lightmap, Or.fog]),
                vertexShader: Nr.meshbasic_vert,
                fragmentShader: Nr.meshbasic_frag
            },
            lambert: {
                uniforms: fr([Or.common, Or.specularmap, Or.envmap, Or.aomap, Or.lightmap, Or.emissivemap, Or.bumpmap, Or.normalmap, Or.displacementmap, Or.fog, Or.lights, {
                    emissive: {
                        value: new Ti(0)
                    }
                }]),
                vertexShader: Nr.meshlambert_vert,
                fragmentShader: Nr.meshlambert_frag
            },
            phong: {
                uniforms: fr([Or.common, Or.specularmap, Or.envmap, Or.aomap, Or.lightmap, Or.emissivemap, Or.bumpmap, Or.normalmap, Or.displacementmap, Or.fog, Or.lights, {
                    emissive: {
                        value: new Ti(0)
                    },
                    specular: {
                        value: new Ti(1118481)
                    },
                    shininess: {
                        value: 30
                    }
                }]),
                vertexShader: Nr.meshphong_vert,
                fragmentShader: Nr.meshphong_frag
            },
            standard: {
                uniforms: fr([Or.common, Or.envmap, Or.aomap, Or.lightmap, Or.emissivemap, Or.bumpmap, Or.normalmap, Or.displacementmap, Or.roughnessmap, Or.metalnessmap, Or.fog, Or.lights, {
                    emissive: {
                        value: new Ti(0)
                    },
                    roughness: {
                        value: 1
                    },
                    metalness: {
                        value: 0
                    },
                    envMapIntensity: {
                        value: 1
                    }
                }]),
                vertexShader: Nr.meshphysical_vert,
                fragmentShader: Nr.meshphysical_frag
            },
            toon: {
                uniforms: fr([Or.common, Or.aomap, Or.lightmap, Or.emissivemap, Or.bumpmap, Or.normalmap, Or.displacementmap, Or.gradientmap, Or.fog, Or.lights, {
                    emissive: {
                        value: new Ti(0)
                    }
                }]),
                vertexShader: Nr.meshtoon_vert,
                fragmentShader: Nr.meshtoon_frag
            },
            matcap: {
                uniforms: fr([Or.common, Or.bumpmap, Or.normalmap, Or.displacementmap, Or.fog, {
                    matcap: {
                        value: null
                    }
                }]),
                vertexShader: Nr.meshmatcap_vert,
                fragmentShader: Nr.meshmatcap_frag
            },
            points: {
                uniforms: fr([Or.points, Or.fog]),
                vertexShader: Nr.points_vert,
                fragmentShader: Nr.points_frag
            },
            dashed: {
                uniforms: fr([Or.common, Or.fog, {
                    scale: {
                        value: 1
                    },
                    dashSize: {
                        value: 1
                    },
                    totalSize: {
                        value: 2
                    }
                }]),
                vertexShader: Nr.linedashed_vert,
                fragmentShader: Nr.linedashed_frag
            },
            depth: {
                uniforms: fr([Or.common, Or.displacementmap]),
                vertexShader: Nr.depth_vert,
                fragmentShader: Nr.depth_frag
            },
            normal: {
                uniforms: fr([Or.common, Or.bumpmap, Or.normalmap, Or.displacementmap, {
                    opacity: {
                        value: 1
                    }
                }]),
                vertexShader: Nr.meshnormal_vert,
                fragmentShader: Nr.meshnormal_frag
            },
            sprite: {
                uniforms: fr([Or.sprite, Or.fog]),
                vertexShader: Nr.sprite_vert,
                fragmentShader: Nr.sprite_frag
            },
            background: {
                uniforms: {
                    uvTransform: {
                        value: new Dt
                    },
                    t2D: {
                        value: null
                    },
                    backgroundIntensity: {
                        value: 1
                    }
                },
                vertexShader: Nr.background_vert,
                fragmentShader: Nr.background_frag
            },
            backgroundCube: {
                uniforms: {
                    envMap: {
                        value: null
                    },
                    flipEnvMap: {
                        value: -1
                    },
                    backgroundBlurriness: {
                        value: 0
                    },
                    backgroundIntensity: {
                        value: 1
                    },
                    backgroundRotation: {
                        value: new Dt
                    }
                },
                vertexShader: Nr.backgroundCube_vert,
                fragmentShader: Nr.backgroundCube_frag
            },
            cube: {
                uniforms: {
                    tCube: {
                        value: null
                    },
                    tFlip: {
                        value: -1
                    },
                    opacity: {
                        value: 1
                    }
                },
                vertexShader: Nr.cube_vert,
                fragmentShader: Nr.cube_frag
            },
            equirect: {
                uniforms: {
                    tEquirect: {
                        value: null
                    }
                },
                vertexShader: Nr.equirect_vert,
                fragmentShader: Nr.equirect_frag
            },
            distanceRGBA: {
                uniforms: fr([Or.common, Or.displacementmap, {
                    referencePosition: {
                        value: new on
                    },
                    nearDistance: {
                        value: 1
                    },
                    farDistance: {
                        value: 1e3
                    }
                }]),
                vertexShader: Nr.distanceRGBA_vert,
                fragmentShader: Nr.distanceRGBA_frag
            },
            shadow: {
                uniforms: fr([Or.lights, Or.fog, {
                    color: {
                        value: new Ti(0)
                    },
                    opacity: {
                        value: 1
                    }
                }]),
                vertexShader: Nr.shadow_vert,
                fragmentShader: Nr.shadow_frag
            }
        };
        Qr.physical = {
            uniforms: fr([Qr.standard.uniforms, {
                clearcoat: {
                    value: 0
                },
                clearcoatMap: {
                    value: null
                },
                clearcoatMapTransform: {
                    value: new Dt
                },
                clearcoatNormalMap: {
                    value: null
                },
                clearcoatNormalMapTransform: {
                    value: new Dt
                },
                clearcoatNormalScale: {
                    value: new Rt(1,1)
                },
                clearcoatRoughness: {
                    value: 0
                },
                clearcoatRoughnessMap: {
                    value: null
                },
                clearcoatRoughnessMapTransform: {
                    value: new Dt
                },
                dispersion: {
                    value: 0
                },
                iridescence: {
                    value: 0
                },
                iridescenceMap: {
                    value: null
                },
                iridescenceMapTransform: {
                    value: new Dt
                },
                iridescenceIOR: {
                    value: 1.3
                },
                iridescenceThicknessMinimum: {
                    value: 100
                },
                iridescenceThicknessMaximum: {
                    value: 400
                },
                iridescenceThicknessMap: {
                    value: null
                },
                iridescenceThicknessMapTransform: {
                    value: new Dt
                },
                sheen: {
                    value: 0
                },
                sheenColor: {
                    value: new Ti(0)
                },
                sheenColorMap: {
                    value: null
                },
                sheenColorMapTransform: {
                    value: new Dt
                },
                sheenRoughness: {
                    value: 1
                },
                sheenRoughnessMap: {
                    value: null
                },
                sheenRoughnessMapTransform: {
                    value: new Dt
                },
                transmission: {
                    value: 0
                },
                transmissionMap: {
                    value: null
                },
                transmissionMapTransform: {
                    value: new Dt
                },
                transmissionSamplerSize: {
                    value: new Rt
                },
                transmissionSamplerMap: {
                    value: null
                },
                thickness: {
                    value: 0
                },
                thicknessMap: {
                    value: null
                },
                thicknessMapTransform: {
                    value: new Dt
                },
                attenuationDistance: {
                    value: 0
                },
                attenuationColor: {
                    value: new Ti(0)
                },
                specularColor: {
                    value: new Ti(1,1,1)
                },
                specularColorMap: {
                    value: null
                },
                specularColorMapTransform: {
                    value: new Dt
                },
                specularIntensity: {
                    value: 1
                },
                specularIntensityMap: {
                    value: null
                },
                specularIntensityMapTransform: {
                    value: new Dt
                },
                anisotropyVector: {
                    value: new Rt
                },
                anisotropyMap: {
                    value: null
                },
                anisotropyMapTransform: {
                    value: new Dt
                }
            }]),
            vertexShader: Nr.meshphysical_vert,
            fragmentShader: Nr.meshphysical_frag
        };
        const kr = {
            r: 0,
            b: 0,
            g: 0
        }
          , Gr = new qn
          , Hr = new Nn;
        function zr(e, t, n, i, r, s, a) {
            const c = new Ti(0);
            let u, h, d = !0 === s ? 0 : 1, p = null, f = 0, A = null;
            function g(e) {
                let i = !0 === e.isScene ? e.background : null;
                if (i && i.isTexture) {
                    i = (e.backgroundBlurriness > 0 ? n : t).get(i)
                }
                return i
            }
            function m(t, n) {
                t.getRGB(kr, Ar(e)),
                i.buffers.color.setClear(kr.r, kr.g, kr.b, n, a)
            }
            return {
                getClearColor: function() {
                    return c
                },
                setClearColor: function(e, t=1) {
                    c.set(e),
                    d = t,
                    m(c, d)
                },
                getClearAlpha: function() {
                    return d
                },
                setClearAlpha: function(e) {
                    d = e,
                    m(c, d)
                },
                render: function(t) {
                    let n = !1;
                    const r = g(t);
                    null === r ? m(c, d) : r && r.isColor && (m(r, 1),
                    n = !0);
                    const s = e.xr.getEnvironmentBlendMode();
                    "additive" === s ? i.buffers.color.setClear(0, 0, 0, 1, a) : "alpha-blend" === s && i.buffers.color.setClear(0, 0, 0, 0, a),
                    (e.autoClear || n) && (i.buffers.depth.setTest(!0),
                    i.buffers.depth.setMask(!0),
                    i.buffers.color.setMask(!0),
                    e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil))
                },
                addToRenderList: function(t, n) {
                    const i = g(n);
                    i && (i.isCubeTexture || i.mapping === F) ? (void 0 === h && (h = new ur(new dr(1,1,1),new mr({
                        name: "BackgroundCubeMaterial",
                        uniforms: pr(Qr.backgroundCube.uniforms),
                        vertexShader: Qr.backgroundCube.vertexShader,
                        fragmentShader: Qr.backgroundCube.fragmentShader,
                        side: l,
                        depthTest: !1,
                        depthWrite: !1,
                        fog: !1
                    })),
                    h.geometry.deleteAttribute("normal"),
                    h.geometry.deleteAttribute("uv"),
                    h.onBeforeRender = function(e, t, n) {
                        this.matrixWorld.copyPosition(n.matrixWorld)
                    }
                    ,
                    Object.defineProperty(h.material, "envMap", {
                        get: function() {
                            return this.uniforms.envMap.value
                        }
                    }),
                    r.update(h)),
                    Gr.copy(n.backgroundRotation),
                    Gr.x *= -1,
                    Gr.y *= -1,
                    Gr.z *= -1,
                    i.isCubeTexture && !1 === i.isRenderTargetTexture && (Gr.y *= -1,
                    Gr.z *= -1),
                    h.material.uniforms.envMap.value = i,
                    h.material.uniforms.flipEnvMap.value = i.isCubeTexture && !1 === i.isRenderTargetTexture ? -1 : 1,
                    h.material.uniforms.backgroundBlurriness.value = n.backgroundBlurriness,
                    h.material.uniforms.backgroundIntensity.value = n.backgroundIntensity,
                    h.material.uniforms.backgroundRotation.value.setFromMatrix4(Hr.makeRotationFromEuler(Gr)),
                    h.material.toneMapped = Qt.getTransfer(i.colorSpace) !== dt,
                    p === i && f === i.version && A === e.toneMapping || (h.material.needsUpdate = !0,
                    p = i,
                    f = i.version,
                    A = e.toneMapping),
                    h.layers.enableAll(),
                    t.unshift(h, h.geometry, h.material, 0, 0, null)) : i && i.isTexture && (void 0 === u && (u = new ur(new Fr(2,2),new mr({
                        name: "BackgroundMaterial",
                        uniforms: pr(Qr.background.uniforms),
                        vertexShader: Qr.background.vertexShader,
                        fragmentShader: Qr.background.fragmentShader,
                        side: o,
                        depthTest: !1,
                        depthWrite: !1,
                        fog: !1
                    })),
                    u.geometry.deleteAttribute("normal"),
                    Object.defineProperty(u.material, "map", {
                        get: function() {
                            return this.uniforms.t2D.value
                        }
                    }),
                    r.update(u)),
                    u.material.uniforms.t2D.value = i,
                    u.material.uniforms.backgroundIntensity.value = n.backgroundIntensity,
                    u.material.toneMapped = Qt.getTransfer(i.colorSpace) !== dt,
                    !0 === i.matrixAutoUpdate && i.updateMatrix(),
                    u.material.uniforms.uvTransform.value.copy(i.matrix),
                    p === i && f === i.version && A === e.toneMapping || (u.material.needsUpdate = !0,
                    p = i,
                    f = i.version,
                    A = e.toneMapping),
                    u.layers.enableAll(),
                    t.unshift(u, u.geometry, u.material, 0, 0, null))
                }
            }
        }
        function Vr(e, t) {
            const n = e.getParameter(e.MAX_VERTEX_ATTRIBS)
              , i = {}
              , r = c(null);
            let s = r
              , a = !1;
            function o(t) {
                return e.bindVertexArray(t)
            }
            function l(t) {
                return e.deleteVertexArray(t)
            }
            function c(e) {
                const t = []
                  , i = []
                  , r = [];
                for (let e = 0; e < n; e++)
                    t[e] = 0,
                    i[e] = 0,
                    r[e] = 0;
                return {
                    geometry: null,
                    program: null,
                    wireframe: !1,
                    newAttributes: t,
                    enabledAttributes: i,
                    attributeDivisors: r,
                    object: e,
                    attributes: {},
                    index: null
                }
            }
            function u() {
                const e = s.newAttributes;
                for (let t = 0, n = e.length; t < n; t++)
                    e[t] = 0
            }
            function h(e) {
                d(e, 0)
            }
            function d(t, n) {
                const i = s.newAttributes
                  , r = s.enabledAttributes
                  , a = s.attributeDivisors;
                i[t] = 1,
                0 === r[t] && (e.enableVertexAttribArray(t),
                r[t] = 1),
                a[t] !== n && (e.vertexAttribDivisor(t, n),
                a[t] = n)
            }
            function p() {
                const t = s.newAttributes
                  , n = s.enabledAttributes;
                for (let i = 0, r = n.length; i < r; i++)
                    n[i] !== t[i] && (e.disableVertexAttribArray(i),
                    n[i] = 0)
            }
            function f(t, n, i, r, s, a, o) {
                !0 === o ? e.vertexAttribIPointer(t, n, i, s, a) : e.vertexAttribPointer(t, n, i, r, s, a)
            }
            function A() {
                g(),
                a = !0,
                s !== r && (s = r,
                o(s.object))
            }
            function g() {
                r.geometry = null,
                r.program = null,
                r.wireframe = !1
            }
            return {
                setup: function(n, r, l, A, g) {
                    let m = !1;
                    const v = function(t, n, r) {
                        const s = !0 === r.wireframe;
                        let a = i[t.id];
                        void 0 === a && (a = {},
                        i[t.id] = a);
                        let o = a[n.id];
                        void 0 === o && (o = {},
                        a[n.id] = o);
                        let l = o[s];
                        void 0 === l && (l = c(e.createVertexArray()),
                        o[s] = l);
                        return l
                    }(A, l, r);
                    s !== v && (s = v,
                    o(s.object)),
                    m = function(e, t, n, i) {
                        const r = s.attributes
                          , a = t.attributes;
                        let o = 0;
                        const l = n.getAttributes();
                        for (const t in l) {
                            if (l[t].location >= 0) {
                                const n = r[t];
                                let i = a[t];
                                if (void 0 === i && ("instanceMatrix" === t && e.instanceMatrix && (i = e.instanceMatrix),
                                "instanceColor" === t && e.instanceColor && (i = e.instanceColor)),
                                void 0 === n)
                                    return !0;
                                if (n.attribute !== i)
                                    return !0;
                                if (i && n.data !== i.data)
                                    return !0;
                                o++
                            }
                        }
                        return s.attributesNum !== o || s.index !== i
                    }(n, A, l, g),
                    m && function(e, t, n, i) {
                        const r = {}
                          , a = t.attributes;
                        let o = 0;
                        const l = n.getAttributes();
                        for (const t in l) {
                            if (l[t].location >= 0) {
                                let n = a[t];
                                void 0 === n && ("instanceMatrix" === t && e.instanceMatrix && (n = e.instanceMatrix),
                                "instanceColor" === t && e.instanceColor && (n = e.instanceColor));
                                const i = {};
                                i.attribute = n,
                                n && n.data && (i.data = n.data),
                                r[t] = i,
                                o++
                            }
                        }
                        s.attributes = r,
                        s.attributesNum = o,
                        s.index = i
                    }(n, A, l, g),
                    null !== g && t.update(g, e.ELEMENT_ARRAY_BUFFER),
                    (m || a) && (a = !1,
                    function(n, i, r, s) {
                        u();
                        const a = s.attributes
                          , o = r.getAttributes()
                          , l = i.defaultAttributeValues;
                        for (const i in o) {
                            const r = o[i];
                            if (r.location >= 0) {
                                let o = a[i];
                                if (void 0 === o && ("instanceMatrix" === i && n.instanceMatrix && (o = n.instanceMatrix),
                                "instanceColor" === i && n.instanceColor && (o = n.instanceColor)),
                                void 0 !== o) {
                                    const i = o.normalized
                                      , a = o.itemSize
                                      , l = t.get(o);
                                    if (void 0 === l)
                                        continue;
                                    const c = l.buffer
                                      , u = l.type
                                      , p = l.bytesPerElement
                                      , A = u === e.INT || u === e.UNSIGNED_INT || o.gpuType === K;
                                    if (o.isInterleavedBufferAttribute) {
                                        const t = o.data
                                          , l = t.stride
                                          , g = o.offset;
                                        if (t.isInstancedInterleavedBuffer) {
                                            for (let e = 0; e < r.locationSize; e++)
                                                d(r.location + e, t.meshPerAttribute);
                                            !0 !== n.isInstancedMesh && void 0 === s._maxInstanceCount && (s._maxInstanceCount = t.meshPerAttribute * t.count)
                                        } else
                                            for (let e = 0; e < r.locationSize; e++)
                                                h(r.location + e);
                                        e.bindBuffer(e.ARRAY_BUFFER, c);
                                        for (let e = 0; e < r.locationSize; e++)
                                            f(r.location + e, a / r.locationSize, u, i, l * p, (g + a / r.locationSize * e) * p, A)
                                    } else {
                                        if (o.isInstancedBufferAttribute) {
                                            for (let e = 0; e < r.locationSize; e++)
                                                d(r.location + e, o.meshPerAttribute);
                                            !0 !== n.isInstancedMesh && void 0 === s._maxInstanceCount && (s._maxInstanceCount = o.meshPerAttribute * o.count)
                                        } else
                                            for (let e = 0; e < r.locationSize; e++)
                                                h(r.location + e);
                                        e.bindBuffer(e.ARRAY_BUFFER, c);
                                        for (let e = 0; e < r.locationSize; e++)
                                            f(r.location + e, a / r.locationSize, u, i, a * p, a / r.locationSize * e * p, A)
                                    }
                                } else if (void 0 !== l) {
                                    const t = l[i];
                                    if (void 0 !== t)
                                        switch (t.length) {
                                        case 2:
                                            e.vertexAttrib2fv(r.location, t);
                                            break;
                                        case 3:
                                            e.vertexAttrib3fv(r.location, t);
                                            break;
                                        case 4:
                                            e.vertexAttrib4fv(r.location, t);
                                            break;
                                        default:
                                            e.vertexAttrib1fv(r.location, t)
                                        }
                                }
                            }
                        }
                        p()
                    }(n, r, l, A),
                    null !== g && e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, t.get(g).buffer))
                },
                reset: A,
                resetDefaultState: g,
                dispose: function() {
                    A();
                    for (const e in i) {
                        const t = i[e];
                        for (const e in t) {
                            const n = t[e];
                            for (const e in n)
                                l(n[e].object),
                                delete n[e];
                            delete t[e]
                        }
                        delete i[e]
                    }
                },
                releaseStatesOfGeometry: function(e) {
                    if (void 0 === i[e.id])
                        return;
                    const t = i[e.id];
                    for (const e in t) {
                        const n = t[e];
                        for (const e in n)
                            l(n[e].object),
                            delete n[e];
                        delete t[e]
                    }
                    delete i[e.id]
                },
                releaseStatesOfProgram: function(e) {
                    for (const t in i) {
                        const n = i[t];
                        if (void 0 === n[e.id])
                            continue;
                        const r = n[e.id];
                        for (const e in r)
                            l(r[e].object),
                            delete r[e];
                        delete n[e.id]
                    }
                },
                initAttributes: u,
                enableAttribute: h,
                disableUnusedAttributes: p
            }
        }
        function Wr(e, t, n) {
            let i;
            function r(t, r, s) {
                0 !== s && (e.drawArraysInstanced(i, t, r, s),
                n.update(r, i, s))
            }
            this.setMode = function(e) {
                i = e
            }
            ,
            this.render = function(t, r) {
                e.drawArrays(i, t, r),
                n.update(r, i, 1)
            }
            ,
            this.renderInstances = r,
            this.renderMultiDraw = function(e, r, s) {
                if (0 === s)
                    return;
                t.get("WEBGL_multi_draw").multiDrawArraysWEBGL(i, e, 0, r, 0, s);
                let a = 0;
                for (let e = 0; e < s; e++)
                    a += r[e];
                n.update(a, i, 1)
            }
            ,
            this.renderMultiDrawInstances = function(e, s, a, o) {
                if (0 === a)
                    return;
                const l = t.get("WEBGL_multi_draw");
                if (null === l)
                    for (let t = 0; t < e.length; t++)
                        r(e[t], s[t], o[t]);
                else {
                    l.multiDrawArraysInstancedWEBGL(i, e, 0, s, 0, o, 0, a);
                    let t = 0;
                    for (let e = 0; e < a; e++)
                        t += s[e] * o[e];
                    n.update(t, i, 1)
                }
            }
        }
        function jr(e, t, n, i) {
            let r;
            function s(t) {
                if ("highp" === t) {
                    if (e.getShaderPrecisionFormat(e.VERTEX_SHADER, e.HIGH_FLOAT).precision > 0 && e.getShaderPrecisionFormat(e.FRAGMENT_SHADER, e.HIGH_FLOAT).precision > 0)
                        return "highp";
                    t = "mediump"
                }
                return "mediump" === t && e.getShaderPrecisionFormat(e.VERTEX_SHADER, e.MEDIUM_FLOAT).precision > 0 && e.getShaderPrecisionFormat(e.FRAGMENT_SHADER, e.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp"
            }
            let a = void 0 !== n.precision ? n.precision : "highp";
            const o = s(a);
            o !== a && (console.warn("THREE.WebGLRenderer:", a, "not supported, using", o, "instead."),
            a = o);
            const l = !0 === n.logarithmicDepthBuffer
              , c = !0 === n.reverseDepthBuffer && t.has("EXT_clip_control")
              , u = e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS)
              , h = e.getParameter(e.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
            return {
                isWebGL2: !0,
                getMaxAnisotropy: function() {
                    if (void 0 !== r)
                        return r;
                    if (!0 === t.has("EXT_texture_filter_anisotropic")) {
                        const n = t.get("EXT_texture_filter_anisotropic");
                        r = e.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
                    } else
                        r = 0;
                    return r
                },
                getMaxPrecision: s,
                textureFormatReadable: function(t) {
                    return t === ae || i.convert(t) === e.getParameter(e.IMPLEMENTATION_COLOR_READ_FORMAT)
                },
                textureTypeReadable: function(n) {
                    const r = n === $ && (t.has("EXT_color_buffer_half_float") || t.has("EXT_color_buffer_float"));
                    return !(n !== j && i.convert(n) !== e.getParameter(e.IMPLEMENTATION_COLOR_READ_TYPE) && n !== Z && !r)
                },
                precision: a,
                logarithmicDepthBuffer: l,
                reverseDepthBuffer: c,
                maxTextures: u,
                maxVertexTextures: h,
                maxTextureSize: e.getParameter(e.MAX_TEXTURE_SIZE),
                maxCubemapSize: e.getParameter(e.MAX_CUBE_MAP_TEXTURE_SIZE),
                maxAttributes: e.getParameter(e.MAX_VERTEX_ATTRIBS),
                maxVertexUniforms: e.getParameter(e.MAX_VERTEX_UNIFORM_VECTORS),
                maxVaryings: e.getParameter(e.MAX_VARYING_VECTORS),
                maxFragmentUniforms: e.getParameter(e.MAX_FRAGMENT_UNIFORM_VECTORS),
                vertexTextures: h > 0,
                maxSamples: e.getParameter(e.MAX_SAMPLES)
            }
        }
        function qr(e) {
            const t = this;
            let n = null
              , i = 0
              , r = !1
              , s = !1;
            const a = new Br
              , o = new Dt
              , l = {
                value: null,
                needsUpdate: !1
            };
            function c(e, n, i, r) {
                const s = null !== e ? e.length : 0;
                let c = null;
                if (0 !== s) {
                    if (c = l.value,
                    !0 !== r || null === c) {
                        const t = i + 4 * s
                          , r = n.matrixWorldInverse;
                        o.getNormalMatrix(r),
                        (null === c || c.length < t) && (c = new Float32Array(t));
                        for (let t = 0, n = i; t !== s; ++t,
                        n += 4)
                            a.copy(e[t]).applyMatrix4(r, o),
                            a.normal.toArray(c, n),
                            c[n + 3] = a.constant
                    }
                    l.value = c,
                    l.needsUpdate = !0
                }
                return t.numPlanes = s,
                t.numIntersection = 0,
                c
            }
            this.uniform = l,
            this.numPlanes = 0,
            this.numIntersection = 0,
            this.init = function(e, t) {
                const n = 0 !== e.length || t || 0 !== i || r;
                return r = t,
                i = e.length,
                n
            }
            ,
            this.beginShadows = function() {
                s = !0,
                c(null)
            }
            ,
            this.endShadows = function() {
                s = !1
            }
            ,
            this.setGlobalState = function(e, t) {
                n = c(e, t, 0)
            }
            ,
            this.setState = function(a, o, u) {
                const h = a.clippingPlanes
                  , d = a.clipIntersection
                  , p = a.clipShadows
                  , f = e.get(a);
                if (!r || null === h || 0 === h.length || s && !p)
                    s ? c(null) : function() {
                        l.value !== n && (l.value = n,
                        l.needsUpdate = i > 0);
                        t.numPlanes = i,
                        t.numIntersection = 0
                    }();
                else {
                    const e = s ? 0 : i
                      , t = 4 * e;
                    let r = f.clippingState || null;
                    l.value = r,
                    r = c(h, o, t, u);
                    for (let e = 0; e !== t; ++e)
                        r[e] = n[e];
                    f.clippingState = r,
                    this.numIntersection = d ? this.numPlanes : 0,
                    this.numPlanes += e
                }
            }
        }
        function Yr(e) {
            let t = new WeakMap;
            function n(e, t) {
                return t === L ? e.mapping = D : t === U && (e.mapping = P),
                e
            }
            function i(e) {
                const n = e.target;
                n.removeEventListener("dispose", i);
                const r = t.get(n);
                void 0 !== r && (t.delete(n),
                r.dispose())
            }
            return {
                get: function(r) {
                    if (r && r.isTexture) {
                        const s = r.mapping;
                        if (s === L || s === U) {
                            if (t.has(r)) {
                                return n(t.get(r).texture, r.mapping)
                            }
                            {
                                const s = r.image;
                                if (s && s.height > 0) {
                                    const a = new Ir(s.height);
                                    return a.fromEquirectangularTexture(e, r),
                                    t.set(r, a),
                                    r.addEventListener("dispose", i),
                                    n(a.texture, r.mapping)
                                }
                                return null
                            }
                        }
                    }
                    return r
                },
                dispose: function() {
                    t = new WeakMap
                }
            }
        }
        class Xr extends vr {
            constructor(e=-1, t=1, n=1, i=-1, r=.1, s=2e3) {
                super(),
                this.isOrthographicCamera = !0,
                this.type = "OrthographicCamera",
                this.zoom = 1,
                this.view = null,
                this.left = e,
                this.right = t,
                this.top = n,
                this.bottom = i,
                this.near = r,
                this.far = s,
                this.updateProjectionMatrix()
            }
            copy(e, t) {
                return super.copy(e, t),
                this.left = e.left,
                this.right = e.right,
                this.top = e.top,
                this.bottom = e.bottom,
                this.near = e.near,
                this.far = e.far,
                this.zoom = e.zoom,
                this.view = null === e.view ? null : Object.assign({}, e.view),
                this
            }
            setViewOffset(e, t, n, i, r, s) {
                null === this.view && (this.view = {
                    enabled: !0,
                    fullWidth: 1,
                    fullHeight: 1,
                    offsetX: 0,
                    offsetY: 0,
                    width: 1,
                    height: 1
                }),
                this.view.enabled = !0,
                this.view.fullWidth = e,
                this.view.fullHeight = t,
                this.view.offsetX = n,
                this.view.offsetY = i,
                this.view.width = r,
                this.view.height = s,
                this.updateProjectionMatrix()
            }
            clearViewOffset() {
                null !== this.view && (this.view.enabled = !1),
                this.updateProjectionMatrix()
            }
            updateProjectionMatrix() {
                const e = (this.right - this.left) / (2 * this.zoom)
                  , t = (this.top - this.bottom) / (2 * this.zoom)
                  , n = (this.right + this.left) / 2
                  , i = (this.top + this.bottom) / 2;
                let r = n - e
                  , s = n + e
                  , a = i + t
                  , o = i - t;
                if (null !== this.view && this.view.enabled) {
                    const e = (this.right - this.left) / this.view.fullWidth / this.zoom
                      , t = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
                    r += e * this.view.offsetX,
                    s = r + e * this.view.width,
                    a -= t * this.view.offsetY,
                    o = a - t * this.view.height
                }
                this.projectionMatrix.makeOrthographic(r, s, a, o, this.near, this.far, this.coordinateSystem),
                this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
            }
            toJSON(e) {
                const t = super.toJSON(e);
                return t.object.zoom = this.zoom,
                t.object.left = this.left,
                t.object.right = this.right,
                t.object.top = this.top,
                t.object.bottom = this.bottom,
                t.object.near = this.near,
                t.object.far = this.far,
                null !== this.view && (t.object.view = Object.assign({}, this.view)),
                t
            }
        }
        const Kr = [.125, .215, .35, .446, .526, .582]
          , Jr = 20
          , Zr = new Xr
          , $r = new Ti;
        let es = null
          , ts = 0
          , ns = 0
          , is = !1;
        const rs = (1 + Math.sqrt(5)) / 2
          , ss = 1 / rs
          , as = [new on(-rs,ss,0), new on(rs,ss,0), new on(-ss,0,rs), new on(ss,0,rs), new on(0,rs,-ss), new on(0,rs,ss), new on(-1,1,-1), new on(1,1,-1), new on(-1,1,1), new on(1,1,1)];
        class os {
            constructor(e) {
                this._renderer = e,
                this._pingPongRenderTarget = null,
                this._lodMax = 0,
                this._cubeSize = 0,
                this._lodPlanes = [],
                this._sizeLods = [],
                this._sigmas = [],
                this._blurMaterial = null,
                this._cubemapMaterial = null,
                this._equirectMaterial = null,
                this._compileMaterial(this._blurMaterial)
            }
            fromScene(e, t=0, n=.1, i=100) {
                es = this._renderer.getRenderTarget(),
                ts = this._renderer.getActiveCubeFace(),
                ns = this._renderer.getActiveMipmapLevel(),
                is = this._renderer.xr.enabled,
                this._renderer.xr.enabled = !1,
                this._setSize(256);
                const r = this._allocateTargets();
                return r.depthBuffer = !0,
                this._sceneToCubeUV(e, n, i, r),
                t > 0 && this._blur(r, 0, 0, t),
                this._applyPMREM(r),
                this._cleanup(r),
                r
            }
            fromEquirectangular(e, t=null) {
                return this._fromTexture(e, t)
            }
            fromCubemap(e, t=null) {
                return this._fromTexture(e, t)
            }
            compileCubemapShader() {
                null === this._cubemapMaterial && (this._cubemapMaterial = hs(),
                this._compileMaterial(this._cubemapMaterial))
            }
            compileEquirectangularShader() {
                null === this._equirectMaterial && (this._equirectMaterial = us(),
                this._compileMaterial(this._equirectMaterial))
            }
            dispose() {
                this._dispose(),
                null !== this._cubemapMaterial && this._cubemapMaterial.dispose(),
                null !== this._equirectMaterial && this._equirectMaterial.dispose()
            }
            _setSize(e) {
                this._lodMax = Math.floor(Math.log2(e)),
                this._cubeSize = Math.pow(2, this._lodMax)
            }
            _dispose() {
                null !== this._blurMaterial && this._blurMaterial.dispose(),
                null !== this._pingPongRenderTarget && this._pingPongRenderTarget.dispose();
                for (let e = 0; e < this._lodPlanes.length; e++)
                    this._lodPlanes[e].dispose()
            }
            _cleanup(e) {
                this._renderer.setRenderTarget(es, ts, ns),
                this._renderer.xr.enabled = is,
                e.scissorTest = !1,
                cs(e, 0, 0, e.width, e.height)
            }
            _fromTexture(e, t) {
                e.mapping === D || e.mapping === P ? this._setSize(0 === e.image.length ? 16 : e.image[0].width || e.image[0].image.width) : this._setSize(e.image.width / 4),
                es = this._renderer.getRenderTarget(),
                ts = this._renderer.getActiveCubeFace(),
                ns = this._renderer.getActiveMipmapLevel(),
                is = this._renderer.xr.enabled,
                this._renderer.xr.enabled = !1;
                const n = t || this._allocateTargets();
                return this._textureToCubeUV(e, n),
                this._applyPMREM(n),
                this._cleanup(n),
                n
            }
            _allocateTargets() {
                const e = 3 * Math.max(this._cubeSize, 112)
                  , t = 4 * this._cubeSize
                  , n = {
                    magFilter: z,
                    minFilter: z,
                    generateMipmaps: !1,
                    type: $,
                    format: ae,
                    colorSpace: ut,
                    depthBuffer: !1
                }
                  , i = ls(e, t, n);
                if (null === this._pingPongRenderTarget || this._pingPongRenderTarget.width !== e || this._pingPongRenderTarget.height !== t) {
                    null !== this._pingPongRenderTarget && this._dispose(),
                    this._pingPongRenderTarget = ls(e, t, n);
                    const {_lodMax: i} = this;
                    ({sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas} = function(e) {
                        const t = []
                          , n = []
                          , i = [];
                        let r = e;
                        const s = e - 4 + 1 + Kr.length;
                        for (let a = 0; a < s; a++) {
                            const s = Math.pow(2, r);
                            n.push(s);
                            let o = 1 / s;
                            a > e - 4 ? o = Kr[a - e + 4 - 1] : 0 === a && (o = 0),
                            i.push(o);
                            const l = 1 / (s - 2)
                              , c = -l
                              , u = 1 + l
                              , h = [c, c, u, c, u, u, c, c, u, u, c, u]
                              , d = 6
                              , p = 6
                              , f = 3
                              , A = 2
                              , g = 1
                              , m = new Float32Array(f * p * d)
                              , v = new Float32Array(A * p * d)
                              , y = new Float32Array(g * p * d);
                            for (let e = 0; e < d; e++) {
                                const t = e % 3 * 2 / 3 - 1
                                  , n = e > 2 ? 0 : -1
                                  , i = [t, n, 0, t + 2 / 3, n, 0, t + 2 / 3, n + 1, 0, t, n, 0, t + 2 / 3, n + 1, 0, t, n + 1, 0];
                                m.set(i, f * p * e),
                                v.set(h, A * p * e);
                                const r = [e, e, e, e, e, e];
                                y.set(r, g * p * e)
                            }
                            const x = new Zi;
                            x.setAttribute("position", new Gi(m,f)),
                            x.setAttribute("uv", new Gi(v,A)),
                            x.setAttribute("faceIndex", new Gi(y,g)),
                            t.push(x),
                            r > 4 && r--
                        }
                        return {
                            lodPlanes: t,
                            sizeLods: n,
                            sigmas: i
                        }
                    }(i)),
                    this._blurMaterial = function(e, t, n) {
                        const i = new Float32Array(Jr)
                          , r = new on(0,1,0)
                          , s = new mr({
                            name: "SphericalGaussianBlur",
                            defines: {
                                n: Jr,
                                CUBEUV_TEXEL_WIDTH: 1 / t,
                                CUBEUV_TEXEL_HEIGHT: 1 / n,
                                CUBEUV_MAX_MIP: `${e}.0`
                            },
                            uniforms: {
                                envMap: {
                                    value: null
                                },
                                samples: {
                                    value: 1
                                },
                                weights: {
                                    value: i
                                },
                                latitudinal: {
                                    value: !1
                                },
                                dTheta: {
                                    value: 0
                                },
                                mipInt: {
                                    value: 0
                                },
                                poleAxis: {
                                    value: r
                                }
                            },
                            vertexShader: ds(),
                            fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t",
                            blending: u,
                            depthTest: !1,
                            depthWrite: !1
                        });
                        return s
                    }(i, e, t)
                }
                return i
            }
            _compileMaterial(e) {
                const t = new ur(this._lodPlanes[0],e);
                this._renderer.compile(t, Zr)
            }
            _sceneToCubeUV(e, t, n, i) {
                const r = new br(90,1,t,n)
                  , s = [1, -1, 1, 1, 1, 1]
                  , a = [1, 1, 1, -1, -1, -1]
                  , o = this._renderer
                  , c = o.autoClear
                  , u = o.toneMapping;
                o.getClearColor($r),
                o.toneMapping = E,
                o.autoClear = !1;
                const h = new Pi({
                    name: "PMREM.Background",
                    side: l,
                    depthWrite: !1,
                    depthTest: !1
                })
                  , d = new ur(new dr,h);
                let p = !1;
                const f = e.background;
                f ? f.isColor && (h.color.copy(f),
                e.background = null,
                p = !0) : (h.color.copy($r),
                p = !0);
                for (let t = 0; t < 6; t++) {
                    const n = t % 3;
                    0 === n ? (r.up.set(0, s[t], 0),
                    r.lookAt(a[t], 0, 0)) : 1 === n ? (r.up.set(0, 0, s[t]),
                    r.lookAt(0, a[t], 0)) : (r.up.set(0, s[t], 0),
                    r.lookAt(0, 0, a[t]));
                    const l = this._cubeSize;
                    cs(i, n * l, t > 2 ? l : 0, l, l),
                    o.setRenderTarget(i),
                    p && o.render(d, r),
                    o.render(e, r)
                }
                d.geometry.dispose(),
                d.material.dispose(),
                o.toneMapping = u,
                o.autoClear = c,
                e.background = f
            }
            _textureToCubeUV(e, t) {
                const n = this._renderer
                  , i = e.mapping === D || e.mapping === P;
                i ? (null === this._cubemapMaterial && (this._cubemapMaterial = hs()),
                this._cubemapMaterial.uniforms.flipEnvMap.value = !1 === e.isRenderTargetTexture ? -1 : 1) : null === this._equirectMaterial && (this._equirectMaterial = us());
                const r = i ? this._cubemapMaterial : this._equirectMaterial
                  , s = new ur(this._lodPlanes[0],r);
                r.uniforms.envMap.value = e;
                const a = this._cubeSize;
                cs(t, 0, 0, 3 * a, 2 * a),
                n.setRenderTarget(t),
                n.render(s, Zr)
            }
            _applyPMREM(e) {
                const t = this._renderer
                  , n = t.autoClear;
                t.autoClear = !1;
                const i = this._lodPlanes.length;
                for (let t = 1; t < i; t++) {
                    const n = Math.sqrt(this._sigmas[t] * this._sigmas[t] - this._sigmas[t - 1] * this._sigmas[t - 1])
                      , r = as[(i - t - 1) % as.length];
                    this._blur(e, t - 1, t, n, r)
                }
                t.autoClear = n
            }
            _blur(e, t, n, i, r) {
                const s = this._pingPongRenderTarget;
                this._halfBlur(e, s, t, n, i, "latitudinal", r),
                this._halfBlur(s, e, n, n, i, "longitudinal", r)
            }
            _halfBlur(e, t, n, i, r, s, a) {
                const o = this._renderer
                  , l = this._blurMaterial;
                "latitudinal" !== s && "longitudinal" !== s && console.error("blur direction must be either latitudinal or longitudinal!");
                const c = new ur(this._lodPlanes[i],l)
                  , u = l.uniforms
                  , h = this._sizeLods[n] - 1
                  , d = isFinite(r) ? Math.PI / (2 * h) : 2 * Math.PI / 39
                  , p = r / d
                  , f = isFinite(r) ? 1 + Math.floor(3 * p) : Jr;
                f > Jr && console.warn(`sigmaRadians, ${r}, is too large and will clip, as it requested ${f} samples when the maximum is set to 20`);
                const A = [];
                let g = 0;
                for (let e = 0; e < Jr; ++e) {
                    const t = e / p
                      , n = Math.exp(-t * t / 2);
                    A.push(n),
                    0 === e ? g += n : e < f && (g += 2 * n)
                }
                for (let e = 0; e < A.length; e++)
                    A[e] = A[e] / g;
                u.envMap.value = e.texture,
                u.samples.value = f,
                u.weights.value = A,
                u.latitudinal.value = "latitudinal" === s,
                a && (u.poleAxis.value = a);
                const {_lodMax: m} = this;
                u.dTheta.value = d,
                u.mipInt.value = m - n;
                const v = this._sizeLods[i];
                cs(t, 3 * v * (i > m - 4 ? i - m + 4 : 0), 4 * (this._cubeSize - v), 3 * v, 2 * v),
                o.setRenderTarget(t),
                o.render(c, Zr)
            }
        }
        function ls(e, t, n) {
            const i = new nn(e,t,n);
            return i.texture.mapping = F,
            i.texture.name = "PMREM.cubeUv",
            i.scissorTest = !0,
            i
        }
        function cs(e, t, n, i, r) {
            e.viewport.set(t, n, i, r),
            e.scissor.set(t, n, i, r)
        }
        function us() {
            return new mr({
                name: "EquirectangularToCubeUV",
                uniforms: {
                    envMap: {
                        value: null
                    }
                },
                vertexShader: ds(),
                fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tgl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );\n\n\t\t\t}\n\t\t",
                blending: u,
                depthTest: !1,
                depthWrite: !1
            })
        }
        function hs() {
            return new mr({
                name: "CubemapToCubeUV",
                uniforms: {
                    envMap: {
                        value: null
                    },
                    flipEnvMap: {
                        value: -1
                    }
                },
                vertexShader: ds(),
                fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tuniform float flipEnvMap;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );\n\n\t\t\t}\n\t\t",
                blending: u,
                depthTest: !1,
                depthWrite: !1
            })
        }
        function ds() {
            return "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t"
        }
        function ps(e) {
            let t = new WeakMap
              , n = null;
            function i(e) {
                const n = e.target;
                n.removeEventListener("dispose", i);
                const r = t.get(n);
                void 0 !== r && (t.delete(n),
                r.dispose())
            }
            return {
                get: function(r) {
                    if (r && r.isTexture) {
                        const s = r.mapping
                          , a = s === L || s === U
                          , o = s === D || s === P;
                        if (a || o) {
                            let s = t.get(r);
                            const l = void 0 !== s ? s.texture.pmremVersion : 0;
                            if (r.isRenderTargetTexture && r.pmremVersion !== l)
                                return null === n && (n = new os(e)),
                                s = a ? n.fromEquirectangular(r, s) : n.fromCubemap(r, s),
                                s.texture.pmremVersion = r.pmremVersion,
                                t.set(r, s),
                                s.texture;
                            if (void 0 !== s)
                                return s.texture;
                            {
                                const l = r.image;
                                return a && l && l.height > 0 || o && l && function(e) {
                                    let t = 0;
                                    const n = 6;
                                    for (let i = 0; i < n; i++)
                                        void 0 !== e[i] && t++;
                                    return t === n
                                }(l) ? (null === n && (n = new os(e)),
                                s = a ? n.fromEquirectangular(r) : n.fromCubemap(r),
                                s.texture.pmremVersion = r.pmremVersion,
                                t.set(r, s),
                                r.addEventListener("dispose", i),
                                s.texture) : null
                            }
                        }
                    }
                    return r
                },
                dispose: function() {
                    t = new WeakMap,
                    null !== n && (n.dispose(),
                    n = null)
                }
            }
        }
        function fs(e) {
            const t = {};
            function n(n) {
                if (void 0 !== t[n])
                    return t[n];
                let i;
                switch (n) {
                case "WEBGL_depth_texture":
                    i = e.getExtension("WEBGL_depth_texture") || e.getExtension("MOZ_WEBGL_depth_texture") || e.getExtension("WEBKIT_WEBGL_depth_texture");
                    break;
                case "EXT_texture_filter_anisotropic":
                    i = e.getExtension("EXT_texture_filter_anisotropic") || e.getExtension("MOZ_EXT_texture_filter_anisotropic") || e.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                    break;
                case "WEBGL_compressed_texture_s3tc":
                    i = e.getExtension("WEBGL_compressed_texture_s3tc") || e.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                    break;
                case "WEBGL_compressed_texture_pvrtc":
                    i = e.getExtension("WEBGL_compressed_texture_pvrtc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                    break;
                default:
                    i = e.getExtension(n)
                }
                return t[n] = i,
                i
            }
            return {
                has: function(e) {
                    return null !== n(e)
                },
                init: function() {
                    n("EXT_color_buffer_float"),
                    n("WEBGL_clip_cull_distance"),
                    n("OES_texture_float_linear"),
                    n("EXT_color_buffer_half_float"),
                    n("WEBGL_multisampled_render_to_texture"),
                    n("WEBGL_render_shared_exponent")
                },
                get: function(e) {
                    const t = n(e);
                    return null === t && Ot("THREE.WebGLRenderer: " + e + " extension not supported."),
                    t
                }
            }
        }
        function As(e, t, n, i) {
            const r = {}
              , s = new WeakMap;
            function a(e) {
                const o = e.target;
                null !== o.index && t.remove(o.index);
                for (const e in o.attributes)
                    t.remove(o.attributes[e]);
                for (const e in o.morphAttributes) {
                    const n = o.morphAttributes[e];
                    for (let e = 0, i = n.length; e < i; e++)
                        t.remove(n[e])
                }
                o.removeEventListener("dispose", a),
                delete r[o.id];
                const l = s.get(o);
                l && (t.remove(l),
                s.delete(o)),
                i.releaseStatesOfGeometry(o),
                !0 === o.isInstancedBufferGeometry && delete o._maxInstanceCount,
                n.memory.geometries--
            }
            function o(e) {
                const n = []
                  , i = e.index
                  , r = e.attributes.position;
                let a = 0;
                if (null !== i) {
                    const e = i.array;
                    a = i.version;
                    for (let t = 0, i = e.length; t < i; t += 3) {
                        const i = e[t + 0]
                          , r = e[t + 1]
                          , s = e[t + 2];
                        n.push(i, r, r, s, s, i)
                    }
                } else {
                    if (void 0 === r)
                        return;
                    {
                        const e = r.array;
                        a = r.version;
                        for (let t = 0, i = e.length / 3 - 1; t < i; t += 3) {
                            const e = t + 0
                              , i = t + 1
                              , r = t + 2;
                            n.push(e, i, i, r, r, e)
                        }
                    }
                }
                const o = new (Lt(n) ? zi : Hi)(n,1);
                o.version = a;
                const l = s.get(e);
                l && t.remove(l),
                s.set(e, o)
            }
            return {
                get: function(e, t) {
                    return !0 === r[t.id] || (t.addEventListener("dispose", a),
                    r[t.id] = !0,
                    n.memory.geometries++),
                    t
                },
                update: function(n) {
                    const i = n.attributes;
                    for (const n in i)
                        t.update(i[n], e.ARRAY_BUFFER);
                    const r = n.morphAttributes;
                    for (const n in r) {
                        const i = r[n];
                        for (let n = 0, r = i.length; n < r; n++)
                            t.update(i[n], e.ARRAY_BUFFER)
                    }
                },
                getWireframeAttribute: function(e) {
                    const t = s.get(e);
                    if (t) {
                        const n = e.index;
                        null !== n && t.version < n.version && o(e)
                    } else
                        o(e);
                    return s.get(e)
                }
            }
        }
        function gs(e, t, n) {
            let i, r, s;
            function a(t, a, o) {
                0 !== o && (e.drawElementsInstanced(i, a, r, t * s, o),
                n.update(a, i, o))
            }
            this.setMode = function(e) {
                i = e
            }
            ,
            this.setIndex = function(e) {
                r = e.type,
                s = e.bytesPerElement
            }
            ,
            this.render = function(t, a) {
                e.drawElements(i, a, r, t * s),
                n.update(a, i, 1)
            }
            ,
            this.renderInstances = a,
            this.renderMultiDraw = function(e, s, a) {
                if (0 === a)
                    return;
                t.get("WEBGL_multi_draw").multiDrawElementsWEBGL(i, s, 0, r, e, 0, a);
                let o = 0;
                for (let e = 0; e < a; e++)
                    o += s[e];
                n.update(o, i, 1)
            }
            ,
            this.renderMultiDrawInstances = function(e, o, l, c) {
                if (0 === l)
                    return;
                const u = t.get("WEBGL_multi_draw");
                if (null === u)
                    for (let t = 0; t < e.length; t++)
                        a(e[t] / s, o[t], c[t]);
                else {
                    u.multiDrawElementsInstancedWEBGL(i, o, 0, r, e, 0, c, 0, l);
                    let t = 0;
                    for (let e = 0; e < l; e++)
                        t += o[e] * c[e];
                    n.update(t, i, 1)
                }
            }
        }
        function ms(e) {
            const t = {
                frame: 0,
                calls: 0,
                triangles: 0,
                points: 0,
                lines: 0
            };
            return {
                memory: {
                    geometries: 0,
                    textures: 0
                },
                render: t,
                programs: null,
                autoReset: !0,
                reset: function() {
                    t.calls = 0,
                    t.triangles = 0,
                    t.points = 0,
                    t.lines = 0
                },
                update: function(n, i, r) {
                    switch (t.calls++,
                    i) {
                    case e.TRIANGLES:
                        t.triangles += r * (n / 3);
                        break;
                    case e.LINES:
                        t.lines += r * (n / 2);
                        break;
                    case e.LINE_STRIP:
                        t.lines += r * (n - 1);
                        break;
                    case e.LINE_LOOP:
                        t.lines += r * n;
                        break;
                    case e.POINTS:
                        t.points += r * n;
                        break;
                    default:
                        console.error("THREE.WebGLInfo: Unknown draw mode:", i)
                    }
                }
            }
        }
        function vs(e, t, n) {
            const i = new WeakMap
              , r = new en;
            return {
                update: function(s, a, o) {
                    const l = s.morphTargetInfluences
                      , c = a.morphAttributes.position || a.morphAttributes.normal || a.morphAttributes.color
                      , u = void 0 !== c ? c.length : 0;
                    let h = i.get(a);
                    if (void 0 === h || h.count !== u) {
                        void 0 !== h && h.texture.dispose();
                        const d = void 0 !== a.morphAttributes.position
                          , p = void 0 !== a.morphAttributes.normal
                          , f = void 0 !== a.morphAttributes.color
                          , A = a.morphAttributes.position || []
                          , g = a.morphAttributes.normal || []
                          , m = a.morphAttributes.color || [];
                        let v = 0;
                        !0 === d && (v = 1),
                        !0 === p && (v = 2),
                        !0 === f && (v = 3);
                        let y = a.attributes.position.count * v
                          , x = 1;
                        y > t.maxTextureSize && (x = Math.ceil(y / t.maxTextureSize),
                        y = t.maxTextureSize);
                        const _ = new Float32Array(y * x * 4 * u)
                          , b = new rn(_,y,x,u);
                        b.type = Z,
                        b.needsUpdate = !0;
                        const E = 4 * v;
                        for (let C = 0; C < u; C++) {
                            const I = A[C]
                              , S = g[C]
                              , M = m[C]
                              , T = y * x * 4 * C;
                            for (let B = 0; B < I.count; B++) {
                                const R = B * E;
                                !0 === d && (r.fromBufferAttribute(I, B),
                                _[T + R + 0] = r.x,
                                _[T + R + 1] = r.y,
                                _[T + R + 2] = r.z,
                                _[T + R + 3] = 0),
                                !0 === p && (r.fromBufferAttribute(S, B),
                                _[T + R + 4] = r.x,
                                _[T + R + 5] = r.y,
                                _[T + R + 6] = r.z,
                                _[T + R + 7] = 0),
                                !0 === f && (r.fromBufferAttribute(M, B),
                                _[T + R + 8] = r.x,
                                _[T + R + 9] = r.y,
                                _[T + R + 10] = r.z,
                                _[T + R + 11] = 4 === M.itemSize ? r.w : 1)
                            }
                        }
                        function w() {
                            b.dispose(),
                            i.delete(a),
                            a.removeEventListener("dispose", w)
                        }
                        h = {
                            count: u,
                            texture: b,
                            size: new Rt(y,x)
                        },
                        i.set(a, h),
                        a.addEventListener("dispose", w)
                    }
                    if (!0 === s.isInstancedMesh && null !== s.morphTexture)
                        o.getUniforms().setValue(e, "morphTexture", s.morphTexture, n);
                    else {
                        let D = 0;
                        for (let L = 0; L < l.length; L++)
                            D += l[L];
                        const P = a.morphTargetsRelative ? 1 : 1 - D;
                        o.getUniforms().setValue(e, "morphTargetBaseInfluence", P),
                        o.getUniforms().setValue(e, "morphTargetInfluences", l)
                    }
                    o.getUniforms().setValue(e, "morphTargetsTexture", h.texture, n),
                    o.getUniforms().setValue(e, "morphTargetsTextureSize", h.size)
                }
            }
        }
        function ys(e, t, n, i) {
            let r = new WeakMap;
            function s(e) {
                const t = e.target;
                t.removeEventListener("dispose", s),
                n.remove(t.instanceMatrix),
                null !== t.instanceColor && n.remove(t.instanceColor)
            }
            return {
                update: function(a) {
                    const o = i.render.frame
                      , l = a.geometry
                      , c = t.get(a, l);
                    if (r.get(c) !== o && (t.update(c),
                    r.set(c, o)),
                    a.isInstancedMesh && (!1 === a.hasEventListener("dispose", s) && a.addEventListener("dispose", s),
                    r.get(a) !== o && (n.update(a.instanceMatrix, e.ARRAY_BUFFER),
                    null !== a.instanceColor && n.update(a.instanceColor, e.ARRAY_BUFFER),
                    r.set(a, o))),
                    a.isSkinnedMesh) {
                        const e = a.skeleton;
                        r.get(e) !== o && (e.update(),
                        r.set(e, o))
                    }
                    return c
                },
                dispose: function() {
                    r = new WeakMap
                }
            }
        }
        class xs extends $t {
            constructor(e, t, n, i, r, s, a, o, l, c=1026) {
                if (c !== ce && c !== ue)
                    throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
                void 0 === n && c === ce && (n = J),
                void 0 === n && c === ue && (n = ne),
                super(null, i, r, s, a, o, c, n, l),
                this.isDepthTexture = !0,
                this.image = {
                    width: e,
                    height: t
                },
                this.magFilter = void 0 !== a ? a : k,
                this.minFilter = void 0 !== o ? o : k,
                this.flipY = !1,
                this.generateMipmaps = !1,
                this.compareFunction = null
            }
            copy(e) {
                return super.copy(e),
                this.compareFunction = e.compareFunction,
                this
            }
            toJSON(e) {
                const t = super.toJSON(e);
                return null !== this.compareFunction && (t.compareFunction = this.compareFunction),
                t
            }
        }
        const _s = new $t
          , bs = new xs(1,1)
          , Es = new rn
          , ws = new sn
          , Cs = new Cr
          , Is = []
          , Ss = []
          , Ms = new Float32Array(16)
          , Ts = new Float32Array(9)
          , Bs = new Float32Array(4);
        function Rs(e, t, n) {
            const i = e[0];
            if (i <= 0 || i > 0)
                return e;
            const r = t * n;
            let s = Is[r];
            if (void 0 === s && (s = new Float32Array(r),
            Is[r] = s),
            0 !== t) {
                i.toArray(s, 0);
                for (let i = 1, r = 0; i !== t; ++i)
                    r += n,
                    e[i].toArray(s, r)
            }
            return s
        }
        function Ds(e, t) {
            if (e.length !== t.length)
                return !1;
            for (let n = 0, i = e.length; n < i; n++)
                if (e[n] !== t[n])
                    return !1;
            return !0
        }
        function Ps(e, t) {
            for (let n = 0, i = t.length; n < i; n++)
                e[n] = t[n]
        }
        function Ls(e, t) {
            let n = Ss[t];
            void 0 === n && (n = new Int32Array(t),
            Ss[t] = n);
            for (let i = 0; i !== t; ++i)
                n[i] = e.allocateTextureUnit();
            return n
        }
        function Us(e, t) {
            const n = this.cache;
            n[0] !== t && (e.uniform1f(this.addr, t),
            n[0] = t)
        }
        function Fs(e, t) {
            const n = this.cache;
            if (void 0 !== t.x)
                n[0] === t.x && n[1] === t.y || (e.uniform2f(this.addr, t.x, t.y),
                n[0] = t.x,
                n[1] = t.y);
            else {
                if (Ds(n, t))
                    return;
                e.uniform2fv(this.addr, t),
                Ps(n, t)
            }
        }
        function Ns(e, t) {
            const n = this.cache;
            if (void 0 !== t.x)
                n[0] === t.x && n[1] === t.y && n[2] === t.z || (e.uniform3f(this.addr, t.x, t.y, t.z),
                n[0] = t.x,
                n[1] = t.y,
                n[2] = t.z);
            else if (void 0 !== t.r)
                n[0] === t.r && n[1] === t.g && n[2] === t.b || (e.uniform3f(this.addr, t.r, t.g, t.b),
                n[0] = t.r,
                n[1] = t.g,
                n[2] = t.b);
            else {
                if (Ds(n, t))
                    return;
                e.uniform3fv(this.addr, t),
                Ps(n, t)
            }
        }
        function Os(e, t) {
            const n = this.cache;
            if (void 0 !== t.x)
                n[0] === t.x && n[1] === t.y && n[2] === t.z && n[3] === t.w || (e.uniform4f(this.addr, t.x, t.y, t.z, t.w),
                n[0] = t.x,
                n[1] = t.y,
                n[2] = t.z,
                n[3] = t.w);
            else {
                if (Ds(n, t))
                    return;
                e.uniform4fv(this.addr, t),
                Ps(n, t)
            }
        }
        function Qs(e, t) {
            const n = this.cache
              , i = t.elements;
            if (void 0 === i) {
                if (Ds(n, t))
                    return;
                e.uniformMatrix2fv(this.addr, !1, t),
                Ps(n, t)
            } else {
                if (Ds(n, i))
                    return;
                Bs.set(i),
                e.uniformMatrix2fv(this.addr, !1, Bs),
                Ps(n, i)
            }
        }
        function ks(e, t) {
            const n = this.cache
              , i = t.elements;
            if (void 0 === i) {
                if (Ds(n, t))
                    return;
                e.uniformMatrix3fv(this.addr, !1, t),
                Ps(n, t)
            } else {
                if (Ds(n, i))
                    return;
                Ts.set(i),
                e.uniformMatrix3fv(this.addr, !1, Ts),
                Ps(n, i)
            }
        }
        function Gs(e, t) {
            const n = this.cache
              , i = t.elements;
            if (void 0 === i) {
                if (Ds(n, t))
                    return;
                e.uniformMatrix4fv(this.addr, !1, t),
                Ps(n, t)
            } else {
                if (Ds(n, i))
                    return;
                Ms.set(i),
                e.uniformMatrix4fv(this.addr, !1, Ms),
                Ps(n, i)
            }
        }
        function Hs(e, t) {
            const n = this.cache;
            n[0] !== t && (e.uniform1i(this.addr, t),
            n[0] = t)
        }
        function zs(e, t) {
            const n = this.cache;
            if (void 0 !== t.x)
                n[0] === t.x && n[1] === t.y || (e.uniform2i(this.addr, t.x, t.y),
                n[0] = t.x,
                n[1] = t.y);
            else {
                if (Ds(n, t))
                    return;
                e.uniform2iv(this.addr, t),
                Ps(n, t)
            }
        }
        function Vs(e, t) {
            const n = this.cache;
            if (void 0 !== t.x)
                n[0] === t.x && n[1] === t.y && n[2] === t.z || (e.uniform3i(this.addr, t.x, t.y, t.z),
                n[0] = t.x,
                n[1] = t.y,
                n[2] = t.z);
            else {
                if (Ds(n, t))
                    return;
                e.uniform3iv(this.addr, t),
                Ps(n, t)
            }
        }
        function Ws(e, t) {
            const n = this.cache;
            if (void 0 !== t.x)
                n[0] === t.x && n[1] === t.y && n[2] === t.z && n[3] === t.w || (e.uniform4i(this.addr, t.x, t.y, t.z, t.w),
                n[0] = t.x,
                n[1] = t.y,
                n[2] = t.z,
                n[3] = t.w);
            else {
                if (Ds(n, t))
                    return;
                e.uniform4iv(this.addr, t),
                Ps(n, t)
            }
        }
        function js(e, t) {
            const n = this.cache;
            n[0] !== t && (e.uniform1ui(this.addr, t),
            n[0] = t)
        }
        function qs(e, t) {
            const n = this.cache;
            if (void 0 !== t.x)
                n[0] === t.x && n[1] === t.y || (e.uniform2ui(this.addr, t.x, t.y),
                n[0] = t.x,
                n[1] = t.y);
            else {
                if (Ds(n, t))
                    return;
                e.uniform2uiv(this.addr, t),
                Ps(n, t)
            }
        }
        function Ys(e, t) {
            const n = this.cache;
            if (void 0 !== t.x)
                n[0] === t.x && n[1] === t.y && n[2] === t.z || (e.uniform3ui(this.addr, t.x, t.y, t.z),
                n[0] = t.x,
                n[1] = t.y,
                n[2] = t.z);
            else {
                if (Ds(n, t))
                    return;
                e.uniform3uiv(this.addr, t),
                Ps(n, t)
            }
        }
        function Xs(e, t) {
            const n = this.cache;
            if (void 0 !== t.x)
                n[0] === t.x && n[1] === t.y && n[2] === t.z && n[3] === t.w || (e.uniform4ui(this.addr, t.x, t.y, t.z, t.w),
                n[0] = t.x,
                n[1] = t.y,
                n[2] = t.z,
                n[3] = t.w);
            else {
                if (Ds(n, t))
                    return;
                e.uniform4uiv(this.addr, t),
                Ps(n, t)
            }
        }
        function Ks(e, t, n) {
            const i = this.cache
              , r = n.allocateTextureUnit();
            let s;
            i[0] !== r && (e.uniform1i(this.addr, r),
            i[0] = r),
            this.type === e.SAMPLER_2D_SHADOW ? (bs.compareFunction = ft,
            s = bs) : s = _s,
            n.setTexture2D(t || s, r)
        }
        function Js(e, t, n) {
            const i = this.cache
              , r = n.allocateTextureUnit();
            i[0] !== r && (e.uniform1i(this.addr, r),
            i[0] = r),
            n.setTexture3D(t || ws, r)
        }
        function Zs(e, t, n) {
            const i = this.cache
              , r = n.allocateTextureUnit();
            i[0] !== r && (e.uniform1i(this.addr, r),
            i[0] = r),
            n.setTextureCube(t || Cs, r)
        }
        function $s(e, t, n) {
            const i = this.cache
              , r = n.allocateTextureUnit();
            i[0] !== r && (e.uniform1i(this.addr, r),
            i[0] = r),
            n.setTexture2DArray(t || Es, r)
        }
        function ea(e, t) {
            e.uniform1fv(this.addr, t)
        }
        function ta(e, t) {
            const n = Rs(t, this.size, 2);
            e.uniform2fv(this.addr, n)
        }
        function na(e, t) {
            const n = Rs(t, this.size, 3);
            e.uniform3fv(this.addr, n)
        }
        function ia(e, t) {
            const n = Rs(t, this.size, 4);
            e.uniform4fv(this.addr, n)
        }
        function ra(e, t) {
            const n = Rs(t, this.size, 4);
            e.uniformMatrix2fv(this.addr, !1, n)
        }
        function sa(e, t) {
            const n = Rs(t, this.size, 9);
            e.uniformMatrix3fv(this.addr, !1, n)
        }
        function aa(e, t) {
            const n = Rs(t, this.size, 16);
            e.uniformMatrix4fv(this.addr, !1, n)
        }
        function oa(e, t) {
            e.uniform1iv(this.addr, t)
        }
        function la(e, t) {
            e.uniform2iv(this.addr, t)
        }
        function ca(e, t) {
            e.uniform3iv(this.addr, t)
        }
        function ua(e, t) {
            e.uniform4iv(this.addr, t)
        }
        function ha(e, t) {
            e.uniform1uiv(this.addr, t)
        }
        function da(e, t) {
            e.uniform2uiv(this.addr, t)
        }
        function pa(e, t) {
            e.uniform3uiv(this.addr, t)
        }
        function fa(e, t) {
            e.uniform4uiv(this.addr, t)
        }
        function Aa(e, t, n) {
            const i = this.cache
              , r = t.length
              , s = Ls(n, r);
            Ds(i, s) || (e.uniform1iv(this.addr, s),
            Ps(i, s));
            for (let e = 0; e !== r; ++e)
                n.setTexture2D(t[e] || _s, s[e])
        }
        function ga(e, t, n) {
            const i = this.cache
              , r = t.length
              , s = Ls(n, r);
            Ds(i, s) || (e.uniform1iv(this.addr, s),
            Ps(i, s));
            for (let e = 0; e !== r; ++e)
                n.setTexture3D(t[e] || ws, s[e])
        }
        function ma(e, t, n) {
            const i = this.cache
              , r = t.length
              , s = Ls(n, r);
            Ds(i, s) || (e.uniform1iv(this.addr, s),
            Ps(i, s));
            for (let e = 0; e !== r; ++e)
                n.setTextureCube(t[e] || Cs, s[e])
        }
        function va(e, t, n) {
            const i = this.cache
              , r = t.length
              , s = Ls(n, r);
            Ds(i, s) || (e.uniform1iv(this.addr, s),
            Ps(i, s));
            for (let e = 0; e !== r; ++e)
                n.setTexture2DArray(t[e] || Es, s[e])
        }
        class ya {
            constructor(e, t, n) {
                this.id = e,
                this.addr = n,
                this.cache = [],
                this.type = t.type,
                this.setValue = function(e) {
                    switch (e) {
                    case 5126:
                        return Us;
                    case 35664:
                        return Fs;
                    case 35665:
                        return Ns;
                    case 35666:
                        return Os;
                    case 35674:
                        return Qs;
                    case 35675:
                        return ks;
                    case 35676:
                        return Gs;
                    case 5124:
                    case 35670:
                        return Hs;
                    case 35667:
                    case 35671:
                        return zs;
                    case 35668:
                    case 35672:
                        return Vs;
                    case 35669:
                    case 35673:
                        return Ws;
                    case 5125:
                        return js;
                    case 36294:
                        return qs;
                    case 36295:
                        return Ys;
                    case 36296:
                        return Xs;
                    case 35678:
                    case 36198:
                    case 36298:
                    case 36306:
                    case 35682:
                        return Ks;
                    case 35679:
                    case 36299:
                    case 36307:
                        return Js;
                    case 35680:
                    case 36300:
                    case 36308:
                    case 36293:
                        return Zs;
                    case 36289:
                    case 36303:
                    case 36311:
                    case 36292:
                        return $s
                    }
                }(t.type)
            }
        }
        class xa {
            constructor(e, t, n) {
                this.id = e,
                this.addr = n,
                this.cache = [],
                this.type = t.type,
                this.size = t.size,
                this.setValue = function(e) {
                    switch (e) {
                    case 5126:
                        return ea;
                    case 35664:
                        return ta;
                    case 35665:
                        return na;
                    case 35666:
                        return ia;
                    case 35674:
                        return ra;
                    case 35675:
                        return sa;
                    case 35676:
                        return aa;
                    case 5124:
                    case 35670:
                        return oa;
                    case 35667:
                    case 35671:
                        return la;
                    case 35668:
                    case 35672:
                        return ca;
                    case 35669:
                    case 35673:
                        return ua;
                    case 5125:
                        return ha;
                    case 36294:
                        return da;
                    case 36295:
                        return pa;
                    case 36296:
                        return fa;
                    case 35678:
                    case 36198:
                    case 36298:
                    case 36306:
                    case 35682:
                        return Aa;
                    case 35679:
                    case 36299:
                    case 36307:
                        return ga;
                    case 35680:
                    case 36300:
                    case 36308:
                    case 36293:
                        return ma;
                    case 36289:
                    case 36303:
                    case 36311:
                    case 36292:
                        return va
                    }
                }(t.type)
            }
        }
        class _a {
            constructor(e) {
                this.id = e,
                this.seq = [],
                this.map = {}
            }
            setValue(e, t, n) {
                const i = this.seq;
                for (let r = 0, s = i.length; r !== s; ++r) {
                    const s = i[r];
                    s.setValue(e, t[s.id], n)
                }
            }
        }
        const ba = /(\w+)(\])?(\[|\.)?/g;
        function Ea(e, t) {
            e.seq.push(t),
            e.map[t.id] = t
        }
        function wa(e, t, n) {
            const i = e.name
              , r = i.length;
            for (ba.lastIndex = 0; ; ) {
                const s = ba.exec(i)
                  , a = ba.lastIndex;
                let o = s[1];
                const l = "]" === s[2]
                  , c = s[3];
                if (l && (o |= 0),
                void 0 === c || "[" === c && a + 2 === r) {
                    Ea(n, void 0 === c ? new ya(o,e,t) : new xa(o,e,t));
                    break
                }
                {
                    let e = n.map[o];
                    void 0 === e && (e = new _a(o),
                    Ea(n, e)),
                    n = e
                }
            }
        }
        class Ca {
            constructor(e, t) {
                this.seq = [],
                this.map = {};
                const n = e.getProgramParameter(t, e.ACTIVE_UNIFORMS);
                for (let i = 0; i < n; ++i) {
                    const n = e.getActiveUniform(t, i);
                    wa(n, e.getUniformLocation(t, n.name), this)
                }
            }
            setValue(e, t, n, i) {
                const r = this.map[t];
                void 0 !== r && r.setValue(e, n, i)
            }
            setOptional(e, t, n) {
                const i = t[n];
                void 0 !== i && this.setValue(e, n, i)
            }
            static upload(e, t, n, i) {
                for (let r = 0, s = t.length; r !== s; ++r) {
                    const s = t[r]
                      , a = n[s.id];
                    !1 !== a.needsUpdate && s.setValue(e, a.value, i)
                }
            }
            static seqWithValue(e, t) {
                const n = [];
                for (let i = 0, r = e.length; i !== r; ++i) {
                    const r = e[i];
                    r.id in t && n.push(r)
                }
                return n
            }
        }
        function Ia(e, t, n) {
            const i = e.createShader(t);
            return e.shaderSource(i, n),
            e.compileShader(i),
            i
        }
        const Sa = 37297;
        let Ma = 0;
        const Ta = new Dt;
        function Ba(e, t, n) {
            const i = e.getShaderParameter(t, e.COMPILE_STATUS)
              , r = e.getShaderInfoLog(t).trim();
            if (i && "" === r)
                return "";
            const s = /ERROR: 0:(\d+)/.exec(r);
            if (s) {
                const i = parseInt(s[1]);
                return n.toUpperCase() + "\n\n" + r + "\n\n" + function(e, t) {
                    const n = e.split("\n")
                      , i = []
                      , r = Math.max(t - 6, 0)
                      , s = Math.min(t + 6, n.length);
                    for (let e = r; e < s; e++) {
                        const r = e + 1;
                        i.push(`${r === t ? ">" : " "} ${r}: ${n[e]}`)
                    }
                    return i.join("\n")
                }(e.getShaderSource(t), i)
            }
            return r
        }
        function Ra(e, t) {
            const n = function(e) {
                Qt._getMatrix(Ta, Qt.workingColorSpace, e);
                const t = `mat3( ${Ta.elements.map((e => e.toFixed(4)))} )`;
                switch (Qt.getTransfer(e)) {
                case ht:
                    return [t, "LinearTransferOETF"];
                case dt:
                    return [t, "sRGBTransferOETF"];
                default:
                    return console.warn("THREE.WebGLProgram: Unsupported color space: ", e),
                    [t, "LinearTransferOETF"]
                }
            }(t);
            return [`vec4 ${e}( vec4 value ) {`, `\treturn ${n[1]}( vec4( value.rgb * ${n[0]}, value.a ) );`, "}"].join("\n")
        }
        function Da(e, t) {
            let n;
            switch (t) {
            case w:
                n = "Linear";
                break;
            case C:
                n = "Reinhard";
                break;
            case I:
                n = "Cineon";
                break;
            case S:
                n = "ACESFilmic";
                break;
            case T:
                n = "AgX";
                break;
            case B:
                n = "Neutral";
                break;
            case M:
                n = "Custom";
                break;
            default:
                console.warn("THREE.WebGLProgram: Unsupported toneMapping:", t),
                n = "Linear"
            }
            return "vec3 " + e + "( vec3 color ) { return " + n + "ToneMapping( color ); }"
        }
        const Pa = new on;
        function La() {
            Qt.getLuminanceCoefficients(Pa);
            return ["float luminance( const in vec3 rgb ) {", `\tconst vec3 weights = vec3( ${Pa.x.toFixed(4)}, ${Pa.y.toFixed(4)}, ${Pa.z.toFixed(4)} );`, "\treturn dot( weights, rgb );", "}"].join("\n")
        }
        function Ua(e) {
            return "" !== e
        }
        function Fa(e, t) {
            const n = t.numSpotLightShadows + t.numSpotLightMaps - t.numSpotLightShadowsWithMaps;
            return e.replace(/NUM_DIR_LIGHTS/g, t.numDirLights).replace(/NUM_SPOT_LIGHTS/g, t.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, t.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, n).replace(/NUM_RECT_AREA_LIGHTS/g, t.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, t.numPointLights).replace(/NUM_HEMI_LIGHTS/g, t.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, t.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, t.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, t.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, t.numPointLightShadows)
        }
        function Na(e, t) {
            return e.replace(/NUM_CLIPPING_PLANES/g, t.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, t.numClippingPlanes - t.numClipIntersection)
        }
        const Oa = /^[ \t]*#include +<([\w\d./]+)>/gm;
        function Qa(e) {
            return e.replace(Oa, Ga)
        }
        const ka = new Map;
        function Ga(e, t) {
            let n = Nr[t];
            if (void 0 === n) {
                const e = ka.get(t);
                if (void 0 === e)
                    throw new Error("Can not resolve #include <" + t + ">");
                n = Nr[e],
                console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.', t, e)
            }
            return Qa(n)
        }
        const Ha = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
        function za(e) {
            return e.replace(Ha, Va)
        }
        function Va(e, t, n, i) {
            let r = "";
            for (let e = parseInt(t); e < parseInt(n); e++)
                r += i.replace(/\[\s*i\s*\]/g, "[ " + e + " ]").replace(/UNROLLED_LOOP_INDEX/g, e);
            return r
        }
        function Wa(e) {
            let t = `precision ${e.precision} float;\n\tprecision ${e.precision} int;\n\tprecision ${e.precision} sampler2D;\n\tprecision ${e.precision} samplerCube;\n\tprecision ${e.precision} sampler3D;\n\tprecision ${e.precision} sampler2DArray;\n\tprecision ${e.precision} sampler2DShadow;\n\tprecision ${e.precision} samplerCubeShadow;\n\tprecision ${e.precision} sampler2DArrayShadow;\n\tprecision ${e.precision} isampler2D;\n\tprecision ${e.precision} isampler3D;\n\tprecision ${e.precision} isamplerCube;\n\tprecision ${e.precision} isampler2DArray;\n\tprecision ${e.precision} usampler2D;\n\tprecision ${e.precision} usampler3D;\n\tprecision ${e.precision} usamplerCube;\n\tprecision ${e.precision} usampler2DArray;\n\t`;
            return "highp" === e.precision ? t += "\n#define HIGH_PRECISION" : "mediump" === e.precision ? t += "\n#define MEDIUM_PRECISION" : "lowp" === e.precision && (t += "\n#define LOW_PRECISION"),
            t
        }
        function ja(e, t, n, i) {
            const o = e.getContext()
              , l = n.defines;
            let c = n.vertexShader
              , u = n.fragmentShader;
            const h = function(e) {
                let t = "SHADOWMAP_TYPE_BASIC";
                return e.shadowMapType === r ? t = "SHADOWMAP_TYPE_PCF" : e.shadowMapType === s ? t = "SHADOWMAP_TYPE_PCF_SOFT" : e.shadowMapType === a && (t = "SHADOWMAP_TYPE_VSM"),
                t
            }(n)
              , d = function(e) {
                let t = "ENVMAP_TYPE_CUBE";
                if (e.envMap)
                    switch (e.envMapMode) {
                    case D:
                    case P:
                        t = "ENVMAP_TYPE_CUBE";
                        break;
                    case F:
                        t = "ENVMAP_TYPE_CUBE_UV"
                    }
                return t
            }(n)
              , p = function(e) {
                let t = "ENVMAP_MODE_REFLECTION";
                e.envMap && e.envMapMode === P && (t = "ENVMAP_MODE_REFRACTION");
                return t
            }(n)
              , f = function(e) {
                let t = "ENVMAP_BLENDING_NONE";
                if (e.envMap)
                    switch (e.combine) {
                    case x:
                        t = "ENVMAP_BLENDING_MULTIPLY";
                        break;
                    case _:
                        t = "ENVMAP_BLENDING_MIX";
                        break;
                    case b:
                        t = "ENVMAP_BLENDING_ADD"
                    }
                return t
            }(n)
              , A = function(e) {
                const t = e.envMapCubeUVHeight;
                if (null === t)
                    return null;
                const n = Math.log2(t) - 2
                  , i = 1 / t;
                return {
                    texelWidth: 1 / (3 * Math.max(Math.pow(2, n), 112)),
                    texelHeight: i,
                    maxMip: n
                }
            }(n)
              , g = function(e) {
                return [e.extensionClipCullDistance ? "#extension GL_ANGLE_clip_cull_distance : require" : "", e.extensionMultiDraw ? "#extension GL_ANGLE_multi_draw : require" : ""].filter(Ua).join("\n")
            }(n)
              , m = function(e) {
                const t = [];
                for (const n in e) {
                    const i = e[n];
                    !1 !== i && t.push("#define " + n + " " + i)
                }
                return t.join("\n")
            }(l)
              , v = o.createProgram();
            let y, w, C = n.glslVersion ? "#version " + n.glslVersion + "\n" : "";
            n.isRawShaderMaterial ? (y = ["#define SHADER_TYPE " + n.shaderType, "#define SHADER_NAME " + n.shaderName, m].filter(Ua).join("\n"),
            y.length > 0 && (y += "\n"),
            w = ["#define SHADER_TYPE " + n.shaderType, "#define SHADER_NAME " + n.shaderName, m].filter(Ua).join("\n"),
            w.length > 0 && (w += "\n")) : (y = [Wa(n), "#define SHADER_TYPE " + n.shaderType, "#define SHADER_NAME " + n.shaderName, m, n.extensionClipCullDistance ? "#define USE_CLIP_DISTANCE" : "", n.batching ? "#define USE_BATCHING" : "", n.batchingColor ? "#define USE_BATCHING_COLOR" : "", n.instancing ? "#define USE_INSTANCING" : "", n.instancingColor ? "#define USE_INSTANCING_COLOR" : "", n.instancingMorph ? "#define USE_INSTANCING_MORPH" : "", n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + p : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", n.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", n.displacementMap ? "#define USE_DISPLACEMENTMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.anisotropy ? "#define USE_ANISOTROPY" : "", n.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", n.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", n.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.alphaHash ? "#define USE_ALPHAHASH" : "", n.transmission ? "#define USE_TRANSMISSION" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.thicknessMap ? "#define USE_THICKNESSMAP" : "", n.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", n.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", n.mapUv ? "#define MAP_UV " + n.mapUv : "", n.alphaMapUv ? "#define ALPHAMAP_UV " + n.alphaMapUv : "", n.lightMapUv ? "#define LIGHTMAP_UV " + n.lightMapUv : "", n.aoMapUv ? "#define AOMAP_UV " + n.aoMapUv : "", n.emissiveMapUv ? "#define EMISSIVEMAP_UV " + n.emissiveMapUv : "", n.bumpMapUv ? "#define BUMPMAP_UV " + n.bumpMapUv : "", n.normalMapUv ? "#define NORMALMAP_UV " + n.normalMapUv : "", n.displacementMapUv ? "#define DISPLACEMENTMAP_UV " + n.displacementMapUv : "", n.metalnessMapUv ? "#define METALNESSMAP_UV " + n.metalnessMapUv : "", n.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + n.roughnessMapUv : "", n.anisotropyMapUv ? "#define ANISOTROPYMAP_UV " + n.anisotropyMapUv : "", n.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + n.clearcoatMapUv : "", n.clearcoatNormalMapUv ? "#define CLEARCOAT_NORMALMAP_UV " + n.clearcoatNormalMapUv : "", n.clearcoatRoughnessMapUv ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + n.clearcoatRoughnessMapUv : "", n.iridescenceMapUv ? "#define IRIDESCENCEMAP_UV " + n.iridescenceMapUv : "", n.iridescenceThicknessMapUv ? "#define IRIDESCENCE_THICKNESSMAP_UV " + n.iridescenceThicknessMapUv : "", n.sheenColorMapUv ? "#define SHEEN_COLORMAP_UV " + n.sheenColorMapUv : "", n.sheenRoughnessMapUv ? "#define SHEEN_ROUGHNESSMAP_UV " + n.sheenRoughnessMapUv : "", n.specularMapUv ? "#define SPECULARMAP_UV " + n.specularMapUv : "", n.specularColorMapUv ? "#define SPECULAR_COLORMAP_UV " + n.specularColorMapUv : "", n.specularIntensityMapUv ? "#define SPECULAR_INTENSITYMAP_UV " + n.specularIntensityMapUv : "", n.transmissionMapUv ? "#define TRANSMISSIONMAP_UV " + n.transmissionMapUv : "", n.thicknessMapUv ? "#define THICKNESSMAP_UV " + n.thicknessMapUv : "", n.vertexTangents && !1 === n.flatShading ? "#define USE_TANGENT" : "", n.vertexColors ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUv1s ? "#define USE_UV1" : "", n.vertexUv2s ? "#define USE_UV2" : "", n.vertexUv3s ? "#define USE_UV3" : "", n.pointsUvs ? "#define USE_POINTS_UV" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.skinning ? "#define USE_SKINNING" : "", n.morphTargets ? "#define USE_MORPHTARGETS" : "", n.morphNormals && !1 === n.flatShading ? "#define USE_MORPHNORMALS" : "", n.morphColors ? "#define USE_MORPHCOLORS" : "", n.morphTargetsCount > 0 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + n.morphTextureStride : "", n.morphTargetsCount > 0 ? "#define MORPHTARGETS_COUNT " + n.morphTargetsCount : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + h : "", n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", n.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.reverseDepthBuffer ? "#define USE_REVERSEDEPTHBUF" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "\tattribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "\tattribute vec3 instanceColor;", "#endif", "#ifdef USE_INSTANCING_MORPH", "\tuniform sampler2D morphTexture;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_UV1", "\tattribute vec2 uv1;", "#endif", "#ifdef USE_UV2", "\tattribute vec2 uv2;", "#endif", "#ifdef USE_UV3", "\tattribute vec2 uv3;", "#endif", "#ifdef USE_TANGENT", "\tattribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "\tattribute vec4 color;", "#elif defined( USE_COLOR )", "\tattribute vec3 color;", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(Ua).join("\n"),
            w = [Wa(n), "#define SHADER_TYPE " + n.shaderType, "#define SHADER_NAME " + n.shaderName, m, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.alphaToCoverage ? "#define ALPHA_TO_COVERAGE" : "", n.map ? "#define USE_MAP" : "", n.matcap ? "#define USE_MATCAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + d : "", n.envMap ? "#define " + p : "", n.envMap ? "#define " + f : "", A ? "#define CUBEUV_TEXEL_WIDTH " + A.texelWidth : "", A ? "#define CUBEUV_TEXEL_HEIGHT " + A.texelHeight : "", A ? "#define CUBEUV_MAX_MIP " + A.maxMip + ".0" : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", n.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.anisotropy ? "#define USE_ANISOTROPY" : "", n.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", n.clearcoat ? "#define USE_CLEARCOAT" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.dispersion ? "#define USE_DISPERSION" : "", n.iridescence ? "#define USE_IRIDESCENCE" : "", n.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", n.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", n.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.alphaTest ? "#define USE_ALPHATEST" : "", n.alphaHash ? "#define USE_ALPHAHASH" : "", n.sheen ? "#define USE_SHEEN" : "", n.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", n.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", n.transmission ? "#define USE_TRANSMISSION" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.thicknessMap ? "#define USE_THICKNESSMAP" : "", n.vertexTangents && !1 === n.flatShading ? "#define USE_TANGENT" : "", n.vertexColors || n.instancingColor || n.batchingColor ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUv1s ? "#define USE_UV1" : "", n.vertexUv2s ? "#define USE_UV2" : "", n.vertexUv3s ? "#define USE_UV3" : "", n.pointsUvs ? "#define USE_POINTS_UV" : "", n.gradientMap ? "#define USE_GRADIENTMAP" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + h : "", n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", n.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "", n.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "", n.decodeVideoTextureEmissive ? "#define DECODE_VIDEO_TEXTURE_EMISSIVE" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.reverseDepthBuffer ? "#define USE_REVERSEDEPTHBUF" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", n.toneMapping !== E ? "#define TONE_MAPPING" : "", n.toneMapping !== E ? Nr.tonemapping_pars_fragment : "", n.toneMapping !== E ? Da("toneMapping", n.toneMapping) : "", n.dithering ? "#define DITHERING" : "", n.opaque ? "#define OPAQUE" : "", Nr.colorspace_pars_fragment, Ra("linearToOutputTexel", n.outputColorSpace), La(), n.useDepthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "", "\n"].filter(Ua).join("\n")),
            c = Qa(c),
            c = Fa(c, n),
            c = Na(c, n),
            u = Qa(u),
            u = Fa(u, n),
            u = Na(u, n),
            c = za(c),
            u = za(u),
            !0 !== n.isRawShaderMaterial && (C = "#version 300 es\n",
            y = [g, "#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + y,
            w = ["#define varying in", n.glslVersion === gt ? "" : "layout(location = 0) out highp vec4 pc_fragColor;", n.glslVersion === gt ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + w);
            const I = C + y + c
              , S = C + w + u
              , M = Ia(o, o.VERTEX_SHADER, I)
              , T = Ia(o, o.FRAGMENT_SHADER, S);
            function B(t) {
                if (e.debug.checkShaderErrors) {
                    const n = o.getProgramInfoLog(v).trim()
                      , i = o.getShaderInfoLog(M).trim()
                      , r = o.getShaderInfoLog(T).trim();
                    let s = !0
                      , a = !0;
                    if (!1 === o.getProgramParameter(v, o.LINK_STATUS))
                        if (s = !1,
                        "function" == typeof e.debug.onShaderError)
                            e.debug.onShaderError(o, v, M, T);
                        else {
                            const e = Ba(o, M, "vertex")
                              , i = Ba(o, T, "fragment");
                            console.error("THREE.WebGLProgram: Shader Error " + o.getError() + " - VALIDATE_STATUS " + o.getProgramParameter(v, o.VALIDATE_STATUS) + "\n\nMaterial Name: " + t.name + "\nMaterial Type: " + t.type + "\n\nProgram Info Log: " + n + "\n" + e + "\n" + i)
                        }
                    else
                        "" !== n ? console.warn("THREE.WebGLProgram: Program Info Log:", n) : "" !== i && "" !== r || (a = !1);
                    a && (t.diagnostics = {
                        runnable: s,
                        programLog: n,
                        vertexShader: {
                            log: i,
                            prefix: y
                        },
                        fragmentShader: {
                            log: r,
                            prefix: w
                        }
                    })
                }
                o.deleteShader(M),
                o.deleteShader(T),
                R = new Ca(o,v),
                L = function(e, t) {
                    const n = {}
                      , i = e.getProgramParameter(t, e.ACTIVE_ATTRIBUTES);
                    for (let r = 0; r < i; r++) {
                        const i = e.getActiveAttrib(t, r)
                          , s = i.name;
                        let a = 1;
                        i.type === e.FLOAT_MAT2 && (a = 2),
                        i.type === e.FLOAT_MAT3 && (a = 3),
                        i.type === e.FLOAT_MAT4 && (a = 4),
                        n[s] = {
                            type: i.type,
                            location: e.getAttribLocation(t, s),
                            locationSize: a
                        }
                    }
                    return n
                }(o, v)
            }
            let R, L;
            o.attachShader(v, M),
            o.attachShader(v, T),
            void 0 !== n.index0AttributeName ? o.bindAttribLocation(v, 0, n.index0AttributeName) : !0 === n.morphTargets && o.bindAttribLocation(v, 0, "position"),
            o.linkProgram(v),
            this.getUniforms = function() {
                return void 0 === R && B(this),
                R
            }
            ,
            this.getAttributes = function() {
                return void 0 === L && B(this),
                L
            }
            ;
            let U = !1 === n.rendererExtensionParallelShaderCompile;
            return this.isReady = function() {
                return !1 === U && (U = o.getProgramParameter(v, Sa)),
                U
            }
            ,
            this.destroy = function() {
                i.releaseStatesOfProgram(this),
                o.deleteProgram(v),
                this.program = void 0
            }
            ,
            this.type = n.shaderType,
            this.name = n.shaderName,
            this.id = Ma++,
            this.cacheKey = t,
            this.usedTimes = 1,
            this.program = v,
            this.vertexShader = M,
            this.fragmentShader = T,
            this
        }
        let qa = 0;
        class Ya {
            constructor() {
                this.shaderCache = new Map,
                this.materialCache = new Map
            }
            update(e) {
                const t = e.vertexShader
                  , n = e.fragmentShader
                  , i = this._getShaderStage(t)
                  , r = this._getShaderStage(n)
                  , s = this._getShaderCacheForMaterial(e);
                return !1 === s.has(i) && (s.add(i),
                i.usedTimes++),
                !1 === s.has(r) && (s.add(r),
                r.usedTimes++),
                this
            }
            remove(e) {
                const t = this.materialCache.get(e);
                for (const e of t)
                    e.usedTimes--,
                    0 === e.usedTimes && this.shaderCache.delete(e.code);
                return this.materialCache.delete(e),
                this
            }
            getVertexShaderID(e) {
                return this._getShaderStage(e.vertexShader).id
            }
            getFragmentShaderID(e) {
                return this._getShaderStage(e.fragmentShader).id
            }
            dispose() {
                this.shaderCache.clear(),
                this.materialCache.clear()
            }
            _getShaderCacheForMaterial(e) {
                const t = this.materialCache;
                let n = t.get(e);
                return void 0 === n && (n = new Set,
                t.set(e, n)),
                n
            }
            _getShaderStage(e) {
                const t = this.shaderCache;
                let n = t.get(e);
                return void 0 === n && (n = new Xa(e),
                t.set(e, n)),
                n
            }
        }
        class Xa {
            constructor(e) {
                this.id = qa++,
                this.code = e,
                this.usedTimes = 0
            }
        }
        function Ka(e, t, n, i, r, s, a) {
            const o = new Yn
              , u = new Ya
              , h = new Set
              , d = []
              , p = r.logarithmicDepthBuffer
              , f = r.vertexTextures;
            let A = r.precision;
            const g = {
                MeshDepthMaterial: "depth",
                MeshDistanceMaterial: "distanceRGBA",
                MeshNormalMaterial: "normal",
                MeshBasicMaterial: "basic",
                MeshLambertMaterial: "lambert",
                MeshPhongMaterial: "phong",
                MeshToonMaterial: "toon",
                MeshStandardMaterial: "physical",
                MeshPhysicalMaterial: "physical",
                MeshMatcapMaterial: "matcap",
                LineBasicMaterial: "basic",
                LineDashedMaterial: "dashed",
                PointsMaterial: "points",
                ShadowMaterial: "shadow",
                SpriteMaterial: "sprite"
            };
            function m(e) {
                return h.add(e),
                0 === e ? "uv" : `uv${e}`
            }
            return {
                getParameters: function(s, o, d, v, y) {
                    const x = v.fog
                      , _ = y.geometry
                      , b = s.isMeshStandardMaterial ? v.environment : null
                      , w = (s.isMeshStandardMaterial ? n : t).get(s.envMap || b)
                      , C = w && w.mapping === F ? w.image.height : null
                      , I = g[s.type];
                    null !== s.precision && (A = r.getMaxPrecision(s.precision),
                    A !== s.precision && console.warn("THREE.WebGLProgram.getParameters:", s.precision, "not supported, using", A, "instead."));
                    const S = _.morphAttributes.position || _.morphAttributes.normal || _.morphAttributes.color
                      , M = void 0 !== S ? S.length : 0;
                    let T, B, R, D, P = 0;
                    if (void 0 !== _.morphAttributes.position && (P = 1),
                    void 0 !== _.morphAttributes.normal && (P = 2),
                    void 0 !== _.morphAttributes.color && (P = 3),
                    I) {
                        const e = Qr[I];
                        T = e.vertexShader,
                        B = e.fragmentShader
                    } else
                        T = s.vertexShader,
                        B = s.fragmentShader,
                        u.update(s),
                        R = u.getVertexShaderID(s),
                        D = u.getFragmentShaderID(s);
                    const L = e.getRenderTarget()
                      , U = e.state.buffers.depth.getReversed()
                      , N = !0 === y.isInstancedMesh
                      , O = !0 === y.isBatchedMesh
                      , Q = !!s.map
                      , k = !!s.matcap
                      , G = !!w
                      , H = !!s.aoMap
                      , z = !!s.lightMap
                      , V = !!s.bumpMap
                      , W = !!s.normalMap
                      , j = !!s.displacementMap
                      , q = !!s.emissiveMap
                      , Y = !!s.metalnessMap
                      , X = !!s.roughnessMap
                      , K = s.anisotropy > 0
                      , J = s.clearcoat > 0
                      , Z = s.dispersion > 0
                      , $ = s.iridescence > 0
                      , ee = s.sheen > 0
                      , te = s.transmission > 0
                      , ne = K && !!s.anisotropyMap
                      , ie = J && !!s.clearcoatMap
                      , re = J && !!s.clearcoatNormalMap
                      , se = J && !!s.clearcoatRoughnessMap
                      , ae = $ && !!s.iridescenceMap
                      , oe = $ && !!s.iridescenceThicknessMap
                      , le = ee && !!s.sheenColorMap
                      , ce = ee && !!s.sheenRoughnessMap
                      , ue = !!s.specularMap
                      , he = !!s.specularColorMap
                      , de = !!s.specularIntensityMap
                      , pe = te && !!s.transmissionMap
                      , fe = te && !!s.thicknessMap
                      , Ae = !!s.gradientMap
                      , ge = !!s.alphaMap
                      , me = s.alphaTest > 0
                      , ve = !!s.alphaHash
                      , ye = !!s.extensions;
                    let xe = E;
                    s.toneMapped && (null !== L && !0 !== L.isXRRenderTarget || (xe = e.toneMapping));
                    const _e = {
                        shaderID: I,
                        shaderType: s.type,
                        shaderName: s.name,
                        vertexShader: T,
                        fragmentShader: B,
                        defines: s.defines,
                        customVertexShaderID: R,
                        customFragmentShaderID: D,
                        isRawShaderMaterial: !0 === s.isRawShaderMaterial,
                        glslVersion: s.glslVersion,
                        precision: A,
                        batching: O,
                        batchingColor: O && null !== y._colorsTexture,
                        instancing: N,
                        instancingColor: N && null !== y.instanceColor,
                        instancingMorph: N && null !== y.morphTexture,
                        supportsVertexTextures: f,
                        outputColorSpace: null === L ? e.outputColorSpace : !0 === L.isXRRenderTarget ? L.texture.colorSpace : ut,
                        alphaToCoverage: !!s.alphaToCoverage,
                        map: Q,
                        matcap: k,
                        envMap: G,
                        envMapMode: G && w.mapping,
                        envMapCubeUVHeight: C,
                        aoMap: H,
                        lightMap: z,
                        bumpMap: V,
                        normalMap: W,
                        displacementMap: f && j,
                        emissiveMap: q,
                        normalMapObjectSpace: W && 1 === s.normalMapType,
                        normalMapTangentSpace: W && 0 === s.normalMapType,
                        metalnessMap: Y,
                        roughnessMap: X,
                        anisotropy: K,
                        anisotropyMap: ne,
                        clearcoat: J,
                        clearcoatMap: ie,
                        clearcoatNormalMap: re,
                        clearcoatRoughnessMap: se,
                        dispersion: Z,
                        iridescence: $,
                        iridescenceMap: ae,
                        iridescenceThicknessMap: oe,
                        sheen: ee,
                        sheenColorMap: le,
                        sheenRoughnessMap: ce,
                        specularMap: ue,
                        specularColorMap: he,
                        specularIntensityMap: de,
                        transmission: te,
                        transmissionMap: pe,
                        thicknessMap: fe,
                        gradientMap: Ae,
                        opaque: !1 === s.transparent && 1 === s.blending && !1 === s.alphaToCoverage,
                        alphaMap: ge,
                        alphaTest: me,
                        alphaHash: ve,
                        combine: s.combine,
                        mapUv: Q && m(s.map.channel),
                        aoMapUv: H && m(s.aoMap.channel),
                        lightMapUv: z && m(s.lightMap.channel),
                        bumpMapUv: V && m(s.bumpMap.channel),
                        normalMapUv: W && m(s.normalMap.channel),
                        displacementMapUv: j && m(s.displacementMap.channel),
                        emissiveMapUv: q && m(s.emissiveMap.channel),
                        metalnessMapUv: Y && m(s.metalnessMap.channel),
                        roughnessMapUv: X && m(s.roughnessMap.channel),
                        anisotropyMapUv: ne && m(s.anisotropyMap.channel),
                        clearcoatMapUv: ie && m(s.clearcoatMap.channel),
                        clearcoatNormalMapUv: re && m(s.clearcoatNormalMap.channel),
                        clearcoatRoughnessMapUv: se && m(s.clearcoatRoughnessMap.channel),
                        iridescenceMapUv: ae && m(s.iridescenceMap.channel),
                        iridescenceThicknessMapUv: oe && m(s.iridescenceThicknessMap.channel),
                        sheenColorMapUv: le && m(s.sheenColorMap.channel),
                        sheenRoughnessMapUv: ce && m(s.sheenRoughnessMap.channel),
                        specularMapUv: ue && m(s.specularMap.channel),
                        specularColorMapUv: he && m(s.specularColorMap.channel),
                        specularIntensityMapUv: de && m(s.specularIntensityMap.channel),
                        transmissionMapUv: pe && m(s.transmissionMap.channel),
                        thicknessMapUv: fe && m(s.thicknessMap.channel),
                        alphaMapUv: ge && m(s.alphaMap.channel),
                        vertexTangents: !!_.attributes.tangent && (W || K),
                        vertexColors: s.vertexColors,
                        vertexAlphas: !0 === s.vertexColors && !!_.attributes.color && 4 === _.attributes.color.itemSize,
                        pointsUvs: !0 === y.isPoints && !!_.attributes.uv && (Q || ge),
                        fog: !!x,
                        useFog: !0 === s.fog,
                        fogExp2: !!x && x.isFogExp2,
                        flatShading: !0 === s.flatShading,
                        sizeAttenuation: !0 === s.sizeAttenuation,
                        logarithmicDepthBuffer: p,
                        reverseDepthBuffer: U,
                        skinning: !0 === y.isSkinnedMesh,
                        morphTargets: void 0 !== _.morphAttributes.position,
                        morphNormals: void 0 !== _.morphAttributes.normal,
                        morphColors: void 0 !== _.morphAttributes.color,
                        morphTargetsCount: M,
                        morphTextureStride: P,
                        numDirLights: o.directional.length,
                        numPointLights: o.point.length,
                        numSpotLights: o.spot.length,
                        numSpotLightMaps: o.spotLightMap.length,
                        numRectAreaLights: o.rectArea.length,
                        numHemiLights: o.hemi.length,
                        numDirLightShadows: o.directionalShadowMap.length,
                        numPointLightShadows: o.pointShadowMap.length,
                        numSpotLightShadows: o.spotShadowMap.length,
                        numSpotLightShadowsWithMaps: o.numSpotLightShadowsWithMaps,
                        numLightProbes: o.numLightProbes,
                        numClippingPlanes: a.numPlanes,
                        numClipIntersection: a.numIntersection,
                        dithering: s.dithering,
                        shadowMapEnabled: e.shadowMap.enabled && d.length > 0,
                        shadowMapType: e.shadowMap.type,
                        toneMapping: xe,
                        decodeVideoTexture: Q && !0 === s.map.isVideoTexture && Qt.getTransfer(s.map.colorSpace) === dt,
                        decodeVideoTextureEmissive: q && !0 === s.emissiveMap.isVideoTexture && Qt.getTransfer(s.emissiveMap.colorSpace) === dt,
                        premultipliedAlpha: s.premultipliedAlpha,
                        doubleSided: s.side === c,
                        flipSided: s.side === l,
                        useDepthPacking: s.depthPacking >= 0,
                        depthPacking: s.depthPacking || 0,
                        index0AttributeName: s.index0AttributeName,
                        extensionClipCullDistance: ye && !0 === s.extensions.clipCullDistance && i.has("WEBGL_clip_cull_distance"),
                        extensionMultiDraw: (ye && !0 === s.extensions.multiDraw || O) && i.has("WEBGL_multi_draw"),
                        rendererExtensionParallelShaderCompile: i.has("KHR_parallel_shader_compile"),
                        customProgramCacheKey: s.customProgramCacheKey()
                    };
                    return _e.vertexUv1s = h.has(1),
                    _e.vertexUv2s = h.has(2),
                    _e.vertexUv3s = h.has(3),
                    h.clear(),
                    _e
                },
                getProgramCacheKey: function(t) {
                    const n = [];
                    if (t.shaderID ? n.push(t.shaderID) : (n.push(t.customVertexShaderID),
                    n.push(t.customFragmentShaderID)),
                    void 0 !== t.defines)
                        for (const e in t.defines)
                            n.push(e),
                            n.push(t.defines[e]);
                    return !1 === t.isRawShaderMaterial && (!function(e, t) {
                        e.push(t.precision),
                        e.push(t.outputColorSpace),
                        e.push(t.envMapMode),
                        e.push(t.envMapCubeUVHeight),
                        e.push(t.mapUv),
                        e.push(t.alphaMapUv),
                        e.push(t.lightMapUv),
                        e.push(t.aoMapUv),
                        e.push(t.bumpMapUv),
                        e.push(t.normalMapUv),
                        e.push(t.displacementMapUv),
                        e.push(t.emissiveMapUv),
                        e.push(t.metalnessMapUv),
                        e.push(t.roughnessMapUv),
                        e.push(t.anisotropyMapUv),
                        e.push(t.clearcoatMapUv),
                        e.push(t.clearcoatNormalMapUv),
                        e.push(t.clearcoatRoughnessMapUv),
                        e.push(t.iridescenceMapUv),
                        e.push(t.iridescenceThicknessMapUv),
                        e.push(t.sheenColorMapUv),
                        e.push(t.sheenRoughnessMapUv),
                        e.push(t.specularMapUv),
                        e.push(t.specularColorMapUv),
                        e.push(t.specularIntensityMapUv),
                        e.push(t.transmissionMapUv),
                        e.push(t.thicknessMapUv),
                        e.push(t.combine),
                        e.push(t.fogExp2),
                        e.push(t.sizeAttenuation),
                        e.push(t.morphTargetsCount),
                        e.push(t.morphAttributeCount),
                        e.push(t.numDirLights),
                        e.push(t.numPointLights),
                        e.push(t.numSpotLights),
                        e.push(t.numSpotLightMaps),
                        e.push(t.numHemiLights),
                        e.push(t.numRectAreaLights),
                        e.push(t.numDirLightShadows),
                        e.push(t.numPointLightShadows),
                        e.push(t.numSpotLightShadows),
                        e.push(t.numSpotLightShadowsWithMaps),
                        e.push(t.numLightProbes),
                        e.push(t.shadowMapType),
                        e.push(t.toneMapping),
                        e.push(t.numClippingPlanes),
                        e.push(t.numClipIntersection),
                        e.push(t.depthPacking)
                    }(n, t),
                    function(e, t) {
                        o.disableAll(),
                        t.supportsVertexTextures && o.enable(0);
                        t.instancing && o.enable(1);
                        t.instancingColor && o.enable(2);
                        t.instancingMorph && o.enable(3);
                        t.matcap && o.enable(4);
                        t.envMap && o.enable(5);
                        t.normalMapObjectSpace && o.enable(6);
                        t.normalMapTangentSpace && o.enable(7);
                        t.clearcoat && o.enable(8);
                        t.iridescence && o.enable(9);
                        t.alphaTest && o.enable(10);
                        t.vertexColors && o.enable(11);
                        t.vertexAlphas && o.enable(12);
                        t.vertexUv1s && o.enable(13);
                        t.vertexUv2s && o.enable(14);
                        t.vertexUv3s && o.enable(15);
                        t.vertexTangents && o.enable(16);
                        t.anisotropy && o.enable(17);
                        t.alphaHash && o.enable(18);
                        t.batching && o.enable(19);
                        t.dispersion && o.enable(20);
                        t.batchingColor && o.enable(21);
                        e.push(o.mask),
                        o.disableAll(),
                        t.fog && o.enable(0);
                        t.useFog && o.enable(1);
                        t.flatShading && o.enable(2);
                        t.logarithmicDepthBuffer && o.enable(3);
                        t.reverseDepthBuffer && o.enable(4);
                        t.skinning && o.enable(5);
                        t.morphTargets && o.enable(6);
                        t.morphNormals && o.enable(7);
                        t.morphColors && o.enable(8);
                        t.premultipliedAlpha && o.enable(9);
                        t.shadowMapEnabled && o.enable(10);
                        t.doubleSided && o.enable(11);
                        t.flipSided && o.enable(12);
                        t.useDepthPacking && o.enable(13);
                        t.dithering && o.enable(14);
                        t.transmission && o.enable(15);
                        t.sheen && o.enable(16);
                        t.opaque && o.enable(17);
                        t.pointsUvs && o.enable(18);
                        t.decodeVideoTexture && o.enable(19);
                        t.decodeVideoTextureEmissive && o.enable(20);
                        t.alphaToCoverage && o.enable(21);
                        e.push(o.mask)
                    }(n, t),
                    n.push(e.outputColorSpace)),
                    n.push(t.customProgramCacheKey),
                    n.join()
                },
                getUniforms: function(e) {
                    const t = g[e.type];
                    let n;
                    if (t) {
                        const e = Qr[t];
                        n = gr.clone(e.uniforms)
                    } else
                        n = e.uniforms;
                    return n
                },
                acquireProgram: function(t, n) {
                    let i;
                    for (let e = 0, t = d.length; e < t; e++) {
                        const t = d[e];
                        if (t.cacheKey === n) {
                            i = t,
                            ++i.usedTimes;
                            break
                        }
                    }
                    return void 0 === i && (i = new ja(e,n,t,s),
                    d.push(i)),
                    i
                },
                releaseProgram: function(e) {
                    if (0 == --e.usedTimes) {
                        const t = d.indexOf(e);
                        d[t] = d[d.length - 1],
                        d.pop(),
                        e.destroy()
                    }
                },
                releaseShaderCache: function(e) {
                    u.remove(e)
                },
                programs: d,
                dispose: function() {
                    u.dispose()
                }
            }
        }
        function Ja() {
            let e = new WeakMap;
            return {
                has: function(t) {
                    return e.has(t)
                },
                get: function(t) {
                    let n = e.get(t);
                    return void 0 === n && (n = {},
                    e.set(t, n)),
                    n
                },
                remove: function(t) {
                    e.delete(t)
                },
                update: function(t, n, i) {
                    e.get(t)[n] = i
                },
                dispose: function() {
                    e = new WeakMap
                }
            }
        }
        function Za(e, t) {
            return e.groupOrder !== t.groupOrder ? e.groupOrder - t.groupOrder : e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.material.id !== t.material.id ? e.material.id - t.material.id : e.z !== t.z ? e.z - t.z : e.id - t.id
        }
        function $a(e, t) {
            return e.groupOrder !== t.groupOrder ? e.groupOrder - t.groupOrder : e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.z !== t.z ? t.z - e.z : e.id - t.id
        }
        function eo() {
            const e = [];
            let t = 0;
            const n = []
              , i = []
              , r = [];
            function s(n, i, r, s, a, o) {
                let l = e[t];
                return void 0 === l ? (l = {
                    id: n.id,
                    object: n,
                    geometry: i,
                    material: r,
                    groupOrder: s,
                    renderOrder: n.renderOrder,
                    z: a,
                    group: o
                },
                e[t] = l) : (l.id = n.id,
                l.object = n,
                l.geometry = i,
                l.material = r,
                l.groupOrder = s,
                l.renderOrder = n.renderOrder,
                l.z = a,
                l.group = o),
                t++,
                l
            }
            return {
                opaque: n,
                transmissive: i,
                transparent: r,
                init: function() {
                    t = 0,
                    n.length = 0,
                    i.length = 0,
                    r.length = 0
                },
                push: function(e, t, a, o, l, c) {
                    const u = s(e, t, a, o, l, c);
                    a.transmission > 0 ? i.push(u) : !0 === a.transparent ? r.push(u) : n.push(u)
                },
                unshift: function(e, t, a, o, l, c) {
                    const u = s(e, t, a, o, l, c);
                    a.transmission > 0 ? i.unshift(u) : !0 === a.transparent ? r.unshift(u) : n.unshift(u)
                },
                finish: function() {
                    for (let n = t, i = e.length; n < i; n++) {
                        const t = e[n];
                        if (null === t.id)
                            break;
                        t.id = null,
                        t.object = null,
                        t.geometry = null,
                        t.material = null,
                        t.group = null
                    }
                },
                sort: function(e, t) {
                    n.length > 1 && n.sort(e || Za),
                    i.length > 1 && i.sort(t || $a),
                    r.length > 1 && r.sort(t || $a)
                }
            }
        }
        function to() {
            let e = new WeakMap;
            return {
                get: function(t, n) {
                    const i = e.get(t);
                    let r;
                    return void 0 === i ? (r = new eo,
                    e.set(t, [r])) : n >= i.length ? (r = new eo,
                    i.push(r)) : r = i[n],
                    r
                },
                dispose: function() {
                    e = new WeakMap
                }
            }
        }
        function no() {
            const e = {};
            return {
                get: function(t) {
                    if (void 0 !== e[t.id])
                        return e[t.id];
                    let n;
                    switch (t.type) {
                    case "DirectionalLight":
                        n = {
                            direction: new on,
                            color: new Ti
                        };
                        break;
                    case "SpotLight":
                        n = {
                            position: new on,
                            direction: new on,
                            color: new Ti,
                            distance: 0,
                            coneCos: 0,
                            penumbraCos: 0,
                            decay: 0
                        };
                        break;
                    case "PointLight":
                        n = {
                            position: new on,
                            color: new Ti,
                            distance: 0,
                            decay: 0
                        };
                        break;
                    case "HemisphereLight":
                        n = {
                            direction: new on,
                            skyColor: new Ti,
                            groundColor: new Ti
                        };
                        break;
                    case "RectAreaLight":
                        n = {
                            color: new Ti,
                            position: new on,
                            halfWidth: new on,
                            halfHeight: new on
                        }
                    }
                    return e[t.id] = n,
                    n
                }
            }
        }
        let io = 0;
        function ro(e, t) {
            return (t.castShadow ? 2 : 0) - (e.castShadow ? 2 : 0) + (t.map ? 1 : 0) - (e.map ? 1 : 0)
        }
        function so(e) {
            const t = new no
              , n = function() {
                const e = {};
                return {
                    get: function(t) {
                        if (void 0 !== e[t.id])
                            return e[t.id];
                        let n;
                        switch (t.type) {
                        case "DirectionalLight":
                        case "SpotLight":
                            n = {
                                shadowIntensity: 1,
                                shadowBias: 0,
                                shadowNormalBias: 0,
                                shadowRadius: 1,
                                shadowMapSize: new Rt
                            };
                            break;
                        case "PointLight":
                            n = {
                                shadowIntensity: 1,
                                shadowBias: 0,
                                shadowNormalBias: 0,
                                shadowRadius: 1,
                                shadowMapSize: new Rt,
                                shadowCameraNear: 1,
                                shadowCameraFar: 1e3
                            }
                        }
                        return e[t.id] = n,
                        n
                    }
                }
            }()
              , i = {
                version: 0,
                hash: {
                    directionalLength: -1,
                    pointLength: -1,
                    spotLength: -1,
                    rectAreaLength: -1,
                    hemiLength: -1,
                    numDirectionalShadows: -1,
                    numPointShadows: -1,
                    numSpotShadows: -1,
                    numSpotMaps: -1,
                    numLightProbes: -1
                },
                ambient: [0, 0, 0],
                probe: [],
                directional: [],
                directionalShadow: [],
                directionalShadowMap: [],
                directionalShadowMatrix: [],
                spot: [],
                spotLightMap: [],
                spotShadow: [],
                spotShadowMap: [],
                spotLightMatrix: [],
                rectArea: [],
                rectAreaLTC1: null,
                rectAreaLTC2: null,
                point: [],
                pointShadow: [],
                pointShadowMap: [],
                pointShadowMatrix: [],
                hemi: [],
                numSpotLightShadowsWithMaps: 0,
                numLightProbes: 0
            };
            for (let e = 0; e < 9; e++)
                i.probe.push(new on);
            const r = new on
              , s = new Nn
              , a = new Nn;
            return {
                setup: function(r) {
                    let s = 0
                      , a = 0
                      , o = 0;
                    for (let e = 0; e < 9; e++)
                        i.probe[e].set(0, 0, 0);
                    let l = 0
                      , c = 0
                      , u = 0
                      , h = 0
                      , d = 0
                      , p = 0
                      , f = 0
                      , A = 0
                      , g = 0
                      , m = 0
                      , v = 0;
                    r.sort(ro);
                    for (let e = 0, y = r.length; e < y; e++) {
                        const y = r[e]
                          , x = y.color
                          , _ = y.intensity
                          , b = y.distance
                          , E = y.shadow && y.shadow.map ? y.shadow.map.texture : null;
                        if (y.isAmbientLight)
                            s += x.r * _,
                            a += x.g * _,
                            o += x.b * _;
                        else if (y.isLightProbe) {
                            for (let e = 0; e < 9; e++)
                                i.probe[e].addScaledVector(y.sh.coefficients[e], _);
                            v++
                        } else if (y.isDirectionalLight) {
                            const e = t.get(y);
                            if (e.color.copy(y.color).multiplyScalar(y.intensity),
                            y.castShadow) {
                                const e = y.shadow
                                  , t = n.get(y);
                                t.shadowIntensity = e.intensity,
                                t.shadowBias = e.bias,
                                t.shadowNormalBias = e.normalBias,
                                t.shadowRadius = e.radius,
                                t.shadowMapSize = e.mapSize,
                                i.directionalShadow[l] = t,
                                i.directionalShadowMap[l] = E,
                                i.directionalShadowMatrix[l] = y.shadow.matrix,
                                p++
                            }
                            i.directional[l] = e,
                            l++
                        } else if (y.isSpotLight) {
                            const e = t.get(y);
                            e.position.setFromMatrixPosition(y.matrixWorld),
                            e.color.copy(x).multiplyScalar(_),
                            e.distance = b,
                            e.coneCos = Math.cos(y.angle),
                            e.penumbraCos = Math.cos(y.angle * (1 - y.penumbra)),
                            e.decay = y.decay,
                            i.spot[u] = e;
                            const r = y.shadow;
                            if (y.map && (i.spotLightMap[g] = y.map,
                            g++,
                            r.updateMatrices(y),
                            y.castShadow && m++),
                            i.spotLightMatrix[u] = r.matrix,
                            y.castShadow) {
                                const e = n.get(y);
                                e.shadowIntensity = r.intensity,
                                e.shadowBias = r.bias,
                                e.shadowNormalBias = r.normalBias,
                                e.shadowRadius = r.radius,
                                e.shadowMapSize = r.mapSize,
                                i.spotShadow[u] = e,
                                i.spotShadowMap[u] = E,
                                A++
                            }
                            u++
                        } else if (y.isRectAreaLight) {
                            const e = t.get(y);
                            e.color.copy(x).multiplyScalar(_),
                            e.halfWidth.set(.5 * y.width, 0, 0),
                            e.halfHeight.set(0, .5 * y.height, 0),
                            i.rectArea[h] = e,
                            h++
                        } else if (y.isPointLight) {
                            const e = t.get(y);
                            if (e.color.copy(y.color).multiplyScalar(y.intensity),
                            e.distance = y.distance,
                            e.decay = y.decay,
                            y.castShadow) {
                                const e = y.shadow
                                  , t = n.get(y);
                                t.shadowIntensity = e.intensity,
                                t.shadowBias = e.bias,
                                t.shadowNormalBias = e.normalBias,
                                t.shadowRadius = e.radius,
                                t.shadowMapSize = e.mapSize,
                                t.shadowCameraNear = e.camera.near,
                                t.shadowCameraFar = e.camera.far,
                                i.pointShadow[c] = t,
                                i.pointShadowMap[c] = E,
                                i.pointShadowMatrix[c] = y.shadow.matrix,
                                f++
                            }
                            i.point[c] = e,
                            c++
                        } else if (y.isHemisphereLight) {
                            const e = t.get(y);
                            e.skyColor.copy(y.color).multiplyScalar(_),
                            e.groundColor.copy(y.groundColor).multiplyScalar(_),
                            i.hemi[d] = e,
                            d++
                        }
                    }
                    h > 0 && (!0 === e.has("OES_texture_float_linear") ? (i.rectAreaLTC1 = Or.LTC_FLOAT_1,
                    i.rectAreaLTC2 = Or.LTC_FLOAT_2) : (i.rectAreaLTC1 = Or.LTC_HALF_1,
                    i.rectAreaLTC2 = Or.LTC_HALF_2)),
                    i.ambient[0] = s,
                    i.ambient[1] = a,
                    i.ambient[2] = o;
                    const y = i.hash;
                    y.directionalLength === l && y.pointLength === c && y.spotLength === u && y.rectAreaLength === h && y.hemiLength === d && y.numDirectionalShadows === p && y.numPointShadows === f && y.numSpotShadows === A && y.numSpotMaps === g && y.numLightProbes === v || (i.directional.length = l,
                    i.spot.length = u,
                    i.rectArea.length = h,
                    i.point.length = c,
                    i.hemi.length = d,
                    i.directionalShadow.length = p,
                    i.directionalShadowMap.length = p,
                    i.pointShadow.length = f,
                    i.pointShadowMap.length = f,
                    i.spotShadow.length = A,
                    i.spotShadowMap.length = A,
                    i.directionalShadowMatrix.length = p,
                    i.pointShadowMatrix.length = f,
                    i.spotLightMatrix.length = A + g - m,
                    i.spotLightMap.length = g,
                    i.numSpotLightShadowsWithMaps = m,
                    i.numLightProbes = v,
                    y.directionalLength = l,
                    y.pointLength = c,
                    y.spotLength = u,
                    y.rectAreaLength = h,
                    y.hemiLength = d,
                    y.numDirectionalShadows = p,
                    y.numPointShadows = f,
                    y.numSpotShadows = A,
                    y.numSpotMaps = g,
                    y.numLightProbes = v,
                    i.version = io++)
                },
                setupView: function(e, t) {
                    let n = 0
                      , o = 0
                      , l = 0
                      , c = 0
                      , u = 0;
                    const h = t.matrixWorldInverse;
                    for (let t = 0, d = e.length; t < d; t++) {
                        const d = e[t];
                        if (d.isDirectionalLight) {
                            const e = i.directional[n];
                            e.direction.setFromMatrixPosition(d.matrixWorld),
                            r.setFromMatrixPosition(d.target.matrixWorld),
                            e.direction.sub(r),
                            e.direction.transformDirection(h),
                            n++
                        } else if (d.isSpotLight) {
                            const e = i.spot[l];
                            e.position.setFromMatrixPosition(d.matrixWorld),
                            e.position.applyMatrix4(h),
                            e.direction.setFromMatrixPosition(d.matrixWorld),
                            r.setFromMatrixPosition(d.target.matrixWorld),
                            e.direction.sub(r),
                            e.direction.transformDirection(h),
                            l++
                        } else if (d.isRectAreaLight) {
                            const e = i.rectArea[c];
                            e.position.setFromMatrixPosition(d.matrixWorld),
                            e.position.applyMatrix4(h),
                            a.identity(),
                            s.copy(d.matrixWorld),
                            s.premultiply(h),
                            a.extractRotation(s),
                            e.halfWidth.set(.5 * d.width, 0, 0),
                            e.halfHeight.set(0, .5 * d.height, 0),
                            e.halfWidth.applyMatrix4(a),
                            e.halfHeight.applyMatrix4(a),
                            c++
                        } else if (d.isPointLight) {
                            const e = i.point[o];
                            e.position.setFromMatrixPosition(d.matrixWorld),
                            e.position.applyMatrix4(h),
                            o++
                        } else if (d.isHemisphereLight) {
                            const e = i.hemi[u];
                            e.direction.setFromMatrixPosition(d.matrixWorld),
                            e.direction.transformDirection(h),
                            u++
                        }
                    }
                },
                state: i
            }
        }
        function ao(e) {
            const t = new so(e)
              , n = []
              , i = [];
            const r = {
                lightsArray: n,
                shadowsArray: i,
                camera: null,
                lights: t,
                transmissionRenderTarget: {}
            };
            return {
                init: function(e) {
                    r.camera = e,
                    n.length = 0,
                    i.length = 0
                },
                state: r,
                setupLights: function() {
                    t.setup(n)
                },
                setupLightsView: function(e) {
                    t.setupView(n, e)
                },
                pushLight: function(e) {
                    n.push(e)
                },
                pushShadow: function(e) {
                    i.push(e)
                }
            }
        }
        function oo(e) {
            let t = new WeakMap;
            return {
                get: function(n, i=0) {
                    const r = t.get(n);
                    let s;
                    return void 0 === r ? (s = new ao(e),
                    t.set(n, [s])) : i >= r.length ? (s = new ao(e),
                    r.push(s)) : s = r[i],
                    s
                },
                dispose: function() {
                    t = new WeakMap
                }
            }
        }
        class lo extends Di {
            static get type() {
                return "MeshDepthMaterial"
            }
            constructor(e) {
                super(),
                this.isMeshDepthMaterial = !0,
                this.depthPacking = at,
                this.map = null,
                this.alphaMap = null,
                this.displacementMap = null,
                this.displacementScale = 1,
                this.displacementBias = 0,
                this.wireframe = !1,
                this.wireframeLinewidth = 1,
                this.setValues(e)
            }
            copy(e) {
                return super.copy(e),
                this.depthPacking = e.depthPacking,
                this.map = e.map,
                this.alphaMap = e.alphaMap,
                this.displacementMap = e.displacementMap,
                this.displacementScale = e.displacementScale,
                this.displacementBias = e.displacementBias,
                this.wireframe = e.wireframe,
                this.wireframeLinewidth = e.wireframeLinewidth,
                this
            }
        }
        class co extends Di {
            static get type() {
                return "MeshDistanceMaterial"
            }
            constructor(e) {
                super(),
                this.isMeshDistanceMaterial = !0,
                this.map = null,
                this.alphaMap = null,
                this.displacementMap = null,
                this.displacementScale = 1,
                this.displacementBias = 0,
                this.setValues(e)
            }
            copy(e) {
                return super.copy(e),
                this.map = e.map,
                this.alphaMap = e.alphaMap,
                this.displacementMap = e.displacementMap,
                this.displacementScale = e.displacementScale,
                this.displacementBias = e.displacementBias,
                this
            }
        }
        function uo(e, t, n) {
            let i = new Pr;
            const s = new Rt
              , h = new Rt
              , d = new en
              , p = new lo({
                depthPacking: ot
            })
              , f = new co
              , A = {}
              , g = n.maxTextureSize
              , m = {
                [o]: l,
                [l]: o,
                [c]: c
            }
              , v = new mr({
                defines: {
                    VSM_SAMPLES: 8
                },
                uniforms: {
                    shadow_pass: {
                        value: null
                    },
                    resolution: {
                        value: new Rt
                    },
                    radius: {
                        value: 4
                    }
                },
                vertexShader: "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}",
                fragmentShader: "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tconst float samples = float( VSM_SAMPLES );\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}"
            })
              , y = v.clone();
            y.defines.HORIZONTAL_PASS = 1;
            const x = new Zi;
            x.setAttribute("position", new Gi(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]),3));
            const _ = new ur(x,v)
              , b = this;
            this.enabled = !1,
            this.autoUpdate = !0,
            this.needsUpdate = !1,
            this.type = r;
            let E = this.type;
            function w(n, i) {
                const r = t.update(_);
                v.defines.VSM_SAMPLES !== n.blurSamples && (v.defines.VSM_SAMPLES = n.blurSamples,
                y.defines.VSM_SAMPLES = n.blurSamples,
                v.needsUpdate = !0,
                y.needsUpdate = !0),
                null === n.mapPass && (n.mapPass = new nn(s.x,s.y)),
                v.uniforms.shadow_pass.value = n.map.texture,
                v.uniforms.resolution.value = n.mapSize,
                v.uniforms.radius.value = n.radius,
                e.setRenderTarget(n.mapPass),
                e.clear(),
                e.renderBufferDirect(i, null, r, v, _, null),
                y.uniforms.shadow_pass.value = n.mapPass.texture,
                y.uniforms.resolution.value = n.mapSize,
                y.uniforms.radius.value = n.radius,
                e.setRenderTarget(n.map),
                e.clear(),
                e.renderBufferDirect(i, null, r, y, _, null)
            }
            function C(t, n, i, r) {
                let s = null;
                const o = !0 === i.isPointLight ? t.customDistanceMaterial : t.customDepthMaterial;
                if (void 0 !== o)
                    s = o;
                else if (s = !0 === i.isPointLight ? f : p,
                e.localClippingEnabled && !0 === n.clipShadows && Array.isArray(n.clippingPlanes) && 0 !== n.clippingPlanes.length || n.displacementMap && 0 !== n.displacementScale || n.alphaMap && n.alphaTest > 0 || n.map && n.alphaTest > 0) {
                    const e = s.uuid
                      , t = n.uuid;
                    let i = A[e];
                    void 0 === i && (i = {},
                    A[e] = i);
                    let r = i[t];
                    void 0 === r && (r = s.clone(),
                    i[t] = r,
                    n.addEventListener("dispose", S)),
                    s = r
                }
                if (s.visible = n.visible,
                s.wireframe = n.wireframe,
                s.side = r === a ? null !== n.shadowSide ? n.shadowSide : n.side : null !== n.shadowSide ? n.shadowSide : m[n.side],
                s.alphaMap = n.alphaMap,
                s.alphaTest = n.alphaTest,
                s.map = n.map,
                s.clipShadows = n.clipShadows,
                s.clippingPlanes = n.clippingPlanes,
                s.clipIntersection = n.clipIntersection,
                s.displacementMap = n.displacementMap,
                s.displacementScale = n.displacementScale,
                s.displacementBias = n.displacementBias,
                s.wireframeLinewidth = n.wireframeLinewidth,
                s.linewidth = n.linewidth,
                !0 === i.isPointLight && !0 === s.isMeshDistanceMaterial) {
                    e.properties.get(s).light = i
                }
                return s
            }
            function I(n, r, s, o, l) {
                if (!1 === n.visible)
                    return;
                if (n.layers.test(r.layers) && (n.isMesh || n.isLine || n.isPoints) && (n.castShadow || n.receiveShadow && l === a) && (!n.frustumCulled || i.intersectsObject(n))) {
                    n.modelViewMatrix.multiplyMatrices(s.matrixWorldInverse, n.matrixWorld);
                    const i = t.update(n)
                      , a = n.material;
                    if (Array.isArray(a)) {
                        const t = i.groups;
                        for (let c = 0, u = t.length; c < u; c++) {
                            const u = t[c]
                              , h = a[u.materialIndex];
                            if (h && h.visible) {
                                const t = C(n, h, o, l);
                                n.onBeforeShadow(e, n, r, s, i, t, u),
                                e.renderBufferDirect(s, null, i, t, n, u),
                                n.onAfterShadow(e, n, r, s, i, t, u)
                            }
                        }
                    } else if (a.visible) {
                        const t = C(n, a, o, l);
                        n.onBeforeShadow(e, n, r, s, i, t, null),
                        e.renderBufferDirect(s, null, i, t, n, null),
                        n.onAfterShadow(e, n, r, s, i, t, null)
                    }
                }
                const c = n.children;
                for (let e = 0, t = c.length; e < t; e++)
                    I(c[e], r, s, o, l)
            }
            function S(e) {
                e.target.removeEventListener("dispose", S);
                for (const t in A) {
                    const n = A[t]
                      , i = e.target.uuid;
                    if (i in n) {
                        n[i].dispose(),
                        delete n[i]
                    }
                }
            }
            this.render = function(t, n, r) {
                if (!1 === b.enabled)
                    return;
                if (!1 === b.autoUpdate && !1 === b.needsUpdate)
                    return;
                if (0 === t.length)
                    return;
                const o = e.getRenderTarget()
                  , l = e.getActiveCubeFace()
                  , c = e.getActiveMipmapLevel()
                  , p = e.state;
                p.setBlending(u),
                p.buffers.color.setClear(1, 1, 1, 1),
                p.buffers.depth.setTest(!0),
                p.setScissorTest(!1);
                const f = E !== a && this.type === a
                  , A = E === a && this.type !== a;
                for (let o = 0, l = t.length; o < l; o++) {
                    const l = t[o]
                      , c = l.shadow;
                    if (void 0 === c) {
                        console.warn("THREE.WebGLShadowMap:", l, "has no shadow.");
                        continue
                    }
                    if (!1 === c.autoUpdate && !1 === c.needsUpdate)
                        continue;
                    s.copy(c.mapSize);
                    const u = c.getFrameExtents();
                    if (s.multiply(u),
                    h.copy(c.mapSize),
                    (s.x > g || s.y > g) && (s.x > g && (h.x = Math.floor(g / u.x),
                    s.x = h.x * u.x,
                    c.mapSize.x = h.x),
                    s.y > g && (h.y = Math.floor(g / u.y),
                    s.y = h.y * u.y,
                    c.mapSize.y = h.y)),
                    null === c.map || !0 === f || !0 === A) {
                        const e = this.type !== a ? {
                            minFilter: k,
                            magFilter: k
                        } : {};
                        null !== c.map && c.map.dispose(),
                        c.map = new nn(s.x,s.y,e),
                        c.map.texture.name = l.name + ".shadowMap",
                        c.camera.updateProjectionMatrix()
                    }
                    e.setRenderTarget(c.map),
                    e.clear();
                    const m = c.getViewportCount();
                    for (let e = 0; e < m; e++) {
                        const t = c.getViewport(e);
                        d.set(h.x * t.x, h.y * t.y, h.x * t.z, h.y * t.w),
                        p.viewport(d),
                        c.updateMatrices(l, e),
                        i = c.getFrustum(),
                        I(n, r, c.camera, l, this.type)
                    }
                    !0 !== c.isPointLightShadow && this.type === a && w(c, r),
                    c.needsUpdate = !1
                }
                E = this.type,
                b.needsUpdate = !1,
                e.setRenderTarget(o, l, c)
            }
        }
        const ho = {
            [d]: p,
            [f]: v,
            [g]: y,
            [A]: m,
            [p]: d,
            [v]: f,
            [y]: g,
            [m]: A
        };
        function po(e, t) {
            const n = new function() {
                let t = !1;
                const n = new en;
                let i = null;
                const r = new en(0,0,0,0);
                return {
                    setMask: function(n) {
                        i === n || t || (e.colorMask(n, n, n, n),
                        i = n)
                    },
                    setLocked: function(e) {
                        t = e
                    },
                    setClear: function(t, i, s, a, o) {
                        !0 === o && (t *= a,
                        i *= a,
                        s *= a),
                        n.set(t, i, s, a),
                        !1 === r.equals(n) && (e.clearColor(t, i, s, a),
                        r.copy(n))
                    },
                    reset: function() {
                        t = !1,
                        i = null,
                        r.set(-1, 0, 0, 0)
                    }
                }
            }
              , i = new function() {
                let n = !1
                  , i = !1
                  , r = null
                  , s = null
                  , a = null;
                return {
                    setReversed: function(e) {
                        if (i !== e) {
                            const e = t.get("EXT_clip_control");
                            i ? e.clipControlEXT(e.LOWER_LEFT_EXT, e.ZERO_TO_ONE_EXT) : e.clipControlEXT(e.LOWER_LEFT_EXT, e.NEGATIVE_ONE_TO_ONE_EXT);
                            const n = a;
                            a = null,
                            this.setClear(n)
                        }
                        i = e
                    },
                    getReversed: function() {
                        return i
                    },
                    setTest: function(t) {
                        t ? Z(e.DEPTH_TEST) : $(e.DEPTH_TEST)
                    },
                    setMask: function(t) {
                        r === t || n || (e.depthMask(t),
                        r = t)
                    },
                    setFunc: function(t) {
                        if (i && (t = ho[t]),
                        s !== t) {
                            switch (t) {
                            case d:
                                e.depthFunc(e.NEVER);
                                break;
                            case p:
                                e.depthFunc(e.ALWAYS);
                                break;
                            case f:
                                e.depthFunc(e.LESS);
                                break;
                            case A:
                                e.depthFunc(e.LEQUAL);
                                break;
                            case g:
                                e.depthFunc(e.EQUAL);
                                break;
                            case m:
                                e.depthFunc(e.GEQUAL);
                                break;
                            case v:
                                e.depthFunc(e.GREATER);
                                break;
                            case y:
                                e.depthFunc(e.NOTEQUAL);
                                break;
                            default:
                                e.depthFunc(e.LEQUAL)
                            }
                            s = t
                        }
                    },
                    setLocked: function(e) {
                        n = e
                    },
                    setClear: function(t) {
                        a !== t && (i && (t = 1 - t),
                        e.clearDepth(t),
                        a = t)
                    },
                    reset: function() {
                        n = !1,
                        r = null,
                        s = null,
                        a = null,
                        i = !1
                    }
                }
            }
              , r = new function() {
                let t = !1
                  , n = null
                  , i = null
                  , r = null
                  , s = null
                  , a = null
                  , o = null
                  , l = null
                  , c = null;
                return {
                    setTest: function(n) {
                        t || (n ? Z(e.STENCIL_TEST) : $(e.STENCIL_TEST))
                    },
                    setMask: function(i) {
                        n === i || t || (e.stencilMask(i),
                        n = i)
                    },
                    setFunc: function(t, n, a) {
                        i === t && r === n && s === a || (e.stencilFunc(t, n, a),
                        i = t,
                        r = n,
                        s = a)
                    },
                    setOp: function(t, n, i) {
                        a === t && o === n && l === i || (e.stencilOp(t, n, i),
                        a = t,
                        o = n,
                        l = i)
                    },
                    setLocked: function(e) {
                        t = e
                    },
                    setClear: function(t) {
                        c !== t && (e.clearStencil(t),
                        c = t)
                    },
                    reset: function() {
                        t = !1,
                        n = null,
                        i = null,
                        r = null,
                        s = null,
                        a = null,
                        o = null,
                        l = null,
                        c = null
                    }
                }
            }
              , s = new WeakMap
              , a = new WeakMap;
            let o = {}
              , x = {}
              , _ = new WeakMap
              , b = []
              , E = null
              , w = !1
              , C = null
              , I = null
              , S = null
              , M = null
              , T = null
              , B = null
              , R = null
              , D = new Ti(0,0,0)
              , P = 0
              , L = !1
              , U = null
              , F = null
              , N = null
              , O = null
              , Q = null;
            const k = e.getParameter(e.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
            let G = !1
              , H = 0;
            const z = e.getParameter(e.VERSION);
            -1 !== z.indexOf("WebGL") ? (H = parseFloat(/^WebGL (\d)/.exec(z)[1]),
            G = H >= 1) : -1 !== z.indexOf("OpenGL ES") && (H = parseFloat(/^OpenGL ES (\d)/.exec(z)[1]),
            G = H >= 2);
            let V = null
              , W = {};
            const j = e.getParameter(e.SCISSOR_BOX)
              , q = e.getParameter(e.VIEWPORT)
              , Y = (new en).fromArray(j)
              , X = (new en).fromArray(q);
            function K(t, n, i, r) {
                const s = new Uint8Array(4)
                  , a = e.createTexture();
                e.bindTexture(t, a),
                e.texParameteri(t, e.TEXTURE_MIN_FILTER, e.NEAREST),
                e.texParameteri(t, e.TEXTURE_MAG_FILTER, e.NEAREST);
                for (let a = 0; a < i; a++)
                    t === e.TEXTURE_3D || t === e.TEXTURE_2D_ARRAY ? e.texImage3D(n, 0, e.RGBA, 1, 1, r, 0, e.RGBA, e.UNSIGNED_BYTE, s) : e.texImage2D(n + a, 0, e.RGBA, 1, 1, 0, e.RGBA, e.UNSIGNED_BYTE, s);
                return a
            }
            const J = {};
            function Z(t) {
                !0 !== o[t] && (e.enable(t),
                o[t] = !0)
            }
            function $(t) {
                !1 !== o[t] && (e.disable(t),
                o[t] = !1)
            }
            J[e.TEXTURE_2D] = K(e.TEXTURE_2D, e.TEXTURE_2D, 1),
            J[e.TEXTURE_CUBE_MAP] = K(e.TEXTURE_CUBE_MAP, e.TEXTURE_CUBE_MAP_POSITIVE_X, 6),
            J[e.TEXTURE_2D_ARRAY] = K(e.TEXTURE_2D_ARRAY, e.TEXTURE_2D_ARRAY, 1, 1),
            J[e.TEXTURE_3D] = K(e.TEXTURE_3D, e.TEXTURE_3D, 1, 1),
            n.setClear(0, 0, 0, 1),
            i.setClear(1),
            r.setClear(0),
            Z(e.DEPTH_TEST),
            i.setFunc(A),
            ie(!1),
            re(1),
            Z(e.CULL_FACE),
            ne(u);
            const ee = {
                [h]: e.FUNC_ADD,
                101: e.FUNC_SUBTRACT,
                102: e.FUNC_REVERSE_SUBTRACT
            };
            ee[103] = e.MIN,
            ee[104] = e.MAX;
            const te = {
                200: e.ZERO,
                201: e.ONE,
                202: e.SRC_COLOR,
                204: e.SRC_ALPHA,
                210: e.SRC_ALPHA_SATURATE,
                208: e.DST_COLOR,
                206: e.DST_ALPHA,
                203: e.ONE_MINUS_SRC_COLOR,
                205: e.ONE_MINUS_SRC_ALPHA,
                209: e.ONE_MINUS_DST_COLOR,
                207: e.ONE_MINUS_DST_ALPHA,
                211: e.CONSTANT_COLOR,
                212: e.ONE_MINUS_CONSTANT_COLOR,
                213: e.CONSTANT_ALPHA,
                214: e.ONE_MINUS_CONSTANT_ALPHA
            };
            function ne(t, n, i, r, s, a, o, l, c, d) {
                if (t !== u) {
                    if (!1 === w && (Z(e.BLEND),
                    w = !0),
                    5 === t)
                        s = s || n,
                        a = a || i,
                        o = o || r,
                        n === I && s === T || (e.blendEquationSeparate(ee[n], ee[s]),
                        I = n,
                        T = s),
                        i === S && r === M && a === B && o === R || (e.blendFuncSeparate(te[i], te[r], te[a], te[o]),
                        S = i,
                        M = r,
                        B = a,
                        R = o),
                        !1 !== l.equals(D) && c === P || (e.blendColor(l.r, l.g, l.b, c),
                        D.copy(l),
                        P = c),
                        C = t,
                        L = !1;
                    else if (t !== C || d !== L) {
                        if (I === h && T === h || (e.blendEquation(e.FUNC_ADD),
                        I = h,
                        T = h),
                        d)
                            switch (t) {
                            case 1:
                                e.blendFuncSeparate(e.ONE, e.ONE_MINUS_SRC_ALPHA, e.ONE, e.ONE_MINUS_SRC_ALPHA);
                                break;
                            case 2:
                                e.blendFunc(e.ONE, e.ONE);
                                break;
                            case 3:
                                e.blendFuncSeparate(e.ZERO, e.ONE_MINUS_SRC_COLOR, e.ZERO, e.ONE);
                                break;
                            case 4:
                                e.blendFuncSeparate(e.ZERO, e.SRC_COLOR, e.ZERO, e.SRC_ALPHA);
                                break;
                            default:
                                console.error("THREE.WebGLState: Invalid blending: ", t)
                            }
                        else
                            switch (t) {
                            case 1:
                                e.blendFuncSeparate(e.SRC_ALPHA, e.ONE_MINUS_SRC_ALPHA, e.ONE, e.ONE_MINUS_SRC_ALPHA);
                                break;
                            case 2:
                                e.blendFunc(e.SRC_ALPHA, e.ONE);
                                break;
                            case 3:
                                e.blendFuncSeparate(e.ZERO, e.ONE_MINUS_SRC_COLOR, e.ZERO, e.ONE);
                                break;
                            case 4:
                                e.blendFunc(e.ZERO, e.SRC_COLOR);
                                break;
                            default:
                                console.error("THREE.WebGLState: Invalid blending: ", t)
                            }
                        S = null,
                        M = null,
                        B = null,
                        R = null,
                        D.set(0, 0, 0),
                        P = 0,
                        C = t,
                        L = d
                    }
                } else
                    !0 === w && ($(e.BLEND),
                    w = !1)
            }
            function ie(t) {
                U !== t && (t ? e.frontFace(e.CW) : e.frontFace(e.CCW),
                U = t)
            }
            function re(t) {
                0 !== t ? (Z(e.CULL_FACE),
                t !== F && (1 === t ? e.cullFace(e.BACK) : 2 === t ? e.cullFace(e.FRONT) : e.cullFace(e.FRONT_AND_BACK))) : $(e.CULL_FACE),
                F = t
            }
            function se(t, n, i) {
                t ? (Z(e.POLYGON_OFFSET_FILL),
                O === n && Q === i || (e.polygonOffset(n, i),
                O = n,
                Q = i)) : $(e.POLYGON_OFFSET_FILL)
            }
            return {
                buffers: {
                    color: n,
                    depth: i,
                    stencil: r
                },
                enable: Z,
                disable: $,
                bindFramebuffer: function(t, n) {
                    return x[t] !== n && (e.bindFramebuffer(t, n),
                    x[t] = n,
                    t === e.DRAW_FRAMEBUFFER && (x[e.FRAMEBUFFER] = n),
                    t === e.FRAMEBUFFER && (x[e.DRAW_FRAMEBUFFER] = n),
                    !0)
                },
                drawBuffers: function(t, n) {
                    let i = b
                      , r = !1;
                    if (t) {
                        i = _.get(n),
                        void 0 === i && (i = [],
                        _.set(n, i));
                        const s = t.textures;
                        if (i.length !== s.length || i[0] !== e.COLOR_ATTACHMENT0) {
                            for (let t = 0, n = s.length; t < n; t++)
                                i[t] = e.COLOR_ATTACHMENT0 + t;
                            i.length = s.length,
                            r = !0
                        }
                    } else
                        i[0] !== e.BACK && (i[0] = e.BACK,
                        r = !0);
                    r && e.drawBuffers(i)
                },
                useProgram: function(t) {
                    return E !== t && (e.useProgram(t),
                    E = t,
                    !0)
                },
                setBlending: ne,
                setMaterial: function(t, s) {
                    t.side === c ? $(e.CULL_FACE) : Z(e.CULL_FACE);
                    let a = t.side === l;
                    s && (a = !a),
                    ie(a),
                    1 === t.blending && !1 === t.transparent ? ne(u) : ne(t.blending, t.blendEquation, t.blendSrc, t.blendDst, t.blendEquationAlpha, t.blendSrcAlpha, t.blendDstAlpha, t.blendColor, t.blendAlpha, t.premultipliedAlpha),
                    i.setFunc(t.depthFunc),
                    i.setTest(t.depthTest),
                    i.setMask(t.depthWrite),
                    n.setMask(t.colorWrite);
                    const o = t.stencilWrite;
                    r.setTest(o),
                    o && (r.setMask(t.stencilWriteMask),
                    r.setFunc(t.stencilFunc, t.stencilRef, t.stencilFuncMask),
                    r.setOp(t.stencilFail, t.stencilZFail, t.stencilZPass)),
                    se(t.polygonOffset, t.polygonOffsetFactor, t.polygonOffsetUnits),
                    !0 === t.alphaToCoverage ? Z(e.SAMPLE_ALPHA_TO_COVERAGE) : $(e.SAMPLE_ALPHA_TO_COVERAGE)
                },
                setFlipSided: ie,
                setCullFace: re,
                setLineWidth: function(t) {
                    t !== N && (G && e.lineWidth(t),
                    N = t)
                },
                setPolygonOffset: se,
                setScissorTest: function(t) {
                    t ? Z(e.SCISSOR_TEST) : $(e.SCISSOR_TEST)
                },
                activeTexture: function(t) {
                    void 0 === t && (t = e.TEXTURE0 + k - 1),
                    V !== t && (e.activeTexture(t),
                    V = t)
                },
                bindTexture: function(t, n, i) {
                    void 0 === i && (i = null === V ? e.TEXTURE0 + k - 1 : V);
                    let r = W[i];
                    void 0 === r && (r = {
                        type: void 0,
                        texture: void 0
                    },
                    W[i] = r),
                    r.type === t && r.texture === n || (V !== i && (e.activeTexture(i),
                    V = i),
                    e.bindTexture(t, n || J[t]),
                    r.type = t,
                    r.texture = n)
                },
                unbindTexture: function() {
                    const t = W[V];
                    void 0 !== t && void 0 !== t.type && (e.bindTexture(t.type, null),
                    t.type = void 0,
                    t.texture = void 0)
                },
                compressedTexImage2D: function() {
                    try {
                        e.compressedTexImage2D.apply(e, arguments)
                    } catch (e) {
                        console.error("THREE.WebGLState:", e)
                    }
                },
                compressedTexImage3D: function() {
                    try {
                        e.compressedTexImage3D.apply(e, arguments)
                    } catch (e) {
                        console.error("THREE.WebGLState:", e)
                    }
                },
                texImage2D: function() {
                    try {
                        e.texImage2D.apply(e, arguments)
                    } catch (e) {
                        console.error("THREE.WebGLState:", e)
                    }
                },
                texImage3D: function() {
                    try {
                        e.texImage3D.apply(e, arguments)
                    } catch (e) {
                        console.error("THREE.WebGLState:", e)
                    }
                },
                updateUBOMapping: function(t, n) {
                    let i = a.get(n);
                    void 0 === i && (i = new WeakMap,
                    a.set(n, i));
                    let r = i.get(t);
                    void 0 === r && (r = e.getUniformBlockIndex(n, t.name),
                    i.set(t, r))
                },
                uniformBlockBinding: function(t, n) {
                    const i = a.get(n).get(t);
                    s.get(n) !== i && (e.uniformBlockBinding(n, i, t.__bindingPointIndex),
                    s.set(n, i))
                },
                texStorage2D: function() {
                    try {
                        e.texStorage2D.apply(e, arguments)
                    } catch (e) {
                        console.error("THREE.WebGLState:", e)
                    }
                },
                texStorage3D: function() {
                    try {
                        e.texStorage3D.apply(e, arguments)
                    } catch (e) {
                        console.error("THREE.WebGLState:", e)
                    }
                },
                texSubImage2D: function() {
                    try {
                        e.texSubImage2D.apply(e, arguments)
                    } catch (e) {
                        console.error("THREE.WebGLState:", e)
                    }
                },
                texSubImage3D: function() {
                    try {
                        e.texSubImage3D.apply(e, arguments)
                    } catch (e) {
                        console.error("THREE.WebGLState:", e)
                    }
                },
                compressedTexSubImage2D: function() {
                    try {
                        e.compressedTexSubImage2D.apply(e, arguments)
                    } catch (e) {
                        console.error("THREE.WebGLState:", e)
                    }
                },
                compressedTexSubImage3D: function() {
                    try {
                        e.compressedTexSubImage3D.apply(e, arguments)
                    } catch (e) {
                        console.error("THREE.WebGLState:", e)
                    }
                },
                scissor: function(t) {
                    !1 === Y.equals(t) && (e.scissor(t.x, t.y, t.z, t.w),
                    Y.copy(t))
                },
                viewport: function(t) {
                    !1 === X.equals(t) && (e.viewport(t.x, t.y, t.z, t.w),
                    X.copy(t))
                },
                reset: function() {
                    e.disable(e.BLEND),
                    e.disable(e.CULL_FACE),
                    e.disable(e.DEPTH_TEST),
                    e.disable(e.POLYGON_OFFSET_FILL),
                    e.disable(e.SCISSOR_TEST),
                    e.disable(e.STENCIL_TEST),
                    e.disable(e.SAMPLE_ALPHA_TO_COVERAGE),
                    e.blendEquation(e.FUNC_ADD),
                    e.blendFunc(e.ONE, e.ZERO),
                    e.blendFuncSeparate(e.ONE, e.ZERO, e.ONE, e.ZERO),
                    e.blendColor(0, 0, 0, 0),
                    e.colorMask(!0, !0, !0, !0),
                    e.clearColor(0, 0, 0, 0),
                    e.depthMask(!0),
                    e.depthFunc(e.LESS),
                    i.setReversed(!1),
                    e.clearDepth(1),
                    e.stencilMask(4294967295),
                    e.stencilFunc(e.ALWAYS, 0, 4294967295),
                    e.stencilOp(e.KEEP, e.KEEP, e.KEEP),
                    e.clearStencil(0),
                    e.cullFace(e.BACK),
                    e.frontFace(e.CCW),
                    e.polygonOffset(0, 0),
                    e.activeTexture(e.TEXTURE0),
                    e.bindFramebuffer(e.FRAMEBUFFER, null),
                    e.bindFramebuffer(e.DRAW_FRAMEBUFFER, null),
                    e.bindFramebuffer(e.READ_FRAMEBUFFER, null),
                    e.useProgram(null),
                    e.lineWidth(1),
                    e.scissor(0, 0, e.canvas.width, e.canvas.height),
                    e.viewport(0, 0, e.canvas.width, e.canvas.height),
                    o = {},
                    V = null,
                    W = {},
                    x = {},
                    _ = new WeakMap,
                    b = [],
                    E = null,
                    w = !1,
                    C = null,
                    I = null,
                    S = null,
                    M = null,
                    T = null,
                    B = null,
                    R = null,
                    D = new Ti(0,0,0),
                    P = 0,
                    L = !1,
                    U = null,
                    F = null,
                    N = null,
                    O = null,
                    Q = null,
                    Y.set(0, 0, e.canvas.width, e.canvas.height),
                    X.set(0, 0, e.canvas.width, e.canvas.height),
                    n.reset(),
                    i.reset(),
                    r.reset()
                }
            }
        }
        function fo(e, t, n, i) {
            const r = function(e) {
                switch (e) {
                case j:
                case q:
                    return {
                        byteLength: 1,
                        components: 1
                    };
                case X:
                case Y:
                case $:
                    return {
                        byteLength: 2,
                        components: 1
                    };
                case ee:
                case te:
                    return {
                        byteLength: 2,
                        components: 4
                    };
                case J:
                case K:
                case Z:
                    return {
                        byteLength: 4,
                        components: 1
                    };
                case ie:
                    return {
                        byteLength: 4,
                        components: 3
                    }
                }
                throw new Error(`Unknown texture type ${e}.`)
            }(i);
            switch (n) {
            case re:
            case oe:
                return e * t;
            case le:
                return e * t * 2;
            case he:
            case de:
                return e * t / r.components * r.byteLength;
            case pe:
            case fe:
                return e * t * 2 / r.components * r.byteLength;
            case se:
                return e * t * 3 / r.components * r.byteLength;
            case ae:
            case Ae:
                return e * t * 4 / r.components * r.byteLength;
            case ge:
            case me:
                return Math.floor((e + 3) / 4) * Math.floor((t + 3) / 4) * 8;
            case ve:
            case ye:
                return Math.floor((e + 3) / 4) * Math.floor((t + 3) / 4) * 16;
            case _e:
            case Ee:
                return Math.max(e, 16) * Math.max(t, 8) / 4;
            case xe:
            case be:
                return Math.max(e, 8) * Math.max(t, 8) / 2;
            case we:
            case Ce:
                return Math.floor((e + 3) / 4) * Math.floor((t + 3) / 4) * 8;
            case Ie:
            case Se:
                return Math.floor((e + 3) / 4) * Math.floor((t + 3) / 4) * 16;
            case Me:
                return Math.floor((e + 4) / 5) * Math.floor((t + 3) / 4) * 16;
            case Te:
                return Math.floor((e + 4) / 5) * Math.floor((t + 4) / 5) * 16;
            case Be:
                return Math.floor((e + 5) / 6) * Math.floor((t + 4) / 5) * 16;
            case Re:
                return Math.floor((e + 5) / 6) * Math.floor((t + 5) / 6) * 16;
            case De:
                return Math.floor((e + 7) / 8) * Math.floor((t + 4) / 5) * 16;
            case Pe:
                return Math.floor((e + 7) / 8) * Math.floor((t + 5) / 6) * 16;
            case Le:
                return Math.floor((e + 7) / 8) * Math.floor((t + 7) / 8) * 16;
            case Ue:
                return Math.floor((e + 9) / 10) * Math.floor((t + 4) / 5) * 16;
            case Fe:
                return Math.floor((e + 9) / 10) * Math.floor((t + 5) / 6) * 16;
            case Ne:
                return Math.floor((e + 9) / 10) * Math.floor((t + 7) / 8) * 16;
            case Oe:
                return Math.floor((e + 9) / 10) * Math.floor((t + 9) / 10) * 16;
            case Qe:
                return Math.floor((e + 11) / 12) * Math.floor((t + 9) / 10) * 16;
            case ke:
                return Math.floor((e + 11) / 12) * Math.floor((t + 11) / 12) * 16;
            case Ge:
            case He:
            case ze:
                return Math.ceil(e / 4) * Math.ceil(t / 4) * 16;
            case Ve:
            case We:
                return Math.ceil(e / 4) * Math.ceil(t / 4) * 8;
            case je:
            case qe:
                return Math.ceil(e / 4) * Math.ceil(t / 4) * 16
            }
            throw new Error(`Unable to determine texture byte length for ${n} format.`)
        }
        function Ao(e, t, n, i, r, s, a) {
            const o = t.has("WEBGL_multisampled_render_to_texture") ? t.get("WEBGL_multisampled_render_to_texture") : null
              , l = "undefined" != typeof navigator && /OculusBrowser/g.test(navigator.userAgent)
              , c = new Rt
              , u = new WeakMap;
            let h;
            const d = new WeakMap;
            let p = !1;
            try {
                p = "undefined" != typeof OffscreenCanvas && null !== new OffscreenCanvas(1,1).getContext("2d")
            } catch (e) {}
            function f(e, t) {
                return p ? new OffscreenCanvas(e,t) : Ut("canvas")
            }
            function A(e, t, n) {
                let i = 1;
                const r = ee(e);
                if ((r.width > n || r.height > n) && (i = n / Math.max(r.width, r.height)),
                i < 1) {
                    if ("undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap || "undefined" != typeof VideoFrame && e instanceof VideoFrame) {
                        const n = Math.floor(i * r.width)
                          , s = Math.floor(i * r.height);
                        void 0 === h && (h = f(n, s));
                        const a = t ? f(n, s) : h;
                        a.width = n,
                        a.height = s;
                        return a.getContext("2d").drawImage(e, 0, 0, n, s),
                        console.warn("THREE.WebGLRenderer: Texture has been resized from (" + r.width + "x" + r.height + ") to (" + n + "x" + s + ")."),
                        a
                    }
                    return "data"in e && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + r.width + "x" + r.height + ")."),
                    e
                }
                return e
            }
            function g(e) {
                return e.generateMipmaps
            }
            function m(t) {
                e.generateMipmap(t)
            }
            function v(t) {
                return t.isWebGLCubeRenderTarget ? e.TEXTURE_CUBE_MAP : t.isWebGL3DRenderTarget ? e.TEXTURE_3D : t.isWebGLArrayRenderTarget || t.isCompressedArrayTexture ? e.TEXTURE_2D_ARRAY : e.TEXTURE_2D
            }
            function y(n, i, r, s, a=!1) {
                if (null !== n) {
                    if (void 0 !== e[n])
                        return e[n];
                    console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + n + "'")
                }
                let o = i;
                if (i === e.RED && (r === e.FLOAT && (o = e.R32F),
                r === e.HALF_FLOAT && (o = e.R16F),
                r === e.UNSIGNED_BYTE && (o = e.R8)),
                i === e.RED_INTEGER && (r === e.UNSIGNED_BYTE && (o = e.R8UI),
                r === e.UNSIGNED_SHORT && (o = e.R16UI),
                r === e.UNSIGNED_INT && (o = e.R32UI),
                r === e.BYTE && (o = e.R8I),
                r === e.SHORT && (o = e.R16I),
                r === e.INT && (o = e.R32I)),
                i === e.RG && (r === e.FLOAT && (o = e.RG32F),
                r === e.HALF_FLOAT && (o = e.RG16F),
                r === e.UNSIGNED_BYTE && (o = e.RG8)),
                i === e.RG_INTEGER && (r === e.UNSIGNED_BYTE && (o = e.RG8UI),
                r === e.UNSIGNED_SHORT && (o = e.RG16UI),
                r === e.UNSIGNED_INT && (o = e.RG32UI),
                r === e.BYTE && (o = e.RG8I),
                r === e.SHORT && (o = e.RG16I),
                r === e.INT && (o = e.RG32I)),
                i === e.RGB_INTEGER && (r === e.UNSIGNED_BYTE && (o = e.RGB8UI),
                r === e.UNSIGNED_SHORT && (o = e.RGB16UI),
                r === e.UNSIGNED_INT && (o = e.RGB32UI),
                r === e.BYTE && (o = e.RGB8I),
                r === e.SHORT && (o = e.RGB16I),
                r === e.INT && (o = e.RGB32I)),
                i === e.RGBA_INTEGER && (r === e.UNSIGNED_BYTE && (o = e.RGBA8UI),
                r === e.UNSIGNED_SHORT && (o = e.RGBA16UI),
                r === e.UNSIGNED_INT && (o = e.RGBA32UI),
                r === e.BYTE && (o = e.RGBA8I),
                r === e.SHORT && (o = e.RGBA16I),
                r === e.INT && (o = e.RGBA32I)),
                i === e.RGB && r === e.UNSIGNED_INT_5_9_9_9_REV && (o = e.RGB9_E5),
                i === e.RGBA) {
                    const t = a ? ht : Qt.getTransfer(s);
                    r === e.FLOAT && (o = e.RGBA32F),
                    r === e.HALF_FLOAT && (o = e.RGBA16F),
                    r === e.UNSIGNED_BYTE && (o = t === dt ? e.SRGB8_ALPHA8 : e.RGBA8),
                    r === e.UNSIGNED_SHORT_4_4_4_4 && (o = e.RGBA4),
                    r === e.UNSIGNED_SHORT_5_5_5_1 && (o = e.RGB5_A1)
                }
                return o !== e.R16F && o !== e.R32F && o !== e.RG16F && o !== e.RG32F && o !== e.RGBA16F && o !== e.RGBA32F || t.get("EXT_color_buffer_float"),
                o
            }
            function x(t, n) {
                let i;
                return t ? null === n || n === J || n === ne ? i = e.DEPTH24_STENCIL8 : n === Z ? i = e.DEPTH32F_STENCIL8 : n === X && (i = e.DEPTH24_STENCIL8,
                console.warn("DepthTexture: 16 bit depth attachment is not supported with stencil. Using 24-bit attachment.")) : null === n || n === J || n === ne ? i = e.DEPTH_COMPONENT24 : n === Z ? i = e.DEPTH_COMPONENT32F : n === X && (i = e.DEPTH_COMPONENT16),
                i
            }
            function _(e, t) {
                return !0 === g(e) || e.isFramebufferTexture && e.minFilter !== k && e.minFilter !== z ? Math.log2(Math.max(t.width, t.height)) + 1 : void 0 !== e.mipmaps && e.mipmaps.length > 0 ? e.mipmaps.length : e.isCompressedTexture && Array.isArray(e.image) ? t.mipmaps.length : 1
            }
            function b(e) {
                const t = e.target;
                t.removeEventListener("dispose", b),
                function(e) {
                    const t = i.get(e);
                    if (void 0 === t.__webglInit)
                        return;
                    const n = e.source
                      , r = d.get(n);
                    if (r) {
                        const i = r[t.__cacheKey];
                        i.usedTimes--,
                        0 === i.usedTimes && w(e),
                        0 === Object.keys(r).length && d.delete(n)
                    }
                    i.remove(e)
                }(t),
                t.isVideoTexture && u.delete(t)
            }
            function E(t) {
                const n = t.target;
                n.removeEventListener("dispose", E),
                function(t) {
                    const n = i.get(t);
                    t.depthTexture && (t.depthTexture.dispose(),
                    i.remove(t.depthTexture));
                    if (t.isWebGLCubeRenderTarget)
                        for (let t = 0; t < 6; t++) {
                            if (Array.isArray(n.__webglFramebuffer[t]))
                                for (let i = 0; i < n.__webglFramebuffer[t].length; i++)
                                    e.deleteFramebuffer(n.__webglFramebuffer[t][i]);
                            else
                                e.deleteFramebuffer(n.__webglFramebuffer[t]);
                            n.__webglDepthbuffer && e.deleteRenderbuffer(n.__webglDepthbuffer[t])
                        }
                    else {
                        if (Array.isArray(n.__webglFramebuffer))
                            for (let t = 0; t < n.__webglFramebuffer.length; t++)
                                e.deleteFramebuffer(n.__webglFramebuffer[t]);
                        else
                            e.deleteFramebuffer(n.__webglFramebuffer);
                        if (n.__webglDepthbuffer && e.deleteRenderbuffer(n.__webglDepthbuffer),
                        n.__webglMultisampledFramebuffer && e.deleteFramebuffer(n.__webglMultisampledFramebuffer),
                        n.__webglColorRenderbuffer)
                            for (let t = 0; t < n.__webglColorRenderbuffer.length; t++)
                                n.__webglColorRenderbuffer[t] && e.deleteRenderbuffer(n.__webglColorRenderbuffer[t]);
                        n.__webglDepthRenderbuffer && e.deleteRenderbuffer(n.__webglDepthRenderbuffer)
                    }
                    const r = t.textures;
                    for (let t = 0, n = r.length; t < n; t++) {
                        const n = i.get(r[t]);
                        n.__webglTexture && (e.deleteTexture(n.__webglTexture),
                        a.memory.textures--),
                        i.remove(r[t])
                    }
                    i.remove(t)
                }(n)
            }
            function w(t) {
                const n = i.get(t);
                e.deleteTexture(n.__webglTexture);
                const r = t.source;
                delete d.get(r)[n.__cacheKey],
                a.memory.textures--
            }
            let C = 0;
            function I(t, r) {
                const s = i.get(t);
                if (t.isVideoTexture && function(e) {
                    const t = a.render.frame;
                    u.get(e) !== t && (u.set(e, t),
                    e.update())
                }(t),
                !1 === t.isRenderTargetTexture && t.version > 0 && s.__version !== t.version) {
                    const e = t.image;
                    if (null === e)
                        console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
                    else {
                        if (!1 !== e.complete)
                            return void D(s, t, r);
                        console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete")
                    }
                }
                n.bindTexture(e.TEXTURE_2D, s.__webglTexture, e.TEXTURE0 + r)
            }
            const S = {
                [N]: e.REPEAT,
                [O]: e.CLAMP_TO_EDGE,
                [Q]: e.MIRRORED_REPEAT
            }
              , M = {
                [k]: e.NEAREST,
                [G]: e.NEAREST_MIPMAP_NEAREST,
                [H]: e.NEAREST_MIPMAP_LINEAR,
                [z]: e.LINEAR,
                [V]: e.LINEAR_MIPMAP_NEAREST,
                [W]: e.LINEAR_MIPMAP_LINEAR
            }
              , T = {
                512: e.NEVER,
                519: e.ALWAYS,
                513: e.LESS,
                [ft]: e.LEQUAL,
                514: e.EQUAL,
                518: e.GEQUAL,
                516: e.GREATER,
                517: e.NOTEQUAL
            };
            function B(n, s) {
                if (s.type !== Z || !1 !== t.has("OES_texture_float_linear") || s.magFilter !== z && s.magFilter !== V && s.magFilter !== H && s.magFilter !== W && s.minFilter !== z && s.minFilter !== V && s.minFilter !== H && s.minFilter !== W || console.warn("THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device."),
                e.texParameteri(n, e.TEXTURE_WRAP_S, S[s.wrapS]),
                e.texParameteri(n, e.TEXTURE_WRAP_T, S[s.wrapT]),
                n !== e.TEXTURE_3D && n !== e.TEXTURE_2D_ARRAY || e.texParameteri(n, e.TEXTURE_WRAP_R, S[s.wrapR]),
                e.texParameteri(n, e.TEXTURE_MAG_FILTER, M[s.magFilter]),
                e.texParameteri(n, e.TEXTURE_MIN_FILTER, M[s.minFilter]),
                s.compareFunction && (e.texParameteri(n, e.TEXTURE_COMPARE_MODE, e.COMPARE_REF_TO_TEXTURE),
                e.texParameteri(n, e.TEXTURE_COMPARE_FUNC, T[s.compareFunction])),
                !0 === t.has("EXT_texture_filter_anisotropic")) {
                    if (s.magFilter === k)
                        return;
                    if (s.minFilter !== H && s.minFilter !== W)
                        return;
                    if (s.type === Z && !1 === t.has("OES_texture_float_linear"))
                        return;
                    if (s.anisotropy > 1 || i.get(s).__currentAnisotropy) {
                        const a = t.get("EXT_texture_filter_anisotropic");
                        e.texParameterf(n, a.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(s.anisotropy, r.getMaxAnisotropy())),
                        i.get(s).__currentAnisotropy = s.anisotropy
                    }
                }
            }
            function R(t, n) {
                let i = !1;
                void 0 === t.__webglInit && (t.__webglInit = !0,
                n.addEventListener("dispose", b));
                const r = n.source;
                let s = d.get(r);
                void 0 === s && (s = {},
                d.set(r, s));
                const o = function(e) {
                    const t = [];
                    return t.push(e.wrapS),
                    t.push(e.wrapT),
                    t.push(e.wrapR || 0),
                    t.push(e.magFilter),
                    t.push(e.minFilter),
                    t.push(e.anisotropy),
                    t.push(e.internalFormat),
                    t.push(e.format),
                    t.push(e.type),
                    t.push(e.generateMipmaps),
                    t.push(e.premultiplyAlpha),
                    t.push(e.flipY),
                    t.push(e.unpackAlignment),
                    t.push(e.colorSpace),
                    t.join()
                }(n);
                if (o !== t.__cacheKey) {
                    void 0 === s[o] && (s[o] = {
                        texture: e.createTexture(),
                        usedTimes: 0
                    },
                    a.memory.textures++,
                    i = !0),
                    s[o].usedTimes++;
                    const r = s[t.__cacheKey];
                    void 0 !== r && (s[t.__cacheKey].usedTimes--,
                    0 === r.usedTimes && w(n)),
                    t.__cacheKey = o,
                    t.__webglTexture = s[o].texture
                }
                return i
            }
            function D(t, a, o) {
                let l = e.TEXTURE_2D;
                (a.isDataArrayTexture || a.isCompressedArrayTexture) && (l = e.TEXTURE_2D_ARRAY),
                a.isData3DTexture && (l = e.TEXTURE_3D);
                const c = R(t, a)
                  , u = a.source;
                n.bindTexture(l, t.__webglTexture, e.TEXTURE0 + o);
                const h = i.get(u);
                if (u.version !== h.__version || !0 === c) {
                    n.activeTexture(e.TEXTURE0 + o);
                    const t = Qt.getPrimaries(Qt.workingColorSpace)
                      , i = a.colorSpace === lt ? null : Qt.getPrimaries(a.colorSpace)
                      , d = a.colorSpace === lt || t === i ? e.NONE : e.BROWSER_DEFAULT_WEBGL;
                    e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL, a.flipY),
                    e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL, a.premultiplyAlpha),
                    e.pixelStorei(e.UNPACK_ALIGNMENT, a.unpackAlignment),
                    e.pixelStorei(e.UNPACK_COLORSPACE_CONVERSION_WEBGL, d);
                    let p = A(a.image, !1, r.maxTextureSize);
                    p = $(a, p);
                    const f = s.convert(a.format, a.colorSpace)
                      , v = s.convert(a.type);
                    let b, E = y(a.internalFormat, f, v, a.colorSpace, a.isVideoTexture);
                    B(l, a);
                    const w = a.mipmaps
                      , C = !0 !== a.isVideoTexture
                      , I = void 0 === h.__version || !0 === c
                      , S = u.dataReady
                      , M = _(a, p);
                    if (a.isDepthTexture)
                        E = x(a.format === ue, a.type),
                        I && (C ? n.texStorage2D(e.TEXTURE_2D, 1, E, p.width, p.height) : n.texImage2D(e.TEXTURE_2D, 0, E, p.width, p.height, 0, f, v, null));
                    else if (a.isDataTexture)
                        if (w.length > 0) {
                            C && I && n.texStorage2D(e.TEXTURE_2D, M, E, w[0].width, w[0].height);
                            for (let t = 0, i = w.length; t < i; t++)
                                b = w[t],
                                C ? S && n.texSubImage2D(e.TEXTURE_2D, t, 0, 0, b.width, b.height, f, v, b.data) : n.texImage2D(e.TEXTURE_2D, t, E, b.width, b.height, 0, f, v, b.data);
                            a.generateMipmaps = !1
                        } else
                            C ? (I && n.texStorage2D(e.TEXTURE_2D, M, E, p.width, p.height),
                            S && n.texSubImage2D(e.TEXTURE_2D, 0, 0, 0, p.width, p.height, f, v, p.data)) : n.texImage2D(e.TEXTURE_2D, 0, E, p.width, p.height, 0, f, v, p.data);
                    else if (a.isCompressedTexture)
                        if (a.isCompressedArrayTexture) {
                            C && I && n.texStorage3D(e.TEXTURE_2D_ARRAY, M, E, w[0].width, w[0].height, p.depth);
                            for (let t = 0, i = w.length; t < i; t++)
                                if (b = w[t],
                                a.format !== ae)
                                    if (null !== f)
                                        if (C) {
                                            if (S)
                                                if (a.layerUpdates.size > 0) {
                                                    const i = fo(b.width, b.height, a.format, a.type);
                                                    for (const r of a.layerUpdates) {
                                                        const s = b.data.subarray(r * i / b.data.BYTES_PER_ELEMENT, (r + 1) * i / b.data.BYTES_PER_ELEMENT);
                                                        n.compressedTexSubImage3D(e.TEXTURE_2D_ARRAY, t, 0, 0, r, b.width, b.height, 1, f, s)
                                                    }
                                                    a.clearLayerUpdates()
                                                } else
                                                    n.compressedTexSubImage3D(e.TEXTURE_2D_ARRAY, t, 0, 0, 0, b.width, b.height, p.depth, f, b.data)
                                        } else
                                            n.compressedTexImage3D(e.TEXTURE_2D_ARRAY, t, E, b.width, b.height, p.depth, 0, b.data, 0, 0);
                                    else
                                        console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");
                                else
                                    C ? S && n.texSubImage3D(e.TEXTURE_2D_ARRAY, t, 0, 0, 0, b.width, b.height, p.depth, f, v, b.data) : n.texImage3D(e.TEXTURE_2D_ARRAY, t, E, b.width, b.height, p.depth, 0, f, v, b.data)
                        } else {
                            C && I && n.texStorage2D(e.TEXTURE_2D, M, E, w[0].width, w[0].height);
                            for (let t = 0, i = w.length; t < i; t++)
                                b = w[t],
                                a.format !== ae ? null !== f ? C ? S && n.compressedTexSubImage2D(e.TEXTURE_2D, t, 0, 0, b.width, b.height, f, b.data) : n.compressedTexImage2D(e.TEXTURE_2D, t, E, b.width, b.height, 0, b.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : C ? S && n.texSubImage2D(e.TEXTURE_2D, t, 0, 0, b.width, b.height, f, v, b.data) : n.texImage2D(e.TEXTURE_2D, t, E, b.width, b.height, 0, f, v, b.data)
                        }
                    else if (a.isDataArrayTexture)
                        if (C) {
                            if (I && n.texStorage3D(e.TEXTURE_2D_ARRAY, M, E, p.width, p.height, p.depth),
                            S)
                                if (a.layerUpdates.size > 0) {
                                    const t = fo(p.width, p.height, a.format, a.type);
                                    for (const i of a.layerUpdates) {
                                        const r = p.data.subarray(i * t / p.data.BYTES_PER_ELEMENT, (i + 1) * t / p.data.BYTES_PER_ELEMENT);
                                        n.texSubImage3D(e.TEXTURE_2D_ARRAY, 0, 0, 0, i, p.width, p.height, 1, f, v, r)
                                    }
                                    a.clearLayerUpdates()
                                } else
                                    n.texSubImage3D(e.TEXTURE_2D_ARRAY, 0, 0, 0, 0, p.width, p.height, p.depth, f, v, p.data)
                        } else
                            n.texImage3D(e.TEXTURE_2D_ARRAY, 0, E, p.width, p.height, p.depth, 0, f, v, p.data);
                    else if (a.isData3DTexture)
                        C ? (I && n.texStorage3D(e.TEXTURE_3D, M, E, p.width, p.height, p.depth),
                        S && n.texSubImage3D(e.TEXTURE_3D, 0, 0, 0, 0, p.width, p.height, p.depth, f, v, p.data)) : n.texImage3D(e.TEXTURE_3D, 0, E, p.width, p.height, p.depth, 0, f, v, p.data);
                    else if (a.isFramebufferTexture) {
                        if (I)
                            if (C)
                                n.texStorage2D(e.TEXTURE_2D, M, E, p.width, p.height);
                            else {
                                let t = p.width
                                  , i = p.height;
                                for (let r = 0; r < M; r++)
                                    n.texImage2D(e.TEXTURE_2D, r, E, t, i, 0, f, v, null),
                                    t >>= 1,
                                    i >>= 1
                            }
                    } else if (w.length > 0) {
                        if (C && I) {
                            const t = ee(w[0]);
                            n.texStorage2D(e.TEXTURE_2D, M, E, t.width, t.height)
                        }
                        for (let t = 0, i = w.length; t < i; t++)
                            b = w[t],
                            C ? S && n.texSubImage2D(e.TEXTURE_2D, t, 0, 0, f, v, b) : n.texImage2D(e.TEXTURE_2D, t, E, f, v, b);
                        a.generateMipmaps = !1
                    } else if (C) {
                        if (I) {
                            const t = ee(p);
                            n.texStorage2D(e.TEXTURE_2D, M, E, t.width, t.height)
                        }
                        S && n.texSubImage2D(e.TEXTURE_2D, 0, 0, 0, f, v, p)
                    } else
                        n.texImage2D(e.TEXTURE_2D, 0, E, f, v, p);
                    g(a) && m(l),
                    h.__version = u.version,
                    a.onUpdate && a.onUpdate(a)
                }
                t.__version = a.version
            }
            function P(t, r, a, l, c, u) {
                const h = s.convert(a.format, a.colorSpace)
                  , d = s.convert(a.type)
                  , p = y(a.internalFormat, h, d, a.colorSpace)
                  , f = i.get(r)
                  , A = i.get(a);
                if (A.__renderTarget = r,
                !f.__hasExternalTextures) {
                    const t = Math.max(1, r.width >> u)
                      , i = Math.max(1, r.height >> u);
                    c === e.TEXTURE_3D || c === e.TEXTURE_2D_ARRAY ? n.texImage3D(c, u, p, t, i, r.depth, 0, h, d, null) : n.texImage2D(c, u, p, t, i, 0, h, d, null)
                }
                n.bindFramebuffer(e.FRAMEBUFFER, t),
                K(r) ? o.framebufferTexture2DMultisampleEXT(e.FRAMEBUFFER, l, c, A.__webglTexture, 0, Y(r)) : (c === e.TEXTURE_2D || c >= e.TEXTURE_CUBE_MAP_POSITIVE_X && c <= e.TEXTURE_CUBE_MAP_NEGATIVE_Z) && e.framebufferTexture2D(e.FRAMEBUFFER, l, c, A.__webglTexture, u),
                n.bindFramebuffer(e.FRAMEBUFFER, null)
            }
            function L(t, n, i) {
                if (e.bindRenderbuffer(e.RENDERBUFFER, t),
                n.depthBuffer) {
                    const r = n.depthTexture
                      , s = r && r.isDepthTexture ? r.type : null
                      , a = x(n.stencilBuffer, s)
                      , l = n.stencilBuffer ? e.DEPTH_STENCIL_ATTACHMENT : e.DEPTH_ATTACHMENT
                      , c = Y(n);
                    K(n) ? o.renderbufferStorageMultisampleEXT(e.RENDERBUFFER, c, a, n.width, n.height) : i ? e.renderbufferStorageMultisample(e.RENDERBUFFER, c, a, n.width, n.height) : e.renderbufferStorage(e.RENDERBUFFER, a, n.width, n.height),
                    e.framebufferRenderbuffer(e.FRAMEBUFFER, l, e.RENDERBUFFER, t)
                } else {
                    const t = n.textures;
                    for (let r = 0; r < t.length; r++) {
                        const a = t[r]
                          , l = s.convert(a.format, a.colorSpace)
                          , c = s.convert(a.type)
                          , u = y(a.internalFormat, l, c, a.colorSpace)
                          , h = Y(n);
                        i && !1 === K(n) ? e.renderbufferStorageMultisample(e.RENDERBUFFER, h, u, n.width, n.height) : K(n) ? o.renderbufferStorageMultisampleEXT(e.RENDERBUFFER, h, u, n.width, n.height) : e.renderbufferStorage(e.RENDERBUFFER, u, n.width, n.height)
                    }
                }
                e.bindRenderbuffer(e.RENDERBUFFER, null)
            }
            function U(t) {
                const r = i.get(t)
                  , s = !0 === t.isWebGLCubeRenderTarget;
                if (r.__boundDepthTexture !== t.depthTexture) {
                    const e = t.depthTexture;
                    if (r.__depthDisposeCallback && r.__depthDisposeCallback(),
                    e) {
                        const t = () => {
                            delete r.__boundDepthTexture,
                            delete r.__depthDisposeCallback,
                            e.removeEventListener("dispose", t)
                        }
                        ;
                        e.addEventListener("dispose", t),
                        r.__depthDisposeCallback = t
                    }
                    r.__boundDepthTexture = e
                }
                if (t.depthTexture && !r.__autoAllocateDepthBuffer) {
                    if (s)
                        throw new Error("target.depthTexture not supported in Cube render targets");
                    !function(t, r) {
                        if (r && r.isWebGLCubeRenderTarget)
                            throw new Error("Depth Texture with cube render targets is not supported");
                        if (n.bindFramebuffer(e.FRAMEBUFFER, t),
                        !r.depthTexture || !r.depthTexture.isDepthTexture)
                            throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
                        const s = i.get(r.depthTexture);
                        s.__renderTarget = r,
                        s.__webglTexture && r.depthTexture.image.width === r.width && r.depthTexture.image.height === r.height || (r.depthTexture.image.width = r.width,
                        r.depthTexture.image.height = r.height,
                        r.depthTexture.needsUpdate = !0),
                        I(r.depthTexture, 0);
                        const a = s.__webglTexture
                          , l = Y(r);
                        if (r.depthTexture.format === ce)
                            K(r) ? o.framebufferTexture2DMultisampleEXT(e.FRAMEBUFFER, e.DEPTH_ATTACHMENT, e.TEXTURE_2D, a, 0, l) : e.framebufferTexture2D(e.FRAMEBUFFER, e.DEPTH_ATTACHMENT, e.TEXTURE_2D, a, 0);
                        else {
                            if (r.depthTexture.format !== ue)
                                throw new Error("Unknown depthTexture format");
                            K(r) ? o.framebufferTexture2DMultisampleEXT(e.FRAMEBUFFER, e.DEPTH_STENCIL_ATTACHMENT, e.TEXTURE_2D, a, 0, l) : e.framebufferTexture2D(e.FRAMEBUFFER, e.DEPTH_STENCIL_ATTACHMENT, e.TEXTURE_2D, a, 0)
                        }
                    }(r.__webglFramebuffer, t)
                } else if (s) {
                    r.__webglDepthbuffer = [];
                    for (let i = 0; i < 6; i++)
                        if (n.bindFramebuffer(e.FRAMEBUFFER, r.__webglFramebuffer[i]),
                        void 0 === r.__webglDepthbuffer[i])
                            r.__webglDepthbuffer[i] = e.createRenderbuffer(),
                            L(r.__webglDepthbuffer[i], t, !1);
                        else {
                            const n = t.stencilBuffer ? e.DEPTH_STENCIL_ATTACHMENT : e.DEPTH_ATTACHMENT
                              , s = r.__webglDepthbuffer[i];
                            e.bindRenderbuffer(e.RENDERBUFFER, s),
                            e.framebufferRenderbuffer(e.FRAMEBUFFER, n, e.RENDERBUFFER, s)
                        }
                } else if (n.bindFramebuffer(e.FRAMEBUFFER, r.__webglFramebuffer),
                void 0 === r.__webglDepthbuffer)
                    r.__webglDepthbuffer = e.createRenderbuffer(),
                    L(r.__webglDepthbuffer, t, !1);
                else {
                    const n = t.stencilBuffer ? e.DEPTH_STENCIL_ATTACHMENT : e.DEPTH_ATTACHMENT
                      , i = r.__webglDepthbuffer;
                    e.bindRenderbuffer(e.RENDERBUFFER, i),
                    e.framebufferRenderbuffer(e.FRAMEBUFFER, n, e.RENDERBUFFER, i)
                }
                n.bindFramebuffer(e.FRAMEBUFFER, null)
            }
            const F = []
              , q = [];
            function Y(e) {
                return Math.min(r.maxSamples, e.samples)
            }
            function K(e) {
                const n = i.get(e);
                return e.samples > 0 && !0 === t.has("WEBGL_multisampled_render_to_texture") && !1 !== n.__useRenderToTexture
            }
            function $(e, t) {
                const n = e.colorSpace
                  , i = e.format
                  , r = e.type;
                return !0 === e.isCompressedTexture || !0 === e.isVideoTexture || n !== ut && n !== lt && (Qt.getTransfer(n) === dt ? i === ae && r === j || console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture color space:", n)),
                t
            }
            function ee(e) {
                return "undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement ? (c.width = e.naturalWidth || e.width,
                c.height = e.naturalHeight || e.height) : "undefined" != typeof VideoFrame && e instanceof VideoFrame ? (c.width = e.displayWidth,
                c.height = e.displayHeight) : (c.width = e.width,
                c.height = e.height),
                c
            }
            this.allocateTextureUnit = function() {
                const e = C;
                return e >= r.maxTextures && console.warn("THREE.WebGLTextures: Trying to use " + e + " texture units while this GPU supports only " + r.maxTextures),
                C += 1,
                e
            }
            ,
            this.resetTextureUnits = function() {
                C = 0
            }
            ,
            this.setTexture2D = I,
            this.setTexture2DArray = function(t, r) {
                const s = i.get(t);
                t.version > 0 && s.__version !== t.version ? D(s, t, r) : n.bindTexture(e.TEXTURE_2D_ARRAY, s.__webglTexture, e.TEXTURE0 + r)
            }
            ,
            this.setTexture3D = function(t, r) {
                const s = i.get(t);
                t.version > 0 && s.__version !== t.version ? D(s, t, r) : n.bindTexture(e.TEXTURE_3D, s.__webglTexture, e.TEXTURE0 + r)
            }
            ,
            this.setTextureCube = function(t, a) {
                const o = i.get(t);
                t.version > 0 && o.__version !== t.version ? function(t, a, o) {
                    if (6 !== a.image.length)
                        return;
                    const l = R(t, a)
                      , c = a.source;
                    n.bindTexture(e.TEXTURE_CUBE_MAP, t.__webglTexture, e.TEXTURE0 + o);
                    const u = i.get(c);
                    if (c.version !== u.__version || !0 === l) {
                        n.activeTexture(e.TEXTURE0 + o);
                        const t = Qt.getPrimaries(Qt.workingColorSpace)
                          , i = a.colorSpace === lt ? null : Qt.getPrimaries(a.colorSpace)
                          , h = a.colorSpace === lt || t === i ? e.NONE : e.BROWSER_DEFAULT_WEBGL;
                        e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL, a.flipY),
                        e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL, a.premultiplyAlpha),
                        e.pixelStorei(e.UNPACK_ALIGNMENT, a.unpackAlignment),
                        e.pixelStorei(e.UNPACK_COLORSPACE_CONVERSION_WEBGL, h);
                        const d = a.isCompressedTexture || a.image[0].isCompressedTexture
                          , p = a.image[0] && a.image[0].isDataTexture
                          , f = [];
                        for (let e = 0; e < 6; e++)
                            f[e] = d || p ? p ? a.image[e].image : a.image[e] : A(a.image[e], !0, r.maxCubemapSize),
                            f[e] = $(a, f[e]);
                        const v = f[0]
                          , x = s.convert(a.format, a.colorSpace)
                          , b = s.convert(a.type)
                          , E = y(a.internalFormat, x, b, a.colorSpace)
                          , w = !0 !== a.isVideoTexture
                          , C = void 0 === u.__version || !0 === l
                          , I = c.dataReady;
                        let S, M = _(a, v);
                        if (B(e.TEXTURE_CUBE_MAP, a),
                        d) {
                            w && C && n.texStorage2D(e.TEXTURE_CUBE_MAP, M, E, v.width, v.height);
                            for (let t = 0; t < 6; t++) {
                                S = f[t].mipmaps;
                                for (let i = 0; i < S.length; i++) {
                                    const r = S[i];
                                    a.format !== ae ? null !== x ? w ? I && n.compressedTexSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, i, 0, 0, r.width, r.height, x, r.data) : n.compressedTexImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, i, E, r.width, r.height, 0, r.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : w ? I && n.texSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, i, 0, 0, r.width, r.height, x, b, r.data) : n.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, i, E, r.width, r.height, 0, x, b, r.data)
                                }
                            }
                        } else {
                            if (S = a.mipmaps,
                            w && C) {
                                S.length > 0 && M++;
                                const t = ee(f[0]);
                                n.texStorage2D(e.TEXTURE_CUBE_MAP, M, E, t.width, t.height)
                            }
                            for (let t = 0; t < 6; t++)
                                if (p) {
                                    w ? I && n.texSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, 0, 0, 0, f[t].width, f[t].height, x, b, f[t].data) : n.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, 0, E, f[t].width, f[t].height, 0, x, b, f[t].data);
                                    for (let i = 0; i < S.length; i++) {
                                        const r = S[i].image[t].image;
                                        w ? I && n.texSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, i + 1, 0, 0, r.width, r.height, x, b, r.data) : n.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, i + 1, E, r.width, r.height, 0, x, b, r.data)
                                    }
                                } else {
                                    w ? I && n.texSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, 0, 0, 0, x, b, f[t]) : n.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, 0, E, x, b, f[t]);
                                    for (let i = 0; i < S.length; i++) {
                                        const r = S[i];
                                        w ? I && n.texSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, i + 1, 0, 0, x, b, r.image[t]) : n.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, i + 1, E, x, b, r.image[t])
                                    }
                                }
                        }
                        g(a) && m(e.TEXTURE_CUBE_MAP),
                        u.__version = c.version,
                        a.onUpdate && a.onUpdate(a)
                    }
                    t.__version = a.version
                }(o, t, a) : n.bindTexture(e.TEXTURE_CUBE_MAP, o.__webglTexture, e.TEXTURE0 + a)
            }
            ,
            this.rebindTextures = function(t, n, r) {
                const s = i.get(t);
                void 0 !== n && P(s.__webglFramebuffer, t, t.texture, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, 0),
                void 0 !== r && U(t)
            }
            ,
            this.setupRenderTarget = function(t) {
                const r = t.texture
                  , o = i.get(t)
                  , l = i.get(r);
                t.addEventListener("dispose", E);
                const c = t.textures
                  , u = !0 === t.isWebGLCubeRenderTarget
                  , h = c.length > 1;
                if (h || (void 0 === l.__webglTexture && (l.__webglTexture = e.createTexture()),
                l.__version = r.version,
                a.memory.textures++),
                u) {
                    o.__webglFramebuffer = [];
                    for (let t = 0; t < 6; t++)
                        if (r.mipmaps && r.mipmaps.length > 0) {
                            o.__webglFramebuffer[t] = [];
                            for (let n = 0; n < r.mipmaps.length; n++)
                                o.__webglFramebuffer[t][n] = e.createFramebuffer()
                        } else
                            o.__webglFramebuffer[t] = e.createFramebuffer()
                } else {
                    if (r.mipmaps && r.mipmaps.length > 0) {
                        o.__webglFramebuffer = [];
                        for (let t = 0; t < r.mipmaps.length; t++)
                            o.__webglFramebuffer[t] = e.createFramebuffer()
                    } else
                        o.__webglFramebuffer = e.createFramebuffer();
                    if (h)
                        for (let t = 0, n = c.length; t < n; t++) {
                            const n = i.get(c[t]);
                            void 0 === n.__webglTexture && (n.__webglTexture = e.createTexture(),
                            a.memory.textures++)
                        }
                    if (t.samples > 0 && !1 === K(t)) {
                        o.__webglMultisampledFramebuffer = e.createFramebuffer(),
                        o.__webglColorRenderbuffer = [],
                        n.bindFramebuffer(e.FRAMEBUFFER, o.__webglMultisampledFramebuffer);
                        for (let n = 0; n < c.length; n++) {
                            const i = c[n];
                            o.__webglColorRenderbuffer[n] = e.createRenderbuffer(),
                            e.bindRenderbuffer(e.RENDERBUFFER, o.__webglColorRenderbuffer[n]);
                            const r = s.convert(i.format, i.colorSpace)
                              , a = s.convert(i.type)
                              , l = y(i.internalFormat, r, a, i.colorSpace, !0 === t.isXRRenderTarget)
                              , u = Y(t);
                            e.renderbufferStorageMultisample(e.RENDERBUFFER, u, l, t.width, t.height),
                            e.framebufferRenderbuffer(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0 + n, e.RENDERBUFFER, o.__webglColorRenderbuffer[n])
                        }
                        e.bindRenderbuffer(e.RENDERBUFFER, null),
                        t.depthBuffer && (o.__webglDepthRenderbuffer = e.createRenderbuffer(),
                        L(o.__webglDepthRenderbuffer, t, !0)),
                        n.bindFramebuffer(e.FRAMEBUFFER, null)
                    }
                }
                if (u) {
                    n.bindTexture(e.TEXTURE_CUBE_MAP, l.__webglTexture),
                    B(e.TEXTURE_CUBE_MAP, r);
                    for (let n = 0; n < 6; n++)
                        if (r.mipmaps && r.mipmaps.length > 0)
                            for (let i = 0; i < r.mipmaps.length; i++)
                                P(o.__webglFramebuffer[n][i], t, r, e.COLOR_ATTACHMENT0, e.TEXTURE_CUBE_MAP_POSITIVE_X + n, i);
                        else
                            P(o.__webglFramebuffer[n], t, r, e.COLOR_ATTACHMENT0, e.TEXTURE_CUBE_MAP_POSITIVE_X + n, 0);
                    g(r) && m(e.TEXTURE_CUBE_MAP),
                    n.unbindTexture()
                } else if (h) {
                    for (let r = 0, s = c.length; r < s; r++) {
                        const s = c[r]
                          , a = i.get(s);
                        n.bindTexture(e.TEXTURE_2D, a.__webglTexture),
                        B(e.TEXTURE_2D, s),
                        P(o.__webglFramebuffer, t, s, e.COLOR_ATTACHMENT0 + r, e.TEXTURE_2D, 0),
                        g(s) && m(e.TEXTURE_2D)
                    }
                    n.unbindTexture()
                } else {
                    let i = e.TEXTURE_2D;
                    if ((t.isWebGL3DRenderTarget || t.isWebGLArrayRenderTarget) && (i = t.isWebGL3DRenderTarget ? e.TEXTURE_3D : e.TEXTURE_2D_ARRAY),
                    n.bindTexture(i, l.__webglTexture),
                    B(i, r),
                    r.mipmaps && r.mipmaps.length > 0)
                        for (let n = 0; n < r.mipmaps.length; n++)
                            P(o.__webglFramebuffer[n], t, r, e.COLOR_ATTACHMENT0, i, n);
                    else
                        P(o.__webglFramebuffer, t, r, e.COLOR_ATTACHMENT0, i, 0);
                    g(r) && m(i),
                    n.unbindTexture()
                }
                t.depthBuffer && U(t)
            }
            ,
            this.updateRenderTargetMipmap = function(e) {
                const t = e.textures;
                for (let r = 0, s = t.length; r < s; r++) {
                    const s = t[r];
                    if (g(s)) {
                        const t = v(e)
                          , r = i.get(s).__webglTexture;
                        n.bindTexture(t, r),
                        m(t),
                        n.unbindTexture()
                    }
                }
            }
            ,
            this.updateMultisampleRenderTarget = function(t) {
                if (t.samples > 0)
                    if (!1 === K(t)) {
                        const r = t.textures
                          , s = t.width
                          , a = t.height;
                        let o = e.COLOR_BUFFER_BIT;
                        const c = t.stencilBuffer ? e.DEPTH_STENCIL_ATTACHMENT : e.DEPTH_ATTACHMENT
                          , u = i.get(t)
                          , h = r.length > 1;
                        if (h)
                            for (let t = 0; t < r.length; t++)
                                n.bindFramebuffer(e.FRAMEBUFFER, u.__webglMultisampledFramebuffer),
                                e.framebufferRenderbuffer(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0 + t, e.RENDERBUFFER, null),
                                n.bindFramebuffer(e.FRAMEBUFFER, u.__webglFramebuffer),
                                e.framebufferTexture2D(e.DRAW_FRAMEBUFFER, e.COLOR_ATTACHMENT0 + t, e.TEXTURE_2D, null, 0);
                        n.bindFramebuffer(e.READ_FRAMEBUFFER, u.__webglMultisampledFramebuffer),
                        n.bindFramebuffer(e.DRAW_FRAMEBUFFER, u.__webglFramebuffer);
                        for (let n = 0; n < r.length; n++) {
                            if (t.resolveDepthBuffer && (t.depthBuffer && (o |= e.DEPTH_BUFFER_BIT),
                            t.stencilBuffer && t.resolveStencilBuffer && (o |= e.STENCIL_BUFFER_BIT)),
                            h) {
                                e.framebufferRenderbuffer(e.READ_FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.RENDERBUFFER, u.__webglColorRenderbuffer[n]);
                                const t = i.get(r[n]).__webglTexture;
                                e.framebufferTexture2D(e.DRAW_FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, t, 0)
                            }
                            e.blitFramebuffer(0, 0, s, a, 0, 0, s, a, o, e.NEAREST),
                            !0 === l && (F.length = 0,
                            q.length = 0,
                            F.push(e.COLOR_ATTACHMENT0 + n),
                            t.depthBuffer && !1 === t.resolveDepthBuffer && (F.push(c),
                            q.push(c),
                            e.invalidateFramebuffer(e.DRAW_FRAMEBUFFER, q)),
                            e.invalidateFramebuffer(e.READ_FRAMEBUFFER, F))
                        }
                        if (n.bindFramebuffer(e.READ_FRAMEBUFFER, null),
                        n.bindFramebuffer(e.DRAW_FRAMEBUFFER, null),
                        h)
                            for (let t = 0; t < r.length; t++) {
                                n.bindFramebuffer(e.FRAMEBUFFER, u.__webglMultisampledFramebuffer),
                                e.framebufferRenderbuffer(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0 + t, e.RENDERBUFFER, u.__webglColorRenderbuffer[t]);
                                const s = i.get(r[t]).__webglTexture;
                                n.bindFramebuffer(e.FRAMEBUFFER, u.__webglFramebuffer),
                                e.framebufferTexture2D(e.DRAW_FRAMEBUFFER, e.COLOR_ATTACHMENT0 + t, e.TEXTURE_2D, s, 0)
                            }
                        n.bindFramebuffer(e.DRAW_FRAMEBUFFER, u.__webglMultisampledFramebuffer)
                    } else if (t.depthBuffer && !1 === t.resolveDepthBuffer && l) {
                        const n = t.stencilBuffer ? e.DEPTH_STENCIL_ATTACHMENT : e.DEPTH_ATTACHMENT;
                        e.invalidateFramebuffer(e.DRAW_FRAMEBUFFER, [n])
                    }
            }
            ,
            this.setupDepthRenderbuffer = U,
            this.setupFrameBufferTexture = P,
            this.useMultisampledRTT = K
        }
        function go(e, t) {
            return {
                convert: function(n, i=lt) {
                    let r;
                    const s = Qt.getTransfer(i);
                    if (n === j)
                        return e.UNSIGNED_BYTE;
                    if (n === ee)
                        return e.UNSIGNED_SHORT_4_4_4_4;
                    if (n === te)
                        return e.UNSIGNED_SHORT_5_5_5_1;
                    if (n === ie)
                        return e.UNSIGNED_INT_5_9_9_9_REV;
                    if (n === q)
                        return e.BYTE;
                    if (n === Y)
                        return e.SHORT;
                    if (n === X)
                        return e.UNSIGNED_SHORT;
                    if (n === K)
                        return e.INT;
                    if (n === J)
                        return e.UNSIGNED_INT;
                    if (n === Z)
                        return e.FLOAT;
                    if (n === $)
                        return e.HALF_FLOAT;
                    if (n === re)
                        return e.ALPHA;
                    if (n === se)
                        return e.RGB;
                    if (n === ae)
                        return e.RGBA;
                    if (n === oe)
                        return e.LUMINANCE;
                    if (n === le)
                        return e.LUMINANCE_ALPHA;
                    if (n === ce)
                        return e.DEPTH_COMPONENT;
                    if (n === ue)
                        return e.DEPTH_STENCIL;
                    if (n === he)
                        return e.RED;
                    if (n === de)
                        return e.RED_INTEGER;
                    if (n === pe)
                        return e.RG;
                    if (n === fe)
                        return e.RG_INTEGER;
                    if (n === Ae)
                        return e.RGBA_INTEGER;
                    if (n === ge || n === me || n === ve || n === ye)
                        if (s === dt) {
                            if (r = t.get("WEBGL_compressed_texture_s3tc_srgb"),
                            null === r)
                                return null;
                            if (n === ge)
                                return r.COMPRESSED_SRGB_S3TC_DXT1_EXT;
                            if (n === me)
                                return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
                            if (n === ve)
                                return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
                            if (n === ye)
                                return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
                        } else {
                            if (r = t.get("WEBGL_compressed_texture_s3tc"),
                            null === r)
                                return null;
                            if (n === ge)
                                return r.COMPRESSED_RGB_S3TC_DXT1_EXT;
                            if (n === me)
                                return r.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                            if (n === ve)
                                return r.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                            if (n === ye)
                                return r.COMPRESSED_RGBA_S3TC_DXT5_EXT
                        }
                    if (n === xe || n === _e || n === be || n === Ee) {
                        if (r = t.get("WEBGL_compressed_texture_pvrtc"),
                        null === r)
                            return null;
                        if (n === xe)
                            return r.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                        if (n === _e)
                            return r.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                        if (n === be)
                            return r.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                        if (n === Ee)
                            return r.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
                    }
                    if (n === we || n === Ce || n === Ie) {
                        if (r = t.get("WEBGL_compressed_texture_etc"),
                        null === r)
                            return null;
                        if (n === we || n === Ce)
                            return s === dt ? r.COMPRESSED_SRGB8_ETC2 : r.COMPRESSED_RGB8_ETC2;
                        if (n === Ie)
                            return s === dt ? r.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : r.COMPRESSED_RGBA8_ETC2_EAC
                    }
                    if (n === Se || n === Me || n === Te || n === Be || n === Re || n === De || n === Pe || n === Le || n === Ue || n === Fe || n === Ne || n === Oe || n === Qe || n === ke) {
                        if (r = t.get("WEBGL_compressed_texture_astc"),
                        null === r)
                            return null;
                        if (n === Se)
                            return s === dt ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : r.COMPRESSED_RGBA_ASTC_4x4_KHR;
                        if (n === Me)
                            return s === dt ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : r.COMPRESSED_RGBA_ASTC_5x4_KHR;
                        if (n === Te)
                            return s === dt ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : r.COMPRESSED_RGBA_ASTC_5x5_KHR;
                        if (n === Be)
                            return s === dt ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : r.COMPRESSED_RGBA_ASTC_6x5_KHR;
                        if (n === Re)
                            return s === dt ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : r.COMPRESSED_RGBA_ASTC_6x6_KHR;
                        if (n === De)
                            return s === dt ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : r.COMPRESSED_RGBA_ASTC_8x5_KHR;
                        if (n === Pe)
                            return s === dt ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : r.COMPRESSED_RGBA_ASTC_8x6_KHR;
                        if (n === Le)
                            return s === dt ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : r.COMPRESSED_RGBA_ASTC_8x8_KHR;
                        if (n === Ue)
                            return s === dt ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : r.COMPRESSED_RGBA_ASTC_10x5_KHR;
                        if (n === Fe)
                            return s === dt ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : r.COMPRESSED_RGBA_ASTC_10x6_KHR;
                        if (n === Ne)
                            return s === dt ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : r.COMPRESSED_RGBA_ASTC_10x8_KHR;
                        if (n === Oe)
                            return s === dt ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : r.COMPRESSED_RGBA_ASTC_10x10_KHR;
                        if (n === Qe)
                            return s === dt ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : r.COMPRESSED_RGBA_ASTC_12x10_KHR;
                        if (n === ke)
                            return s === dt ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : r.COMPRESSED_RGBA_ASTC_12x12_KHR
                    }
                    if (n === Ge || n === He || n === ze) {
                        if (r = t.get("EXT_texture_compression_bptc"),
                        null === r)
                            return null;
                        if (n === Ge)
                            return s === dt ? r.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : r.COMPRESSED_RGBA_BPTC_UNORM_EXT;
                        if (n === He)
                            return r.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
                        if (n === ze)
                            return r.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT
                    }
                    if (n === Ve || n === We || n === je || n === qe) {
                        if (r = t.get("EXT_texture_compression_rgtc"),
                        null === r)
                            return null;
                        if (n === Ge)
                            return r.COMPRESSED_RED_RGTC1_EXT;
                        if (n === We)
                            return r.COMPRESSED_SIGNED_RED_RGTC1_EXT;
                        if (n === je)
                            return r.COMPRESSED_RED_GREEN_RGTC2_EXT;
                        if (n === qe)
                            return r.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT
                    }
                    return n === ne ? e.UNSIGNED_INT_24_8 : void 0 !== e[n] ? e[n] : null
                }
            }
        }
        class mo extends br {
            constructor(e=[]) {
                super(),
                this.isArrayCamera = !0,
                this.cameras = e
            }
        }
        class vo extends ui {
            constructor() {
                super(),
                this.isGroup = !0,
                this.type = "Group"
            }
        }
        const yo = {
            type: "move"
        };
        class xo {
            constructor() {
                this._targetRay = null,
                this._grip = null,
                this._hand = null
            }
            getHandSpace() {
                return null === this._hand && (this._hand = new vo,
                this._hand.matrixAutoUpdate = !1,
                this._hand.visible = !1,
                this._hand.joints = {},
                this._hand.inputState = {
                    pinching: !1
                }),
                this._hand
            }
            getTargetRaySpace() {
                return null === this._targetRay && (this._targetRay = new vo,
                this._targetRay.matrixAutoUpdate = !1,
                this._targetRay.visible = !1,
                this._targetRay.hasLinearVelocity = !1,
                this._targetRay.linearVelocity = new on,
                this._targetRay.hasAngularVelocity = !1,
                this._targetRay.angularVelocity = new on),
                this._targetRay
            }
            getGripSpace() {
                return null === this._grip && (this._grip = new vo,
                this._grip.matrixAutoUpdate = !1,
                this._grip.visible = !1,
                this._grip.hasLinearVelocity = !1,
                this._grip.linearVelocity = new on,
                this._grip.hasAngularVelocity = !1,
                this._grip.angularVelocity = new on),
                this._grip
            }
            dispatchEvent(e) {
                return null !== this._targetRay && this._targetRay.dispatchEvent(e),
                null !== this._grip && this._grip.dispatchEvent(e),
                null !== this._hand && this._hand.dispatchEvent(e),
                this
            }
            connect(e) {
                if (e && e.hand) {
                    const t = this._hand;
                    if (t)
                        for (const n of e.hand.values())
                            this._getHandJoint(t, n)
                }
                return this.dispatchEvent({
                    type: "connected",
                    data: e
                }),
                this
            }
            disconnect(e) {
                return this.dispatchEvent({
                    type: "disconnected",
                    data: e
                }),
                null !== this._targetRay && (this._targetRay.visible = !1),
                null !== this._grip && (this._grip.visible = !1),
                null !== this._hand && (this._hand.visible = !1),
                this
            }
            update(e, t, n) {
                let i = null
                  , r = null
                  , s = null;
                const a = this._targetRay
                  , o = this._grip
                  , l = this._hand;
                if (e && "visible-blurred" !== t.session.visibilityState) {
                    if (l && e.hand) {
                        s = !0;
                        for (const i of e.hand.values()) {
                            const e = t.getJointPose(i, n)
                              , r = this._getHandJoint(l, i);
                            null !== e && (r.matrix.fromArray(e.transform.matrix),
                            r.matrix.decompose(r.position, r.rotation, r.scale),
                            r.matrixWorldNeedsUpdate = !0,
                            r.jointRadius = e.radius),
                            r.visible = null !== e
                        }
                        const i = l.joints["index-finger-tip"]
                          , r = l.joints["thumb-tip"]
                          , a = i.position.distanceTo(r.position)
                          , o = .02
                          , c = .005;
                        l.inputState.pinching && a > o + c ? (l.inputState.pinching = !1,
                        this.dispatchEvent({
                            type: "pinchend",
                            handedness: e.handedness,
                            target: this
                        })) : !l.inputState.pinching && a <= o - c && (l.inputState.pinching = !0,
                        this.dispatchEvent({
                            type: "pinchstart",
                            handedness: e.handedness,
                            target: this
                        }))
                    } else
                        null !== o && e.gripSpace && (r = t.getPose(e.gripSpace, n),
                        null !== r && (o.matrix.fromArray(r.transform.matrix),
                        o.matrix.decompose(o.position, o.rotation, o.scale),
                        o.matrixWorldNeedsUpdate = !0,
                        r.linearVelocity ? (o.hasLinearVelocity = !0,
                        o.linearVelocity.copy(r.linearVelocity)) : o.hasLinearVelocity = !1,
                        r.angularVelocity ? (o.hasAngularVelocity = !0,
                        o.angularVelocity.copy(r.angularVelocity)) : o.hasAngularVelocity = !1));
                    null !== a && (i = t.getPose(e.targetRaySpace, n),
                    null === i && null !== r && (i = r),
                    null !== i && (a.matrix.fromArray(i.transform.matrix),
                    a.matrix.decompose(a.position, a.rotation, a.scale),
                    a.matrixWorldNeedsUpdate = !0,
                    i.linearVelocity ? (a.hasLinearVelocity = !0,
                    a.linearVelocity.copy(i.linearVelocity)) : a.hasLinearVelocity = !1,
                    i.angularVelocity ? (a.hasAngularVelocity = !0,
                    a.angularVelocity.copy(i.angularVelocity)) : a.hasAngularVelocity = !1,
                    this.dispatchEvent(yo)))
                }
                return null !== a && (a.visible = null !== i),
                null !== o && (o.visible = null !== r),
                null !== l && (l.visible = null !== s),
                this
            }
            _getHandJoint(e, t) {
                if (void 0 === e.joints[t.jointName]) {
                    const n = new vo;
                    n.matrixAutoUpdate = !1,
                    n.visible = !1,
                    e.joints[t.jointName] = n,
                    e.add(n)
                }
                return e.joints[t.jointName]
            }
        }
        class _o {
            constructor() {
                this.texture = null,
                this.mesh = null,
                this.depthNear = 0,
                this.depthFar = 0
            }
            init(e, t, n) {
                if (null === this.texture) {
                    const i = new $t;
                    e.properties.get(i).__webglTexture = t.texture,
                    t.depthNear == n.depthNear && t.depthFar == n.depthFar || (this.depthNear = t.depthNear,
                    this.depthFar = t.depthFar),
                    this.texture = i
                }
            }
            getMesh(e) {
                if (null !== this.texture && null === this.mesh) {
                    const t = e.cameras[0].viewport
                      , n = new mr({
                        vertexShader: "\nvoid main() {\n\n\tgl_Position = vec4( position, 1.0 );\n\n}",
                        fragmentShader: "\nuniform sampler2DArray depthColor;\nuniform float depthWidth;\nuniform float depthHeight;\n\nvoid main() {\n\n\tvec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );\n\n\tif ( coord.x >= 1.0 ) {\n\n\t\tgl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;\n\n\t} else {\n\n\t\tgl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;\n\n\t}\n\n}",
                        uniforms: {
                            depthColor: {
                                value: this.texture
                            },
                            depthWidth: {
                                value: t.z
                            },
                            depthHeight: {
                                value: t.w
                            }
                        }
                    });
                    this.mesh = new ur(new Fr(20,20),n)
                }
                return this.mesh
            }
            reset() {
                this.texture = null,
                this.mesh = null
            }
            getDepthTexture() {
                return this.texture
            }
        }
        class bo extends yt {
            constructor(e, t) {
                super();
                const n = this;
                let i = null
                  , r = 1
                  , s = null
                  , a = "local-floor"
                  , o = 1
                  , l = null
                  , c = null
                  , u = null
                  , h = null
                  , d = null
                  , p = null;
                const f = new _o
                  , A = t.getContextAttributes();
                let g = null
                  , m = null;
                const v = []
                  , y = []
                  , x = new Rt;
                let _ = null;
                const b = new br;
                b.viewport = new en;
                const E = new br;
                E.viewport = new en;
                const w = [b, E]
                  , C = new mo;
                let I = null
                  , S = null;
                function M(e) {
                    const t = y.indexOf(e.inputSource);
                    if (-1 === t)
                        return;
                    const n = v[t];
                    void 0 !== n && (n.update(e.inputSource, e.frame, l || s),
                    n.dispatchEvent({
                        type: e.type,
                        data: e.inputSource
                    }))
                }
                function T() {
                    i.removeEventListener("select", M),
                    i.removeEventListener("selectstart", M),
                    i.removeEventListener("selectend", M),
                    i.removeEventListener("squeeze", M),
                    i.removeEventListener("squeezestart", M),
                    i.removeEventListener("squeezeend", M),
                    i.removeEventListener("end", T),
                    i.removeEventListener("inputsourceschange", B);
                    for (let e = 0; e < v.length; e++) {
                        const t = y[e];
                        null !== t && (y[e] = null,
                        v[e].disconnect(t))
                    }
                    I = null,
                    S = null,
                    f.reset(),
                    e.setRenderTarget(g),
                    d = null,
                    h = null,
                    u = null,
                    i = null,
                    m = null,
                    U.stop(),
                    n.isPresenting = !1,
                    e.setPixelRatio(_),
                    e.setSize(x.width, x.height, !1),
                    n.dispatchEvent({
                        type: "sessionend"
                    })
                }
                function B(e) {
                    for (let t = 0; t < e.removed.length; t++) {
                        const n = e.removed[t]
                          , i = y.indexOf(n);
                        i >= 0 && (y[i] = null,
                        v[i].disconnect(n))
                    }
                    for (let t = 0; t < e.added.length; t++) {
                        const n = e.added[t];
                        let i = y.indexOf(n);
                        if (-1 === i) {
                            for (let e = 0; e < v.length; e++) {
                                if (e >= y.length) {
                                    y.push(n),
                                    i = e;
                                    break
                                }
                                if (null === y[e]) {
                                    y[e] = n,
                                    i = e;
                                    break
                                }
                            }
                            if (-1 === i)
                                break
                        }
                        const r = v[i];
                        r && r.connect(n)
                    }
                }
                this.cameraAutoUpdate = !0,
                this.enabled = !1,
                this.isPresenting = !1,
                this.getController = function(e) {
                    let t = v[e];
                    return void 0 === t && (t = new xo,
                    v[e] = t),
                    t.getTargetRaySpace()
                }
                ,
                this.getControllerGrip = function(e) {
                    let t = v[e];
                    return void 0 === t && (t = new xo,
                    v[e] = t),
                    t.getGripSpace()
                }
                ,
                this.getHand = function(e) {
                    let t = v[e];
                    return void 0 === t && (t = new xo,
                    v[e] = t),
                    t.getHandSpace()
                }
                ,
                this.setFramebufferScaleFactor = function(e) {
                    r = e,
                    !0 === n.isPresenting && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")
                }
                ,
                this.setReferenceSpaceType = function(e) {
                    a = e,
                    !0 === n.isPresenting && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")
                }
                ,
                this.getReferenceSpace = function() {
                    return l || s
                }
                ,
                this.setReferenceSpace = function(e) {
                    l = e
                }
                ,
                this.getBaseLayer = function() {
                    return null !== h ? h : d
                }
                ,
                this.getBinding = function() {
                    return u
                }
                ,
                this.getFrame = function() {
                    return p
                }
                ,
                this.getSession = function() {
                    return i
                }
                ,
                this.setSession = async function(c) {
                    if (i = c,
                    null !== i) {
                        if (g = e.getRenderTarget(),
                        i.addEventListener("select", M),
                        i.addEventListener("selectstart", M),
                        i.addEventListener("selectend", M),
                        i.addEventListener("squeeze", M),
                        i.addEventListener("squeezestart", M),
                        i.addEventListener("squeezeend", M),
                        i.addEventListener("end", T),
                        i.addEventListener("inputsourceschange", B),
                        !0 !== A.xrCompatible && await t.makeXRCompatible(),
                        _ = e.getPixelRatio(),
                        e.getSize(x),
                        void 0 === i.renderState.layers) {
                            const n = {
                                antialias: A.antialias,
                                alpha: !0,
                                depth: A.depth,
                                stencil: A.stencil,
                                framebufferScaleFactor: r
                            };
                            d = new XRWebGLLayer(i,t,n),
                            i.updateRenderState({
                                baseLayer: d
                            }),
                            e.setPixelRatio(1),
                            e.setSize(d.framebufferWidth, d.framebufferHeight, !1),
                            m = new nn(d.framebufferWidth,d.framebufferHeight,{
                                format: ae,
                                type: j,
                                colorSpace: e.outputColorSpace,
                                stencilBuffer: A.stencil
                            })
                        } else {
                            let n = null
                              , s = null
                              , a = null;
                            A.depth && (a = A.stencil ? t.DEPTH24_STENCIL8 : t.DEPTH_COMPONENT24,
                            n = A.stencil ? ue : ce,
                            s = A.stencil ? ne : J);
                            const o = {
                                colorFormat: t.RGBA8,
                                depthFormat: a,
                                scaleFactor: r
                            };
                            u = new XRWebGLBinding(i,t),
                            h = u.createProjectionLayer(o),
                            i.updateRenderState({
                                layers: [h]
                            }),
                            e.setPixelRatio(1),
                            e.setSize(h.textureWidth, h.textureHeight, !1),
                            m = new nn(h.textureWidth,h.textureHeight,{
                                format: ae,
                                type: j,
                                depthTexture: new xs(h.textureWidth,h.textureHeight,s,void 0,void 0,void 0,void 0,void 0,void 0,n),
                                stencilBuffer: A.stencil,
                                colorSpace: e.outputColorSpace,
                                samples: A.antialias ? 4 : 0,
                                resolveDepthBuffer: !1 === h.ignoreDepthValues
                            })
                        }
                        m.isXRRenderTarget = !0,
                        this.setFoveation(o),
                        l = null,
                        s = await i.requestReferenceSpace(a),
                        U.setContext(i),
                        U.start(),
                        n.isPresenting = !0,
                        n.dispatchEvent({
                            type: "sessionstart"
                        })
                    }
                }
                ,
                this.getEnvironmentBlendMode = function() {
                    if (null !== i)
                        return i.environmentBlendMode
                }
                ,
                this.getDepthTexture = function() {
                    return f.getDepthTexture()
                }
                ;
                const R = new on
                  , D = new on;
                function P(e, t) {
                    null === t ? e.matrixWorld.copy(e.matrix) : e.matrixWorld.multiplyMatrices(t.matrixWorld, e.matrix),
                    e.matrixWorldInverse.copy(e.matrixWorld).invert()
                }
                this.updateCamera = function(e) {
                    if (null === i)
                        return;
                    let t = e.near
                      , n = e.far;
                    null !== f.texture && (f.depthNear > 0 && (t = f.depthNear),
                    f.depthFar > 0 && (n = f.depthFar)),
                    C.near = E.near = b.near = t,
                    C.far = E.far = b.far = n,
                    I === C.near && S === C.far || (i.updateRenderState({
                        depthNear: C.near,
                        depthFar: C.far
                    }),
                    I = C.near,
                    S = C.far),
                    b.layers.mask = 2 | e.layers.mask,
                    E.layers.mask = 4 | e.layers.mask,
                    C.layers.mask = b.layers.mask | E.layers.mask;
                    const r = e.parent
                      , s = C.cameras;
                    P(C, r);
                    for (let e = 0; e < s.length; e++)
                        P(s[e], r);
                    2 === s.length ? function(e, t, n) {
                        R.setFromMatrixPosition(t.matrixWorld),
                        D.setFromMatrixPosition(n.matrixWorld);
                        const i = R.distanceTo(D)
                          , r = t.projectionMatrix.elements
                          , s = n.projectionMatrix.elements
                          , a = r[14] / (r[10] - 1)
                          , o = r[14] / (r[10] + 1)
                          , l = (r[9] + 1) / r[5]
                          , c = (r[9] - 1) / r[5]
                          , u = (r[8] - 1) / r[0]
                          , h = (s[8] + 1) / s[0]
                          , d = a * u
                          , p = a * h
                          , f = i / (-u + h)
                          , A = f * -u;
                        if (t.matrixWorld.decompose(e.position, e.quaternion, e.scale),
                        e.translateX(A),
                        e.translateZ(f),
                        e.matrixWorld.compose(e.position, e.quaternion, e.scale),
                        e.matrixWorldInverse.copy(e.matrixWorld).invert(),
                        -1 === r[10])
                            e.projectionMatrix.copy(t.projectionMatrix),
                            e.projectionMatrixInverse.copy(t.projectionMatrixInverse);
                        else {
                            const t = a + f
                              , n = o + f
                              , r = d - A
                              , s = p + (i - A)
                              , u = l * o / n * t
                              , h = c * o / n * t;
                            e.projectionMatrix.makePerspective(r, s, u, h, t, n),
                            e.projectionMatrixInverse.copy(e.projectionMatrix).invert()
                        }
                    }(C, b, E) : C.projectionMatrix.copy(b.projectionMatrix),
                    function(e, t, n) {
                        null === n ? e.matrix.copy(t.matrixWorld) : (e.matrix.copy(n.matrixWorld),
                        e.matrix.invert(),
                        e.matrix.multiply(t.matrixWorld));
                        e.matrix.decompose(e.position, e.quaternion, e.scale),
                        e.updateMatrixWorld(!0),
                        e.projectionMatrix.copy(t.projectionMatrix),
                        e.projectionMatrixInverse.copy(t.projectionMatrixInverse),
                        e.isPerspectiveCamera && (e.fov = 2 * Et * Math.atan(1 / e.projectionMatrix.elements[5]),
                        e.zoom = 1)
                    }(e, C, r)
                }
                ,
                this.getCamera = function() {
                    return C
                }
                ,
                this.getFoveation = function() {
                    if (null !== h || null !== d)
                        return o
                }
                ,
                this.setFoveation = function(e) {
                    o = e,
                    null !== h && (h.fixedFoveation = e),
                    null !== d && void 0 !== d.fixedFoveation && (d.fixedFoveation = e)
                }
                ,
                this.hasDepthSensing = function() {
                    return null !== f.texture
                }
                ,
                this.getDepthSensingMesh = function() {
                    return f.getMesh(C)
                }
                ;
                let L = null;
                const U = new Lr;
                U.setAnimationLoop((function(t, r) {
                    if (c = r.getViewerPose(l || s),
                    p = r,
                    null !== c) {
                        const t = c.views;
                        null !== d && (e.setRenderTargetFramebuffer(m, d.framebuffer),
                        e.setRenderTarget(m));
                        let n = !1;
                        t.length !== C.cameras.length && (C.cameras.length = 0,
                        n = !0);
                        for (let i = 0; i < t.length; i++) {
                            const r = t[i];
                            let s = null;
                            if (null !== d)
                                s = d.getViewport(r);
                            else {
                                const t = u.getViewSubImage(h, r);
                                s = t.viewport,
                                0 === i && (e.setRenderTargetTextures(m, t.colorTexture, h.ignoreDepthValues ? void 0 : t.depthStencilTexture),
                                e.setRenderTarget(m))
                            }
                            let a = w[i];
                            void 0 === a && (a = new br,
                            a.layers.enable(i),
                            a.viewport = new en,
                            w[i] = a),
                            a.matrix.fromArray(r.transform.matrix),
                            a.matrix.decompose(a.position, a.quaternion, a.scale),
                            a.projectionMatrix.fromArray(r.projectionMatrix),
                            a.projectionMatrixInverse.copy(a.projectionMatrix).invert(),
                            a.viewport.set(s.x, s.y, s.width, s.height),
                            0 === i && (C.matrix.copy(a.matrix),
                            C.matrix.decompose(C.position, C.quaternion, C.scale)),
                            !0 === n && C.cameras.push(a)
                        }
                        const r = i.enabledFeatures;
                        if (r && r.includes("depth-sensing")) {
                            const n = u.getDepthInformation(t[0]);
                            n && n.isValid && n.texture && f.init(e, n, i.renderState)
                        }
                    }
                    for (let e = 0; e < v.length; e++) {
                        const t = y[e]
                          , n = v[e];
                        null !== t && void 0 !== n && n.update(t, r, l || s)
                    }
                    L && L(t, r),
                    r.detectedPlanes && n.dispatchEvent({
                        type: "planesdetected",
                        data: r
                    }),
                    p = null
                }
                )),
                this.setAnimationLoop = function(e) {
                    L = e
                }
                ,
                this.dispose = function() {}
            }
        }
        const Eo = new qn
          , wo = new Nn;
        function Co(e, t) {
            function n(e, t) {
                !0 === e.matrixAutoUpdate && e.updateMatrix(),
                t.value.copy(e.matrix)
            }
            function i(e, i) {
                e.opacity.value = i.opacity,
                i.color && e.diffuse.value.copy(i.color),
                i.emissive && e.emissive.value.copy(i.emissive).multiplyScalar(i.emissiveIntensity),
                i.map && (e.map.value = i.map,
                n(i.map, e.mapTransform)),
                i.alphaMap && (e.alphaMap.value = i.alphaMap,
                n(i.alphaMap, e.alphaMapTransform)),
                i.bumpMap && (e.bumpMap.value = i.bumpMap,
                n(i.bumpMap, e.bumpMapTransform),
                e.bumpScale.value = i.bumpScale,
                i.side === l && (e.bumpScale.value *= -1)),
                i.normalMap && (e.normalMap.value = i.normalMap,
                n(i.normalMap, e.normalMapTransform),
                e.normalScale.value.copy(i.normalScale),
                i.side === l && e.normalScale.value.negate()),
                i.displacementMap && (e.displacementMap.value = i.displacementMap,
                n(i.displacementMap, e.displacementMapTransform),
                e.displacementScale.value = i.displacementScale,
                e.displacementBias.value = i.displacementBias),
                i.emissiveMap && (e.emissiveMap.value = i.emissiveMap,
                n(i.emissiveMap, e.emissiveMapTransform)),
                i.specularMap && (e.specularMap.value = i.specularMap,
                n(i.specularMap, e.specularMapTransform)),
                i.alphaTest > 0 && (e.alphaTest.value = i.alphaTest);
                const r = t.get(i)
                  , s = r.envMap
                  , a = r.envMapRotation;
                s && (e.envMap.value = s,
                Eo.copy(a),
                Eo.x *= -1,
                Eo.y *= -1,
                Eo.z *= -1,
                s.isCubeTexture && !1 === s.isRenderTargetTexture && (Eo.y *= -1,
                Eo.z *= -1),
                e.envMapRotation.value.setFromMatrix4(wo.makeRotationFromEuler(Eo)),
                e.flipEnvMap.value = s.isCubeTexture && !1 === s.isRenderTargetTexture ? -1 : 1,
                e.reflectivity.value = i.reflectivity,
                e.ior.value = i.ior,
                e.refractionRatio.value = i.refractionRatio),
                i.lightMap && (e.lightMap.value = i.lightMap,
                e.lightMapIntensity.value = i.lightMapIntensity,
                n(i.lightMap, e.lightMapTransform)),
                i.aoMap && (e.aoMap.value = i.aoMap,
                e.aoMapIntensity.value = i.aoMapIntensity,
                n(i.aoMap, e.aoMapTransform))
            }
            return {
                refreshFogUniforms: function(t, n) {
                    n.color.getRGB(t.fogColor.value, Ar(e)),
                    n.isFog ? (t.fogNear.value = n.near,
                    t.fogFar.value = n.far) : n.isFogExp2 && (t.fogDensity.value = n.density)
                },
                refreshMaterialUniforms: function(e, r, s, a, o) {
                    r.isMeshBasicMaterial || r.isMeshLambertMaterial ? i(e, r) : r.isMeshToonMaterial ? (i(e, r),
                    function(e, t) {
                        t.gradientMap && (e.gradientMap.value = t.gradientMap)
                    }(e, r)) : r.isMeshPhongMaterial ? (i(e, r),
                    function(e, t) {
                        e.specular.value.copy(t.specular),
                        e.shininess.value = Math.max(t.shininess, 1e-4)
                    }(e, r)) : r.isMeshStandardMaterial ? (i(e, r),
                    function(e, t) {
                        e.metalness.value = t.metalness,
                        t.metalnessMap && (e.metalnessMap.value = t.metalnessMap,
                        n(t.metalnessMap, e.metalnessMapTransform));
                        e.roughness.value = t.roughness,
                        t.roughnessMap && (e.roughnessMap.value = t.roughnessMap,
                        n(t.roughnessMap, e.roughnessMapTransform));
                        t.envMap && (e.envMapIntensity.value = t.envMapIntensity)
                    }(e, r),
                    r.isMeshPhysicalMaterial && function(e, t, i) {
                        e.ior.value = t.ior,
                        t.sheen > 0 && (e.sheenColor.value.copy(t.sheenColor).multiplyScalar(t.sheen),
                        e.sheenRoughness.value = t.sheenRoughness,
                        t.sheenColorMap && (e.sheenColorMap.value = t.sheenColorMap,
                        n(t.sheenColorMap, e.sheenColorMapTransform)),
                        t.sheenRoughnessMap && (e.sheenRoughnessMap.value = t.sheenRoughnessMap,
                        n(t.sheenRoughnessMap, e.sheenRoughnessMapTransform)));
                        t.clearcoat > 0 && (e.clearcoat.value = t.clearcoat,
                        e.clearcoatRoughness.value = t.clearcoatRoughness,
                        t.clearcoatMap && (e.clearcoatMap.value = t.clearcoatMap,
                        n(t.clearcoatMap, e.clearcoatMapTransform)),
                        t.clearcoatRoughnessMap && (e.clearcoatRoughnessMap.value = t.clearcoatRoughnessMap,
                        n(t.clearcoatRoughnessMap, e.clearcoatRoughnessMapTransform)),
                        t.clearcoatNormalMap && (e.clearcoatNormalMap.value = t.clearcoatNormalMap,
                        n(t.clearcoatNormalMap, e.clearcoatNormalMapTransform),
                        e.clearcoatNormalScale.value.copy(t.clearcoatNormalScale),
                        t.side === l && e.clearcoatNormalScale.value.negate()));
                        t.dispersion > 0 && (e.dispersion.value = t.dispersion);
                        t.iridescence > 0 && (e.iridescence.value = t.iridescence,
                        e.iridescenceIOR.value = t.iridescenceIOR,
                        e.iridescenceThicknessMinimum.value = t.iridescenceThicknessRange[0],
                        e.iridescenceThicknessMaximum.value = t.iridescenceThicknessRange[1],
                        t.iridescenceMap && (e.iridescenceMap.value = t.iridescenceMap,
                        n(t.iridescenceMap, e.iridescenceMapTransform)),
                        t.iridescenceThicknessMap && (e.iridescenceThicknessMap.value = t.iridescenceThicknessMap,
                        n(t.iridescenceThicknessMap, e.iridescenceThicknessMapTransform)));
                        t.transmission > 0 && (e.transmission.value = t.transmission,
                        e.transmissionSamplerMap.value = i.texture,
                        e.transmissionSamplerSize.value.set(i.width, i.height),
                        t.transmissionMap && (e.transmissionMap.value = t.transmissionMap,
                        n(t.transmissionMap, e.transmissionMapTransform)),
                        e.thickness.value = t.thickness,
                        t.thicknessMap && (e.thicknessMap.value = t.thicknessMap,
                        n(t.thicknessMap, e.thicknessMapTransform)),
                        e.attenuationDistance.value = t.attenuationDistance,
                        e.attenuationColor.value.copy(t.attenuationColor));
                        t.anisotropy > 0 && (e.anisotropyVector.value.set(t.anisotropy * Math.cos(t.anisotropyRotation), t.anisotropy * Math.sin(t.anisotropyRotation)),
                        t.anisotropyMap && (e.anisotropyMap.value = t.anisotropyMap,
                        n(t.anisotropyMap, e.anisotropyMapTransform)));
                        e.specularIntensity.value = t.specularIntensity,
                        e.specularColor.value.copy(t.specularColor),
                        t.specularColorMap && (e.specularColorMap.value = t.specularColorMap,
                        n(t.specularColorMap, e.specularColorMapTransform));
                        t.specularIntensityMap && (e.specularIntensityMap.value = t.specularIntensityMap,
                        n(t.specularIntensityMap, e.specularIntensityMapTransform))
                    }(e, r, o)) : r.isMeshMatcapMaterial ? (i(e, r),
                    function(e, t) {
                        t.matcap && (e.matcap.value = t.matcap)
                    }(e, r)) : r.isMeshDepthMaterial ? i(e, r) : r.isMeshDistanceMaterial ? (i(e, r),
                    function(e, n) {
                        const i = t.get(n).light;
                        e.referencePosition.value.setFromMatrixPosition(i.matrixWorld),
                        e.nearDistance.value = i.shadow.camera.near,
                        e.farDistance.value = i.shadow.camera.far
                    }(e, r)) : r.isMeshNormalMaterial ? i(e, r) : r.isLineBasicMaterial ? (function(e, t) {
                        e.diffuse.value.copy(t.color),
                        e.opacity.value = t.opacity,
                        t.map && (e.map.value = t.map,
                        n(t.map, e.mapTransform))
                    }(e, r),
                    r.isLineDashedMaterial && function(e, t) {
                        e.dashSize.value = t.dashSize,
                        e.totalSize.value = t.dashSize + t.gapSize,
                        e.scale.value = t.scale
                    }(e, r)) : r.isPointsMaterial ? function(e, t, i, r) {
                        e.diffuse.value.copy(t.color),
                        e.opacity.value = t.opacity,
                        e.size.value = t.size * i,
                        e.scale.value = .5 * r,
                        t.map && (e.map.value = t.map,
                        n(t.map, e.uvTransform));
                        t.alphaMap && (e.alphaMap.value = t.alphaMap,
                        n(t.alphaMap, e.alphaMapTransform));
                        t.alphaTest > 0 && (e.alphaTest.value = t.alphaTest)
                    }(e, r, s, a) : r.isSpriteMaterial ? function(e, t) {
                        e.diffuse.value.copy(t.color),
                        e.opacity.value = t.opacity,
                        e.rotation.value = t.rotation,
                        t.map && (e.map.value = t.map,
                        n(t.map, e.mapTransform));
                        t.alphaMap && (e.alphaMap.value = t.alphaMap,
                        n(t.alphaMap, e.alphaMapTransform));
                        t.alphaTest > 0 && (e.alphaTest.value = t.alphaTest)
                    }(e, r) : r.isShadowMaterial ? (e.color.value.copy(r.color),
                    e.opacity.value = r.opacity) : r.isShaderMaterial && (r.uniformsNeedUpdate = !1)
                }
            }
        }
        function Io(e, t, n, i) {
            let r = {}
              , s = {}
              , a = [];
            const o = e.getParameter(e.MAX_UNIFORM_BUFFER_BINDINGS);
            function l(e, t, n, i) {
                const r = e.value
                  , s = t + "_" + n;
                if (void 0 === i[s])
                    return i[s] = "number" == typeof r || "boolean" == typeof r ? r : r.clone(),
                    !0;
                {
                    const e = i[s];
                    if ("number" == typeof r || "boolean" == typeof r) {
                        if (e !== r)
                            return i[s] = r,
                            !0
                    } else if (!1 === e.equals(r))
                        return e.copy(r),
                        !0
                }
                return !1
            }
            function c(e) {
                const t = {
                    boundary: 0,
                    storage: 0
                };
                return "number" == typeof e || "boolean" == typeof e ? (t.boundary = 4,
                t.storage = 4) : e.isVector2 ? (t.boundary = 8,
                t.storage = 8) : e.isVector3 || e.isColor ? (t.boundary = 16,
                t.storage = 12) : e.isVector4 ? (t.boundary = 16,
                t.storage = 16) : e.isMatrix3 ? (t.boundary = 48,
                t.storage = 48) : e.isMatrix4 ? (t.boundary = 64,
                t.storage = 64) : e.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", e),
                t
            }
            function u(t) {
                const n = t.target;
                n.removeEventListener("dispose", u);
                const i = a.indexOf(n.__bindingPointIndex);
                a.splice(i, 1),
                e.deleteBuffer(r[n.id]),
                delete r[n.id],
                delete s[n.id]
            }
            return {
                bind: function(e, t) {
                    const n = t.program;
                    i.uniformBlockBinding(e, n)
                },
                update: function(n, h) {
                    let d = r[n.id];
                    void 0 === d && (!function(e) {
                        const t = e.uniforms;
                        let n = 0;
                        const i = 16;
                        for (let e = 0, r = t.length; e < r; e++) {
                            const r = Array.isArray(t[e]) ? t[e] : [t[e]];
                            for (let e = 0, t = r.length; e < t; e++) {
                                const t = r[e]
                                  , s = Array.isArray(t.value) ? t.value : [t.value];
                                for (let e = 0, r = s.length; e < r; e++) {
                                    const r = c(s[e])
                                      , a = n % i
                                      , o = a % r.boundary
                                      , l = a + o;
                                    n += o,
                                    0 !== l && i - l < r.storage && (n += i - l),
                                    t.__data = new Float32Array(r.storage / Float32Array.BYTES_PER_ELEMENT),
                                    t.__offset = n,
                                    n += r.storage
                                }
                            }
                        }
                        const r = n % i;
                        r > 0 && (n += i - r);
                        e.__size = n,
                        e.__cache = {}
                    }(n),
                    d = function(t) {
                        const n = function() {
                            for (let e = 0; e < o; e++)
                                if (-1 === a.indexOf(e))
                                    return a.push(e),
                                    e;
                            return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."),
                            0
                        }();
                        t.__bindingPointIndex = n;
                        const i = e.createBuffer()
                          , r = t.__size
                          , s = t.usage;
                        return e.bindBuffer(e.UNIFORM_BUFFER, i),
                        e.bufferData(e.UNIFORM_BUFFER, r, s),
                        e.bindBuffer(e.UNIFORM_BUFFER, null),
                        e.bindBufferBase(e.UNIFORM_BUFFER, n, i),
                        i
                    }(n),
                    r[n.id] = d,
                    n.addEventListener("dispose", u));
                    const p = h.program;
                    i.updateUBOMapping(n, p);
                    const f = t.render.frame;
                    s[n.id] !== f && (!function(t) {
                        const n = r[t.id]
                          , i = t.uniforms
                          , s = t.__cache;
                        e.bindBuffer(e.UNIFORM_BUFFER, n);
                        for (let t = 0, n = i.length; t < n; t++) {
                            const n = Array.isArray(i[t]) ? i[t] : [i[t]];
                            for (let i = 0, r = n.length; i < r; i++) {
                                const r = n[i];
                                if (!0 === l(r, t, i, s)) {
                                    const t = r.__offset
                                      , n = Array.isArray(r.value) ? r.value : [r.value];
                                    let i = 0;
                                    for (let s = 0; s < n.length; s++) {
                                        const a = n[s]
                                          , o = c(a);
                                        "number" == typeof a || "boolean" == typeof a ? (r.__data[0] = a,
                                        e.bufferSubData(e.UNIFORM_BUFFER, t + i, r.__data)) : a.isMatrix3 ? (r.__data[0] = a.elements[0],
                                        r.__data[1] = a.elements[1],
                                        r.__data[2] = a.elements[2],
                                        r.__data[3] = 0,
                                        r.__data[4] = a.elements[3],
                                        r.__data[5] = a.elements[4],
                                        r.__data[6] = a.elements[5],
                                        r.__data[7] = 0,
                                        r.__data[8] = a.elements[6],
                                        r.__data[9] = a.elements[7],
                                        r.__data[10] = a.elements[8],
                                        r.__data[11] = 0) : (a.toArray(r.__data, i),
                                        i += o.storage / Float32Array.BYTES_PER_ELEMENT)
                                    }
                                    e.bufferSubData(e.UNIFORM_BUFFER, t, r.__data)
                                }
                            }
                        }
                        e.bindBuffer(e.UNIFORM_BUFFER, null)
                    }(n),
                    s[n.id] = f)
                },
                dispose: function() {
                    for (const t in r)
                        e.deleteBuffer(r[t]);
                    a = [],
                    r = {},
                    s = {}
                }
            }
        }
        class So {
            constructor(e={}) {
                const {canvas: t=Ft(), context: n=null, depth: r=!0, stencil: s=!1, alpha: a=!1, antialias: u=!1, premultipliedAlpha: h=!0, preserveDrawingBuffer: d=!1, powerPreference: p="default", failIfMajorPerformanceCaveat: f=!1, reverseDepthBuffer: A=!1} = e;
                let g;
                if (this.isWebGLRenderer = !0,
                null !== n) {
                    if ("undefined" != typeof WebGLRenderingContext && n instanceof WebGLRenderingContext)
                        throw new Error("THREE.WebGLRenderer: WebGL 1 is not supported since r163.");
                    g = n.getContextAttributes().alpha
                } else
                    g = a;
                const m = new Uint32Array(4)
                  , v = new Int32Array(4);
                let y = null
                  , x = null;
                const _ = []
                  , b = [];
                this.domElement = t,
                this.debug = {
                    checkShaderErrors: !0,
                    onShaderError: null
                },
                this.autoClear = !0,
                this.autoClearColor = !0,
                this.autoClearDepth = !0,
                this.autoClearStencil = !0,
                this.sortObjects = !0,
                this.clippingPlanes = [],
                this.localClippingEnabled = !1,
                this._outputColorSpace = ct,
                this.toneMapping = E,
                this.toneMappingExposure = 1;
                const w = this;
                let C = !1
                  , I = 0
                  , S = 0
                  , M = null
                  , T = -1
                  , B = null;
                const R = new en
                  , D = new en;
                let P = null;
                const L = new Ti(0);
                let U = 0
                  , F = t.width
                  , N = t.height
                  , O = 1
                  , Q = null
                  , k = null;
                const G = new en(0,0,F,N)
                  , H = new en(0,0,F,N);
                let z = !1;
                const V = new Pr;
                let q = !1
                  , Y = !1;
                const K = new Nn
                  , Z = new Nn
                  , ie = new on
                  , re = new en
                  , se = {
                    background: null,
                    fog: null,
                    environment: null,
                    overrideMaterial: null,
                    isScene: !0
                };
                let ae = !1;
                function oe() {
                    return null === M ? O : 1
                }
                let le, ce, ue, he, pe, ge, me, ve, ye, xe, _e, be, Ee, we, Ce, Ie, Se, Me, Te, Be, Re, De, Pe, Le, Ue = n;
                function Fe(e, n) {
                    return t.getContext(e, n)
                }
                try {
                    const e = {
                        alpha: !0,
                        depth: r,
                        stencil: s,
                        antialias: u,
                        premultipliedAlpha: h,
                        preserveDrawingBuffer: d,
                        powerPreference: p,
                        failIfMajorPerformanceCaveat: f
                    };
                    if ("setAttribute"in t && t.setAttribute("data-engine", `three.js r${i}`),
                    t.addEventListener("webglcontextlost", Qe, !1),
                    t.addEventListener("webglcontextrestored", ke, !1),
                    t.addEventListener("webglcontextcreationerror", Ge, !1),
                    null === Ue) {
                        const t = "webgl2";
                        if (Ue = Fe(t, e),
                        null === Ue)
                            throw Fe(t) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.")
                    }
                } catch (e) {
                    throw console.error("THREE.WebGLRenderer: " + e.message),
                    e
                }
                function Ne() {
                    le = new fs(Ue),
                    le.init(),
                    De = new go(Ue,le),
                    ce = new jr(Ue,le,e,De),
                    ue = new po(Ue,le),
                    ce.reverseDepthBuffer && A && ue.buffers.depth.setReversed(!0),
                    he = new ms(Ue),
                    pe = new Ja,
                    ge = new Ao(Ue,le,ue,pe,ce,De,he),
                    me = new Yr(w),
                    ve = new ps(w),
                    ye = new Ur(Ue),
                    Pe = new Vr(Ue,ye),
                    xe = new As(Ue,ye,he,Pe),
                    _e = new ys(Ue,xe,ye,he),
                    Te = new vs(Ue,ce,ge),
                    Ie = new qr(pe),
                    be = new Ka(w,me,ve,le,ce,Pe,Ie),
                    Ee = new Co(w,pe),
                    we = new to,
                    Ce = new oo(le),
                    Me = new zr(w,me,ve,ue,_e,g,h),
                    Se = new uo(w,_e,ce),
                    Le = new Io(Ue,he,ce,ue),
                    Be = new Wr(Ue,le,he),
                    Re = new gs(Ue,le,he),
                    he.programs = be.programs,
                    w.capabilities = ce,
                    w.extensions = le,
                    w.properties = pe,
                    w.renderLists = we,
                    w.shadowMap = Se,
                    w.state = ue,
                    w.info = he
                }
                Ne();
                const Oe = new bo(w,Ue);
                function Qe(e) {
                    e.preventDefault(),
                    console.log("THREE.WebGLRenderer: Context Lost."),
                    C = !0
                }
                function ke() {
                    console.log("THREE.WebGLRenderer: Context Restored."),
                    C = !1;
                    const e = he.autoReset
                      , t = Se.enabled
                      , n = Se.autoUpdate
                      , i = Se.needsUpdate
                      , r = Se.type;
                    Ne(),
                    he.autoReset = e,
                    Se.enabled = t,
                    Se.autoUpdate = n,
                    Se.needsUpdate = i,
                    Se.type = r
                }
                function Ge(e) {
                    console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", e.statusMessage)
                }
                function He(e) {
                    const t = e.target;
                    t.removeEventListener("dispose", He),
                    function(e) {
                        (function(e) {
                            const t = pe.get(e).programs;
                            void 0 !== t && (t.forEach((function(e) {
                                be.releaseProgram(e)
                            }
                            )),
                            e.isShaderMaterial && be.releaseShaderCache(e))
                        }
                        )(e),
                        pe.remove(e)
                    }(t)
                }
                function ze(e, t, n) {
                    !0 === e.transparent && e.side === c && !1 === e.forceSinglePass ? (e.side = l,
                    e.needsUpdate = !0,
                    $e(e, t, n),
                    e.side = o,
                    e.needsUpdate = !0,
                    $e(e, t, n),
                    e.side = c) : $e(e, t, n)
                }
                this.xr = Oe,
                this.getContext = function() {
                    return Ue
                }
                ,
                this.getContextAttributes = function() {
                    return Ue.getContextAttributes()
                }
                ,
                this.forceContextLoss = function() {
                    const e = le.get("WEBGL_lose_context");
                    e && e.loseContext()
                }
                ,
                this.forceContextRestore = function() {
                    const e = le.get("WEBGL_lose_context");
                    e && e.restoreContext()
                }
                ,
                this.getPixelRatio = function() {
                    return O
                }
                ,
                this.setPixelRatio = function(e) {
                    void 0 !== e && (O = e,
                    this.setSize(F, N, !1))
                }
                ,
                this.getSize = function(e) {
                    return e.set(F, N)
                }
                ,
                this.setSize = function(e, n, i=!0) {
                    Oe.isPresenting ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (F = e,
                    N = n,
                    t.width = Math.floor(e * O),
                    t.height = Math.floor(n * O),
                    !0 === i && (t.style.width = e + "px",
                    t.style.height = n + "px"),
                    this.setViewport(0, 0, e, n))
                }
                ,
                this.getDrawingBufferSize = function(e) {
                    return e.set(F * O, N * O).floor()
                }
                ,
                this.setDrawingBufferSize = function(e, n, i) {
                    F = e,
                    N = n,
                    O = i,
                    t.width = Math.floor(e * i),
                    t.height = Math.floor(n * i),
                    this.setViewport(0, 0, e, n)
                }
                ,
                this.getCurrentViewport = function(e) {
                    return e.copy(R)
                }
                ,
                this.getViewport = function(e) {
                    return e.copy(G)
                }
                ,
                this.setViewport = function(e, t, n, i) {
                    e.isVector4 ? G.set(e.x, e.y, e.z, e.w) : G.set(e, t, n, i),
                    ue.viewport(R.copy(G).multiplyScalar(O).round())
                }
                ,
                this.getScissor = function(e) {
                    return e.copy(H)
                }
                ,
                this.setScissor = function(e, t, n, i) {
                    e.isVector4 ? H.set(e.x, e.y, e.z, e.w) : H.set(e, t, n, i),
                    ue.scissor(D.copy(H).multiplyScalar(O).round())
                }
                ,
                this.getScissorTest = function() {
                    return z
                }
                ,
                this.setScissorTest = function(e) {
                    ue.setScissorTest(z = e)
                }
                ,
                this.setOpaqueSort = function(e) {
                    Q = e
                }
                ,
                this.setTransparentSort = function(e) {
                    k = e
                }
                ,
                this.getClearColor = function(e) {
                    return e.copy(Me.getClearColor())
                }
                ,
                this.setClearColor = function() {
                    Me.setClearColor.apply(Me, arguments)
                }
                ,
                this.getClearAlpha = function() {
                    return Me.getClearAlpha()
                }
                ,
                this.setClearAlpha = function() {
                    Me.setClearAlpha.apply(Me, arguments)
                }
                ,
                this.clear = function(e=!0, t=!0, n=!0) {
                    let i = 0;
                    if (e) {
                        let e = !1;
                        if (null !== M) {
                            const t = M.texture.format;
                            e = t === Ae || t === fe || t === de
                        }
                        if (e) {
                            const e = M.texture.type
                              , t = e === j || e === J || e === X || e === ne || e === ee || e === te
                              , n = Me.getClearColor()
                              , i = Me.getClearAlpha()
                              , r = n.r
                              , s = n.g
                              , a = n.b;
                            t ? (m[0] = r,
                            m[1] = s,
                            m[2] = a,
                            m[3] = i,
                            Ue.clearBufferuiv(Ue.COLOR, 0, m)) : (v[0] = r,
                            v[1] = s,
                            v[2] = a,
                            v[3] = i,
                            Ue.clearBufferiv(Ue.COLOR, 0, v))
                        } else
                            i |= Ue.COLOR_BUFFER_BIT
                    }
                    t && (i |= Ue.DEPTH_BUFFER_BIT),
                    n && (i |= Ue.STENCIL_BUFFER_BIT,
                    this.state.buffers.stencil.setMask(4294967295)),
                    Ue.clear(i)
                }
                ,
                this.clearColor = function() {
                    this.clear(!0, !1, !1)
                }
                ,
                this.clearDepth = function() {
                    this.clear(!1, !0, !1)
                }
                ,
                this.clearStencil = function() {
                    this.clear(!1, !1, !0)
                }
                ,
                this.dispose = function() {
                    t.removeEventListener("webglcontextlost", Qe, !1),
                    t.removeEventListener("webglcontextrestored", ke, !1),
                    t.removeEventListener("webglcontextcreationerror", Ge, !1),
                    we.dispose(),
                    Ce.dispose(),
                    pe.dispose(),
                    me.dispose(),
                    ve.dispose(),
                    _e.dispose(),
                    Pe.dispose(),
                    Le.dispose(),
                    be.dispose(),
                    Oe.dispose(),
                    Oe.removeEventListener("sessionstart", We),
                    Oe.removeEventListener("sessionend", je),
                    qe.stop()
                }
                ,
                this.renderBufferDirect = function(e, t, n, i, r, s) {
                    null === t && (t = se);
                    const a = r.isMesh && r.matrixWorld.determinant() < 0
                      , o = function(e, t, n, i, r) {
                        !0 !== t.isScene && (t = se);
                        ge.resetTextureUnits();
                        const s = t.fog
                          , a = i.isMeshStandardMaterial ? t.environment : null
                          , o = null === M ? w.outputColorSpace : !0 === M.isXRRenderTarget ? M.texture.colorSpace : ut
                          , l = (i.isMeshStandardMaterial ? ve : me).get(i.envMap || a)
                          , c = !0 === i.vertexColors && !!n.attributes.color && 4 === n.attributes.color.itemSize
                          , u = !!n.attributes.tangent && (!!i.normalMap || i.anisotropy > 0)
                          , h = !!n.morphAttributes.position
                          , d = !!n.morphAttributes.normal
                          , p = !!n.morphAttributes.color;
                        let f = E;
                        i.toneMapped && (null !== M && !0 !== M.isXRRenderTarget || (f = w.toneMapping));
                        const A = n.morphAttributes.position || n.morphAttributes.normal || n.morphAttributes.color
                          , g = void 0 !== A ? A.length : 0
                          , m = pe.get(i)
                          , v = x.state.lights;
                        if (!0 === q && (!0 === Y || e !== B)) {
                            const t = e === B && i.id === T;
                            Ie.setState(i, e, t)
                        }
                        let y = !1;
                        i.version === m.__version ? m.needsLights && m.lightsStateVersion !== v.state.version || m.outputColorSpace !== o || r.isBatchedMesh && !1 === m.batching ? y = !0 : r.isBatchedMesh || !0 !== m.batching ? r.isBatchedMesh && !0 === m.batchingColor && null === r.colorTexture || r.isBatchedMesh && !1 === m.batchingColor && null !== r.colorTexture || r.isInstancedMesh && !1 === m.instancing ? y = !0 : r.isInstancedMesh || !0 !== m.instancing ? r.isSkinnedMesh && !1 === m.skinning ? y = !0 : r.isSkinnedMesh || !0 !== m.skinning ? r.isInstancedMesh && !0 === m.instancingColor && null === r.instanceColor || r.isInstancedMesh && !1 === m.instancingColor && null !== r.instanceColor || r.isInstancedMesh && !0 === m.instancingMorph && null === r.morphTexture || r.isInstancedMesh && !1 === m.instancingMorph && null !== r.morphTexture || m.envMap !== l || !0 === i.fog && m.fog !== s ? y = !0 : void 0 === m.numClippingPlanes || m.numClippingPlanes === Ie.numPlanes && m.numIntersection === Ie.numIntersection ? (m.vertexAlphas !== c || m.vertexTangents !== u || m.morphTargets !== h || m.morphNormals !== d || m.morphColors !== p || m.toneMapping !== f || m.morphTargetsCount !== g) && (y = !0) : y = !0 : y = !0 : y = !0 : y = !0 : (y = !0,
                        m.__version = i.version);
                        let _ = m.currentProgram;
                        !0 === y && (_ = $e(i, t, r));
                        let b = !1
                          , C = !1
                          , I = !1;
                        const S = _.getUniforms()
                          , R = m.uniforms;
                        ue.useProgram(_.program) && (b = !0,
                        C = !0,
                        I = !0);
                        i.id !== T && (T = i.id,
                        C = !0);
                        if (b || B !== e) {
                            ue.buffers.depth.getReversed() ? (K.copy(e.projectionMatrix),
                            function(e) {
                                const t = e.elements;
                                t[2] = .5 * t[2] + .5 * t[3],
                                t[6] = .5 * t[6] + .5 * t[7],
                                t[10] = .5 * t[10] + .5 * t[11],
                                t[14] = .5 * t[14] + .5 * t[15]
                            }(K),
                            function(e) {
                                const t = e.elements;
                                -1 === t[11] ? (t[10] = -t[10] - 1,
                                t[14] = -t[14]) : (t[10] = -t[10],
                                t[14] = 1 - t[14])
                            }(K),
                            S.setValue(Ue, "projectionMatrix", K)) : S.setValue(Ue, "projectionMatrix", e.projectionMatrix),
                            S.setValue(Ue, "viewMatrix", e.matrixWorldInverse);
                            const t = S.map.cameraPosition;
                            void 0 !== t && t.setValue(Ue, ie.setFromMatrixPosition(e.matrixWorld)),
                            ce.logarithmicDepthBuffer && S.setValue(Ue, "logDepthBufFC", 2 / (Math.log(e.far + 1) / Math.LN2)),
                            (i.isMeshPhongMaterial || i.isMeshToonMaterial || i.isMeshLambertMaterial || i.isMeshBasicMaterial || i.isMeshStandardMaterial || i.isShaderMaterial) && S.setValue(Ue, "isOrthographic", !0 === e.isOrthographicCamera),
                            B !== e && (B = e,
                            C = !0,
                            I = !0)
                        }
                        if (r.isSkinnedMesh) {
                            S.setOptional(Ue, r, "bindMatrix"),
                            S.setOptional(Ue, r, "bindMatrixInverse");
                            const e = r.skeleton;
                            e && (null === e.boneTexture && e.computeBoneTexture(),
                            S.setValue(Ue, "boneTexture", e.boneTexture, ge))
                        }
                        r.isBatchedMesh && (S.setOptional(Ue, r, "batchingTexture"),
                        S.setValue(Ue, "batchingTexture", r._matricesTexture, ge),
                        S.setOptional(Ue, r, "batchingIdTexture"),
                        S.setValue(Ue, "batchingIdTexture", r._indirectTexture, ge),
                        S.setOptional(Ue, r, "batchingColorTexture"),
                        null !== r._colorsTexture && S.setValue(Ue, "batchingColorTexture", r._colorsTexture, ge));
                        const D = n.morphAttributes;
                        void 0 === D.position && void 0 === D.normal && void 0 === D.color || Te.update(r, n, _);
                        (C || m.receiveShadow !== r.receiveShadow) && (m.receiveShadow = r.receiveShadow,
                        S.setValue(Ue, "receiveShadow", r.receiveShadow));
                        i.isMeshGouraudMaterial && null !== i.envMap && (R.envMap.value = l,
                        R.flipEnvMap.value = l.isCubeTexture && !1 === l.isRenderTargetTexture ? -1 : 1);
                        i.isMeshStandardMaterial && null === i.envMap && null !== t.environment && (R.envMapIntensity.value = t.environmentIntensity);
                        C && (S.setValue(Ue, "toneMappingExposure", w.toneMappingExposure),
                        m.needsLights && (L = I,
                        (P = R).ambientLightColor.needsUpdate = L,
                        P.lightProbe.needsUpdate = L,
                        P.directionalLights.needsUpdate = L,
                        P.directionalLightShadows.needsUpdate = L,
                        P.pointLights.needsUpdate = L,
                        P.pointLightShadows.needsUpdate = L,
                        P.spotLights.needsUpdate = L,
                        P.spotLightShadows.needsUpdate = L,
                        P.rectAreaLights.needsUpdate = L,
                        P.hemisphereLights.needsUpdate = L),
                        s && !0 === i.fog && Ee.refreshFogUniforms(R, s),
                        Ee.refreshMaterialUniforms(R, i, O, N, x.state.transmissionRenderTarget[e.id]),
                        Ca.upload(Ue, et(m), R, ge));
                        var P, L;
                        i.isShaderMaterial && !0 === i.uniformsNeedUpdate && (Ca.upload(Ue, et(m), R, ge),
                        i.uniformsNeedUpdate = !1);
                        i.isSpriteMaterial && S.setValue(Ue, "center", r.center);
                        if (S.setValue(Ue, "modelViewMatrix", r.modelViewMatrix),
                        S.setValue(Ue, "normalMatrix", r.normalMatrix),
                        S.setValue(Ue, "modelMatrix", r.matrixWorld),
                        i.isShaderMaterial || i.isRawShaderMaterial) {
                            const e = i.uniformsGroups;
                            for (let t = 0, n = e.length; t < n; t++) {
                                const n = e[t];
                                Le.update(n, _),
                                Le.bind(n, _)
                            }
                        }
                        return _
                    }(e, t, n, i, r);
                    ue.setMaterial(i, a);
                    let l = n.index
                      , c = 1;
                    if (!0 === i.wireframe) {
                        if (l = xe.getWireframeAttribute(n),
                        void 0 === l)
                            return;
                        c = 2
                    }
                    const u = n.drawRange
                      , h = n.attributes.position;
                    let d = u.start * c
                      , p = (u.start + u.count) * c;
                    null !== s && (d = Math.max(d, s.start * c),
                    p = Math.min(p, (s.start + s.count) * c)),
                    null !== l ? (d = Math.max(d, 0),
                    p = Math.min(p, l.count)) : null != h && (d = Math.max(d, 0),
                    p = Math.min(p, h.count));
                    const f = p - d;
                    if (f < 0 || f === 1 / 0)
                        return;
                    let A;
                    Pe.setup(r, i, o, n, l);
                    let g = Be;
                    if (null !== l && (A = ye.get(l),
                    g = Re,
                    g.setIndex(A)),
                    r.isMesh)
                        !0 === i.wireframe ? (ue.setLineWidth(i.wireframeLinewidth * oe()),
                        g.setMode(Ue.LINES)) : g.setMode(Ue.TRIANGLES);
                    else if (r.isLine) {
                        let e = i.linewidth;
                        void 0 === e && (e = 1),
                        ue.setLineWidth(e * oe()),
                        r.isLineSegments ? g.setMode(Ue.LINES) : r.isLineLoop ? g.setMode(Ue.LINE_LOOP) : g.setMode(Ue.LINE_STRIP)
                    } else
                        r.isPoints ? g.setMode(Ue.POINTS) : r.isSprite && g.setMode(Ue.TRIANGLES);
                    if (r.isBatchedMesh)
                        if (null !== r._multiDrawInstances)
                            g.renderMultiDrawInstances(r._multiDrawStarts, r._multiDrawCounts, r._multiDrawCount, r._multiDrawInstances);
                        else if (le.get("WEBGL_multi_draw"))
                            g.renderMultiDraw(r._multiDrawStarts, r._multiDrawCounts, r._multiDrawCount);
                        else {
                            const e = r._multiDrawStarts
                              , t = r._multiDrawCounts
                              , n = r._multiDrawCount
                              , s = l ? ye.get(l).bytesPerElement : 1
                              , a = pe.get(i).currentProgram.getUniforms();
                            for (let i = 0; i < n; i++)
                                a.setValue(Ue, "_gl_DrawID", i),
                                g.render(e[i] / s, t[i])
                        }
                    else if (r.isInstancedMesh)
                        g.renderInstances(d, f, r.count);
                    else if (n.isInstancedBufferGeometry) {
                        const e = void 0 !== n._maxInstanceCount ? n._maxInstanceCount : 1 / 0
                          , t = Math.min(n.instanceCount, e);
                        g.renderInstances(d, f, t)
                    } else
                        g.render(d, f)
                }
                ,
                this.compile = function(e, t, n=null) {
                    null === n && (n = e),
                    x = Ce.get(n),
                    x.init(t),
                    b.push(x),
                    n.traverseVisible((function(e) {
                        e.isLight && e.layers.test(t.layers) && (x.pushLight(e),
                        e.castShadow && x.pushShadow(e))
                    }
                    )),
                    e !== n && e.traverseVisible((function(e) {
                        e.isLight && e.layers.test(t.layers) && (x.pushLight(e),
                        e.castShadow && x.pushShadow(e))
                    }
                    )),
                    x.setupLights();
                    const i = new Set;
                    return e.traverse((function(e) {
                        if (!(e.isMesh || e.isPoints || e.isLine || e.isSprite))
                            return;
                        const t = e.material;
                        if (t)
                            if (Array.isArray(t))
                                for (let r = 0; r < t.length; r++) {
                                    const s = t[r];
                                    ze(s, n, e),
                                    i.add(s)
                                }
                            else
                                ze(t, n, e),
                                i.add(t)
                    }
                    )),
                    b.pop(),
                    x = null,
                    i
                }
                ,
                this.compileAsync = function(e, t, n=null) {
                    const i = this.compile(e, t, n);
                    return new Promise((t => {
                        function n() {
                            i.forEach((function(e) {
                                pe.get(e).currentProgram.isReady() && i.delete(e)
                            }
                            )),
                            0 !== i.size ? setTimeout(n, 10) : t(e)
                        }
                        null !== le.get("KHR_parallel_shader_compile") ? n() : setTimeout(n, 10)
                    }
                    ))
                }
                ;
                let Ve = null;
                function We() {
                    qe.stop()
                }
                function je() {
                    qe.start()
                }
                const qe = new Lr;
                function Ye(e, t, n, i) {
                    if (!1 === e.visible)
                        return;
                    if (e.layers.test(t.layers))
                        if (e.isGroup)
                            n = e.renderOrder;
                        else if (e.isLOD)
                            !0 === e.autoUpdate && e.update(t);
                        else if (e.isLight)
                            x.pushLight(e),
                            e.castShadow && x.pushShadow(e);
                        else if (e.isSprite) {
                            if (!e.frustumCulled || V.intersectsSprite(e)) {
                                i && re.setFromMatrixPosition(e.matrixWorld).applyMatrix4(Z);
                                const t = _e.update(e)
                                  , r = e.material;
                                r.visible && y.push(e, t, r, n, re.z, null)
                            }
                        } else if ((e.isMesh || e.isLine || e.isPoints) && (!e.frustumCulled || V.intersectsObject(e))) {
                            const t = _e.update(e)
                              , r = e.material;
                            if (i && (void 0 !== e.boundingSphere ? (null === e.boundingSphere && e.computeBoundingSphere(),
                            re.copy(e.boundingSphere.center)) : (null === t.boundingSphere && t.computeBoundingSphere(),
                            re.copy(t.boundingSphere.center)),
                            re.applyMatrix4(e.matrixWorld).applyMatrix4(Z)),
                            Array.isArray(r)) {
                                const i = t.groups;
                                for (let s = 0, a = i.length; s < a; s++) {
                                    const a = i[s]
                                      , o = r[a.materialIndex];
                                    o && o.visible && y.push(e, t, o, n, re.z, a)
                                }
                            } else
                                r.visible && y.push(e, t, r, n, re.z, null)
                        }
                    const r = e.children;
                    for (let e = 0, s = r.length; e < s; e++)
                        Ye(r[e], t, n, i)
                }
                function Xe(e, t, n, i) {
                    const r = e.opaque
                      , s = e.transmissive
                      , a = e.transparent;
                    x.setupLightsView(n),
                    !0 === q && Ie.setGlobalState(w.clippingPlanes, n),
                    i && ue.viewport(R.copy(i)),
                    r.length > 0 && Je(r, t, n),
                    s.length > 0 && Je(s, t, n),
                    a.length > 0 && Je(a, t, n),
                    ue.buffers.depth.setTest(!0),
                    ue.buffers.depth.setMask(!0),
                    ue.buffers.color.setMask(!0),
                    ue.setPolygonOffset(!1)
                }
                function Ke(e, t, n, i) {
                    if (null !== (!0 === n.isScene ? n.overrideMaterial : null))
                        return;
                    void 0 === x.state.transmissionRenderTarget[i.id] && (x.state.transmissionRenderTarget[i.id] = new nn(1,1,{
                        generateMipmaps: !0,
                        type: le.has("EXT_color_buffer_half_float") || le.has("EXT_color_buffer_float") ? $ : j,
                        minFilter: W,
                        samples: 4,
                        stencilBuffer: s,
                        resolveDepthBuffer: !1,
                        resolveStencilBuffer: !1,
                        colorSpace: Qt.workingColorSpace
                    }));
                    const r = x.state.transmissionRenderTarget[i.id]
                      , a = i.viewport || R;
                    r.setSize(a.z, a.w);
                    const o = w.getRenderTarget();
                    w.setRenderTarget(r),
                    w.getClearColor(L),
                    U = w.getClearAlpha(),
                    U < 1 && w.setClearColor(16777215, .5),
                    w.clear(),
                    ae && Me.render(n);
                    const u = w.toneMapping;
                    w.toneMapping = E;
                    const h = i.viewport;
                    if (void 0 !== i.viewport && (i.viewport = void 0),
                    x.setupLightsView(i),
                    !0 === q && Ie.setGlobalState(w.clippingPlanes, i),
                    Je(e, n, i),
                    ge.updateMultisampleRenderTarget(r),
                    ge.updateRenderTargetMipmap(r),
                    !1 === le.has("WEBGL_multisampled_render_to_texture")) {
                        let e = !1;
                        for (let r = 0, s = t.length; r < s; r++) {
                            const s = t[r]
                              , a = s.object
                              , o = s.geometry
                              , u = s.material
                              , h = s.group;
                            if (u.side === c && a.layers.test(i.layers)) {
                                const t = u.side;
                                u.side = l,
                                u.needsUpdate = !0,
                                Ze(a, n, i, o, u, h),
                                u.side = t,
                                u.needsUpdate = !0,
                                e = !0
                            }
                        }
                        !0 === e && (ge.updateMultisampleRenderTarget(r),
                        ge.updateRenderTargetMipmap(r))
                    }
                    w.setRenderTarget(o),
                    w.setClearColor(L, U),
                    void 0 !== h && (i.viewport = h),
                    w.toneMapping = u
                }
                function Je(e, t, n) {
                    const i = !0 === t.isScene ? t.overrideMaterial : null;
                    for (let r = 0, s = e.length; r < s; r++) {
                        const s = e[r]
                          , a = s.object
                          , o = s.geometry
                          , l = null === i ? s.material : i
                          , c = s.group;
                        a.layers.test(n.layers) && Ze(a, t, n, o, l, c)
                    }
                }
                function Ze(e, t, n, i, r, s) {
                    e.onBeforeRender(w, t, n, i, r, s),
                    e.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, e.matrixWorld),
                    e.normalMatrix.getNormalMatrix(e.modelViewMatrix),
                    r.onBeforeRender(w, t, n, i, e, s),
                    !0 === r.transparent && r.side === c && !1 === r.forceSinglePass ? (r.side = l,
                    r.needsUpdate = !0,
                    w.renderBufferDirect(n, t, i, r, e, s),
                    r.side = o,
                    r.needsUpdate = !0,
                    w.renderBufferDirect(n, t, i, r, e, s),
                    r.side = c) : w.renderBufferDirect(n, t, i, r, e, s),
                    e.onAfterRender(w, t, n, i, r, s)
                }
                function $e(e, t, n) {
                    !0 !== t.isScene && (t = se);
                    const i = pe.get(e)
                      , r = x.state.lights
                      , s = x.state.shadowsArray
                      , a = r.state.version
                      , o = be.getParameters(e, r.state, s, t, n)
                      , l = be.getProgramCacheKey(o);
                    let c = i.programs;
                    i.environment = e.isMeshStandardMaterial ? t.environment : null,
                    i.fog = t.fog,
                    i.envMap = (e.isMeshStandardMaterial ? ve : me).get(e.envMap || i.environment),
                    i.envMapRotation = null !== i.environment && null === e.envMap ? t.environmentRotation : e.envMapRotation,
                    void 0 === c && (e.addEventListener("dispose", He),
                    c = new Map,
                    i.programs = c);
                    let u = c.get(l);
                    if (void 0 !== u) {
                        if (i.currentProgram === u && i.lightsStateVersion === a)
                            return tt(e, o),
                            u
                    } else
                        o.uniforms = be.getUniforms(e),
                        e.onBeforeCompile(o, w),
                        u = be.acquireProgram(o, l),
                        c.set(l, u),
                        i.uniforms = o.uniforms;
                    const h = i.uniforms;
                    return (e.isShaderMaterial || e.isRawShaderMaterial) && !0 !== e.clipping || (h.clippingPlanes = Ie.uniform),
                    tt(e, o),
                    i.needsLights = function(e) {
                        return e.isMeshLambertMaterial || e.isMeshToonMaterial || e.isMeshPhongMaterial || e.isMeshStandardMaterial || e.isShadowMaterial || e.isShaderMaterial && !0 === e.lights
                    }(e),
                    i.lightsStateVersion = a,
                    i.needsLights && (h.ambientLightColor.value = r.state.ambient,
                    h.lightProbe.value = r.state.probe,
                    h.directionalLights.value = r.state.directional,
                    h.directionalLightShadows.value = r.state.directionalShadow,
                    h.spotLights.value = r.state.spot,
                    h.spotLightShadows.value = r.state.spotShadow,
                    h.rectAreaLights.value = r.state.rectArea,
                    h.ltc_1.value = r.state.rectAreaLTC1,
                    h.ltc_2.value = r.state.rectAreaLTC2,
                    h.pointLights.value = r.state.point,
                    h.pointLightShadows.value = r.state.pointShadow,
                    h.hemisphereLights.value = r.state.hemi,
                    h.directionalShadowMap.value = r.state.directionalShadowMap,
                    h.directionalShadowMatrix.value = r.state.directionalShadowMatrix,
                    h.spotShadowMap.value = r.state.spotShadowMap,
                    h.spotLightMatrix.value = r.state.spotLightMatrix,
                    h.spotLightMap.value = r.state.spotLightMap,
                    h.pointShadowMap.value = r.state.pointShadowMap,
                    h.pointShadowMatrix.value = r.state.pointShadowMatrix),
                    i.currentProgram = u,
                    i.uniformsList = null,
                    u
                }
                function et(e) {
                    if (null === e.uniformsList) {
                        const t = e.currentProgram.getUniforms();
                        e.uniformsList = Ca.seqWithValue(t.seq, e.uniforms)
                    }
                    return e.uniformsList
                }
                function tt(e, t) {
                    const n = pe.get(e);
                    n.outputColorSpace = t.outputColorSpace,
                    n.batching = t.batching,
                    n.batchingColor = t.batchingColor,
                    n.instancing = t.instancing,
                    n.instancingColor = t.instancingColor,
                    n.instancingMorph = t.instancingMorph,
                    n.skinning = t.skinning,
                    n.morphTargets = t.morphTargets,
                    n.morphNormals = t.morphNormals,
                    n.morphColors = t.morphColors,
                    n.morphTargetsCount = t.morphTargetsCount,
                    n.numClippingPlanes = t.numClippingPlanes,
                    n.numIntersection = t.numClipIntersection,
                    n.vertexAlphas = t.vertexAlphas,
                    n.vertexTangents = t.vertexTangents,
                    n.toneMapping = t.toneMapping
                }
                qe.setAnimationLoop((function(e) {
                    Ve && Ve(e)
                }
                )),
                "undefined" != typeof self && qe.setContext(self),
                this.setAnimationLoop = function(e) {
                    Ve = e,
                    Oe.setAnimationLoop(e),
                    null === e ? qe.stop() : qe.start()
                }
                ,
                Oe.addEventListener("sessionstart", We),
                Oe.addEventListener("sessionend", je),
                this.render = function(e, t) {
                    if (void 0 !== t && !0 !== t.isCamera)
                        return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
                    if (!0 === C)
                        return;
                    if (!0 === e.matrixWorldAutoUpdate && e.updateMatrixWorld(),
                    null === t.parent && !0 === t.matrixWorldAutoUpdate && t.updateMatrixWorld(),
                    !0 === Oe.enabled && !0 === Oe.isPresenting && (!0 === Oe.cameraAutoUpdate && Oe.updateCamera(t),
                    t = Oe.getCamera()),
                    !0 === e.isScene && e.onBeforeRender(w, e, t, M),
                    x = Ce.get(e, b.length),
                    x.init(t),
                    b.push(x),
                    Z.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse),
                    V.setFromProjectionMatrix(Z),
                    Y = this.localClippingEnabled,
                    q = Ie.init(this.clippingPlanes, Y),
                    y = we.get(e, _.length),
                    y.init(),
                    _.push(y),
                    !0 === Oe.enabled && !0 === Oe.isPresenting) {
                        const e = w.xr.getDepthSensingMesh();
                        null !== e && Ye(e, t, -1 / 0, w.sortObjects)
                    }
                    Ye(e, t, 0, w.sortObjects),
                    y.finish(),
                    !0 === w.sortObjects && y.sort(Q, k),
                    ae = !1 === Oe.enabled || !1 === Oe.isPresenting || !1 === Oe.hasDepthSensing(),
                    ae && Me.addToRenderList(y, e),
                    this.info.render.frame++,
                    !0 === q && Ie.beginShadows();
                    const n = x.state.shadowsArray;
                    Se.render(n, e, t),
                    !0 === q && Ie.endShadows(),
                    !0 === this.info.autoReset && this.info.reset();
                    const i = y.opaque
                      , r = y.transmissive;
                    if (x.setupLights(),
                    t.isArrayCamera) {
                        const n = t.cameras;
                        if (r.length > 0)
                            for (let t = 0, s = n.length; t < s; t++) {
                                Ke(i, r, e, n[t])
                            }
                        ae && Me.render(e);
                        for (let t = 0, i = n.length; t < i; t++) {
                            const i = n[t];
                            Xe(y, e, i, i.viewport)
                        }
                    } else
                        r.length > 0 && Ke(i, r, e, t),
                        ae && Me.render(e),
                        Xe(y, e, t);
                    null !== M && (ge.updateMultisampleRenderTarget(M),
                    ge.updateRenderTargetMipmap(M)),
                    !0 === e.isScene && e.onAfterRender(w, e, t),
                    Pe.resetDefaultState(),
                    T = -1,
                    B = null,
                    b.pop(),
                    b.length > 0 ? (x = b[b.length - 1],
                    !0 === q && Ie.setGlobalState(w.clippingPlanes, x.state.camera)) : x = null,
                    _.pop(),
                    y = _.length > 0 ? _[_.length - 1] : null
                }
                ,
                this.getActiveCubeFace = function() {
                    return I
                }
                ,
                this.getActiveMipmapLevel = function() {
                    return S
                }
                ,
                this.getRenderTarget = function() {
                    return M
                }
                ,
                this.setRenderTargetTextures = function(e, t, n) {
                    pe.get(e.texture).__webglTexture = t,
                    pe.get(e.depthTexture).__webglTexture = n;
                    const i = pe.get(e);
                    i.__hasExternalTextures = !0,
                    i.__autoAllocateDepthBuffer = void 0 === n,
                    i.__autoAllocateDepthBuffer || !0 === le.has("WEBGL_multisampled_render_to_texture") && (console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"),
                    i.__useRenderToTexture = !1)
                }
                ,
                this.setRenderTargetFramebuffer = function(e, t) {
                    const n = pe.get(e);
                    n.__webglFramebuffer = t,
                    n.__useDefaultFramebuffer = void 0 === t
                }
                ,
                this.setRenderTarget = function(e, t=0, n=0) {
                    M = e,
                    I = t,
                    S = n;
                    let i = !0
                      , r = null
                      , s = !1
                      , a = !1;
                    if (e) {
                        const o = pe.get(e);
                        if (void 0 !== o.__useDefaultFramebuffer)
                            ue.bindFramebuffer(Ue.FRAMEBUFFER, null),
                            i = !1;
                        else if (void 0 === o.__webglFramebuffer)
                            ge.setupRenderTarget(e);
                        else if (o.__hasExternalTextures)
                            ge.rebindTextures(e, pe.get(e.texture).__webglTexture, pe.get(e.depthTexture).__webglTexture);
                        else if (e.depthBuffer) {
                            const t = e.depthTexture;
                            if (o.__boundDepthTexture !== t) {
                                if (null !== t && pe.has(t) && (e.width !== t.image.width || e.height !== t.image.height))
                                    throw new Error("WebGLRenderTarget: Attached DepthTexture is initialized to the incorrect size.");
                                ge.setupDepthRenderbuffer(e)
                            }
                        }
                        const l = e.texture;
                        (l.isData3DTexture || l.isDataArrayTexture || l.isCompressedArrayTexture) && (a = !0);
                        const c = pe.get(e).__webglFramebuffer;
                        e.isWebGLCubeRenderTarget ? (r = Array.isArray(c[t]) ? c[t][n] : c[t],
                        s = !0) : r = e.samples > 0 && !1 === ge.useMultisampledRTT(e) ? pe.get(e).__webglMultisampledFramebuffer : Array.isArray(c) ? c[n] : c,
                        R.copy(e.viewport),
                        D.copy(e.scissor),
                        P = e.scissorTest
                    } else
                        R.copy(G).multiplyScalar(O).floor(),
                        D.copy(H).multiplyScalar(O).floor(),
                        P = z;
                    if (ue.bindFramebuffer(Ue.FRAMEBUFFER, r) && i && ue.drawBuffers(e, r),
                    ue.viewport(R),
                    ue.scissor(D),
                    ue.setScissorTest(P),
                    s) {
                        const i = pe.get(e.texture);
                        Ue.framebufferTexture2D(Ue.FRAMEBUFFER, Ue.COLOR_ATTACHMENT0, Ue.TEXTURE_CUBE_MAP_POSITIVE_X + t, i.__webglTexture, n)
                    } else if (a) {
                        const i = pe.get(e.texture)
                          , r = t || 0;
                        Ue.framebufferTextureLayer(Ue.FRAMEBUFFER, Ue.COLOR_ATTACHMENT0, i.__webglTexture, n || 0, r)
                    }
                    T = -1
                }
                ,
                this.readRenderTargetPixels = function(e, t, n, i, r, s, a) {
                    if (!e || !e.isWebGLRenderTarget)
                        return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
                    let o = pe.get(e).__webglFramebuffer;
                    if (e.isWebGLCubeRenderTarget && void 0 !== a && (o = o[a]),
                    o) {
                        ue.bindFramebuffer(Ue.FRAMEBUFFER, o);
                        try {
                            const a = e.texture
                              , o = a.format
                              , l = a.type;
                            if (!ce.textureFormatReadable(o))
                                return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                            if (!ce.textureTypeReadable(l))
                                return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                            t >= 0 && t <= e.width - i && n >= 0 && n <= e.height - r && Ue.readPixels(t, n, i, r, De.convert(o), De.convert(l), s)
                        } finally {
                            const e = null !== M ? pe.get(M).__webglFramebuffer : null;
                            ue.bindFramebuffer(Ue.FRAMEBUFFER, e)
                        }
                    }
                }
                ,
                this.readRenderTargetPixelsAsync = async function(e, t, n, i, r, s, a) {
                    if (!e || !e.isWebGLRenderTarget)
                        throw new Error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
                    let o = pe.get(e).__webglFramebuffer;
                    if (e.isWebGLCubeRenderTarget && void 0 !== a && (o = o[a]),
                    o) {
                        const a = e.texture
                          , l = a.format
                          , c = a.type;
                        if (!ce.textureFormatReadable(l))
                            throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format.");
                        if (!ce.textureTypeReadable(c))
                            throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type.");
                        if (t >= 0 && t <= e.width - i && n >= 0 && n <= e.height - r) {
                            ue.bindFramebuffer(Ue.FRAMEBUFFER, o);
                            const e = Ue.createBuffer();
                            Ue.bindBuffer(Ue.PIXEL_PACK_BUFFER, e),
                            Ue.bufferData(Ue.PIXEL_PACK_BUFFER, s.byteLength, Ue.STREAM_READ),
                            Ue.readPixels(t, n, i, r, De.convert(l), De.convert(c), 0);
                            const a = null !== M ? pe.get(M).__webglFramebuffer : null;
                            ue.bindFramebuffer(Ue.FRAMEBUFFER, a);
                            const u = Ue.fenceSync(Ue.SYNC_GPU_COMMANDS_COMPLETE, 0);
                            return Ue.flush(),
                            await function(e, t, n) {
                                return new Promise((function(i, r) {
                                    setTimeout((function s() {
                                        switch (e.clientWaitSync(t, e.SYNC_FLUSH_COMMANDS_BIT, 0)) {
                                        case e.WAIT_FAILED:
                                            r();
                                            break;
                                        case e.TIMEOUT_EXPIRED:
                                            setTimeout(s, n);
                                            break;
                                        default:
                                            i()
                                        }
                                    }
                                    ), n)
                                }
                                ))
                            }(Ue, u, 4),
                            Ue.bindBuffer(Ue.PIXEL_PACK_BUFFER, e),
                            Ue.getBufferSubData(Ue.PIXEL_PACK_BUFFER, 0, s),
                            Ue.deleteBuffer(e),
                            Ue.deleteSync(u),
                            s
                        }
                        throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: requested read bounds are out of range.")
                    }
                }
                ,
                this.copyFramebufferToTexture = function(e, t=null, n=0) {
                    !0 !== e.isTexture && (Ot("WebGLRenderer: copyFramebufferToTexture function signature has changed."),
                    t = arguments[0] || null,
                    e = arguments[1]);
                    const i = Math.pow(2, -n)
                      , r = Math.floor(e.image.width * i)
                      , s = Math.floor(e.image.height * i)
                      , a = null !== t ? t.x : 0
                      , o = null !== t ? t.y : 0;
                    ge.setTexture2D(e, 0),
                    Ue.copyTexSubImage2D(Ue.TEXTURE_2D, n, 0, 0, a, o, r, s),
                    ue.unbindTexture()
                }
                ,
                this.copyTextureToTexture = function(e, t, n=null, i=null, r=0) {
                    let s, a, o, l, c, u, h, d, p;
                    !0 !== e.isTexture && (Ot("WebGLRenderer: copyTextureToTexture function signature has changed."),
                    i = arguments[0] || null,
                    e = arguments[1],
                    t = arguments[2],
                    r = arguments[3] || 0,
                    n = null);
                    const f = e.isCompressedTexture ? e.mipmaps[r] : e.image;
                    null !== n ? (s = n.max.x - n.min.x,
                    a = n.max.y - n.min.y,
                    o = n.isBox3 ? n.max.z - n.min.z : 1,
                    l = n.min.x,
                    c = n.min.y,
                    u = n.isBox3 ? n.min.z : 0) : (s = f.width,
                    a = f.height,
                    o = f.depth || 1,
                    l = 0,
                    c = 0,
                    u = 0),
                    null !== i ? (h = i.x,
                    d = i.y,
                    p = i.z) : (h = 0,
                    d = 0,
                    p = 0);
                    const A = De.convert(t.format)
                      , g = De.convert(t.type);
                    let m;
                    t.isData3DTexture ? (ge.setTexture3D(t, 0),
                    m = Ue.TEXTURE_3D) : t.isDataArrayTexture || t.isCompressedArrayTexture ? (ge.setTexture2DArray(t, 0),
                    m = Ue.TEXTURE_2D_ARRAY) : (ge.setTexture2D(t, 0),
                    m = Ue.TEXTURE_2D),
                    Ue.pixelStorei(Ue.UNPACK_FLIP_Y_WEBGL, t.flipY),
                    Ue.pixelStorei(Ue.UNPACK_PREMULTIPLY_ALPHA_WEBGL, t.premultiplyAlpha),
                    Ue.pixelStorei(Ue.UNPACK_ALIGNMENT, t.unpackAlignment);
                    const v = Ue.getParameter(Ue.UNPACK_ROW_LENGTH)
                      , y = Ue.getParameter(Ue.UNPACK_IMAGE_HEIGHT)
                      , x = Ue.getParameter(Ue.UNPACK_SKIP_PIXELS)
                      , _ = Ue.getParameter(Ue.UNPACK_SKIP_ROWS)
                      , b = Ue.getParameter(Ue.UNPACK_SKIP_IMAGES);
                    Ue.pixelStorei(Ue.UNPACK_ROW_LENGTH, f.width),
                    Ue.pixelStorei(Ue.UNPACK_IMAGE_HEIGHT, f.height),
                    Ue.pixelStorei(Ue.UNPACK_SKIP_PIXELS, l),
                    Ue.pixelStorei(Ue.UNPACK_SKIP_ROWS, c),
                    Ue.pixelStorei(Ue.UNPACK_SKIP_IMAGES, u);
                    const E = e.isDataArrayTexture || e.isData3DTexture
                      , w = t.isDataArrayTexture || t.isData3DTexture;
                    if (e.isRenderTargetTexture || e.isDepthTexture) {
                        const n = pe.get(e)
                          , i = pe.get(t)
                          , f = pe.get(n.__renderTarget)
                          , A = pe.get(i.__renderTarget);
                        ue.bindFramebuffer(Ue.READ_FRAMEBUFFER, f.__webglFramebuffer),
                        ue.bindFramebuffer(Ue.DRAW_FRAMEBUFFER, A.__webglFramebuffer);
                        for (let n = 0; n < o; n++)
                            E && Ue.framebufferTextureLayer(Ue.READ_FRAMEBUFFER, Ue.COLOR_ATTACHMENT0, pe.get(e).__webglTexture, r, u + n),
                            e.isDepthTexture ? (w && Ue.framebufferTextureLayer(Ue.DRAW_FRAMEBUFFER, Ue.COLOR_ATTACHMENT0, pe.get(t).__webglTexture, r, p + n),
                            Ue.blitFramebuffer(l, c, s, a, h, d, s, a, Ue.DEPTH_BUFFER_BIT, Ue.NEAREST)) : w ? Ue.copyTexSubImage3D(m, r, h, d, p + n, l, c, s, a) : Ue.copyTexSubImage2D(m, r, h, d, p + n, l, c, s, a);
                        ue.bindFramebuffer(Ue.READ_FRAMEBUFFER, null),
                        ue.bindFramebuffer(Ue.DRAW_FRAMEBUFFER, null)
                    } else
                        w ? e.isDataTexture || e.isData3DTexture ? Ue.texSubImage3D(m, r, h, d, p, s, a, o, A, g, f.data) : t.isCompressedArrayTexture ? Ue.compressedTexSubImage3D(m, r, h, d, p, s, a, o, A, f.data) : Ue.texSubImage3D(m, r, h, d, p, s, a, o, A, g, f) : e.isDataTexture ? Ue.texSubImage2D(Ue.TEXTURE_2D, r, h, d, s, a, A, g, f.data) : e.isCompressedTexture ? Ue.compressedTexSubImage2D(Ue.TEXTURE_2D, r, h, d, f.width, f.height, A, f.data) : Ue.texSubImage2D(Ue.TEXTURE_2D, r, h, d, s, a, A, g, f);
                    Ue.pixelStorei(Ue.UNPACK_ROW_LENGTH, v),
                    Ue.pixelStorei(Ue.UNPACK_IMAGE_HEIGHT, y),
                    Ue.pixelStorei(Ue.UNPACK_SKIP_PIXELS, x),
                    Ue.pixelStorei(Ue.UNPACK_SKIP_ROWS, _),
                    Ue.pixelStorei(Ue.UNPACK_SKIP_IMAGES, b),
                    0 === r && t.generateMipmaps && Ue.generateMipmap(m),
                    ue.unbindTexture()
                }
                ,
                this.copyTextureToTexture3D = function(e, t, n=null, i=null, r=0) {
                    return !0 !== e.isTexture && (Ot("WebGLRenderer: copyTextureToTexture3D function signature has changed."),
                    n = arguments[0] || null,
                    i = arguments[1] || null,
                    e = arguments[2],
                    t = arguments[3],
                    r = arguments[4] || 0),
                    Ot('WebGLRenderer: copyTextureToTexture3D function has been deprecated. Use "copyTextureToTexture" instead.'),
                    this.copyTextureToTexture(e, t, n, i, r)
                }
                ,
                this.initRenderTarget = function(e) {
                    void 0 === pe.get(e).__webglFramebuffer && ge.setupRenderTarget(e)
                }
                ,
                this.initTexture = function(e) {
                    e.isCubeTexture ? ge.setTextureCube(e, 0) : e.isData3DTexture ? ge.setTexture3D(e, 0) : e.isDataArrayTexture || e.isCompressedArrayTexture ? ge.setTexture2DArray(e, 0) : ge.setTexture2D(e, 0),
                    ue.unbindTexture()
                }
                ,
                this.resetState = function() {
                    I = 0,
                    S = 0,
                    M = null,
                    ue.reset(),
                    Pe.reset()
                }
                ,
                "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{
                    detail: this
                }))
            }
            get coordinateSystem() {
                return mt
            }
            get outputColorSpace() {
                return this._outputColorSpace
            }
            set outputColorSpace(e) {
                this._outputColorSpace = e;
                const t = this.getContext();
                t.drawingBufferColorspace = Qt._getDrawingBufferColorSpace(e),
                t.unpackColorSpace = Qt._getUnpackColorSpace()
            }
        }
        class Mo {
            constructor(e, t=1, n=1e3) {
                this.isFog = !0,
                this.name = "",
                this.color = new Ti(e),
                this.near = t,
                this.far = n
            }
            clone() {
                return new Mo(this.color,this.near,this.far)
            }
            toJSON() {
                return {
                    type: "Fog",
                    name: this.name,
                    color: this.color.getHex(),
                    near: this.near,
                    far: this.far
                }
            }
        }
        class To extends ui {
            constructor() {
                super(),
                this.isScene = !0,
                this.type = "Scene",
                this.background = null,
                this.environment = null,
                this.fog = null,
                this.backgroundBlurriness = 0,
                this.backgroundIntensity = 1,
                this.backgroundRotation = new qn,
                this.environmentIntensity = 1,
                this.environmentRotation = new qn,
                this.overrideMaterial = null,
                "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{
                    detail: this
                }))
            }
            copy(e, t) {
                return super.copy(e, t),
                null !== e.background && (this.background = e.background.clone()),
                null !== e.environment && (this.environment = e.environment.clone()),
                null !== e.fog && (this.fog = e.fog.clone()),
                this.backgroundBlurriness = e.backgroundBlurriness,
                this.backgroundIntensity = e.backgroundIntensity,
                this.backgroundRotation.copy(e.backgroundRotation),
                this.environmentIntensity = e.environmentIntensity,
                this.environmentRotation.copy(e.environmentRotation),
                null !== e.overrideMaterial && (this.overrideMaterial = e.overrideMaterial.clone()),
                this.matrixAutoUpdate = e.matrixAutoUpdate,
                this
            }
            toJSON(e) {
                const t = super.toJSON(e);
                return null !== this.fog && (t.object.fog = this.fog.toJSON()),
                this.backgroundBlurriness > 0 && (t.object.backgroundBlurriness = this.backgroundBlurriness),
                1 !== this.backgroundIntensity && (t.object.backgroundIntensity = this.backgroundIntensity),
                t.object.backgroundRotation = this.backgroundRotation.toArray(),
                1 !== this.environmentIntensity && (t.object.environmentIntensity = this.environmentIntensity),
                t.object.environmentRotation = this.environmentRotation.toArray(),
                t
            }
        }
        class Bo {
            constructor(e, t) {
                this.isInterleavedBuffer = !0,
                this.array = e,
                this.stride = t,
                this.count = void 0 !== e ? e.length / t : 0,
                this.usage = At,
                this.updateRanges = [],
                this.version = 0,
                this.uuid = wt()
            }
            onUploadCallback() {}
            set needsUpdate(e) {
                !0 === e && this.version++
            }
            setUsage(e) {
                return this.usage = e,
                this
            }
            addUpdateRange(e, t) {
                this.updateRanges.push({
                    start: e,
                    count: t
                })
            }
            clearUpdateRanges() {
                this.updateRanges.length = 0
            }
            copy(e) {
                return this.array = new e.array.constructor(e.array),
                this.count = e.count,
                this.stride = e.stride,
                this.usage = e.usage,
                this
            }
            copyAt(e, t, n) {
                e *= this.stride,
                n *= t.stride;
                for (let i = 0, r = this.stride; i < r; i++)
                    this.array[e + i] = t.array[n + i];
                return this
            }
            set(e, t=0) {
                return this.array.set(e, t),
                this
            }
            clone(e) {
                void 0 === e.arrayBuffers && (e.arrayBuffers = {}),
                void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = wt()),
                void 0 === e.arrayBuffers[this.array.buffer._uuid] && (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
                const t = new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid])
                  , n = new this.constructor(t,this.stride);
                return n.setUsage(this.usage),
                n
            }
            onUpload(e) {
                return this.onUploadCallback = e,
                this
            }
            toJSON(e) {
                return void 0 === e.arrayBuffers && (e.arrayBuffers = {}),
                void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = wt()),
                void 0 === e.arrayBuffers[this.array.buffer._uuid] && (e.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))),
                {
                    uuid: this.uuid,
                    buffer: this.array.buffer._uuid,
                    type: this.array.constructor.name,
                    stride: this.stride
                }
            }
        }
        const Ro = new on;
        class Do {
            constructor(e, t, n, i=!1) {
                this.isInterleavedBufferAttribute = !0,
                this.name = "",
                this.data = e,
                this.itemSize = t,
                this.offset = n,
                this.normalized = i
            }
            get count() {
                return this.data.count
            }
            get array() {
                return this.data.array
            }
            set needsUpdate(e) {
                this.data.needsUpdate = e
            }
            applyMatrix4(e) {
                for (let t = 0, n = this.data.count; t < n; t++)
                    Ro.fromBufferAttribute(this, t),
                    Ro.applyMatrix4(e),
                    this.setXYZ(t, Ro.x, Ro.y, Ro.z);
                return this
            }
            applyNormalMatrix(e) {
                for (let t = 0, n = this.count; t < n; t++)
                    Ro.fromBufferAttribute(this, t),
                    Ro.applyNormalMatrix(e),
                    this.setXYZ(t, Ro.x, Ro.y, Ro.z);
                return this
            }
            transformDirection(e) {
                for (let t = 0, n = this.count; t < n; t++)
                    Ro.fromBufferAttribute(this, t),
                    Ro.transformDirection(e),
                    this.setXYZ(t, Ro.x, Ro.y, Ro.z);
                return this
            }
            getComponent(e, t) {
                let n = this.array[e * this.data.stride + this.offset + t];
                return this.normalized && (n = Mt(n, this.array)),
                n
            }
            setComponent(e, t, n) {
                return this.normalized && (n = Tt(n, this.array)),
                this.data.array[e * this.data.stride + this.offset + t] = n,
                this
            }
            setX(e, t) {
                return this.normalized && (t = Tt(t, this.array)),
                this.data.array[e * this.data.stride + this.offset] = t,
                this
            }
            setY(e, t) {
                return this.normalized && (t = Tt(t, this.array)),
                this.data.array[e * this.data.stride + this.offset + 1] = t,
                this
            }
            setZ(e, t) {
                return this.normalized && (t = Tt(t, this.array)),
                this.data.array[e * this.data.stride + this.offset + 2] = t,
                this
            }
            setW(e, t) {
                return this.normalized && (t = Tt(t, this.array)),
                this.data.array[e * this.data.stride + this.offset + 3] = t,
                this
            }
            getX(e) {
                let t = this.data.array[e * this.data.stride + this.offset];
                return this.normalized && (t = Mt(t, this.array)),
                t
            }
            getY(e) {
                let t = this.data.array[e * this.data.stride + this.offset + 1];
                return this.normalized && (t = Mt(t, this.array)),
                t
            }
            getZ(e) {
                let t = this.data.array[e * this.data.stride + this.offset + 2];
                return this.normalized && (t = Mt(t, this.array)),
                t
            }
            getW(e) {
                let t = this.data.array[e * this.data.stride + this.offset + 3];
                return this.normalized && (t = Mt(t, this.array)),
                t
            }
            setXY(e, t, n) {
                return e = e * this.data.stride + this.offset,
                this.normalized && (t = Tt(t, this.array),
                n = Tt(n, this.array)),
                this.data.array[e + 0] = t,
                this.data.array[e + 1] = n,
                this
            }
            setXYZ(e, t, n, i) {
                return e = e * this.data.stride + this.offset,
                this.normalized && (t = Tt(t, this.array),
                n = Tt(n, this.array),
                i = Tt(i, this.array)),
                this.data.array[e + 0] = t,
                this.data.array[e + 1] = n,
                this.data.array[e + 2] = i,
                this
            }
            setXYZW(e, t, n, i, r) {
                return e = e * this.data.stride + this.offset,
                this.normalized && (t = Tt(t, this.array),
                n = Tt(n, this.array),
                i = Tt(i, this.array),
                r = Tt(r, this.array)),
                this.data.array[e + 0] = t,
                this.data.array[e + 1] = n,
                this.data.array[e + 2] = i,
                this.data.array[e + 3] = r,
                this
            }
            clone(e) {
                if (void 0 === e) {
                    console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");
                    const e = [];
                    for (let t = 0; t < this.count; t++) {
                        const n = t * this.data.stride + this.offset;
                        for (let t = 0; t < this.itemSize; t++)
                            e.push(this.data.array[n + t])
                    }
                    return new Gi(new this.array.constructor(e),this.itemSize,this.normalized)
                }
                return void 0 === e.interleavedBuffers && (e.interleavedBuffers = {}),
                void 0 === e.interleavedBuffers[this.data.uuid] && (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)),
                new Do(e.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)
            }
            toJSON(e) {
                if (void 0 === e) {
                    console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");
                    const e = [];
                    for (let t = 0; t < this.count; t++) {
                        const n = t * this.data.stride + this.offset;
                        for (let t = 0; t < this.itemSize; t++)
                            e.push(this.data.array[n + t])
                    }
                    return {
                        itemSize: this.itemSize,
                        type: this.array.constructor.name,
                        array: e,
                        normalized: this.normalized
                    }
                }
                return void 0 === e.interleavedBuffers && (e.interleavedBuffers = {}),
                void 0 === e.interleavedBuffers[this.data.uuid] && (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)),
                {
                    isInterleavedBufferAttribute: !0,
                    itemSize: this.itemSize,
                    data: this.data.uuid,
                    offset: this.offset,
                    normalized: this.normalized
                }
            }
        }
        const Po = new on
          , Lo = new en
          , Uo = new en
          , Fo = new on
          , No = new Nn
          , Oo = new on
          , Qo = new Mn
          , ko = new Nn
          , Go = new Fn;
        class Ho extends ur {
            constructor(e, t) {
                super(e, t),
                this.isSkinnedMesh = !0,
                this.type = "SkinnedMesh",
                this.bindMode = R,
                this.bindMatrix = new Nn,
                this.bindMatrixInverse = new Nn,
                this.boundingBox = null,
                this.boundingSphere = null
            }
            computeBoundingBox() {
                const e = this.geometry;
                null === this.boundingBox && (this.boundingBox = new un),
                this.boundingBox.makeEmpty();
                const t = e.getAttribute("position");
                for (let e = 0; e < t.count; e++)
                    this.getVertexPosition(e, Oo),
                    this.boundingBox.expandByPoint(Oo)
            }
            computeBoundingSphere() {
                const e = this.geometry;
                null === this.boundingSphere && (this.boundingSphere = new Mn),
                this.boundingSphere.makeEmpty();
                const t = e.getAttribute("position");
                for (let e = 0; e < t.count; e++)
                    this.getVertexPosition(e, Oo),
                    this.boundingSphere.expandByPoint(Oo)
            }
            copy(e, t) {
                return super.copy(e, t),
                this.bindMode = e.bindMode,
                this.bindMatrix.copy(e.bindMatrix),
                this.bindMatrixInverse.copy(e.bindMatrixInverse),
                this.skeleton = e.skeleton,
                null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone()),
                null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()),
                this
            }
            raycast(e, t) {
                const n = this.material
                  , i = this.matrixWorld;
                void 0 !== n && (null === this.boundingSphere && this.computeBoundingSphere(),
                Qo.copy(this.boundingSphere),
                Qo.applyMatrix4(i),
                !1 !== e.ray.intersectsSphere(Qo) && (ko.copy(i).invert(),
                Go.copy(e.ray).applyMatrix4(ko),
                null !== this.boundingBox && !1 === Go.intersectsBox(this.boundingBox) || this._computeIntersections(e, t, Go)))
            }
            getVertexPosition(e, t) {
                return super.getVertexPosition(e, t),
                this.applyBoneTransform(e, t),
                t
            }
            bind(e, t) {
                this.skeleton = e,
                void 0 === t && (this.updateMatrixWorld(!0),
                this.skeleton.calculateInverses(),
                t = this.matrixWorld),
                this.bindMatrix.copy(t),
                this.bindMatrixInverse.copy(t).invert()
            }
            pose() {
                this.skeleton.pose()
            }
            normalizeSkinWeights() {
                const e = new en
                  , t = this.geometry.attributes.skinWeight;
                for (let n = 0, i = t.count; n < i; n++) {
                    e.fromBufferAttribute(t, n);
                    const i = 1 / e.manhattanLength();
                    i !== 1 / 0 ? e.multiplyScalar(i) : e.set(1, 0, 0, 0),
                    t.setXYZW(n, e.x, e.y, e.z, e.w)
                }
            }
            updateMatrixWorld(e) {
                super.updateMatrixWorld(e),
                this.bindMode === R ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : "detached" === this.bindMode ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
            }
            applyBoneTransform(e, t) {
                const n = this.skeleton
                  , i = this.geometry;
                Lo.fromBufferAttribute(i.attributes.skinIndex, e),
                Uo.fromBufferAttribute(i.attributes.skinWeight, e),
                Po.copy(t).applyMatrix4(this.bindMatrix),
                t.set(0, 0, 0);
                for (let e = 0; e < 4; e++) {
                    const i = Uo.getComponent(e);
                    if (0 !== i) {
                        const r = Lo.getComponent(e);
                        No.multiplyMatrices(n.bones[r].matrixWorld, n.boneInverses[r]),
                        t.addScaledVector(Fo.copy(Po).applyMatrix4(No), i)
                    }
                }
                return t.applyMatrix4(this.bindMatrixInverse)
            }
        }
        class zo extends ui {
            constructor() {
                super(),
                this.isBone = !0,
                this.type = "Bone"
            }
        }
        class Vo extends $t {
            constructor(e=null, t=1, n=1, i, r, s, a, o, l=k, c=k, u, h) {
                super(null, s, a, o, l, c, i, r, u, h),
                this.isDataTexture = !0,
                this.image = {
                    data: e,
                    width: t,
                    height: n
                },
                this.generateMipmaps = !1,
                this.flipY = !1,
                this.unpackAlignment = 1
            }
        }
        const Wo = new Nn
          , jo = new Nn;
        class qo {
            constructor(e=[], t=[]) {
                this.uuid = wt(),
                this.bones = e.slice(0),
                this.boneInverses = t,
                this.boneMatrices = null,
                this.boneTexture = null,
                this.init()
            }
            init() {
                const e = this.bones
                  , t = this.boneInverses;
                if (this.boneMatrices = new Float32Array(16 * e.length),
                0 === t.length)
                    this.calculateInverses();
                else if (e.length !== t.length) {
                    console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."),
                    this.boneInverses = [];
                    for (let e = 0, t = this.bones.length; e < t; e++)
                        this.boneInverses.push(new Nn)
                }
            }
            calculateInverses() {
                this.boneInverses.length = 0;
                for (let e = 0, t = this.bones.length; e < t; e++) {
                    const t = new Nn;
                    this.bones[e] && t.copy(this.bones[e].matrixWorld).invert(),
                    this.boneInverses.push(t)
                }
            }
            pose() {
                for (let e = 0, t = this.bones.length; e < t; e++) {
                    const t = this.bones[e];
                    t && t.matrixWorld.copy(this.boneInverses[e]).invert()
                }
                for (let e = 0, t = this.bones.length; e < t; e++) {
                    const t = this.bones[e];
                    t && (t.parent && t.parent.isBone ? (t.matrix.copy(t.parent.matrixWorld).invert(),
                    t.matrix.multiply(t.matrixWorld)) : t.matrix.copy(t.matrixWorld),
                    t.matrix.decompose(t.position, t.quaternion, t.scale))
                }
            }
            update() {
                const e = this.bones
                  , t = this.boneInverses
                  , n = this.boneMatrices
                  , i = this.boneTexture;
                for (let i = 0, r = e.length; i < r; i++) {
                    const r = e[i] ? e[i].matrixWorld : jo;
                    Wo.multiplyMatrices(r, t[i]),
                    Wo.toArray(n, 16 * i)
                }
                null !== i && (i.needsUpdate = !0)
            }
            clone() {
                return new qo(this.bones,this.boneInverses)
            }
            computeBoneTexture() {
                let e = Math.sqrt(4 * this.bones.length);
                e = 4 * Math.ceil(e / 4),
                e = Math.max(e, 4);
                const t = new Float32Array(e * e * 4);
                t.set(this.boneMatrices);
                const n = new Vo(t,e,e,ae,Z);
                return n.needsUpdate = !0,
                this.boneMatrices = t,
                this.boneTexture = n,
                this
            }
            getBoneByName(e) {
                for (let t = 0, n = this.bones.length; t < n; t++) {
                    const n = this.bones[t];
                    if (n.name === e)
                        return n
                }
            }
            dispose() {
                null !== this.boneTexture && (this.boneTexture.dispose(),
                this.boneTexture = null)
            }
            fromJSON(e, t) {
                this.uuid = e.uuid;
                for (let n = 0, i = e.bones.length; n < i; n++) {
                    const i = e.bones[n];
                    let r = t[i];
                    void 0 === r && (console.warn("THREE.Skeleton: No bone found with UUID:", i),
                    r = new zo),
                    this.bones.push(r),
                    this.boneInverses.push((new Nn).fromArray(e.boneInverses[n]))
                }
                return this.init(),
                this
            }
            toJSON() {
                const e = {
                    metadata: {
                        version: 4.6,
                        type: "Skeleton",
                        generator: "Skeleton.toJSON"
                    },
                    bones: [],
                    boneInverses: []
                };
                e.uuid = this.uuid;
                const t = this.bones
                  , n = this.boneInverses;
                for (let i = 0, r = t.length; i < r; i++) {
                    const r = t[i];
                    e.bones.push(r.uuid);
                    const s = n[i];
                    e.boneInverses.push(s.toArray())
                }
                return e
            }
        }
        class Yo extends Gi {
            constructor(e, t, n, i=1) {
                super(e, t, n),
                this.isInstancedBufferAttribute = !0,
                this.meshPerAttribute = i
            }
            copy(e) {
                return super.copy(e),
                this.meshPerAttribute = e.meshPerAttribute,
                this
            }
            toJSON() {
                const e = super.toJSON();
                return e.meshPerAttribute = this.meshPerAttribute,
                e.isInstancedBufferAttribute = !0,
                e
            }
        }
        const Xo = new Nn
          , Ko = new Nn
          , Jo = []
          , Zo = new un
          , $o = new Nn
          , el = new ur
          , tl = new Mn;
        class nl extends ur {
            constructor(e, t, n) {
                super(e, t),
                this.isInstancedMesh = !0,
                this.instanceMatrix = new Yo(new Float32Array(16 * n),16),
                this.instanceColor = null,
                this.morphTexture = null,
                this.count = n,
                this.boundingBox = null,
                this.boundingSphere = null;
                for (let e = 0; e < n; e++)
                    this.setMatrixAt(e, $o)
            }
            computeBoundingBox() {
                const e = this.geometry
                  , t = this.count;
                null === this.boundingBox && (this.boundingBox = new un),
                null === e.boundingBox && e.computeBoundingBox(),
                this.boundingBox.makeEmpty();
                for (let n = 0; n < t; n++)
                    this.getMatrixAt(n, Xo),
                    Zo.copy(e.boundingBox).applyMatrix4(Xo),
                    this.boundingBox.union(Zo)
            }
            computeBoundingSphere() {
                const e = this.geometry
                  , t = this.count;
                null === this.boundingSphere && (this.boundingSphere = new Mn),
                null === e.boundingSphere && e.computeBoundingSphere(),
                this.boundingSphere.makeEmpty();
                for (let n = 0; n < t; n++)
                    this.getMatrixAt(n, Xo),
                    tl.copy(e.boundingSphere).applyMatrix4(Xo),
                    this.boundingSphere.union(tl)
            }
            copy(e, t) {
                return super.copy(e, t),
                this.instanceMatrix.copy(e.instanceMatrix),
                null !== e.morphTexture && (this.morphTexture = e.morphTexture.clone()),
                null !== e.instanceColor && (this.instanceColor = e.instanceColor.clone()),
                this.count = e.count,
                null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone()),
                null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()),
                this
            }
            getColorAt(e, t) {
                t.fromArray(this.instanceColor.array, 3 * e)
            }
            getMatrixAt(e, t) {
                t.fromArray(this.instanceMatrix.array, 16 * e)
            }
            getMorphAt(e, t) {
                const n = t.morphTargetInfluences
                  , i = this.morphTexture.source.data.data
                  , r = e * (n.length + 1) + 1;
                for (let e = 0; e < n.length; e++)
                    n[e] = i[r + e]
            }
            raycast(e, t) {
                const n = this.matrixWorld
                  , i = this.count;
                if (el.geometry = this.geometry,
                el.material = this.material,
                void 0 !== el.material && (null === this.boundingSphere && this.computeBoundingSphere(),
                tl.copy(this.boundingSphere),
                tl.applyMatrix4(n),
                !1 !== e.ray.intersectsSphere(tl)))
                    for (let r = 0; r < i; r++) {
                        this.getMatrixAt(r, Xo),
                        Ko.multiplyMatrices(n, Xo),
                        el.matrixWorld = Ko,
                        el.raycast(e, Jo);
                        for (let e = 0, n = Jo.length; e < n; e++) {
                            const n = Jo[e];
                            n.instanceId = r,
                            n.object = this,
                            t.push(n)
                        }
                        Jo.length = 0
                    }
            }
            setColorAt(e, t) {
                null === this.instanceColor && (this.instanceColor = new Yo(new Float32Array(3 * this.instanceMatrix.count).fill(1),3)),
                t.toArray(this.instanceColor.array, 3 * e)
            }
            setMatrixAt(e, t) {
                t.toArray(this.instanceMatrix.array, 16 * e)
            }
            setMorphAt(e, t) {
                const n = t.morphTargetInfluences
                  , i = n.length + 1;
                null === this.morphTexture && (this.morphTexture = new Vo(new Float32Array(i * this.count),i,this.count,he,Z));
                const r = this.morphTexture.source.data.data;
                let s = 0;
                for (let e = 0; e < n.length; e++)
                    s += n[e];
                const a = this.geometry.morphTargetsRelative ? 1 : 1 - s
                  , o = i * e;
                r[o] = a,
                r.set(n, o + 1)
            }
            updateMorphTargets() {}
            dispose() {
                return this.dispatchEvent({
                    type: "dispose"
                }),
                null !== this.morphTexture && (this.morphTexture.dispose(),
                this.morphTexture = null),
                this
            }
        }
        class il extends Di {
            static get type() {
                return "LineBasicMaterial"
            }
            constructor(e) {
                super(),
                this.isLineBasicMaterial = !0,
                this.color = new Ti(16777215),
                this.map = null,
                this.linewidth = 1,
                this.linecap = "round",
                this.linejoin = "round",
                this.fog = !0,
                this.setValues(e)
            }
            copy(e) {
                return super.copy(e),
                this.color.copy(e.color),
                this.map = e.map,
                this.linewidth = e.linewidth,
                this.linecap = e.linecap,
                this.linejoin = e.linejoin,
                this.fog = e.fog,
                this
            }
        }
        const rl = new on
          , sl = new on
          , al = new Nn
          , ol = new Fn
          , ll = new Mn
          , cl = new on
          , ul = new on;
        class hl extends ui {
            constructor(e=new Zi, t=new il) {
                super(),
                this.isLine = !0,
                this.type = "Line",
                this.geometry = e,
                this.material = t,
                this.updateMorphTargets()
            }
            copy(e, t) {
                return super.copy(e, t),
                this.material = Array.isArray(e.material) ? e.material.slice() : e.material,
                this.geometry = e.geometry,
                this
            }
            computeLineDistances() {
                const e = this.geometry;
                if (null === e.index) {
                    const t = e.attributes.position
                      , n = [0];
                    for (let e = 1, i = t.count; e < i; e++)
                        rl.fromBufferAttribute(t, e - 1),
                        sl.fromBufferAttribute(t, e),
                        n[e] = n[e - 1],
                        n[e] += rl.distanceTo(sl);
                    e.setAttribute("lineDistance", new Vi(n,1))
                } else
                    console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                return this
            }
            raycast(e, t) {
                const n = this.geometry
                  , i = this.matrixWorld
                  , r = e.params.Line.threshold
                  , s = n.drawRange;
                if (null === n.boundingSphere && n.computeBoundingSphere(),
                ll.copy(n.boundingSphere),
                ll.applyMatrix4(i),
                ll.radius += r,
                !1 === e.ray.intersectsSphere(ll))
                    return;
                al.copy(i).invert(),
                ol.copy(e.ray).applyMatrix4(al);
                const a = r / ((this.scale.x + this.scale.y + this.scale.z) / 3)
                  , o = a * a
                  , l = this.isLineSegments ? 2 : 1
                  , c = n.index
                  , u = n.attributes.position;
                if (null !== c) {
                    const n = Math.max(0, s.start)
                      , i = Math.min(c.count, s.start + s.count);
                    for (let r = n, s = i - 1; r < s; r += l) {
                        const n = c.getX(r)
                          , i = c.getX(r + 1)
                          , s = dl(this, e, ol, o, n, i);
                        s && t.push(s)
                    }
                    if (this.isLineLoop) {
                        const r = c.getX(i - 1)
                          , s = c.getX(n)
                          , a = dl(this, e, ol, o, r, s);
                        a && t.push(a)
                    }
                } else {
                    const n = Math.max(0, s.start)
                      , i = Math.min(u.count, s.start + s.count);
                    for (let r = n, s = i - 1; r < s; r += l) {
                        const n = dl(this, e, ol, o, r, r + 1);
                        n && t.push(n)
                    }
                    if (this.isLineLoop) {
                        const r = dl(this, e, ol, o, i - 1, n);
                        r && t.push(r)
                    }
                }
            }
            updateMorphTargets() {
                const e = this.geometry.morphAttributes
                  , t = Object.keys(e);
                if (t.length > 0) {
                    const n = e[t[0]];
                    if (void 0 !== n) {
                        this.morphTargetInfluences = [],
                        this.morphTargetDictionary = {};
                        for (let e = 0, t = n.length; e < t; e++) {
                            const t = n[e].name || String(e);
                            this.morphTargetInfluences.push(0),
                            this.morphTargetDictionary[t] = e
                        }
                    }
                }
            }
        }
        function dl(e, t, n, i, r, s) {
            const a = e.geometry.attributes.position;
            rl.fromBufferAttribute(a, r),
            sl.fromBufferAttribute(a, s);
            if (n.distanceSqToSegment(rl, sl, cl, ul) > i)
                return;
            cl.applyMatrix4(e.matrixWorld);
            const o = t.ray.origin.distanceTo(cl);
            return o < t.near || o > t.far ? void 0 : {
                distance: o,
                point: ul.clone().applyMatrix4(e.matrixWorld),
                index: r,
                face: null,
                faceIndex: null,
                barycoord: null,
                object: e
            }
        }
        const pl = new on
          , fl = new on;
        class Al extends hl {
            constructor(e, t) {
                super(e, t),
                this.isLineSegments = !0,
                this.type = "LineSegments"
            }
            computeLineDistances() {
                const e = this.geometry;
                if (null === e.index) {
                    const t = e.attributes.position
                      , n = [];
                    for (let e = 0, i = t.count; e < i; e += 2)
                        pl.fromBufferAttribute(t, e),
                        fl.fromBufferAttribute(t, e + 1),
                        n[e] = 0 === e ? 0 : n[e - 1],
                        n[e + 1] = n[e] + pl.distanceTo(fl);
                    e.setAttribute("lineDistance", new Vi(n,1))
                } else
                    console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                return this
            }
        }
        class gl extends hl {
            constructor(e, t) {
                super(e, t),
                this.isLineLoop = !0,
                this.type = "LineLoop"
            }
        }
        class ml extends Di {
            static get type() {
                return "PointsMaterial"
            }
            constructor(e) {
                super(),
                this.isPointsMaterial = !0,
                this.color = new Ti(16777215),
                this.map = null,
                this.alphaMap = null,
                this.size = 1,
                this.sizeAttenuation = !0,
                this.fog = !0,
                this.setValues(e)
            }
            copy(e) {
                return super.copy(e),
                this.color.copy(e.color),
                this.map = e.map,
                this.alphaMap = e.alphaMap,
                this.size = e.size,
                this.sizeAttenuation = e.sizeAttenuation,
                this.fog = e.fog,
                this
            }
        }
        const vl = new Nn
          , yl = new Fn
          , xl = new Mn
          , _l = new on;
        class bl extends ui {
            constructor(e=new Zi, t=new ml) {
                super(),
                this.isPoints = !0,
                this.type = "Points",
                this.geometry = e,
                this.material = t,
                this.updateMorphTargets()
            }
            copy(e, t) {
                return super.copy(e, t),
                this.material = Array.isArray(e.material) ? e.material.slice() : e.material,
                this.geometry = e.geometry,
                this
            }
            raycast(e, t) {
                const n = this.geometry
                  , i = this.matrixWorld
                  , r = e.params.Points.threshold
                  , s = n.drawRange;
                if (null === n.boundingSphere && n.computeBoundingSphere(),
                xl.copy(n.boundingSphere),
                xl.applyMatrix4(i),
                xl.radius += r,
                !1 === e.ray.intersectsSphere(xl))
                    return;
                vl.copy(i).invert(),
                yl.copy(e.ray).applyMatrix4(vl);
                const a = r / ((this.scale.x + this.scale.y + this.scale.z) / 3)
                  , o = a * a
                  , l = n.index
                  , c = n.attributes.position;
                if (null !== l) {
                    for (let n = Math.max(0, s.start), r = Math.min(l.count, s.start + s.count); n < r; n++) {
                        const r = l.getX(n);
                        _l.fromBufferAttribute(c, r),
                        El(_l, r, o, i, e, t, this)
                    }
                } else {
                    for (let n = Math.max(0, s.start), r = Math.min(c.count, s.start + s.count); n < r; n++)
                        _l.fromBufferAttribute(c, n),
                        El(_l, n, o, i, e, t, this)
                }
            }
            updateMorphTargets() {
                const e = this.geometry.morphAttributes
                  , t = Object.keys(e);
                if (t.length > 0) {
                    const n = e[t[0]];
                    if (void 0 !== n) {
                        this.morphTargetInfluences = [],
                        this.morphTargetDictionary = {};
                        for (let e = 0, t = n.length; e < t; e++) {
                            const t = n[e].name || String(e);
                            this.morphTargetInfluences.push(0),
                            this.morphTargetDictionary[t] = e
                        }
                    }
                }
            }
        }
        function El(e, t, n, i, r, s, a) {
            const o = yl.distanceSqToPoint(e);
            if (o < n) {
                const n = new on;
                yl.closestPointToPoint(e, n),
                n.applyMatrix4(i);
                const l = r.ray.origin.distanceTo(n);
                if (l < r.near || l > r.far)
                    return;
                s.push({
                    distance: l,
                    distanceToRay: Math.sqrt(o),
                    point: n,
                    index: t,
                    face: null,
                    faceIndex: null,
                    barycoord: null,
                    object: a
                })
            }
        }
        class wl extends $t {
            constructor(e, t, n, i, r, s, a, o, l) {
                super(e, t, n, i, r, s, a, o, l),
                this.isVideoTexture = !0,
                this.minFilter = void 0 !== s ? s : z,
                this.magFilter = void 0 !== r ? r : z,
                this.generateMipmaps = !1;
                const c = this;
                "requestVideoFrameCallback"in e && e.requestVideoFrameCallback((function t() {
                    c.needsUpdate = !0,
                    e.requestVideoFrameCallback(t)
                }
                ))
            }
            clone() {
                return new this.constructor(this.image).copy(this)
            }
            update() {
                const e = this.image;
                !1 === "requestVideoFrameCallback"in e && e.readyState >= e.HAVE_CURRENT_DATA && (this.needsUpdate = !0)
            }
        }
        class Cl extends $t {
            constructor(e, t, n, i, r, s, a, o, l, c, u, h) {
                super(null, s, a, o, l, c, i, r, u, h),
                this.isCompressedTexture = !0,
                this.image = {
                    width: t,
                    height: n
                },
                this.mipmaps = e,
                this.flipY = !1,
                this.generateMipmaps = !1
            }
        }
        class Il extends Cl {
            constructor(e, t, n, i, r, s) {
                super(e, t, n, r, s),
                this.isCompressedArrayTexture = !0,
                this.image.depth = i,
                this.wrapR = O,
                this.layerUpdates = new Set
            }
            addLayerUpdate(e) {
                this.layerUpdates.add(e)
            }
            clearLayerUpdates() {
                this.layerUpdates.clear()
            }
        }
        class Sl extends Cl {
            constructor(e, t, n) {
                super(void 0, e[0].width, e[0].height, t, n, D),
                this.isCompressedCubeTexture = !0,
                this.isCubeTexture = !0,
                this.image = e
            }
        }
        class Ml {
            constructor() {
                this.type = "Curve",
                this.arcLengthDivisions = 200
            }
            getPoint() {
                return console.warn("THREE.Curve: .getPoint() not implemented."),
                null
            }
            getPointAt(e, t) {
                const n = this.getUtoTmapping(e);
                return this.getPoint(n, t)
            }
            getPoints(e=5) {
                const t = [];
                for (let n = 0; n <= e; n++)
                    t.push(this.getPoint(n / e));
                return t
            }
            getSpacedPoints(e=5) {
                const t = [];
                for (let n = 0; n <= e; n++)
                    t.push(this.getPointAt(n / e));
                return t
            }
            getLength() {
                const e = this.getLengths();
                return e[e.length - 1]
            }
            getLengths(e=this.arcLengthDivisions) {
                if (this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate)
                    return this.cacheArcLengths;
                this.needsUpdate = !1;
                const t = [];
                let n, i = this.getPoint(0), r = 0;
                t.push(0);
                for (let s = 1; s <= e; s++)
                    n = this.getPoint(s / e),
                    r += n.distanceTo(i),
                    t.push(r),
                    i = n;
                return this.cacheArcLengths = t,
                t
            }
            updateArcLengths() {
                this.needsUpdate = !0,
                this.getLengths()
            }
            getUtoTmapping(e, t) {
                const n = this.getLengths();
                let i = 0;
                const r = n.length;
                let s;
                s = t || e * n[r - 1];
                let a, o = 0, l = r - 1;
                for (; o <= l; )
                    if (i = Math.floor(o + (l - o) / 2),
                    a = n[i] - s,
                    a < 0)
                        o = i + 1;
                    else {
                        if (!(a > 0)) {
                            l = i;
                            break
                        }
                        l = i - 1
                    }
                if (i = l,
                n[i] === s)
                    return i / (r - 1);
                const c = n[i];
                return (i + (s - c) / (n[i + 1] - c)) / (r - 1)
            }
            getTangent(e, t) {
                const n = 1e-4;
                let i = e - n
                  , r = e + n;
                i < 0 && (i = 0),
                r > 1 && (r = 1);
                const s = this.getPoint(i)
                  , a = this.getPoint(r)
                  , o = t || (s.isVector2 ? new Rt : new on);
                return o.copy(a).sub(s).normalize(),
                o
            }
            getTangentAt(e, t) {
                const n = this.getUtoTmapping(e);
                return this.getTangent(n, t)
            }
            computeFrenetFrames(e, t) {
                const n = new on
                  , i = []
                  , r = []
                  , s = []
                  , a = new on
                  , o = new Nn;
                for (let t = 0; t <= e; t++) {
                    const n = t / e;
                    i[t] = this.getTangentAt(n, new on)
                }
                r[0] = new on,
                s[0] = new on;
                let l = Number.MAX_VALUE;
                const c = Math.abs(i[0].x)
                  , u = Math.abs(i[0].y)
                  , h = Math.abs(i[0].z);
                c <= l && (l = c,
                n.set(1, 0, 0)),
                u <= l && (l = u,
                n.set(0, 1, 0)),
                h <= l && n.set(0, 0, 1),
                a.crossVectors(i[0], n).normalize(),
                r[0].crossVectors(i[0], a),
                s[0].crossVectors(i[0], r[0]);
                for (let t = 1; t <= e; t++) {
                    if (r[t] = r[t - 1].clone(),
                    s[t] = s[t - 1].clone(),
                    a.crossVectors(i[t - 1], i[t]),
                    a.length() > Number.EPSILON) {
                        a.normalize();
                        const e = Math.acos(Ct(i[t - 1].dot(i[t]), -1, 1));
                        r[t].applyMatrix4(o.makeRotationAxis(a, e))
                    }
                    s[t].crossVectors(i[t], r[t])
                }
                if (!0 === t) {
                    let t = Math.acos(Ct(r[0].dot(r[e]), -1, 1));
                    t /= e,
                    i[0].dot(a.crossVectors(r[0], r[e])) > 0 && (t = -t);
                    for (let n = 1; n <= e; n++)
                        r[n].applyMatrix4(o.makeRotationAxis(i[n], t * n)),
                        s[n].crossVectors(i[n], r[n])
                }
                return {
                    tangents: i,
                    normals: r,
                    binormals: s
                }
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            copy(e) {
                return this.arcLengthDivisions = e.arcLengthDivisions,
                this
            }
            toJSON() {
                const e = {
                    metadata: {
                        version: 4.6,
                        type: "Curve",
                        generator: "Curve.toJSON"
                    }
                };
                return e.arcLengthDivisions = this.arcLengthDivisions,
                e.type = this.type,
                e
            }
            fromJSON(e) {
                return this.arcLengthDivisions = e.arcLengthDivisions,
                this
            }
        }
        class Tl extends Zi {
            constructor(e=1, t=1, n=1, i=32, r=1, s=!1, a=0, o=2 * Math.PI) {
                super(),
                this.type = "CylinderGeometry",
                this.parameters = {
                    radiusTop: e,
                    radiusBottom: t,
                    height: n,
                    radialSegments: i,
                    heightSegments: r,
                    openEnded: s,
                    thetaStart: a,
                    thetaLength: o
                };
                const l = this;
                i = Math.floor(i),
                r = Math.floor(r);
                const c = []
                  , u = []
                  , h = []
                  , d = [];
                let p = 0;
                const f = []
                  , A = n / 2;
                let g = 0;
                function m(n) {
                    const r = p
                      , s = new Rt
                      , f = new on;
                    let m = 0;
                    const v = !0 === n ? e : t
                      , y = !0 === n ? 1 : -1;
                    for (let e = 1; e <= i; e++)
                        u.push(0, A * y, 0),
                        h.push(0, y, 0),
                        d.push(.5, .5),
                        p++;
                    const x = p;
                    for (let e = 0; e <= i; e++) {
                        const t = e / i * o + a
                          , n = Math.cos(t)
                          , r = Math.sin(t);
                        f.x = v * r,
                        f.y = A * y,
                        f.z = v * n,
                        u.push(f.x, f.y, f.z),
                        h.push(0, y, 0),
                        s.x = .5 * n + .5,
                        s.y = .5 * r * y + .5,
                        d.push(s.x, s.y),
                        p++
                    }
                    for (let e = 0; e < i; e++) {
                        const t = r + e
                          , i = x + e;
                        !0 === n ? c.push(i, i + 1, t) : c.push(i + 1, i, t),
                        m += 3
                    }
                    l.addGroup(g, m, !0 === n ? 1 : 2),
                    g += m
                }
                !function() {
                    const s = new on
                      , m = new on;
                    let v = 0;
                    const y = (t - e) / n;
                    for (let l = 0; l <= r; l++) {
                        const c = []
                          , g = l / r
                          , v = g * (t - e) + e;
                        for (let e = 0; e <= i; e++) {
                            const t = e / i
                              , r = t * o + a
                              , l = Math.sin(r)
                              , f = Math.cos(r);
                            m.x = v * l,
                            m.y = -g * n + A,
                            m.z = v * f,
                            u.push(m.x, m.y, m.z),
                            s.set(l, y, f).normalize(),
                            h.push(s.x, s.y, s.z),
                            d.push(t, 1 - g),
                            c.push(p++)
                        }
                        f.push(c)
                    }
                    for (let n = 0; n < i; n++)
                        for (let i = 0; i < r; i++) {
                            const s = f[i][n]
                              , a = f[i + 1][n]
                              , o = f[i + 1][n + 1]
                              , l = f[i][n + 1];
                            (e > 0 || 0 !== i) && (c.push(s, a, l),
                            v += 3),
                            (t > 0 || i !== r - 1) && (c.push(a, o, l),
                            v += 3)
                        }
                    l.addGroup(g, v, 0),
                    g += v
                }(),
                !1 === s && (e > 0 && m(!0),
                t > 0 && m(!1)),
                this.setIndex(c),
                this.setAttribute("position", new Vi(u,3)),
                this.setAttribute("normal", new Vi(h,3)),
                this.setAttribute("uv", new Vi(d,2))
            }
            copy(e) {
                return super.copy(e),
                this.parameters = Object.assign({}, e.parameters),
                this
            }
            static fromJSON(e) {
                return new Tl(e.radiusTop,e.radiusBottom,e.height,e.radialSegments,e.heightSegments,e.openEnded,e.thetaStart,e.thetaLength)
            }
        }
        class Bl extends Tl {
            constructor(e=1, t=1, n=32, i=1, r=!1, s=0, a=2 * Math.PI) {
                super(0, e, t, n, i, r, s, a),
                this.type = "ConeGeometry",
                this.parameters = {
                    radius: e,
                    height: t,
                    radialSegments: n,
                    heightSegments: i,
                    openEnded: r,
                    thetaStart: s,
                    thetaLength: a
                }
            }
            static fromJSON(e) {
                return new Bl(e.radius,e.height,e.radialSegments,e.heightSegments,e.openEnded,e.thetaStart,e.thetaLength)
            }
        }
        const Rl = function(e, t, n=2) {
            const i = t && t.length
              , r = i ? t[0] * n : e.length;
            let s = Dl(e, 0, r, n, !0);
            const a = [];
            if (!s || s.next === s.prev)
                return a;
            let o, l, c, u, h, d, p;
            if (i && (s = function(e, t, n, i) {
                const r = [];
                let s, a, o, l, c;
                for (s = 0,
                a = t.length; s < a; s++)
                    o = t[s] * i,
                    l = s < a - 1 ? t[s + 1] * i : e.length,
                    c = Dl(e, o, l, i, !1),
                    c === c.next && (c.steiner = !0),
                    r.push(zl(c));
                for (r.sort(Ql),
                s = 0; s < r.length; s++)
                    n = kl(r[s], n);
                return n
            }(e, t, s, n)),
            e.length > 80 * n) {
                o = c = e[0],
                l = u = e[1];
                for (let t = n; t < r; t += n)
                    h = e[t],
                    d = e[t + 1],
                    h < o && (o = h),
                    d < l && (l = d),
                    h > c && (c = h),
                    d > u && (u = d);
                p = Math.max(c - o, u - l),
                p = 0 !== p ? 32767 / p : 0
            }
            return Ll(s, a, n, o, l, p, 0),
            a
        };
        function Dl(e, t, n, i, r) {
            let s, a;
            if (r === function(e, t, n, i) {
                let r = 0;
                for (let s = t, a = n - i; s < n; s += i)
                    r += (e[a] - e[s]) * (e[s + 1] + e[a + 1]),
                    a = s;
                return r
            }(e, t, n, i) > 0)
                for (s = t; s < n; s += i)
                    a = $l(s, e[s], e[s + 1], a);
            else
                for (s = n - i; s >= t; s -= i)
                    a = $l(s, e[s], e[s + 1], a);
            return a && ql(a, a.next) && (ec(a),
            a = a.next),
            a
        }
        function Pl(e, t) {
            if (!e)
                return e;
            t || (t = e);
            let n, i = e;
            do {
                if (n = !1,
                i.steiner || !ql(i, i.next) && 0 !== jl(i.prev, i, i.next))
                    i = i.next;
                else {
                    if (ec(i),
                    i = t = i.prev,
                    i === i.next)
                        break;
                    n = !0
                }
            } while (n || i !== t);
            return t
        }
        function Ll(e, t, n, i, r, s, a) {
            if (!e)
                return;
            !a && s && function(e, t, n, i) {
                let r = e;
                do {
                    0 === r.z && (r.z = Hl(r.x, r.y, t, n, i)),
                    r.prevZ = r.prev,
                    r.nextZ = r.next,
                    r = r.next
                } while (r !== e);
                r.prevZ.nextZ = null,
                r.prevZ = null,
                function(e) {
                    let t, n, i, r, s, a, o, l, c = 1;
                    do {
                        for (n = e,
                        e = null,
                        s = null,
                        a = 0; n; ) {
                            for (a++,
                            i = n,
                            o = 0,
                            t = 0; t < c && (o++,
                            i = i.nextZ,
                            i); t++)
                                ;
                            for (l = c; o > 0 || l > 0 && i; )
                                0 !== o && (0 === l || !i || n.z <= i.z) ? (r = n,
                                n = n.nextZ,
                                o--) : (r = i,
                                i = i.nextZ,
                                l--),
                                s ? s.nextZ = r : e = r,
                                r.prevZ = s,
                                s = r;
                            n = i
                        }
                        s.nextZ = null,
                        c *= 2
                    } while (a > 1)
                }(r)
            }(e, i, r, s);
            let o, l, c = e;
            for (; e.prev !== e.next; )
                if (o = e.prev,
                l = e.next,
                s ? Fl(e, i, r, s) : Ul(e))
                    t.push(o.i / n | 0),
                    t.push(e.i / n | 0),
                    t.push(l.i / n | 0),
                    ec(e),
                    e = l.next,
                    c = l.next;
                else if ((e = l) === c) {
                    a ? 1 === a ? Ll(e = Nl(Pl(e), t, n), t, n, i, r, s, 2) : 2 === a && Ol(e, t, n, i, r, s) : Ll(Pl(e), t, n, i, r, s, 1);
                    break
                }
        }
        function Ul(e) {
            const t = e.prev
              , n = e
              , i = e.next;
            if (jl(t, n, i) >= 0)
                return !1;
            const r = t.x
              , s = n.x
              , a = i.x
              , o = t.y
              , l = n.y
              , c = i.y
              , u = r < s ? r < a ? r : a : s < a ? s : a
              , h = o < l ? o < c ? o : c : l < c ? l : c
              , d = r > s ? r > a ? r : a : s > a ? s : a
              , p = o > l ? o > c ? o : c : l > c ? l : c;
            let f = i.next;
            for (; f !== t; ) {
                if (f.x >= u && f.x <= d && f.y >= h && f.y <= p && Vl(r, o, s, l, a, c, f.x, f.y) && jl(f.prev, f, f.next) >= 0)
                    return !1;
                f = f.next
            }
            return !0
        }
        function Fl(e, t, n, i) {
            const r = e.prev
              , s = e
              , a = e.next;
            if (jl(r, s, a) >= 0)
                return !1;
            const o = r.x
              , l = s.x
              , c = a.x
              , u = r.y
              , h = s.y
              , d = a.y
              , p = o < l ? o < c ? o : c : l < c ? l : c
              , f = u < h ? u < d ? u : d : h < d ? h : d
              , A = o > l ? o > c ? o : c : l > c ? l : c
              , g = u > h ? u > d ? u : d : h > d ? h : d
              , m = Hl(p, f, t, n, i)
              , v = Hl(A, g, t, n, i);
            let y = e.prevZ
              , x = e.nextZ;
            for (; y && y.z >= m && x && x.z <= v; ) {
                if (y.x >= p && y.x <= A && y.y >= f && y.y <= g && y !== r && y !== a && Vl(o, u, l, h, c, d, y.x, y.y) && jl(y.prev, y, y.next) >= 0)
                    return !1;
                if (y = y.prevZ,
                x.x >= p && x.x <= A && x.y >= f && x.y <= g && x !== r && x !== a && Vl(o, u, l, h, c, d, x.x, x.y) && jl(x.prev, x, x.next) >= 0)
                    return !1;
                x = x.nextZ
            }
            for (; y && y.z >= m; ) {
                if (y.x >= p && y.x <= A && y.y >= f && y.y <= g && y !== r && y !== a && Vl(o, u, l, h, c, d, y.x, y.y) && jl(y.prev, y, y.next) >= 0)
                    return !1;
                y = y.prevZ
            }
            for (; x && x.z <= v; ) {
                if (x.x >= p && x.x <= A && x.y >= f && x.y <= g && x !== r && x !== a && Vl(o, u, l, h, c, d, x.x, x.y) && jl(x.prev, x, x.next) >= 0)
                    return !1;
                x = x.nextZ
            }
            return !0
        }
        function Nl(e, t, n) {
            let i = e;
            do {
                const r = i.prev
                  , s = i.next.next;
                !ql(r, s) && Yl(r, i, i.next, s) && Jl(r, s) && Jl(s, r) && (t.push(r.i / n | 0),
                t.push(i.i / n | 0),
                t.push(s.i / n | 0),
                ec(i),
                ec(i.next),
                i = e = s),
                i = i.next
            } while (i !== e);
            return Pl(i)
        }
        function Ol(e, t, n, i, r, s) {
            let a = e;
            do {
                let e = a.next.next;
                for (; e !== a.prev; ) {
                    if (a.i !== e.i && Wl(a, e)) {
                        let o = Zl(a, e);
                        return a = Pl(a, a.next),
                        o = Pl(o, o.next),
                        Ll(a, t, n, i, r, s, 0),
                        void Ll(o, t, n, i, r, s, 0)
                    }
                    e = e.next
                }
                a = a.next
            } while (a !== e)
        }
        function Ql(e, t) {
            return e.x - t.x
        }
        function kl(e, t) {
            const n = function(e, t) {
                let n, i = t, r = -1 / 0;
                const s = e.x
                  , a = e.y;
                do {
                    if (a <= i.y && a >= i.next.y && i.next.y !== i.y) {
                        const e = i.x + (a - i.y) * (i.next.x - i.x) / (i.next.y - i.y);
                        if (e <= s && e > r && (r = e,
                        n = i.x < i.next.x ? i : i.next,
                        e === s))
                            return n
                    }
                    i = i.next
                } while (i !== t);
                if (!n)
                    return null;
                const o = n
                  , l = n.x
                  , c = n.y;
                let u, h = 1 / 0;
                i = n;
                do {
                    s >= i.x && i.x >= l && s !== i.x && Vl(a < c ? s : r, a, l, c, a < c ? r : s, a, i.x, i.y) && (u = Math.abs(a - i.y) / (s - i.x),
                    Jl(i, e) && (u < h || u === h && (i.x > n.x || i.x === n.x && Gl(n, i))) && (n = i,
                    h = u)),
                    i = i.next
                } while (i !== o);
                return n
            }(e, t);
            if (!n)
                return t;
            const i = Zl(n, e);
            return Pl(i, i.next),
            Pl(n, n.next)
        }
        function Gl(e, t) {
            return jl(e.prev, e, t.prev) < 0 && jl(t.next, e, e.next) < 0
        }
        function Hl(e, t, n, i, r) {
            return (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = (e - n) * r | 0) | e << 8)) | e << 4)) | e << 2)) | e << 1)) | (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = (t - i) * r | 0) | t << 8)) | t << 4)) | t << 2)) | t << 1)) << 1
        }
        function zl(e) {
            let t = e
              , n = e;
            do {
                (t.x < n.x || t.x === n.x && t.y < n.y) && (n = t),
                t = t.next
            } while (t !== e);
            return n
        }
        function Vl(e, t, n, i, r, s, a, o) {
            return (r - a) * (t - o) >= (e - a) * (s - o) && (e - a) * (i - o) >= (n - a) * (t - o) && (n - a) * (s - o) >= (r - a) * (i - o)
        }
        function Wl(e, t) {
            return e.next.i !== t.i && e.prev.i !== t.i && !function(e, t) {
                let n = e;
                do {
                    if (n.i !== e.i && n.next.i !== e.i && n.i !== t.i && n.next.i !== t.i && Yl(n, n.next, e, t))
                        return !0;
                    n = n.next
                } while (n !== e);
                return !1
            }(e, t) && (Jl(e, t) && Jl(t, e) && function(e, t) {
                let n = e
                  , i = !1;
                const r = (e.x + t.x) / 2
                  , s = (e.y + t.y) / 2;
                do {
                    n.y > s != n.next.y > s && n.next.y !== n.y && r < (n.next.x - n.x) * (s - n.y) / (n.next.y - n.y) + n.x && (i = !i),
                    n = n.next
                } while (n !== e);
                return i
            }(e, t) && (jl(e.prev, e, t.prev) || jl(e, t.prev, t)) || ql(e, t) && jl(e.prev, e, e.next) > 0 && jl(t.prev, t, t.next) > 0)
        }
        function jl(e, t, n) {
            return (t.y - e.y) * (n.x - t.x) - (t.x - e.x) * (n.y - t.y)
        }
        function ql(e, t) {
            return e.x === t.x && e.y === t.y
        }
        function Yl(e, t, n, i) {
            const r = Kl(jl(e, t, n))
              , s = Kl(jl(e, t, i))
              , a = Kl(jl(n, i, e))
              , o = Kl(jl(n, i, t));
            return r !== s && a !== o || (!(0 !== r || !Xl(e, n, t)) || (!(0 !== s || !Xl(e, i, t)) || (!(0 !== a || !Xl(n, e, i)) || !(0 !== o || !Xl(n, t, i)))))
        }
        function Xl(e, t, n) {
            return t.x <= Math.max(e.x, n.x) && t.x >= Math.min(e.x, n.x) && t.y <= Math.max(e.y, n.y) && t.y >= Math.min(e.y, n.y)
        }
        function Kl(e) {
            return e > 0 ? 1 : e < 0 ? -1 : 0
        }
        function Jl(e, t) {
            return jl(e.prev, e, e.next) < 0 ? jl(e, t, e.next) >= 0 && jl(e, e.prev, t) >= 0 : jl(e, t, e.prev) < 0 || jl(e, e.next, t) < 0
        }
        function Zl(e, t) {
            const n = new tc(e.i,e.x,e.y)
              , i = new tc(t.i,t.x,t.y)
              , r = e.next
              , s = t.prev;
            return e.next = t,
            t.prev = e,
            n.next = r,
            r.prev = n,
            i.next = n,
            n.prev = i,
            s.next = i,
            i.prev = s,
            i
        }
        function $l(e, t, n, i) {
            const r = new tc(e,t,n);
            return i ? (r.next = i.next,
            r.prev = i,
            i.next.prev = r,
            i.next = r) : (r.prev = r,
            r.next = r),
            r
        }
        function ec(e) {
            e.next.prev = e.prev,
            e.prev.next = e.next,
            e.prevZ && (e.prevZ.nextZ = e.nextZ),
            e.nextZ && (e.nextZ.prevZ = e.prevZ)
        }
        function tc(e, t, n) {
            this.i = e,
            this.x = t,
            this.y = n,
            this.prev = null,
            this.next = null,
            this.z = 0,
            this.prevZ = null,
            this.nextZ = null,
            this.steiner = !1
        }
        class nc {
            static area(e) {
                const t = e.length;
                let n = 0;
                for (let i = t - 1, r = 0; r < t; i = r++)
                    n += e[i].x * e[r].y - e[r].x * e[i].y;
                return .5 * n
            }
            static isClockWise(e) {
                return nc.area(e) < 0
            }
            static triangulateShape(e, t) {
                const n = []
                  , i = []
                  , r = [];
                ic(e),
                rc(n, e);
                let s = e.length;
                t.forEach(ic);
                for (let e = 0; e < t.length; e++)
                    i.push(s),
                    s += t[e].length,
                    rc(n, t[e]);
                const a = Rl(n, i);
                for (let e = 0; e < a.length; e += 3)
                    r.push(a.slice(e, e + 3));
                return r
            }
        }
        function ic(e) {
            const t = e.length;
            t > 2 && e[t - 1].equals(e[0]) && e.pop()
        }
        function rc(e, t) {
            for (let n = 0; n < t.length; n++)
                e.push(t[n].x),
                e.push(t[n].y)
        }
        class sc extends Zi {
            constructor(e=1, t=32, n=16, i=0, r=2 * Math.PI, s=0, a=Math.PI) {
                super(),
                this.type = "SphereGeometry",
                this.parameters = {
                    radius: e,
                    widthSegments: t,
                    heightSegments: n,
                    phiStart: i,
                    phiLength: r,
                    thetaStart: s,
                    thetaLength: a
                },
                t = Math.max(3, Math.floor(t)),
                n = Math.max(2, Math.floor(n));
                const o = Math.min(s + a, Math.PI);
                let l = 0;
                const c = []
                  , u = new on
                  , h = new on
                  , d = []
                  , p = []
                  , f = []
                  , A = [];
                for (let d = 0; d <= n; d++) {
                    const g = []
                      , m = d / n;
                    let v = 0;
                    0 === d && 0 === s ? v = .5 / t : d === n && o === Math.PI && (v = -.5 / t);
                    for (let n = 0; n <= t; n++) {
                        const o = n / t;
                        u.x = -e * Math.cos(i + o * r) * Math.sin(s + m * a),
                        u.y = e * Math.cos(s + m * a),
                        u.z = e * Math.sin(i + o * r) * Math.sin(s + m * a),
                        p.push(u.x, u.y, u.z),
                        h.copy(u).normalize(),
                        f.push(h.x, h.y, h.z),
                        A.push(o + v, 1 - m),
                        g.push(l++)
                    }
                    c.push(g)
                }
                for (let e = 0; e < n; e++)
                    for (let i = 0; i < t; i++) {
                        const t = c[e][i + 1]
                          , r = c[e][i]
                          , a = c[e + 1][i]
                          , l = c[e + 1][i + 1];
                        (0 !== e || s > 0) && d.push(t, r, l),
                        (e !== n - 1 || o < Math.PI) && d.push(r, a, l)
                    }
                this.setIndex(d),
                this.setAttribute("position", new Vi(p,3)),
                this.setAttribute("normal", new Vi(f,3)),
                this.setAttribute("uv", new Vi(A,2))
            }
            copy(e) {
                return super.copy(e),
                this.parameters = Object.assign({}, e.parameters),
                this
            }
            static fromJSON(e) {
                return new sc(e.radius,e.widthSegments,e.heightSegments,e.phiStart,e.phiLength,e.thetaStart,e.thetaLength)
            }
        }
        class ac extends Zi {
            constructor(e=1, t=.4, n=12, i=48, r=2 * Math.PI) {
                super(),
                this.type = "TorusGeometry",
                this.parameters = {
                    radius: e,
                    tube: t,
                    radialSegments: n,
                    tubularSegments: i,
                    arc: r
                },
                n = Math.floor(n),
                i = Math.floor(i);
                const s = []
                  , a = []
                  , o = []
                  , l = []
                  , c = new on
                  , u = new on
                  , h = new on;
                for (let s = 0; s <= n; s++)
                    for (let d = 0; d <= i; d++) {
                        const p = d / i * r
                          , f = s / n * Math.PI * 2;
                        u.x = (e + t * Math.cos(f)) * Math.cos(p),
                        u.y = (e + t * Math.cos(f)) * Math.sin(p),
                        u.z = t * Math.sin(f),
                        a.push(u.x, u.y, u.z),
                        c.x = e * Math.cos(p),
                        c.y = e * Math.sin(p),
                        h.subVectors(u, c).normalize(),
                        o.push(h.x, h.y, h.z),
                        l.push(d / i),
                        l.push(s / n)
                    }
                for (let e = 1; e <= n; e++)
                    for (let t = 1; t <= i; t++) {
                        const n = (i + 1) * e + t - 1
                          , r = (i + 1) * (e - 1) + t - 1
                          , a = (i + 1) * (e - 1) + t
                          , o = (i + 1) * e + t;
                        s.push(n, r, o),
                        s.push(r, a, o)
                    }
                this.setIndex(s),
                this.setAttribute("position", new Vi(a,3)),
                this.setAttribute("normal", new Vi(o,3)),
                this.setAttribute("uv", new Vi(l,2))
            }
            copy(e) {
                return super.copy(e),
                this.parameters = Object.assign({}, e.parameters),
                this
            }
            static fromJSON(e) {
                return new ac(e.radius,e.tube,e.radialSegments,e.tubularSegments,e.arc)
            }
        }
        class oc extends Di {
            static get type() {
                return "MeshStandardMaterial"
            }
            constructor(e) {
                super(),
                this.isMeshStandardMaterial = !0,
                this.defines = {
                    STANDARD: ""
                },
                this.color = new Ti(16777215),
                this.roughness = 1,
                this.metalness = 0,
                this.map = null,
                this.lightMap = null,
                this.lightMapIntensity = 1,
                this.aoMap = null,
                this.aoMapIntensity = 1,
                this.emissive = new Ti(0),
                this.emissiveIntensity = 1,
                this.emissiveMap = null,
                this.bumpMap = null,
                this.bumpScale = 1,
                this.normalMap = null,
                this.normalMapType = 0,
                this.normalScale = new Rt(1,1),
                this.displacementMap = null,
                this.displacementScale = 1,
                this.displacementBias = 0,
                this.roughnessMap = null,
                this.metalnessMap = null,
                this.alphaMap = null,
                this.envMap = null,
                this.envMapRotation = new qn,
                this.envMapIntensity = 1,
                this.wireframe = !1,
                this.wireframeLinewidth = 1,
                this.wireframeLinecap = "round",
                this.wireframeLinejoin = "round",
                this.flatShading = !1,
                this.fog = !0,
                this.setValues(e)
            }
            copy(e) {
                return super.copy(e),
                this.defines = {
                    STANDARD: ""
                },
                this.color.copy(e.color),
                this.roughness = e.roughness,
                this.metalness = e.metalness,
                this.map = e.map,
                this.lightMap = e.lightMap,
                this.lightMapIntensity = e.lightMapIntensity,
                this.aoMap = e.aoMap,
                this.aoMapIntensity = e.aoMapIntensity,
                this.emissive.copy(e.emissive),
                this.emissiveMap = e.emissiveMap,
                this.emissiveIntensity = e.emissiveIntensity,
                this.bumpMap = e.bumpMap,
                this.bumpScale = e.bumpScale,
                this.normalMap = e.normalMap,
                this.normalMapType = e.normalMapType,
                this.normalScale.copy(e.normalScale),
                this.displacementMap = e.displacementMap,
                this.displacementScale = e.displacementScale,
                this.displacementBias = e.displacementBias,
                this.roughnessMap = e.roughnessMap,
                this.metalnessMap = e.metalnessMap,
                this.alphaMap = e.alphaMap,
                this.envMap = e.envMap,
                this.envMapRotation.copy(e.envMapRotation),
                this.envMapIntensity = e.envMapIntensity,
                this.wireframe = e.wireframe,
                this.wireframeLinewidth = e.wireframeLinewidth,
                this.wireframeLinecap = e.wireframeLinecap,
                this.wireframeLinejoin = e.wireframeLinejoin,
                this.flatShading = e.flatShading,
                this.fog = e.fog,
                this
            }
        }
        class lc extends oc {
            static get type() {
                return "MeshPhysicalMaterial"
            }
            constructor(e) {
                super(),
                this.isMeshPhysicalMaterial = !0,
                this.defines = {
                    STANDARD: "",
                    PHYSICAL: ""
                },
                this.anisotropyRotation = 0,
                this.anisotropyMap = null,
                this.clearcoatMap = null,
                this.clearcoatRoughness = 0,
                this.clearcoatRoughnessMap = null,
                this.clearcoatNormalScale = new Rt(1,1),
                this.clearcoatNormalMap = null,
                this.ior = 1.5,
                Object.defineProperty(this, "reflectivity", {
                    get: function() {
                        return Ct(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1)
                    },
                    set: function(e) {
                        this.ior = (1 + .4 * e) / (1 - .4 * e)
                    }
                }),
                this.iridescenceMap = null,
                this.iridescenceIOR = 1.3,
                this.iridescenceThicknessRange = [100, 400],
                this.iridescenceThicknessMap = null,
                this.sheenColor = new Ti(0),
                this.sheenColorMap = null,
                this.sheenRoughness = 1,
                this.sheenRoughnessMap = null,
                this.transmissionMap = null,
                this.thickness = 0,
                this.thicknessMap = null,
                this.attenuationDistance = 1 / 0,
                this.attenuationColor = new Ti(1,1,1),
                this.specularIntensity = 1,
                this.specularIntensityMap = null,
                this.specularColor = new Ti(1,1,1),
                this.specularColorMap = null,
                this._anisotropy = 0,
                this._clearcoat = 0,
                this._dispersion = 0,
                this._iridescence = 0,
                this._sheen = 0,
                this._transmission = 0,
                this.setValues(e)
            }
            get anisotropy() {
                return this._anisotropy
            }
            set anisotropy(e) {
                this._anisotropy > 0 != e > 0 && this.version++,
                this._anisotropy = e
            }
            get clearcoat() {
                return this._clearcoat
            }
            set clearcoat(e) {
                this._clearcoat > 0 != e > 0 && this.version++,
                this._clearcoat = e
            }
            get iridescence() {
                return this._iridescence
            }
            set iridescence(e) {
                this._iridescence > 0 != e > 0 && this.version++,
                this._iridescence = e
            }
            get dispersion() {
                return this._dispersion
            }
            set dispersion(e) {
                this._dispersion > 0 != e > 0 && this.version++,
                this._dispersion = e
            }
            get sheen() {
                return this._sheen
            }
            set sheen(e) {
                this._sheen > 0 != e > 0 && this.version++,
                this._sheen = e
            }
            get transmission() {
                return this._transmission
            }
            set transmission(e) {
                this._transmission > 0 != e > 0 && this.version++,
                this._transmission = e
            }
            copy(e) {
                return super.copy(e),
                this.defines = {
                    STANDARD: "",
                    PHYSICAL: ""
                },
                this.anisotropy = e.anisotropy,
                this.anisotropyRotation = e.anisotropyRotation,
                this.anisotropyMap = e.anisotropyMap,
                this.clearcoat = e.clearcoat,
                this.clearcoatMap = e.clearcoatMap,
                this.clearcoatRoughness = e.clearcoatRoughness,
                this.clearcoatRoughnessMap = e.clearcoatRoughnessMap,
                this.clearcoatNormalMap = e.clearcoatNormalMap,
                this.clearcoatNormalScale.copy(e.clearcoatNormalScale),
                this.dispersion = e.dispersion,
                this.ior = e.ior,
                this.iridescence = e.iridescence,
                this.iridescenceMap = e.iridescenceMap,
                this.iridescenceIOR = e.iridescenceIOR,
                this.iridescenceThicknessRange = [...e.iridescenceThicknessRange],
                this.iridescenceThicknessMap = e.iridescenceThicknessMap,
                this.sheen = e.sheen,
                this.sheenColor.copy(e.sheenColor),
                this.sheenColorMap = e.sheenColorMap,
                this.sheenRoughness = e.sheenRoughness,
                this.sheenRoughnessMap = e.sheenRoughnessMap,
                this.transmission = e.transmission,
                this.transmissionMap = e.transmissionMap,
                this.thickness = e.thickness,
                this.thicknessMap = e.thicknessMap,
                this.attenuationDistance = e.attenuationDistance,
                this.attenuationColor.copy(e.attenuationColor),
                this.specularIntensity = e.specularIntensity,
                this.specularIntensityMap = e.specularIntensityMap,
                this.specularColor.copy(e.specularColor),
                this.specularColorMap = e.specularColorMap,
                this
            }
        }
        class cc extends Di {
            static get type() {
                return "MeshPhongMaterial"
            }
            constructor(e) {
                super(),
                this.isMeshPhongMaterial = !0,
                this.color = new Ti(16777215),
                this.specular = new Ti(1118481),
                this.shininess = 30,
                this.map = null,
                this.lightMap = null,
                this.lightMapIntensity = 1,
                this.aoMap = null,
                this.aoMapIntensity = 1,
                this.emissive = new Ti(0),
                this.emissiveIntensity = 1,
                this.emissiveMap = null,
                this.bumpMap = null,
                this.bumpScale = 1,
                this.normalMap = null,
                this.normalMapType = 0,
                this.normalScale = new Rt(1,1),
                this.displacementMap = null,
                this.displacementScale = 1,
                this.displacementBias = 0,
                this.specularMap = null,
                this.alphaMap = null,
                this.envMap = null,
                this.envMapRotation = new qn,
                this.combine = x,
                this.reflectivity = 1,
                this.refractionRatio = .98,
                this.wireframe = !1,
                this.wireframeLinewidth = 1,
                this.wireframeLinecap = "round",
                this.wireframeLinejoin = "round",
                this.flatShading = !1,
                this.fog = !0,
                this.setValues(e)
            }
            copy(e) {
                return super.copy(e),
                this.color.copy(e.color),
                this.specular.copy(e.specular),
                this.shininess = e.shininess,
                this.map = e.map,
                this.lightMap = e.lightMap,
                this.lightMapIntensity = e.lightMapIntensity,
                this.aoMap = e.aoMap,
                this.aoMapIntensity = e.aoMapIntensity,
                this.emissive.copy(e.emissive),
                this.emissiveMap = e.emissiveMap,
                this.emissiveIntensity = e.emissiveIntensity,
                this.bumpMap = e.bumpMap,
                this.bumpScale = e.bumpScale,
                this.normalMap = e.normalMap,
                this.normalMapType = e.normalMapType,
                this.normalScale.copy(e.normalScale),
                this.displacementMap = e.displacementMap,
                this.displacementScale = e.displacementScale,
                this.displacementBias = e.displacementBias,
                this.specularMap = e.specularMap,
                this.alphaMap = e.alphaMap,
                this.envMap = e.envMap,
                this.envMapRotation.copy(e.envMapRotation),
                this.combine = e.combine,
                this.reflectivity = e.reflectivity,
                this.refractionRatio = e.refractionRatio,
                this.wireframe = e.wireframe,
                this.wireframeLinewidth = e.wireframeLinewidth,
                this.wireframeLinecap = e.wireframeLinecap,
                this.wireframeLinejoin = e.wireframeLinejoin,
                this.flatShading = e.flatShading,
                this.fog = e.fog,
                this
            }
        }
        class uc extends Di {
            static get type() {
                return "MeshNormalMaterial"
            }
            constructor(e) {
                super(),
                this.isMeshNormalMaterial = !0,
                this.bumpMap = null,
                this.bumpScale = 1,
                this.normalMap = null,
                this.normalMapType = 0,
                this.normalScale = new Rt(1,1),
                this.displacementMap = null,
                this.displacementScale = 1,
                this.displacementBias = 0,
                this.wireframe = !1,
                this.wireframeLinewidth = 1,
                this.flatShading = !1,
                this.setValues(e)
            }
            copy(e) {
                return super.copy(e),
                this.bumpMap = e.bumpMap,
                this.bumpScale = e.bumpScale,
                this.normalMap = e.normalMap,
                this.normalMapType = e.normalMapType,
                this.normalScale.copy(e.normalScale),
                this.displacementMap = e.displacementMap,
                this.displacementScale = e.displacementScale,
                this.displacementBias = e.displacementBias,
                this.wireframe = e.wireframe,
                this.wireframeLinewidth = e.wireframeLinewidth,
                this.flatShading = e.flatShading,
                this
            }
        }
        class hc extends Di {
            static get type() {
                return "MeshLambertMaterial"
            }
            constructor(e) {
                super(),
                this.isMeshLambertMaterial = !0,
                this.color = new Ti(16777215),
                this.map = null,
                this.lightMap = null,
                this.lightMapIntensity = 1,
                this.aoMap = null,
                this.aoMapIntensity = 1,
                this.emissive = new Ti(0),
                this.emissiveIntensity = 1,
                this.emissiveMap = null,
                this.bumpMap = null,
                this.bumpScale = 1,
                this.normalMap = null,
                this.normalMapType = 0,
                this.normalScale = new Rt(1,1),
                this.displacementMap = null,
                this.displacementScale = 1,
                this.displacementBias = 0,
                this.specularMap = null,
                this.alphaMap = null,
                this.envMap = null,
                this.envMapRotation = new qn,
                this.combine = x,
                this.reflectivity = 1,
                this.refractionRatio = .98,
                this.wireframe = !1,
                this.wireframeLinewidth = 1,
                this.wireframeLinecap = "round",
                this.wireframeLinejoin = "round",
                this.flatShading = !1,
                this.fog = !0,
                this.setValues(e)
            }
            copy(e) {
                return super.copy(e),
                this.color.copy(e.color),
                this.map = e.map,
                this.lightMap = e.lightMap,
                this.lightMapIntensity = e.lightMapIntensity,
                this.aoMap = e.aoMap,
                this.aoMapIntensity = e.aoMapIntensity,
                this.emissive.copy(e.emissive),
                this.emissiveMap = e.emissiveMap,
                this.emissiveIntensity = e.emissiveIntensity,
                this.bumpMap = e.bumpMap,
                this.bumpScale = e.bumpScale,
                this.normalMap = e.normalMap,
                this.normalMapType = e.normalMapType,
                this.normalScale.copy(e.normalScale),
                this.displacementMap = e.displacementMap,
                this.displacementScale = e.displacementScale,
                this.displacementBias = e.displacementBias,
                this.specularMap = e.specularMap,
                this.alphaMap = e.alphaMap,
                this.envMap = e.envMap,
                this.envMapRotation.copy(e.envMapRotation),
                this.combine = e.combine,
                this.reflectivity = e.reflectivity,
                this.refractionRatio = e.refractionRatio,
                this.wireframe = e.wireframe,
                this.wireframeLinewidth = e.wireframeLinewidth,
                this.wireframeLinecap = e.wireframeLinecap,
                this.wireframeLinejoin = e.wireframeLinejoin,
                this.flatShading = e.flatShading,
                this.fog = e.fog,
                this
            }
        }
        function dc(e, t, n) {
            return !e || !n && e.constructor === t ? e : "number" == typeof t.BYTES_PER_ELEMENT ? new t(e) : Array.prototype.slice.call(e)
        }
        function pc(e) {
            return ArrayBuffer.isView(e) && !(e instanceof DataView)
        }
        function fc(e) {
            const t = e.length
              , n = new Array(t);
            for (let e = 0; e !== t; ++e)
                n[e] = e;
            return n.sort((function(t, n) {
                return e[t] - e[n]
            }
            )),
            n
        }
        function Ac(e, t, n) {
            const i = e.length
              , r = new e.constructor(i);
            for (let s = 0, a = 0; a !== i; ++s) {
                const i = n[s] * t;
                for (let n = 0; n !== t; ++n)
                    r[a++] = e[i + n]
            }
            return r
        }
        function gc(e, t, n, i) {
            let r = 1
              , s = e[0];
            for (; void 0 !== s && void 0 === s[i]; )
                s = e[r++];
            if (void 0 === s)
                return;
            let a = s[i];
            if (void 0 !== a)
                if (Array.isArray(a))
                    do {
                        a = s[i],
                        void 0 !== a && (t.push(s.time),
                        n.push.apply(n, a)),
                        s = e[r++]
                    } while (void 0 !== s);
                else if (void 0 !== a.toArray)
                    do {
                        a = s[i],
                        void 0 !== a && (t.push(s.time),
                        a.toArray(n, n.length)),
                        s = e[r++]
                    } while (void 0 !== s);
                else
                    do {
                        a = s[i],
                        void 0 !== a && (t.push(s.time),
                        n.push(a)),
                        s = e[r++]
                    } while (void 0 !== s)
        }
        class mc {
            constructor(e, t, n, i) {
                this.parameterPositions = e,
                this._cachedIndex = 0,
                this.resultBuffer = void 0 !== i ? i : new t.constructor(n),
                this.sampleValues = t,
                this.valueSize = n,
                this.settings = null,
                this.DefaultSettings_ = {}
            }
            evaluate(e) {
                const t = this.parameterPositions;
                let n = this._cachedIndex
                  , i = t[n]
                  , r = t[n - 1];
                e: {
                    t: {
                        let s;
                        n: {
                            i: if (!(e < i)) {
                                for (let s = n + 2; ; ) {
                                    if (void 0 === i) {
                                        if (e < r)
                                            break i;
                                        return n = t.length,
                                        this._cachedIndex = n,
                                        this.copySampleValue_(n - 1)
                                    }
                                    if (n === s)
                                        break;
                                    if (r = i,
                                    i = t[++n],
                                    e < i)
                                        break t
                                }
                                s = t.length;
                                break n
                            }
                            if (e >= r)
                                break e;
                            {
                                const a = t[1];
                                e < a && (n = 2,
                                r = a);
                                for (let s = n - 2; ; ) {
                                    if (void 0 === r)
                                        return this._cachedIndex = 0,
                                        this.copySampleValue_(0);
                                    if (n === s)
                                        break;
                                    if (i = r,
                                    r = t[--n - 1],
                                    e >= r)
                                        break t
                                }
                                s = n,
                                n = 0
                            }
                        }
                        for (; n < s; ) {
                            const i = n + s >>> 1;
                            e < t[i] ? s = i : n = i + 1
                        }
                        if (i = t[n],
                        r = t[n - 1],
                        void 0 === r)
                            return this._cachedIndex = 0,
                            this.copySampleValue_(0);
                        if (void 0 === i)
                            return n = t.length,
                            this._cachedIndex = n,
                            this.copySampleValue_(n - 1)
                    }
                    this._cachedIndex = n,
                    this.intervalChanged_(n, r, i)
                }
                return this.interpolate_(n, r, e, i)
            }
            getSettings_() {
                return this.settings || this.DefaultSettings_
            }
            copySampleValue_(e) {
                const t = this.resultBuffer
                  , n = this.sampleValues
                  , i = this.valueSize
                  , r = e * i;
                for (let e = 0; e !== i; ++e)
                    t[e] = n[r + e];
                return t
            }
            interpolate_() {
                throw new Error("call to abstract method")
            }
            intervalChanged_() {}
        }
        class vc extends mc {
            constructor(e, t, n, i) {
                super(e, t, n, i),
                this._weightPrev = -0,
                this._offsetPrev = -0,
                this._weightNext = -0,
                this._offsetNext = -0,
                this.DefaultSettings_ = {
                    endingStart: $e,
                    endingEnd: $e
                }
            }
            intervalChanged_(e, t, n) {
                const i = this.parameterPositions;
                let r = e - 2
                  , s = e + 1
                  , a = i[r]
                  , o = i[s];
                if (void 0 === a)
                    switch (this.getSettings_().endingStart) {
                    case et:
                        r = e,
                        a = 2 * t - n;
                        break;
                    case tt:
                        r = i.length - 2,
                        a = t + i[r] - i[r + 1];
                        break;
                    default:
                        r = e,
                        a = n
                    }
                if (void 0 === o)
                    switch (this.getSettings_().endingEnd) {
                    case et:
                        s = e,
                        o = 2 * n - t;
                        break;
                    case tt:
                        s = 1,
                        o = n + i[1] - i[0];
                        break;
                    default:
                        s = e - 1,
                        o = t
                    }
                const l = .5 * (n - t)
                  , c = this.valueSize;
                this._weightPrev = l / (t - a),
                this._weightNext = l / (o - n),
                this._offsetPrev = r * c,
                this._offsetNext = s * c
            }
            interpolate_(e, t, n, i) {
                const r = this.resultBuffer
                  , s = this.sampleValues
                  , a = this.valueSize
                  , o = e * a
                  , l = o - a
                  , c = this._offsetPrev
                  , u = this._offsetNext
                  , h = this._weightPrev
                  , d = this._weightNext
                  , p = (n - t) / (i - t)
                  , f = p * p
                  , A = f * p
                  , g = -h * A + 2 * h * f - h * p
                  , m = (1 + h) * A + (-1.5 - 2 * h) * f + (-.5 + h) * p + 1
                  , v = (-1 - d) * A + (1.5 + d) * f + .5 * p
                  , y = d * A - d * f;
                for (let e = 0; e !== a; ++e)
                    r[e] = g * s[c + e] + m * s[l + e] + v * s[o + e] + y * s[u + e];
                return r
            }
        }
        class yc extends mc {
            constructor(e, t, n, i) {
                super(e, t, n, i)
            }
            interpolate_(e, t, n, i) {
                const r = this.resultBuffer
                  , s = this.sampleValues
                  , a = this.valueSize
                  , o = e * a
                  , l = o - a
                  , c = (n - t) / (i - t)
                  , u = 1 - c;
                for (let e = 0; e !== a; ++e)
                    r[e] = s[l + e] * u + s[o + e] * c;
                return r
            }
        }
        class xc extends mc {
            constructor(e, t, n, i) {
                super(e, t, n, i)
            }
            interpolate_(e) {
                return this.copySampleValue_(e - 1)
            }
        }
        class _c {
            constructor(e, t, n, i) {
                if (void 0 === e)
                    throw new Error("THREE.KeyframeTrack: track name is undefined");
                if (void 0 === t || 0 === t.length)
                    throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
                this.name = e,
                this.times = dc(t, this.TimeBufferType),
                this.values = dc(n, this.ValueBufferType),
                this.setInterpolation(i || this.DefaultInterpolation)
            }
            static toJSON(e) {
                const t = e.constructor;
                let n;
                if (t.toJSON !== this.toJSON)
                    n = t.toJSON(e);
                else {
                    n = {
                        name: e.name,
                        times: dc(e.times, Array),
                        values: dc(e.values, Array)
                    };
                    const t = e.getInterpolation();
                    t !== e.DefaultInterpolation && (n.interpolation = t)
                }
                return n.type = e.ValueTypeName,
                n
            }
            InterpolantFactoryMethodDiscrete(e) {
                return new xc(this.times,this.values,this.getValueSize(),e)
            }
            InterpolantFactoryMethodLinear(e) {
                return new yc(this.times,this.values,this.getValueSize(),e)
            }
            InterpolantFactoryMethodSmooth(e) {
                return new vc(this.times,this.values,this.getValueSize(),e)
            }
            setInterpolation(e) {
                let t;
                switch (e) {
                case Ke:
                    t = this.InterpolantFactoryMethodDiscrete;
                    break;
                case Je:
                    t = this.InterpolantFactoryMethodLinear;
                    break;
                case Ze:
                    t = this.InterpolantFactoryMethodSmooth
                }
                if (void 0 === t) {
                    const t = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
                    if (void 0 === this.createInterpolant) {
                        if (e === this.DefaultInterpolation)
                            throw new Error(t);
                        this.setInterpolation(this.DefaultInterpolation)
                    }
                    return console.warn("THREE.KeyframeTrack:", t),
                    this
                }
                return this.createInterpolant = t,
                this
            }
            getInterpolation() {
                switch (this.createInterpolant) {
                case this.InterpolantFactoryMethodDiscrete:
                    return Ke;
                case this.InterpolantFactoryMethodLinear:
                    return Je;
                case this.InterpolantFactoryMethodSmooth:
                    return Ze
                }
            }
            getValueSize() {
                return this.values.length / this.times.length
            }
            shift(e) {
                if (0 !== e) {
                    const t = this.times;
                    for (let n = 0, i = t.length; n !== i; ++n)
                        t[n] += e
                }
                return this
            }
            scale(e) {
                if (1 !== e) {
                    const t = this.times;
                    for (let n = 0, i = t.length; n !== i; ++n)
                        t[n] *= e
                }
                return this
            }
            trim(e, t) {
                const n = this.times
                  , i = n.length;
                let r = 0
                  , s = i - 1;
                for (; r !== i && n[r] < e; )
                    ++r;
                for (; -1 !== s && n[s] > t; )
                    --s;
                if (++s,
                0 !== r || s !== i) {
                    r >= s && (s = Math.max(s, 1),
                    r = s - 1);
                    const e = this.getValueSize();
                    this.times = n.slice(r, s),
                    this.values = this.values.slice(r * e, s * e)
                }
                return this
            }
            validate() {
                let e = !0;
                const t = this.getValueSize();
                t - Math.floor(t) != 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this),
                e = !1);
                const n = this.times
                  , i = this.values
                  , r = n.length;
                0 === r && (console.error("THREE.KeyframeTrack: Track is empty.", this),
                e = !1);
                let s = null;
                for (let t = 0; t !== r; t++) {
                    const i = n[t];
                    if ("number" == typeof i && isNaN(i)) {
                        console.error("THREE.KeyframeTrack: Time is not a valid number.", this, t, i),
                        e = !1;
                        break
                    }
                    if (null !== s && s > i) {
                        console.error("THREE.KeyframeTrack: Out of order keys.", this, t, i, s),
                        e = !1;
                        break
                    }
                    s = i
                }
                if (void 0 !== i && pc(i))
                    for (let t = 0, n = i.length; t !== n; ++t) {
                        const n = i[t];
                        if (isNaN(n)) {
                            console.error("THREE.KeyframeTrack: Value is not a valid number.", this, t, n),
                            e = !1;
                            break
                        }
                    }
                return e
            }
            optimize() {
                const e = this.times.slice()
                  , t = this.values.slice()
                  , n = this.getValueSize()
                  , i = this.getInterpolation() === Ze
                  , r = e.length - 1;
                let s = 1;
                for (let a = 1; a < r; ++a) {
                    let r = !1;
                    const o = e[a];
                    if (o !== e[a + 1] && (1 !== a || o !== e[0]))
                        if (i)
                            r = !0;
                        else {
                            const e = a * n
                              , i = e - n
                              , s = e + n;
                            for (let a = 0; a !== n; ++a) {
                                const n = t[e + a];
                                if (n !== t[i + a] || n !== t[s + a]) {
                                    r = !0;
                                    break
                                }
                            }
                        }
                    if (r) {
                        if (a !== s) {
                            e[s] = e[a];
                            const i = a * n
                              , r = s * n;
                            for (let e = 0; e !== n; ++e)
                                t[r + e] = t[i + e]
                        }
                        ++s
                    }
                }
                if (r > 0) {
                    e[s] = e[r];
                    for (let e = r * n, i = s * n, a = 0; a !== n; ++a)
                        t[i + a] = t[e + a];
                    ++s
                }
                return s !== e.length ? (this.times = e.slice(0, s),
                this.values = t.slice(0, s * n)) : (this.times = e,
                this.values = t),
                this
            }
            clone() {
                const e = this.times.slice()
                  , t = this.values.slice()
                  , n = new (0,
                this.constructor)(this.name,e,t);
                return n.createInterpolant = this.createInterpolant,
                n
            }
        }
        _c.prototype.TimeBufferType = Float32Array,
        _c.prototype.ValueBufferType = Float32Array,
        _c.prototype.DefaultInterpolation = Je;
        class bc extends _c {
            constructor(e, t, n) {
                super(e, t, n)
            }
        }
        bc.prototype.ValueTypeName = "bool",
        bc.prototype.ValueBufferType = Array,
        bc.prototype.DefaultInterpolation = Ke,
        bc.prototype.InterpolantFactoryMethodLinear = void 0,
        bc.prototype.InterpolantFactoryMethodSmooth = void 0;
        class Ec extends _c {
        }
        Ec.prototype.ValueTypeName = "color";
        class wc extends _c {
        }
        wc.prototype.ValueTypeName = "number";
        class Cc extends mc {
            constructor(e, t, n, i) {
                super(e, t, n, i)
            }
            interpolate_(e, t, n, i) {
                const r = this.resultBuffer
                  , s = this.sampleValues
                  , a = this.valueSize
                  , o = (n - t) / (i - t);
                let l = e * a;
                for (let e = l + a; l !== e; l += 4)
                    an.slerpFlat(r, 0, s, l - a, s, l, o);
                return r
            }
        }
        class Ic extends _c {
            InterpolantFactoryMethodLinear(e) {
                return new Cc(this.times,this.values,this.getValueSize(),e)
            }
        }
        Ic.prototype.ValueTypeName = "quaternion",
        Ic.prototype.InterpolantFactoryMethodSmooth = void 0;
        class Sc extends _c {
            constructor(e, t, n) {
                super(e, t, n)
            }
        }
        Sc.prototype.ValueTypeName = "string",
        Sc.prototype.ValueBufferType = Array,
        Sc.prototype.DefaultInterpolation = Ke,
        Sc.prototype.InterpolantFactoryMethodLinear = void 0,
        Sc.prototype.InterpolantFactoryMethodSmooth = void 0;
        class Mc extends _c {
        }
        Mc.prototype.ValueTypeName = "vector";
        class Tc {
            constructor(e="", t=-1, n=[], i=nt) {
                this.name = e,
                this.tracks = n,
                this.duration = t,
                this.blendMode = i,
                this.uuid = wt(),
                this.duration < 0 && this.resetDuration()
            }
            static parse(e) {
                const t = []
                  , n = e.tracks
                  , i = 1 / (e.fps || 1);
                for (let e = 0, r = n.length; e !== r; ++e)
                    t.push(Bc(n[e]).scale(i));
                const r = new this(e.name,e.duration,t,e.blendMode);
                return r.uuid = e.uuid,
                r
            }
            static toJSON(e) {
                const t = []
                  , n = e.tracks
                  , i = {
                    name: e.name,
                    duration: e.duration,
                    tracks: t,
                    uuid: e.uuid,
                    blendMode: e.blendMode
                };
                for (let e = 0, i = n.length; e !== i; ++e)
                    t.push(_c.toJSON(n[e]));
                return i
            }
            static CreateFromMorphTargetSequence(e, t, n, i) {
                const r = t.length
                  , s = [];
                for (let e = 0; e < r; e++) {
                    let a = []
                      , o = [];
                    a.push((e + r - 1) % r, e, (e + 1) % r),
                    o.push(0, 1, 0);
                    const l = fc(a);
                    a = Ac(a, 1, l),
                    o = Ac(o, 1, l),
                    i || 0 !== a[0] || (a.push(r),
                    o.push(o[0])),
                    s.push(new wc(".morphTargetInfluences[" + t[e].name + "]",a,o).scale(1 / n))
                }
                return new this(e,-1,s)
            }
            static findByName(e, t) {
                let n = e;
                if (!Array.isArray(e)) {
                    const t = e;
                    n = t.geometry && t.geometry.animations || t.animations
                }
                for (let e = 0; e < n.length; e++)
                    if (n[e].name === t)
                        return n[e];
                return null
            }
            static CreateClipsFromMorphTargetSequences(e, t, n) {
                const i = {}
                  , r = /^([\w-]*?)([\d]+)$/;
                for (let t = 0, n = e.length; t < n; t++) {
                    const n = e[t]
                      , s = n.name.match(r);
                    if (s && s.length > 1) {
                        const e = s[1];
                        let t = i[e];
                        t || (i[e] = t = []),
                        t.push(n)
                    }
                }
                const s = [];
                for (const e in i)
                    s.push(this.CreateFromMorphTargetSequence(e, i[e], t, n));
                return s
            }
            static parseAnimation(e, t) {
                if (!e)
                    return console.error("THREE.AnimationClip: No animation in JSONLoader data."),
                    null;
                const n = function(e, t, n, i, r) {
                    if (0 !== n.length) {
                        const s = []
                          , a = [];
                        gc(n, s, a, i),
                        0 !== s.length && r.push(new e(t,s,a))
                    }
                }
                  , i = []
                  , r = e.name || "default"
                  , s = e.fps || 30
                  , a = e.blendMode;
                let o = e.length || -1;
                const l = e.hierarchy || [];
                for (let e = 0; e < l.length; e++) {
                    const r = l[e].keys;
                    if (r && 0 !== r.length)
                        if (r[0].morphTargets) {
                            const e = {};
                            let t;
                            for (t = 0; t < r.length; t++)
                                if (r[t].morphTargets)
                                    for (let n = 0; n < r[t].morphTargets.length; n++)
                                        e[r[t].morphTargets[n]] = -1;
                            for (const n in e) {
                                const e = []
                                  , s = [];
                                for (let i = 0; i !== r[t].morphTargets.length; ++i) {
                                    const i = r[t];
                                    e.push(i.time),
                                    s.push(i.morphTarget === n ? 1 : 0)
                                }
                                i.push(new wc(".morphTargetInfluence[" + n + "]",e,s))
                            }
                            o = e.length * s
                        } else {
                            const s = ".bones[" + t[e].name + "]";
                            n(Mc, s + ".position", r, "pos", i),
                            n(Ic, s + ".quaternion", r, "rot", i),
                            n(Mc, s + ".scale", r, "scl", i)
                        }
                }
                if (0 === i.length)
                    return null;
                return new this(r,o,i,a)
            }
            resetDuration() {
                let e = 0;
                for (let t = 0, n = this.tracks.length; t !== n; ++t) {
                    const n = this.tracks[t];
                    e = Math.max(e, n.times[n.times.length - 1])
                }
                return this.duration = e,
                this
            }
            trim() {
                for (let e = 0; e < this.tracks.length; e++)
                    this.tracks[e].trim(0, this.duration);
                return this
            }
            validate() {
                let e = !0;
                for (let t = 0; t < this.tracks.length; t++)
                    e = e && this.tracks[t].validate();
                return e
            }
            optimize() {
                for (let e = 0; e < this.tracks.length; e++)
                    this.tracks[e].optimize();
                return this
            }
            clone() {
                const e = [];
                for (let t = 0; t < this.tracks.length; t++)
                    e.push(this.tracks[t].clone());
                return new this.constructor(this.name,this.duration,e,this.blendMode)
            }
            toJSON() {
                return this.constructor.toJSON(this)
            }
        }
        function Bc(e) {
            if (void 0 === e.type)
                throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
            const t = function(e) {
                switch (e.toLowerCase()) {
                case "scalar":
                case "double":
                case "float":
                case "number":
                case "integer":
                    return wc;
                case "vector":
                case "vector2":
                case "vector3":
                case "vector4":
                    return Mc;
                case "color":
                    return Ec;
                case "quaternion":
                    return Ic;
                case "bool":
                case "boolean":
                    return bc;
                case "string":
                    return Sc
                }
                throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + e)
            }(e.type);
            if (void 0 === e.times) {
                const t = []
                  , n = [];
                gc(e.keys, t, n, "value"),
                e.times = t,
                e.values = n
            }
            return void 0 !== t.parse ? t.parse(e) : new t(e.name,e.times,e.values,e.interpolation)
        }
        const Rc = {
            enabled: !1,
            files: {},
            add: function(e, t) {
                !1 !== this.enabled && (this.files[e] = t)
            },
            get: function(e) {
                if (!1 !== this.enabled)
                    return this.files[e]
            },
            remove: function(e) {
                delete this.files[e]
            },
            clear: function() {
                this.files = {}
            }
        };
        class Dc {
            constructor(e, t, n) {
                const i = this;
                let r, s = !1, a = 0, o = 0;
                const l = [];
                this.onStart = void 0,
                this.onLoad = e,
                this.onProgress = t,
                this.onError = n,
                this.itemStart = function(e) {
                    o++,
                    !1 === s && void 0 !== i.onStart && i.onStart(e, a, o),
                    s = !0
                }
                ,
                this.itemEnd = function(e) {
                    a++,
                    void 0 !== i.onProgress && i.onProgress(e, a, o),
                    a === o && (s = !1,
                    void 0 !== i.onLoad && i.onLoad())
                }
                ,
                this.itemError = function(e) {
                    void 0 !== i.onError && i.onError(e)
                }
                ,
                this.resolveURL = function(e) {
                    return r ? r(e) : e
                }
                ,
                this.setURLModifier = function(e) {
                    return r = e,
                    this
                }
                ,
                this.addHandler = function(e, t) {
                    return l.push(e, t),
                    this
                }
                ,
                this.removeHandler = function(e) {
                    const t = l.indexOf(e);
                    return -1 !== t && l.splice(t, 2),
                    this
                }
                ,
                this.getHandler = function(e) {
                    for (let t = 0, n = l.length; t < n; t += 2) {
                        const n = l[t]
                          , i = l[t + 1];
                        if (n.global && (n.lastIndex = 0),
                        n.test(e))
                            return i
                    }
                    return null
                }
            }
        }
        const Pc = new Dc;
        class Lc {
            constructor(e) {
                this.manager = void 0 !== e ? e : Pc,
                this.crossOrigin = "anonymous",
                this.withCredentials = !1,
                this.path = "",
                this.resourcePath = "",
                this.requestHeader = {}
            }
            load() {}
            loadAsync(e, t) {
                const n = this;
                return new Promise((function(i, r) {
                    n.load(e, i, t, r)
                }
                ))
            }
            parse() {}
            setCrossOrigin(e) {
                return this.crossOrigin = e,
                this
            }
            setWithCredentials(e) {
                return this.withCredentials = e,
                this
            }
            setPath(e) {
                return this.path = e,
                this
            }
            setResourcePath(e) {
                return this.resourcePath = e,
                this
            }
            setRequestHeader(e) {
                return this.requestHeader = e,
                this
            }
        }
        Lc.DEFAULT_MATERIAL_NAME = "__DEFAULT";
        const Uc = {};
        class Fc extends Error {
            constructor(e, t) {
                super(e),
                this.response = t
            }
        }
        class Nc extends Lc {
            constructor(e) {
                super(e)
            }
            load(e, t, n, i) {
                void 0 === e && (e = ""),
                void 0 !== this.path && (e = this.path + e),
                e = this.manager.resolveURL(e);
                const r = Rc.get(e);
                if (void 0 !== r)
                    return this.manager.itemStart(e),
                    setTimeout(( () => {
                        t && t(r),
                        this.manager.itemEnd(e)
                    }
                    ), 0),
                    r;
                if (void 0 !== Uc[e])
                    return void Uc[e].push({
                        onLoad: t,
                        onProgress: n,
                        onError: i
                    });
                Uc[e] = [],
                Uc[e].push({
                    onLoad: t,
                    onProgress: n,
                    onError: i
                });
                const s = new Request(e,{
                    headers: new Headers(this.requestHeader),
                    credentials: this.withCredentials ? "include" : "same-origin"
                })
                  , a = this.mimeType
                  , o = this.responseType;
                fetch(s).then((t => {
                    if (200 === t.status || 0 === t.status) {
                        if (0 === t.status && console.warn("THREE.FileLoader: HTTP Status 0 received."),
                        "undefined" == typeof ReadableStream || void 0 === t.body || void 0 === t.body.getReader)
                            return t;
                        const n = Uc[e]
                          , i = t.body.getReader()
                          , r = t.headers.get("X-File-Size") || t.headers.get("Content-Length")
                          , s = r ? parseInt(r) : 0
                          , a = 0 !== s;
                        let o = 0;
                        const l = new ReadableStream({
                            start(e) {
                                !function t() {
                                    i.read().then(( ({done: i, value: r}) => {
                                        if (i)
                                            e.close();
                                        else {
                                            o += r.byteLength;
                                            const i = new ProgressEvent("progress",{
                                                lengthComputable: a,
                                                loaded: o,
                                                total: s
                                            });
                                            for (let e = 0, t = n.length; e < t; e++) {
                                                const t = n[e];
                                                t.onProgress && t.onProgress(i)
                                            }
                                            e.enqueue(r),
                                            t()
                                        }
                                    }
                                    ), (t => {
                                        e.error(t)
                                    }
                                    ))
                                }()
                            }
                        });
                        return new Response(l)
                    }
                    throw new Fc(`fetch for "${t.url}" responded with ${t.status}: ${t.statusText}`,t)
                }
                )).then((e => {
                    switch (o) {
                    case "arraybuffer":
                        return e.arrayBuffer();
                    case "blob":
                        return e.blob();
                    case "document":
                        return e.text().then((e => (new DOMParser).parseFromString(e, a)));
                    case "json":
                        return e.json();
                    default:
                        if (void 0 === a)
                            return e.text();
                        {
                            const t = /charset="?([^;"\s]*)"?/i.exec(a)
                              , n = t && t[1] ? t[1].toLowerCase() : void 0
                              , i = new TextDecoder(n);
                            return e.arrayBuffer().then((e => i.decode(e)))
                        }
                    }
                }
                )).then((t => {
                    Rc.add(e, t);
                    const n = Uc[e];
                    delete Uc[e];
                    for (let e = 0, i = n.length; e < i; e++) {
                        const i = n[e];
                        i.onLoad && i.onLoad(t)
                    }
                }
                )).catch((t => {
                    const n = Uc[e];
                    if (void 0 === n)
                        throw this.manager.itemError(e),
                        t;
                    delete Uc[e];
                    for (let e = 0, i = n.length; e < i; e++) {
                        const i = n[e];
                        i.onError && i.onError(t)
                    }
                    this.manager.itemError(e)
                }
                )).finally(( () => {
                    this.manager.itemEnd(e)
                }
                )),
                this.manager.itemStart(e)
            }
            setResponseType(e) {
                return this.responseType = e,
                this
            }
            setMimeType(e) {
                return this.mimeType = e,
                this
            }
        }
        class Oc extends Lc {
            constructor(e) {
                super(e)
            }
            load(e, t, n, i) {
                void 0 !== this.path && (e = this.path + e),
                e = this.manager.resolveURL(e);
                const r = this
                  , s = Rc.get(e);
                if (void 0 !== s)
                    return r.manager.itemStart(e),
                    setTimeout((function() {
                        t && t(s),
                        r.manager.itemEnd(e)
                    }
                    ), 0),
                    s;
                const a = Ut("img");
                function o() {
                    c(),
                    Rc.add(e, this),
                    t && t(this),
                    r.manager.itemEnd(e)
                }
                function l(t) {
                    c(),
                    i && i(t),
                    r.manager.itemError(e),
                    r.manager.itemEnd(e)
                }
                function c() {
                    a.removeEventListener("load", o, !1),
                    a.removeEventListener("error", l, !1)
                }
                return a.addEventListener("load", o, !1),
                a.addEventListener("error", l, !1),
                "data:" !== e.slice(0, 5) && void 0 !== this.crossOrigin && (a.crossOrigin = this.crossOrigin),
                r.manager.itemStart(e),
                a.src = e,
                a
            }
        }
        class Qc extends Lc {
            constructor(e) {
                super(e)
            }
            load(e, t, n, i) {
                const r = this
                  , s = new Vo
                  , a = new Nc(this.manager);
                return a.setResponseType("arraybuffer"),
                a.setRequestHeader(this.requestHeader),
                a.setPath(this.path),
                a.setWithCredentials(r.withCredentials),
                a.load(e, (function(e) {
                    let n;
                    try {
                        n = r.parse(e)
                    } catch (e) {
                        if (void 0 === i)
                            return void console.error(e);
                        i(e)
                    }
                    void 0 !== n.image ? s.image = n.image : void 0 !== n.data && (s.image.width = n.width,
                    s.image.height = n.height,
                    s.image.data = n.data),
                    s.wrapS = void 0 !== n.wrapS ? n.wrapS : O,
                    s.wrapT = void 0 !== n.wrapT ? n.wrapT : O,
                    s.magFilter = void 0 !== n.magFilter ? n.magFilter : z,
                    s.minFilter = void 0 !== n.minFilter ? n.minFilter : z,
                    s.anisotropy = void 0 !== n.anisotropy ? n.anisotropy : 1,
                    void 0 !== n.colorSpace && (s.colorSpace = n.colorSpace),
                    void 0 !== n.flipY && (s.flipY = n.flipY),
                    void 0 !== n.format && (s.format = n.format),
                    void 0 !== n.type && (s.type = n.type),
                    void 0 !== n.mipmaps && (s.mipmaps = n.mipmaps,
                    s.minFilter = W),
                    1 === n.mipmapCount && (s.minFilter = z),
                    void 0 !== n.generateMipmaps && (s.generateMipmaps = n.generateMipmaps),
                    s.needsUpdate = !0,
                    t && t(s, n)
                }
                ), n, i),
                s
            }
        }
        class kc extends Lc {
            constructor(e) {
                super(e)
            }
            load(e, t, n, i) {
                const r = new $t
                  , s = new Oc(this.manager);
                return s.setCrossOrigin(this.crossOrigin),
                s.setPath(this.path),
                s.load(e, (function(e) {
                    r.image = e,
                    r.needsUpdate = !0,
                    void 0 !== t && t(r)
                }
                ), n, i),
                r
            }
        }
        class Gc extends ui {
            constructor(e, t=1) {
                super(),
                this.isLight = !0,
                this.type = "Light",
                this.color = new Ti(e),
                this.intensity = t
            }
            dispose() {}
            copy(e, t) {
                return super.copy(e, t),
                this.color.copy(e.color),
                this.intensity = e.intensity,
                this
            }
            toJSON(e) {
                const t = super.toJSON(e);
                return t.object.color = this.color.getHex(),
                t.object.intensity = this.intensity,
                void 0 !== this.groundColor && (t.object.groundColor = this.groundColor.getHex()),
                void 0 !== this.distance && (t.object.distance = this.distance),
                void 0 !== this.angle && (t.object.angle = this.angle),
                void 0 !== this.decay && (t.object.decay = this.decay),
                void 0 !== this.penumbra && (t.object.penumbra = this.penumbra),
                void 0 !== this.shadow && (t.object.shadow = this.shadow.toJSON()),
                void 0 !== this.target && (t.object.target = this.target.uuid),
                t
            }
        }
        const Hc = new Nn
          , zc = new on
          , Vc = new on;
        class Wc {
            constructor(e) {
                this.camera = e,
                this.intensity = 1,
                this.bias = 0,
                this.normalBias = 0,
                this.radius = 1,
                this.blurSamples = 8,
                this.mapSize = new Rt(512,512),
                this.map = null,
                this.mapPass = null,
                this.matrix = new Nn,
                this.autoUpdate = !0,
                this.needsUpdate = !1,
                this._frustum = new Pr,
                this._frameExtents = new Rt(1,1),
                this._viewportCount = 1,
                this._viewports = [new en(0,0,1,1)]
            }
            getViewportCount() {
                return this._viewportCount
            }
            getFrustum() {
                return this._frustum
            }
            updateMatrices(e) {
                const t = this.camera
                  , n = this.matrix;
                zc.setFromMatrixPosition(e.matrixWorld),
                t.position.copy(zc),
                Vc.setFromMatrixPosition(e.target.matrixWorld),
                t.lookAt(Vc),
                t.updateMatrixWorld(),
                Hc.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse),
                this._frustum.setFromProjectionMatrix(Hc),
                n.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1),
                n.multiply(Hc)
            }
            getViewport(e) {
                return this._viewports[e]
            }
            getFrameExtents() {
                return this._frameExtents
            }
            dispose() {
                this.map && this.map.dispose(),
                this.mapPass && this.mapPass.dispose()
            }
            copy(e) {
                return this.camera = e.camera.clone(),
                this.intensity = e.intensity,
                this.bias = e.bias,
                this.radius = e.radius,
                this.mapSize.copy(e.mapSize),
                this
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            toJSON() {
                const e = {};
                return 1 !== this.intensity && (e.intensity = this.intensity),
                0 !== this.bias && (e.bias = this.bias),
                0 !== this.normalBias && (e.normalBias = this.normalBias),
                1 !== this.radius && (e.radius = this.radius),
                512 === this.mapSize.x && 512 === this.mapSize.y || (e.mapSize = this.mapSize.toArray()),
                e.camera = this.camera.toJSON(!1).object,
                delete e.camera.matrix,
                e
            }
        }
        class jc extends Wc {
            constructor() {
                super(new br(50,1,.5,500)),
                this.isSpotLightShadow = !0,
                this.focus = 1
            }
            updateMatrices(e) {
                const t = this.camera
                  , n = 2 * Et * e.angle * this.focus
                  , i = this.mapSize.width / this.mapSize.height
                  , r = e.distance || t.far;
                n === t.fov && i === t.aspect && r === t.far || (t.fov = n,
                t.aspect = i,
                t.far = r,
                t.updateProjectionMatrix()),
                super.updateMatrices(e)
            }
            copy(e) {
                return super.copy(e),
                this.focus = e.focus,
                this
            }
        }
        class qc extends Gc {
            constructor(e, t, n=0, i=Math.PI / 3, r=0, s=2) {
                super(e, t),
                this.isSpotLight = !0,
                this.type = "SpotLight",
                this.position.copy(ui.DEFAULT_UP),
                this.updateMatrix(),
                this.target = new ui,
                this.distance = n,
                this.angle = i,
                this.penumbra = r,
                this.decay = s,
                this.map = null,
                this.shadow = new jc
            }
            get power() {
                return this.intensity * Math.PI
            }
            set power(e) {
                this.intensity = e / Math.PI
            }
            dispose() {
                this.shadow.dispose()
            }
            copy(e, t) {
                return super.copy(e, t),
                this.distance = e.distance,
                this.angle = e.angle,
                this.penumbra = e.penumbra,
                this.decay = e.decay,
                this.target = e.target.clone(),
                this.shadow = e.shadow.clone(),
                this
            }
        }
        const Yc = new Nn
          , Xc = new on
          , Kc = new on;
        class Jc extends Wc {
            constructor() {
                super(new br(90,1,.5,500)),
                this.isPointLightShadow = !0,
                this._frameExtents = new Rt(4,2),
                this._viewportCount = 6,
                this._viewports = [new en(2,1,1,1), new en(0,1,1,1), new en(3,1,1,1), new en(1,1,1,1), new en(3,0,1,1), new en(1,0,1,1)],
                this._cubeDirections = [new on(1,0,0), new on(-1,0,0), new on(0,0,1), new on(0,0,-1), new on(0,1,0), new on(0,-1,0)],
                this._cubeUps = [new on(0,1,0), new on(0,1,0), new on(0,1,0), new on(0,1,0), new on(0,0,1), new on(0,0,-1)]
            }
            updateMatrices(e, t=0) {
                const n = this.camera
                  , i = this.matrix
                  , r = e.distance || n.far;
                r !== n.far && (n.far = r,
                n.updateProjectionMatrix()),
                Xc.setFromMatrixPosition(e.matrixWorld),
                n.position.copy(Xc),
                Kc.copy(n.position),
                Kc.add(this._cubeDirections[t]),
                n.up.copy(this._cubeUps[t]),
                n.lookAt(Kc),
                n.updateMatrixWorld(),
                i.makeTranslation(-Xc.x, -Xc.y, -Xc.z),
                Yc.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse),
                this._frustum.setFromProjectionMatrix(Yc)
            }
        }
        class Zc extends Gc {
            constructor(e, t, n=0, i=2) {
                super(e, t),
                this.isPointLight = !0,
                this.type = "PointLight",
                this.distance = n,
                this.decay = i,
                this.shadow = new Jc
            }
            get power() {
                return 4 * this.intensity * Math.PI
            }
            set power(e) {
                this.intensity = e / (4 * Math.PI)
            }
            dispose() {
                this.shadow.dispose()
            }
            copy(e, t) {
                return super.copy(e, t),
                this.distance = e.distance,
                this.decay = e.decay,
                this.shadow = e.shadow.clone(),
                this
            }
        }
        class $c extends Wc {
            constructor() {
                super(new Xr(-5,5,5,-5,.5,500)),
                this.isDirectionalLightShadow = !0
            }
        }
        class eu extends Gc {
            constructor(e, t) {
                super(e, t),
                this.isDirectionalLight = !0,
                this.type = "DirectionalLight",
                this.position.copy(ui.DEFAULT_UP),
                this.updateMatrix(),
                this.target = new ui,
                this.shadow = new $c
            }
            dispose() {
                this.shadow.dispose()
            }
            copy(e) {
                return super.copy(e),
                this.target = e.target.clone(),
                this.shadow = e.shadow.clone(),
                this
            }
        }
        class tu extends Gc {
            constructor(e, t) {
                super(e, t),
                this.isAmbientLight = !0,
                this.type = "AmbientLight"
            }
        }
        class nu {
            static decodeText(e) {
                if (console.warn("THREE.LoaderUtils: decodeText() has been deprecated with r165 and will be removed with r175. Use TextDecoder instead."),
                "undefined" != typeof TextDecoder)
                    return (new TextDecoder).decode(e);
                let t = "";
                for (let n = 0, i = e.length; n < i; n++)
                    t += String.fromCharCode(e[n]);
                try {
                    return decodeURIComponent(escape(t))
                } catch (e) {
                    return t
                }
            }
            static extractUrlBase(e) {
                const t = e.lastIndexOf("/");
                return -1 === t ? "./" : e.slice(0, t + 1)
            }
            static resolveURL(e, t) {
                return "string" != typeof e || "" === e ? "" : (/^https?:\/\//i.test(t) && /^\//.test(e) && (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")),
                /^(https?:)?\/\//i.test(e) || /^data:.*,.*$/i.test(e) || /^blob:.*$/i.test(e) ? e : t + e)
            }
        }
        class iu extends Lc {
            constructor(e) {
                super(e),
                this.isImageBitmapLoader = !0,
                "undefined" == typeof createImageBitmap && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),
                "undefined" == typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported."),
                this.options = {
                    premultiplyAlpha: "none"
                }
            }
            setOptions(e) {
                return this.options = e,
                this
            }
            load(e, t, n, i) {
                void 0 === e && (e = ""),
                void 0 !== this.path && (e = this.path + e),
                e = this.manager.resolveURL(e);
                const r = this
                  , s = Rc.get(e);
                if (void 0 !== s)
                    return r.manager.itemStart(e),
                    s.then ? void s.then((n => {
                        t && t(n),
                        r.manager.itemEnd(e)
                    }
                    )).catch((e => {
                        i && i(e)
                    }
                    )) : (setTimeout((function() {
                        t && t(s),
                        r.manager.itemEnd(e)
                    }
                    ), 0),
                    s);
                const a = {};
                a.credentials = "anonymous" === this.crossOrigin ? "same-origin" : "include",
                a.headers = this.requestHeader;
                const o = fetch(e, a).then((function(e) {
                    return e.blob()
                }
                )).then((function(e) {
                    return createImageBitmap(e, Object.assign(r.options, {
                        colorSpaceConversion: "none"
                    }))
                }
                )).then((function(n) {
                    return Rc.add(e, n),
                    t && t(n),
                    r.manager.itemEnd(e),
                    n
                }
                )).catch((function(t) {
                    i && i(t),
                    Rc.remove(e),
                    r.manager.itemError(e),
                    r.manager.itemEnd(e)
                }
                ));
                Rc.add(e, o),
                r.manager.itemStart(e)
            }
        }
        class ru {
            constructor(e=!0) {
                this.autoStart = e,
                this.startTime = 0,
                this.oldTime = 0,
                this.elapsedTime = 0,
                this.running = !1
            }
            start() {
                this.startTime = su(),
                this.oldTime = this.startTime,
                this.elapsedTime = 0,
                this.running = !0
            }
            stop() {
                this.getElapsedTime(),
                this.running = !1,
                this.autoStart = !1
            }
            getElapsedTime() {
                return this.getDelta(),
                this.elapsedTime
            }
            getDelta() {
                let e = 0;
                if (this.autoStart && !this.running)
                    return this.start(),
                    0;
                if (this.running) {
                    const t = su();
                    e = (t - this.oldTime) / 1e3,
                    this.oldTime = t,
                    this.elapsedTime += e
                }
                return e
            }
        }
        function su() {
            return performance.now()
        }
        class au {
            constructor(e, t, n) {
                let i, r, s;
                switch (this.binding = e,
                this.valueSize = n,
                t) {
                case "quaternion":
                    i = this._slerp,
                    r = this._slerpAdditive,
                    s = this._setAdditiveIdentityQuaternion,
                    this.buffer = new Float64Array(6 * n),
                    this._workIndex = 5;
                    break;
                case "string":
                case "bool":
                    i = this._select,
                    r = this._select,
                    s = this._setAdditiveIdentityOther,
                    this.buffer = new Array(5 * n);
                    break;
                default:
                    i = this._lerp,
                    r = this._lerpAdditive,
                    s = this._setAdditiveIdentityNumeric,
                    this.buffer = new Float64Array(5 * n)
                }
                this._mixBufferRegion = i,
                this._mixBufferRegionAdditive = r,
                this._setIdentity = s,
                this._origIndex = 3,
                this._addIndex = 4,
                this.cumulativeWeight = 0,
                this.cumulativeWeightAdditive = 0,
                this.useCount = 0,
                this.referenceCount = 0
            }
            accumulate(e, t) {
                const n = this.buffer
                  , i = this.valueSize
                  , r = e * i + i;
                let s = this.cumulativeWeight;
                if (0 === s) {
                    for (let e = 0; e !== i; ++e)
                        n[r + e] = n[e];
                    s = t
                } else {
                    s += t;
                    const e = t / s;
                    this._mixBufferRegion(n, r, 0, e, i)
                }
                this.cumulativeWeight = s
            }
            accumulateAdditive(e) {
                const t = this.buffer
                  , n = this.valueSize
                  , i = n * this._addIndex;
                0 === this.cumulativeWeightAdditive && this._setIdentity(),
                this._mixBufferRegionAdditive(t, i, 0, e, n),
                this.cumulativeWeightAdditive += e
            }
            apply(e) {
                const t = this.valueSize
                  , n = this.buffer
                  , i = e * t + t
                  , r = this.cumulativeWeight
                  , s = this.cumulativeWeightAdditive
                  , a = this.binding;
                if (this.cumulativeWeight = 0,
                this.cumulativeWeightAdditive = 0,
                r < 1) {
                    const e = t * this._origIndex;
                    this._mixBufferRegion(n, i, e, 1 - r, t)
                }
                s > 0 && this._mixBufferRegionAdditive(n, i, this._addIndex * t, 1, t);
                for (let e = t, r = t + t; e !== r; ++e)
                    if (n[e] !== n[e + t]) {
                        a.setValue(n, i);
                        break
                    }
            }
            saveOriginalState() {
                const e = this.binding
                  , t = this.buffer
                  , n = this.valueSize
                  , i = n * this._origIndex;
                e.getValue(t, i);
                for (let e = n, r = i; e !== r; ++e)
                    t[e] = t[i + e % n];
                this._setIdentity(),
                this.cumulativeWeight = 0,
                this.cumulativeWeightAdditive = 0
            }
            restoreOriginalState() {
                const e = 3 * this.valueSize;
                this.binding.setValue(this.buffer, e)
            }
            _setAdditiveIdentityNumeric() {
                const e = this._addIndex * this.valueSize
                  , t = e + this.valueSize;
                for (let n = e; n < t; n++)
                    this.buffer[n] = 0
            }
            _setAdditiveIdentityQuaternion() {
                this._setAdditiveIdentityNumeric(),
                this.buffer[this._addIndex * this.valueSize + 3] = 1
            }
            _setAdditiveIdentityOther() {
                const e = this._origIndex * this.valueSize
                  , t = this._addIndex * this.valueSize;
                for (let n = 0; n < this.valueSize; n++)
                    this.buffer[t + n] = this.buffer[e + n]
            }
            _select(e, t, n, i, r) {
                if (i >= .5)
                    for (let i = 0; i !== r; ++i)
                        e[t + i] = e[n + i]
            }
            _slerp(e, t, n, i) {
                an.slerpFlat(e, t, e, t, e, n, i)
            }
            _slerpAdditive(e, t, n, i, r) {
                const s = this._workIndex * r;
                an.multiplyQuaternionsFlat(e, s, e, t, e, n),
                an.slerpFlat(e, t, e, t, e, s, i)
            }
            _lerp(e, t, n, i, r) {
                const s = 1 - i;
                for (let a = 0; a !== r; ++a) {
                    const r = t + a;
                    e[r] = e[r] * s + e[n + a] * i
                }
            }
            _lerpAdditive(e, t, n, i, r) {
                for (let s = 0; s !== r; ++s) {
                    const r = t + s;
                    e[r] = e[r] + e[n + s] * i
                }
            }
        }
        const ou = "\\[\\]\\.:\\/"
          , lu = new RegExp("[" + ou + "]","g")
          , cu = "[^" + ou + "]"
          , uu = "[^" + ou.replace("\\.", "") + "]"
          , hu = new RegExp("^" + /((?:WC+[\/:])*)/.source.replace("WC", cu) + /(WCOD+)?/.source.replace("WCOD", uu) + /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", cu) + /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", cu) + "$")
          , du = ["material", "materials", "bones", "map"];
        class pu {
            constructor(e, t, n) {
                this.path = t,
                this.parsedPath = n || pu.parseTrackName(t),
                this.node = pu.findNode(e, this.parsedPath.nodeName),
                this.rootNode = e,
                this.getValue = this._getValue_unbound,
                this.setValue = this._setValue_unbound
            }
            static create(e, t, n) {
                return e && e.isAnimationObjectGroup ? new pu.Composite(e,t,n) : new pu(e,t,n)
            }
            static sanitizeNodeName(e) {
                return e.replace(/\s/g, "_").replace(lu, "")
            }
            static parseTrackName(e) {
                const t = hu.exec(e);
                if (null === t)
                    throw new Error("PropertyBinding: Cannot parse trackName: " + e);
                const n = {
                    nodeName: t[2],
                    objectName: t[3],
                    objectIndex: t[4],
                    propertyName: t[5],
                    propertyIndex: t[6]
                }
                  , i = n.nodeName && n.nodeName.lastIndexOf(".");
                if (void 0 !== i && -1 !== i) {
                    const e = n.nodeName.substring(i + 1);
                    -1 !== du.indexOf(e) && (n.nodeName = n.nodeName.substring(0, i),
                    n.objectName = e)
                }
                if (null === n.propertyName || 0 === n.propertyName.length)
                    throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e);
                return n
            }
            static findNode(e, t) {
                if (void 0 === t || "" === t || "." === t || -1 === t || t === e.name || t === e.uuid)
                    return e;
                if (e.skeleton) {
                    const n = e.skeleton.getBoneByName(t);
                    if (void 0 !== n)
                        return n
                }
                if (e.children) {
                    const n = function(e) {
                        for (let i = 0; i < e.length; i++) {
                            const r = e[i];
                            if (r.name === t || r.uuid === t)
                                return r;
                            const s = n(r.children);
                            if (s)
                                return s
                        }
                        return null
                    }
                      , i = n(e.children);
                    if (i)
                        return i
                }
                return null
            }
            _getValue_unavailable() {}
            _setValue_unavailable() {}
            _getValue_direct(e, t) {
                e[t] = this.targetObject[this.propertyName]
            }
            _getValue_array(e, t) {
                const n = this.resolvedProperty;
                for (let i = 0, r = n.length; i !== r; ++i)
                    e[t++] = n[i]
            }
            _getValue_arrayElement(e, t) {
                e[t] = this.resolvedProperty[this.propertyIndex]
            }
            _getValue_toArray(e, t) {
                this.resolvedProperty.toArray(e, t)
            }
            _setValue_direct(e, t) {
                this.targetObject[this.propertyName] = e[t]
            }
            _setValue_direct_setNeedsUpdate(e, t) {
                this.targetObject[this.propertyName] = e[t],
                this.targetObject.needsUpdate = !0
            }
            _setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
                this.targetObject[this.propertyName] = e[t],
                this.targetObject.matrixWorldNeedsUpdate = !0
            }
            _setValue_array(e, t) {
                const n = this.resolvedProperty;
                for (let i = 0, r = n.length; i !== r; ++i)
                    n[i] = e[t++]
            }
            _setValue_array_setNeedsUpdate(e, t) {
                const n = this.resolvedProperty;
                for (let i = 0, r = n.length; i !== r; ++i)
                    n[i] = e[t++];
                this.targetObject.needsUpdate = !0
            }
            _setValue_array_setMatrixWorldNeedsUpdate(e, t) {
                const n = this.resolvedProperty;
                for (let i = 0, r = n.length; i !== r; ++i)
                    n[i] = e[t++];
                this.targetObject.matrixWorldNeedsUpdate = !0
            }
            _setValue_arrayElement(e, t) {
                this.resolvedProperty[this.propertyIndex] = e[t]
            }
            _setValue_arrayElement_setNeedsUpdate(e, t) {
                this.resolvedProperty[this.propertyIndex] = e[t],
                this.targetObject.needsUpdate = !0
            }
            _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
                this.resolvedProperty[this.propertyIndex] = e[t],
                this.targetObject.matrixWorldNeedsUpdate = !0
            }
            _setValue_fromArray(e, t) {
                this.resolvedProperty.fromArray(e, t)
            }
            _setValue_fromArray_setNeedsUpdate(e, t) {
                this.resolvedProperty.fromArray(e, t),
                this.targetObject.needsUpdate = !0
            }
            _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
                this.resolvedProperty.fromArray(e, t),
                this.targetObject.matrixWorldNeedsUpdate = !0
            }
            _getValue_unbound(e, t) {
                this.bind(),
                this.getValue(e, t)
            }
            _setValue_unbound(e, t) {
                this.bind(),
                this.setValue(e, t)
            }
            bind() {
                let e = this.node;
                const t = this.parsedPath
                  , n = t.objectName
                  , i = t.propertyName;
                let r = t.propertyIndex;
                if (e || (e = pu.findNode(this.rootNode, t.nodeName),
                this.node = e),
                this.getValue = this._getValue_unavailable,
                this.setValue = this._setValue_unavailable,
                !e)
                    return void console.warn("THREE.PropertyBinding: No target node found for track: " + this.path + ".");
                if (n) {
                    let i = t.objectIndex;
                    switch (n) {
                    case "materials":
                        if (!e.material)
                            return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                        if (!e.material.materials)
                            return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                        e = e.material.materials;
                        break;
                    case "bones":
                        if (!e.skeleton)
                            return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                        e = e.skeleton.bones;
                        for (let t = 0; t < e.length; t++)
                            if (e[t].name === i) {
                                i = t;
                                break
                            }
                        break;
                    case "map":
                        if ("map"in e) {
                            e = e.map;
                            break
                        }
                        if (!e.material)
                            return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                        if (!e.material.map)
                            return void console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.", this);
                        e = e.material.map;
                        break;
                    default:
                        if (void 0 === e[n])
                            return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                        e = e[n]
                    }
                    if (void 0 !== i) {
                        if (void 0 === e[i])
                            return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e);
                        e = e[i]
                    }
                }
                const s = e[i];
                if (void 0 === s) {
                    const n = t.nodeName;
                    return void console.error("THREE.PropertyBinding: Trying to update property for track: " + n + "." + i + " but it wasn't found.", e)
                }
                let a = this.Versioning.None;
                this.targetObject = e,
                void 0 !== e.needsUpdate ? a = this.Versioning.NeedsUpdate : void 0 !== e.matrixWorldNeedsUpdate && (a = this.Versioning.MatrixWorldNeedsUpdate);
                let o = this.BindingType.Direct;
                if (void 0 !== r) {
                    if ("morphTargetInfluences" === i) {
                        if (!e.geometry)
                            return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                        if (!e.geometry.morphAttributes)
                            return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                        void 0 !== e.morphTargetDictionary[r] && (r = e.morphTargetDictionary[r])
                    }
                    o = this.BindingType.ArrayElement,
                    this.resolvedProperty = s,
                    this.propertyIndex = r
                } else
                    void 0 !== s.fromArray && void 0 !== s.toArray ? (o = this.BindingType.HasFromToArray,
                    this.resolvedProperty = s) : Array.isArray(s) ? (o = this.BindingType.EntireArray,
                    this.resolvedProperty = s) : this.propertyName = i;
                this.getValue = this.GetterByBindingType[o],
                this.setValue = this.SetterByBindingTypeAndVersioning[o][a]
            }
            unbind() {
                this.node = null,
                this.getValue = this._getValue_unbound,
                this.setValue = this._setValue_unbound
            }
        }
        pu.Composite = class {
            constructor(e, t, n) {
                const i = n || pu.parseTrackName(t);
                this._targetGroup = e,
                this._bindings = e.subscribe_(t, i)
            }
            getValue(e, t) {
                this.bind();
                const n = this._targetGroup.nCachedObjects_
                  , i = this._bindings[n];
                void 0 !== i && i.getValue(e, t)
            }
            setValue(e, t) {
                const n = this._bindings;
                for (let i = this._targetGroup.nCachedObjects_, r = n.length; i !== r; ++i)
                    n[i].setValue(e, t)
            }
            bind() {
                const e = this._bindings;
                for (let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t)
                    e[t].bind()
            }
            unbind() {
                const e = this._bindings;
                for (let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t)
                    e[t].unbind()
            }
        }
        ,
        pu.prototype.BindingType = {
            Direct: 0,
            EntireArray: 1,
            ArrayElement: 2,
            HasFromToArray: 3
        },
        pu.prototype.Versioning = {
            None: 0,
            NeedsUpdate: 1,
            MatrixWorldNeedsUpdate: 2
        },
        pu.prototype.GetterByBindingType = [pu.prototype._getValue_direct, pu.prototype._getValue_array, pu.prototype._getValue_arrayElement, pu.prototype._getValue_toArray],
        pu.prototype.SetterByBindingTypeAndVersioning = [[pu.prototype._setValue_direct, pu.prototype._setValue_direct_setNeedsUpdate, pu.prototype._setValue_direct_setMatrixWorldNeedsUpdate], [pu.prototype._setValue_array, pu.prototype._setValue_array_setNeedsUpdate, pu.prototype._setValue_array_setMatrixWorldNeedsUpdate], [pu.prototype._setValue_arrayElement, pu.prototype._setValue_arrayElement_setNeedsUpdate, pu.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate], [pu.prototype._setValue_fromArray, pu.prototype._setValue_fromArray_setNeedsUpdate, pu.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];
        class fu {
            constructor(e, t, n=null, i=t.blendMode) {
                this._mixer = e,
                this._clip = t,
                this._localRoot = n,
                this.blendMode = i;
                const r = t.tracks
                  , s = r.length
                  , a = new Array(s)
                  , o = {
                    endingStart: $e,
                    endingEnd: $e
                };
                for (let e = 0; e !== s; ++e) {
                    const t = r[e].createInterpolant(null);
                    a[e] = t,
                    t.settings = o
                }
                this._interpolantSettings = o,
                this._interpolants = a,
                this._propertyBindings = new Array(s),
                this._cacheIndex = null,
                this._byClipCacheIndex = null,
                this._timeScaleInterpolant = null,
                this._weightInterpolant = null,
                this.loop = Xe,
                this._loopCount = -1,
                this._startTime = null,
                this.time = 0,
                this.timeScale = 1,
                this._effectiveTimeScale = 1,
                this.weight = 1,
                this._effectiveWeight = 1,
                this.repetitions = 1 / 0,
                this.paused = !1,
                this.enabled = !0,
                this.clampWhenFinished = !1,
                this.zeroSlopeAtStart = !0,
                this.zeroSlopeAtEnd = !0
            }
            play() {
                return this._mixer._activateAction(this),
                this
            }
            stop() {
                return this._mixer._deactivateAction(this),
                this.reset()
            }
            reset() {
                return this.paused = !1,
                this.enabled = !0,
                this.time = 0,
                this._loopCount = -1,
                this._startTime = null,
                this.stopFading().stopWarping()
            }
            isRunning() {
                return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this)
            }
            isScheduled() {
                return this._mixer._isActiveAction(this)
            }
            startAt(e) {
                return this._startTime = e,
                this
            }
            setLoop(e, t) {
                return this.loop = e,
                this.repetitions = t,
                this
            }
            setEffectiveWeight(e) {
                return this.weight = e,
                this._effectiveWeight = this.enabled ? e : 0,
                this.stopFading()
            }
            getEffectiveWeight() {
                return this._effectiveWeight
            }
            fadeIn(e) {
                return this._scheduleFading(e, 0, 1)
            }
            fadeOut(e) {
                return this._scheduleFading(e, 1, 0)
            }
            crossFadeFrom(e, t, n) {
                if (e.fadeOut(t),
                this.fadeIn(t),
                n) {
                    const n = this._clip.duration
                      , i = e._clip.duration
                      , r = i / n
                      , s = n / i;
                    e.warp(1, r, t),
                    this.warp(s, 1, t)
                }
                return this
            }
            crossFadeTo(e, t, n) {
                return e.crossFadeFrom(this, t, n)
            }
            stopFading() {
                const e = this._weightInterpolant;
                return null !== e && (this._weightInterpolant = null,
                this._mixer._takeBackControlInterpolant(e)),
                this
            }
            setEffectiveTimeScale(e) {
                return this.timeScale = e,
                this._effectiveTimeScale = this.paused ? 0 : e,
                this.stopWarping()
            }
            getEffectiveTimeScale() {
                return this._effectiveTimeScale
            }
            setDuration(e) {
                return this.timeScale = this._clip.duration / e,
                this.stopWarping()
            }
            syncWith(e) {
                return this.time = e.time,
                this.timeScale = e.timeScale,
                this.stopWarping()
            }
            halt(e) {
                return this.warp(this._effectiveTimeScale, 0, e)
            }
            warp(e, t, n) {
                const i = this._mixer
                  , r = i.time
                  , s = this.timeScale;
                let a = this._timeScaleInterpolant;
                null === a && (a = i._lendControlInterpolant(),
                this._timeScaleInterpolant = a);
                const o = a.parameterPositions
                  , l = a.sampleValues;
                return o[0] = r,
                o[1] = r + n,
                l[0] = e / s,
                l[1] = t / s,
                this
            }
            stopWarping() {
                const e = this._timeScaleInterpolant;
                return null !== e && (this._timeScaleInterpolant = null,
                this._mixer._takeBackControlInterpolant(e)),
                this
            }
            getMixer() {
                return this._mixer
            }
            getClip() {
                return this._clip
            }
            getRoot() {
                return this._localRoot || this._mixer._root
            }
            _update(e, t, n, i) {
                if (!this.enabled)
                    return void this._updateWeight(e);
                const r = this._startTime;
                if (null !== r) {
                    const i = (e - r) * n;
                    i < 0 || 0 === n ? t = 0 : (this._startTime = null,
                    t = n * i)
                }
                t *= this._updateTimeScale(e);
                const s = this._updateTime(t)
                  , a = this._updateWeight(e);
                if (a > 0) {
                    const e = this._interpolants
                      , t = this._propertyBindings;
                    if (2501 === this.blendMode)
                        for (let n = 0, i = e.length; n !== i; ++n)
                            e[n].evaluate(s),
                            t[n].accumulateAdditive(a);
                    else
                        for (let n = 0, r = e.length; n !== r; ++n)
                            e[n].evaluate(s),
                            t[n].accumulate(i, a)
                }
            }
            _updateWeight(e) {
                let t = 0;
                if (this.enabled) {
                    t = this.weight;
                    const n = this._weightInterpolant;
                    if (null !== n) {
                        const i = n.evaluate(e)[0];
                        t *= i,
                        e > n.parameterPositions[1] && (this.stopFading(),
                        0 === i && (this.enabled = !1))
                    }
                }
                return this._effectiveWeight = t,
                t
            }
            _updateTimeScale(e) {
                let t = 0;
                if (!this.paused) {
                    t = this.timeScale;
                    const n = this._timeScaleInterpolant;
                    if (null !== n) {
                        t *= n.evaluate(e)[0],
                        e > n.parameterPositions[1] && (this.stopWarping(),
                        0 === t ? this.paused = !0 : this.timeScale = t)
                    }
                }
                return this._effectiveTimeScale = t,
                t
            }
            _updateTime(e) {
                const t = this._clip.duration
                  , n = this.loop;
                let i = this.time + e
                  , r = this._loopCount;
                const s = 2202 === n;
                if (0 === e)
                    return -1 === r || !s || 1 & ~r ? i : t - i;
                if (n === Ye) {
                    -1 === r && (this._loopCount = 0,
                    this._setEndings(!0, !0, !1));
                    e: {
                        if (i >= t)
                            i = t;
                        else {
                            if (!(i < 0)) {
                                this.time = i;
                                break e
                            }
                            i = 0
                        }
                        this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                        this.time = i,
                        this._mixer.dispatchEvent({
                            type: "finished",
                            action: this,
                            direction: e < 0 ? -1 : 1
                        })
                    }
                } else {
                    if (-1 === r && (e >= 0 ? (r = 0,
                    this._setEndings(!0, 0 === this.repetitions, s)) : this._setEndings(0 === this.repetitions, !0, s)),
                    i >= t || i < 0) {
                        const n = Math.floor(i / t);
                        i -= t * n,
                        r += Math.abs(n);
                        const a = this.repetitions - r;
                        if (a <= 0)
                            this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                            i = e > 0 ? t : 0,
                            this.time = i,
                            this._mixer.dispatchEvent({
                                type: "finished",
                                action: this,
                                direction: e > 0 ? 1 : -1
                            });
                        else {
                            if (1 === a) {
                                const t = e < 0;
                                this._setEndings(t, !t, s)
                            } else
                                this._setEndings(!1, !1, s);
                            this._loopCount = r,
                            this.time = i,
                            this._mixer.dispatchEvent({
                                type: "loop",
                                action: this,
                                loopDelta: n
                            })
                        }
                    } else
                        this.time = i;
                    if (s && !(1 & ~r))
                        return t - i
                }
                return i
            }
            _setEndings(e, t, n) {
                const i = this._interpolantSettings;
                n ? (i.endingStart = et,
                i.endingEnd = et) : (i.endingStart = e ? this.zeroSlopeAtStart ? et : $e : tt,
                i.endingEnd = t ? this.zeroSlopeAtEnd ? et : $e : tt)
            }
            _scheduleFading(e, t, n) {
                const i = this._mixer
                  , r = i.time;
                let s = this._weightInterpolant;
                null === s && (s = i._lendControlInterpolant(),
                this._weightInterpolant = s);
                const a = s.parameterPositions
                  , o = s.sampleValues;
                return a[0] = r,
                o[0] = t,
                a[1] = r + e,
                o[1] = n,
                this
            }
        }
        const Au = new Float32Array(1);
        class gu extends yt {
            constructor(e) {
                super(),
                this._root = e,
                this._initMemoryManager(),
                this._accuIndex = 0,
                this.time = 0,
                this.timeScale = 1
            }
            _bindAction(e, t) {
                const n = e._localRoot || this._root
                  , i = e._clip.tracks
                  , r = i.length
                  , s = e._propertyBindings
                  , a = e._interpolants
                  , o = n.uuid
                  , l = this._bindingsByRootAndName;
                let c = l[o];
                void 0 === c && (c = {},
                l[o] = c);
                for (let e = 0; e !== r; ++e) {
                    const r = i[e]
                      , l = r.name;
                    let u = c[l];
                    if (void 0 !== u)
                        ++u.referenceCount,
                        s[e] = u;
                    else {
                        if (u = s[e],
                        void 0 !== u) {
                            null === u._cacheIndex && (++u.referenceCount,
                            this._addInactiveBinding(u, o, l));
                            continue
                        }
                        const i = t && t._propertyBindings[e].binding.parsedPath;
                        u = new au(pu.create(n, l, i),r.ValueTypeName,r.getValueSize()),
                        ++u.referenceCount,
                        this._addInactiveBinding(u, o, l),
                        s[e] = u
                    }
                    a[e].resultBuffer = u.buffer
                }
            }
            _activateAction(e) {
                if (!this._isActiveAction(e)) {
                    if (null === e._cacheIndex) {
                        const t = (e._localRoot || this._root).uuid
                          , n = e._clip.uuid
                          , i = this._actionsByClip[n];
                        this._bindAction(e, i && i.knownActions[0]),
                        this._addInactiveAction(e, n, t)
                    }
                    const t = e._propertyBindings;
                    for (let e = 0, n = t.length; e !== n; ++e) {
                        const n = t[e];
                        0 == n.useCount++ && (this._lendBinding(n),
                        n.saveOriginalState())
                    }
                    this._lendAction(e)
                }
            }
            _deactivateAction(e) {
                if (this._isActiveAction(e)) {
                    const t = e._propertyBindings;
                    for (let e = 0, n = t.length; e !== n; ++e) {
                        const n = t[e];
                        0 == --n.useCount && (n.restoreOriginalState(),
                        this._takeBackBinding(n))
                    }
                    this._takeBackAction(e)
                }
            }
            _initMemoryManager() {
                this._actions = [],
                this._nActiveActions = 0,
                this._actionsByClip = {},
                this._bindings = [],
                this._nActiveBindings = 0,
                this._bindingsByRootAndName = {},
                this._controlInterpolants = [],
                this._nActiveControlInterpolants = 0;
                const e = this;
                this.stats = {
                    actions: {
                        get total() {
                            return e._actions.length
                        },
                        get inUse() {
                            return e._nActiveActions
                        }
                    },
                    bindings: {
                        get total() {
                            return e._bindings.length
                        },
                        get inUse() {
                            return e._nActiveBindings
                        }
                    },
                    controlInterpolants: {
                        get total() {
                            return e._controlInterpolants.length
                        },
                        get inUse() {
                            return e._nActiveControlInterpolants
                        }
                    }
                }
            }
            _isActiveAction(e) {
                const t = e._cacheIndex;
                return null !== t && t < this._nActiveActions
            }
            _addInactiveAction(e, t, n) {
                const i = this._actions
                  , r = this._actionsByClip;
                let s = r[t];
                if (void 0 === s)
                    s = {
                        knownActions: [e],
                        actionByRoot: {}
                    },
                    e._byClipCacheIndex = 0,
                    r[t] = s;
                else {
                    const t = s.knownActions;
                    e._byClipCacheIndex = t.length,
                    t.push(e)
                }
                e._cacheIndex = i.length,
                i.push(e),
                s.actionByRoot[n] = e
            }
            _removeInactiveAction(e) {
                const t = this._actions
                  , n = t[t.length - 1]
                  , i = e._cacheIndex;
                n._cacheIndex = i,
                t[i] = n,
                t.pop(),
                e._cacheIndex = null;
                const r = e._clip.uuid
                  , s = this._actionsByClip
                  , a = s[r]
                  , o = a.knownActions
                  , l = o[o.length - 1]
                  , c = e._byClipCacheIndex;
                l._byClipCacheIndex = c,
                o[c] = l,
                o.pop(),
                e._byClipCacheIndex = null;
                delete a.actionByRoot[(e._localRoot || this._root).uuid],
                0 === o.length && delete s[r],
                this._removeInactiveBindingsForAction(e)
            }
            _removeInactiveBindingsForAction(e) {
                const t = e._propertyBindings;
                for (let e = 0, n = t.length; e !== n; ++e) {
                    const n = t[e];
                    0 == --n.referenceCount && this._removeInactiveBinding(n)
                }
            }
            _lendAction(e) {
                const t = this._actions
                  , n = e._cacheIndex
                  , i = this._nActiveActions++
                  , r = t[i];
                e._cacheIndex = i,
                t[i] = e,
                r._cacheIndex = n,
                t[n] = r
            }
            _takeBackAction(e) {
                const t = this._actions
                  , n = e._cacheIndex
                  , i = --this._nActiveActions
                  , r = t[i];
                e._cacheIndex = i,
                t[i] = e,
                r._cacheIndex = n,
                t[n] = r
            }
            _addInactiveBinding(e, t, n) {
                const i = this._bindingsByRootAndName
                  , r = this._bindings;
                let s = i[t];
                void 0 === s && (s = {},
                i[t] = s),
                s[n] = e,
                e._cacheIndex = r.length,
                r.push(e)
            }
            _removeInactiveBinding(e) {
                const t = this._bindings
                  , n = e.binding
                  , i = n.rootNode.uuid
                  , r = n.path
                  , s = this._bindingsByRootAndName
                  , a = s[i]
                  , o = t[t.length - 1]
                  , l = e._cacheIndex;
                o._cacheIndex = l,
                t[l] = o,
                t.pop(),
                delete a[r],
                0 === Object.keys(a).length && delete s[i]
            }
            _lendBinding(e) {
                const t = this._bindings
                  , n = e._cacheIndex
                  , i = this._nActiveBindings++
                  , r = t[i];
                e._cacheIndex = i,
                t[i] = e,
                r._cacheIndex = n,
                t[n] = r
            }
            _takeBackBinding(e) {
                const t = this._bindings
                  , n = e._cacheIndex
                  , i = --this._nActiveBindings
                  , r = t[i];
                e._cacheIndex = i,
                t[i] = e,
                r._cacheIndex = n,
                t[n] = r
            }
            _lendControlInterpolant() {
                const e = this._controlInterpolants
                  , t = this._nActiveControlInterpolants++;
                let n = e[t];
                return void 0 === n && (n = new yc(new Float32Array(2),new Float32Array(2),1,Au),
                n.__cacheIndex = t,
                e[t] = n),
                n
            }
            _takeBackControlInterpolant(e) {
                const t = this._controlInterpolants
                  , n = e.__cacheIndex
                  , i = --this._nActiveControlInterpolants
                  , r = t[i];
                e.__cacheIndex = i,
                t[i] = e,
                r.__cacheIndex = n,
                t[n] = r
            }
            clipAction(e, t, n) {
                const i = t || this._root
                  , r = i.uuid;
                let s = "string" == typeof e ? Tc.findByName(i, e) : e;
                const a = null !== s ? s.uuid : e
                  , o = this._actionsByClip[a];
                let l = null;
                if (void 0 === n && (n = null !== s ? s.blendMode : nt),
                void 0 !== o) {
                    const e = o.actionByRoot[r];
                    if (void 0 !== e && e.blendMode === n)
                        return e;
                    l = o.knownActions[0],
                    null === s && (s = l._clip)
                }
                if (null === s)
                    return null;
                const c = new fu(this,s,t,n);
                return this._bindAction(c, l),
                this._addInactiveAction(c, a, r),
                c
            }
            existingAction(e, t) {
                const n = t || this._root
                  , i = n.uuid
                  , r = "string" == typeof e ? Tc.findByName(n, e) : e
                  , s = r ? r.uuid : e
                  , a = this._actionsByClip[s];
                return void 0 !== a && a.actionByRoot[i] || null
            }
            stopAllAction() {
                const e = this._actions;
                for (let t = this._nActiveActions - 1; t >= 0; --t)
                    e[t].stop();
                return this
            }
            update(e) {
                e *= this.timeScale;
                const t = this._actions
                  , n = this._nActiveActions
                  , i = this.time += e
                  , r = Math.sign(e)
                  , s = this._accuIndex ^= 1;
                for (let a = 0; a !== n; ++a) {
                    t[a]._update(i, e, r, s)
                }
                const a = this._bindings
                  , o = this._nActiveBindings;
                for (let e = 0; e !== o; ++e)
                    a[e].apply(s);
                return this
            }
            setTime(e) {
                this.time = 0;
                for (let e = 0; e < this._actions.length; e++)
                    this._actions[e].time = 0;
                return this.update(e)
            }
            getRoot() {
                return this._root
            }
            uncacheClip(e) {
                const t = this._actions
                  , n = e.uuid
                  , i = this._actionsByClip
                  , r = i[n];
                if (void 0 !== r) {
                    const e = r.knownActions;
                    for (let n = 0, i = e.length; n !== i; ++n) {
                        const i = e[n];
                        this._deactivateAction(i);
                        const r = i._cacheIndex
                          , s = t[t.length - 1];
                        i._cacheIndex = null,
                        i._byClipCacheIndex = null,
                        s._cacheIndex = r,
                        t[r] = s,
                        t.pop(),
                        this._removeInactiveBindingsForAction(i)
                    }
                    delete i[n]
                }
            }
            uncacheRoot(e) {
                const t = e.uuid
                  , n = this._actionsByClip;
                for (const e in n) {
                    const i = n[e].actionByRoot[t];
                    void 0 !== i && (this._deactivateAction(i),
                    this._removeInactiveAction(i))
                }
                const i = this._bindingsByRootAndName[t];
                if (void 0 !== i)
                    for (const e in i) {
                        const t = i[e];
                        t.restoreOriginalState(),
                        this._removeInactiveBinding(t)
                    }
            }
            uncacheAction(e, t) {
                const n = this.existingAction(e, t);
                null !== n && (this._deactivateAction(n),
                this._removeInactiveAction(n))
            }
        }
        class mu {
            constructor(e) {
                this.value = e
            }
            clone() {
                return new mu(void 0 === this.value.clone ? this.value : this.value.clone())
            }
        }
        const vu = new Nn;
        class yu {
            constructor(e, t, n=0, i=1 / 0) {
                this.ray = new Fn(e,t),
                this.near = n,
                this.far = i,
                this.camera = null,
                this.layers = new Yn,
                this.params = {
                    Mesh: {},
                    Line: {
                        threshold: 1
                    },
                    LOD: {},
                    Points: {
                        threshold: 1
                    },
                    Sprite: {}
                }
            }
            set(e, t) {
                this.ray.set(e, t)
            }
            setFromCamera(e, t) {
                t.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld),
                this.ray.direction.set(e.x, e.y, .5).unproject(t).sub(this.ray.origin).normalize(),
                this.camera = t) : t.isOrthographicCamera ? (this.ray.origin.set(e.x, e.y, (t.near + t.far) / (t.near - t.far)).unproject(t),
                this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld),
                this.camera = t) : console.error("THREE.Raycaster: Unsupported camera type: " + t.type)
            }
            setFromXRController(e) {
                return vu.identity().extractRotation(e.matrixWorld),
                this.ray.origin.setFromMatrixPosition(e.matrixWorld),
                this.ray.direction.set(0, 0, -1).applyMatrix4(vu),
                this
            }
            intersectObject(e, t=!0, n=[]) {
                return _u(e, this, n, t),
                n.sort(xu),
                n
            }
            intersectObjects(e, t=!0, n=[]) {
                for (let i = 0, r = e.length; i < r; i++)
                    _u(e[i], this, n, t);
                return n.sort(xu),
                n
            }
        }
        function xu(e, t) {
            return e.distance - t.distance
        }
        function _u(e, t, n, i) {
            let r = !0;
            if (e.layers.test(t.layers)) {
                !1 === e.raycast(t, n) && (r = !1)
            }
            if (!0 === r && !0 === i) {
                const i = e.children;
                for (let e = 0, r = i.length; e < r; e++)
                    _u(i[e], t, n, !0)
            }
        }
        const bu = new Rt;
        class Eu {
            constructor(e=new Rt(1 / 0,1 / 0), t=new Rt(-1 / 0,-1 / 0)) {
                this.isBox2 = !0,
                this.min = e,
                this.max = t
            }
            set(e, t) {
                return this.min.copy(e),
                this.max.copy(t),
                this
            }
            setFromPoints(e) {
                this.makeEmpty();
                for (let t = 0, n = e.length; t < n; t++)
                    this.expandByPoint(e[t]);
                return this
            }
            setFromCenterAndSize(e, t) {
                const n = bu.copy(t).multiplyScalar(.5);
                return this.min.copy(e).sub(n),
                this.max.copy(e).add(n),
                this
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            copy(e) {
                return this.min.copy(e.min),
                this.max.copy(e.max),
                this
            }
            makeEmpty() {
                return this.min.x = this.min.y = 1 / 0,
                this.max.x = this.max.y = -1 / 0,
                this
            }
            isEmpty() {
                return this.max.x < this.min.x || this.max.y < this.min.y
            }
            getCenter(e) {
                return this.isEmpty() ? e.set(0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
            }
            getSize(e) {
                return this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min)
            }
            expandByPoint(e) {
                return this.min.min(e),
                this.max.max(e),
                this
            }
            expandByVector(e) {
                return this.min.sub(e),
                this.max.add(e),
                this
            }
            expandByScalar(e) {
                return this.min.addScalar(-e),
                this.max.addScalar(e),
                this
            }
            containsPoint(e) {
                return e.x >= this.min.x && e.x <= this.max.x && e.y >= this.min.y && e.y <= this.max.y
            }
            containsBox(e) {
                return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y
            }
            getParameter(e, t) {
                return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y))
            }
            intersectsBox(e) {
                return e.max.x >= this.min.x && e.min.x <= this.max.x && e.max.y >= this.min.y && e.min.y <= this.max.y
            }
            clampPoint(e, t) {
                return t.copy(e).clamp(this.min, this.max)
            }
            distanceToPoint(e) {
                return this.clampPoint(e, bu).distanceTo(e)
            }
            intersect(e) {
                return this.min.max(e.min),
                this.max.min(e.max),
                this.isEmpty() && this.makeEmpty(),
                this
            }
            union(e) {
                return this.min.min(e.min),
                this.max.max(e.max),
                this
            }
            translate(e) {
                return this.min.add(e),
                this.max.add(e),
                this
            }
            equals(e) {
                return e.min.equals(this.min) && e.max.equals(this.max)
            }
        }
        const wu = new on
          , Cu = new on;
        class Iu {
            constructor(e=new on, t=new on) {
                this.start = e,
                this.end = t
            }
            set(e, t) {
                return this.start.copy(e),
                this.end.copy(t),
                this
            }
            copy(e) {
                return this.start.copy(e.start),
                this.end.copy(e.end),
                this
            }
            getCenter(e) {
                return e.addVectors(this.start, this.end).multiplyScalar(.5)
            }
            delta(e) {
                return e.subVectors(this.end, this.start)
            }
            distanceSq() {
                return this.start.distanceToSquared(this.end)
            }
            distance() {
                return this.start.distanceTo(this.end)
            }
            at(e, t) {
                return this.delta(t).multiplyScalar(e).add(this.start)
            }
            closestPointToPointParameter(e, t) {
                wu.subVectors(e, this.start),
                Cu.subVectors(this.end, this.start);
                const n = Cu.dot(Cu);
                let i = Cu.dot(wu) / n;
                return t && (i = Ct(i, 0, 1)),
                i
            }
            closestPointToPoint(e, t, n) {
                const i = this.closestPointToPointParameter(e, t);
                return this.delta(n).multiplyScalar(i).add(this.start)
            }
            applyMatrix4(e) {
                return this.start.applyMatrix4(e),
                this.end.applyMatrix4(e),
                this
            }
            equals(e) {
                return e.start.equals(this.start) && e.end.equals(this.end)
            }
            clone() {
                return (new this.constructor).copy(this)
            }
        }
        "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{
            detail: {
                revision: i
            }
        })),
        "undefined" != typeof window && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = i)
    }
    ,
    7971: (e, t, n) => {
        "use strict";
        n.d(t, {
            a8: () => P
        });
        var i = Uint8Array
          , r = Uint16Array
          , s = Int32Array
          , a = new i([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0])
          , o = new i([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0])
          , l = new i([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15])
          , c = function(e, t) {
            for (var n = new r(31), i = 0; i < 31; ++i)
                n[i] = t += 1 << e[i - 1];
            var a = new s(n[30]);
            for (i = 1; i < 30; ++i)
                for (var o = n[i]; o < n[i + 1]; ++o)
                    a[o] = o - n[i] << 5 | i;
            return {
                b: n,
                r: a
            }
        }
          , u = c(a, 2)
          , h = u.b
          , d = u.r;
        h[28] = 258,
        d[258] = 28;
        for (var p = c(o, 0), f = p.b, A = (p.r,
        new r(32768)), g = 0; g < 32768; ++g) {
            var m = (43690 & g) >> 1 | (21845 & g) << 1;
            m = (61680 & (m = (52428 & m) >> 2 | (13107 & m) << 2)) >> 4 | (3855 & m) << 4,
            A[g] = ((65280 & m) >> 8 | (255 & m) << 8) >> 1
        }
        var v = function(e, t, n) {
            for (var i = e.length, s = 0, a = new r(t); s < i; ++s)
                e[s] && ++a[e[s] - 1];
            var o, l = new r(t);
            for (s = 1; s < t; ++s)
                l[s] = l[s - 1] + a[s - 1] << 1;
            if (n) {
                o = new r(1 << t);
                var c = 15 - t;
                for (s = 0; s < i; ++s)
                    if (e[s])
                        for (var u = s << 4 | e[s], h = t - e[s], d = l[e[s] - 1]++ << h, p = d | (1 << h) - 1; d <= p; ++d)
                            o[A[d] >> c] = u
            } else
                for (o = new r(i),
                s = 0; s < i; ++s)
                    e[s] && (o[s] = A[l[e[s] - 1]++] >> 15 - e[s]);
            return o
        }
          , y = new i(288);
        for (g = 0; g < 144; ++g)
            y[g] = 8;
        for (g = 144; g < 256; ++g)
            y[g] = 9;
        for (g = 256; g < 280; ++g)
            y[g] = 7;
        for (g = 280; g < 288; ++g)
            y[g] = 8;
        var x = new i(32);
        for (g = 0; g < 32; ++g)
            x[g] = 5;
        var _ = v(y, 9, 1)
          , b = v(x, 5, 1)
          , E = function(e) {
            for (var t = e[0], n = 1; n < e.length; ++n)
                e[n] > t && (t = e[n]);
            return t
        }
          , w = function(e, t, n) {
            var i = t / 8 | 0;
            return (e[i] | e[i + 1] << 8) >> (7 & t) & n
        }
          , C = function(e, t) {
            var n = t / 8 | 0;
            return (e[n] | e[n + 1] << 8 | e[n + 2] << 16) >> (7 & t)
        }
          , I = function(e) {
            return (e + 7) / 8 | 0
        }
          , S = function(e, t, n) {
            return (null == t || t < 0) && (t = 0),
            (null == n || n > e.length) && (n = e.length),
            new i(e.subarray(t, n))
        }
          , M = ["unexpected EOF", "invalid block type", "invalid length/literal", "invalid distance", "stream finished", "no stream handler", , "no callback", "invalid UTF-8 data", "extra field too long", "date not in range 1980-2099", "filename too long", "stream finishing", "invalid zip data"]
          , T = function(e, t, n) {
            var i = new Error(t || M[e]);
            if (i.code = e,
            Error.captureStackTrace && Error.captureStackTrace(i, T),
            !n)
                throw i;
            return i
        }
          , B = function(e, t, n, r) {
            var s = e.length
              , c = r ? r.length : 0;
            if (!s || t.f && !t.l)
                return n || new i(0);
            var u = !n
              , d = u || 2 != t.i
              , p = t.i;
            u && (n = new i(3 * s));
            var A = function(e) {
                var t = n.length;
                if (e > t) {
                    var r = new i(Math.max(2 * t, e));
                    r.set(n),
                    n = r
                }
            }
              , g = t.f || 0
              , m = t.p || 0
              , y = t.b || 0
              , x = t.l
              , M = t.d
              , B = t.m
              , R = t.n
              , D = 8 * s;
            do {
                if (!x) {
                    g = w(e, m, 1);
                    var P = w(e, m + 1, 3);
                    if (m += 3,
                    !P) {
                        var L = e[(W = I(m) + 4) - 4] | e[W - 3] << 8
                          , U = W + L;
                        if (U > s) {
                            p && T(0);
                            break
                        }
                        d && A(y + L),
                        n.set(e.subarray(W, U), y),
                        t.b = y += L,
                        t.p = m = 8 * U,
                        t.f = g;
                        continue
                    }
                    if (1 == P)
                        x = _,
                        M = b,
                        B = 9,
                        R = 5;
                    else if (2 == P) {
                        var F = w(e, m, 31) + 257
                          , N = w(e, m + 10, 15) + 4
                          , O = F + w(e, m + 5, 31) + 1;
                        m += 14;
                        for (var Q = new i(O), k = new i(19), G = 0; G < N; ++G)
                            k[l[G]] = w(e, m + 3 * G, 7);
                        m += 3 * N;
                        var H = E(k)
                          , z = (1 << H) - 1
                          , V = v(k, H, 1);
                        for (G = 0; G < O; ) {
                            var W, j = V[w(e, m, z)];
                            if (m += 15 & j,
                            (W = j >> 4) < 16)
                                Q[G++] = W;
                            else {
                                var q = 0
                                  , Y = 0;
                                for (16 == W ? (Y = 3 + w(e, m, 3),
                                m += 2,
                                q = Q[G - 1]) : 17 == W ? (Y = 3 + w(e, m, 7),
                                m += 3) : 18 == W && (Y = 11 + w(e, m, 127),
                                m += 7); Y--; )
                                    Q[G++] = q
                            }
                        }
                        var X = Q.subarray(0, F)
                          , K = Q.subarray(F);
                        B = E(X),
                        R = E(K),
                        x = v(X, B, 1),
                        M = v(K, R, 1)
                    } else
                        T(1);
                    if (m > D) {
                        p && T(0);
                        break
                    }
                }
                d && A(y + 131072);
                for (var J = (1 << B) - 1, Z = (1 << R) - 1, $ = m; ; $ = m) {
                    var ee = (q = x[C(e, m) & J]) >> 4;
                    if ((m += 15 & q) > D) {
                        p && T(0);
                        break
                    }
                    if (q || T(2),
                    ee < 256)
                        n[y++] = ee;
                    else {
                        if (256 == ee) {
                            $ = m,
                            x = null;
                            break
                        }
                        var te = ee - 254;
                        if (ee > 264) {
                            var ne = a[G = ee - 257];
                            te = w(e, m, (1 << ne) - 1) + h[G],
                            m += ne
                        }
                        var ie = M[C(e, m) & Z]
                          , re = ie >> 4;
                        ie || T(3),
                        m += 15 & ie;
                        K = f[re];
                        if (re > 3) {
                            ne = o[re];
                            K += C(e, m) & (1 << ne) - 1,
                            m += ne
                        }
                        if (m > D) {
                            p && T(0);
                            break
                        }
                        d && A(y + 131072);
                        var se = y + te;
                        if (y < K) {
                            var ae = c - K
                              , oe = Math.min(K, se);
                            for (ae + y < 0 && T(3); y < oe; ++y)
                                n[y] = r[ae + y]
                        }
                        for (; y < se; ++y)
                            n[y] = n[y - K]
                    }
                }
                t.l = x,
                t.p = $,
                t.b = y,
                t.f = g,
                x && (g = 1,
                t.m = B,
                t.d = M,
                t.n = R)
            } while (!g);
            return y != n.length && u ? S(n, 0, y) : n.subarray(0, y)
        }
          , R = new i(0)
          , D = function(e, t) {
            return (8 != (15 & e[0]) || e[0] >> 4 > 7 || (e[0] << 8 | e[1]) % 31) && T(6, "invalid zlib data"),
            (e[1] >> 5 & 1) == +!t && T(6, "invalid zlib data: " + (32 & e[1] ? "need" : "unexpected") + " dictionary"),
            2 + (e[1] >> 3 & 4)
        };
        function P(e, t) {
            return B(e.subarray(D(e, t && t.dictionary), -4), {
                i: 2
            }, t && t.out, t && t.dictionary)
        }
        var L = "undefined" != typeof TextDecoder && new TextDecoder;
        try {
            L.decode(R, {
                stream: !0
            }),
            1
        } catch (e) {}
        "function" == typeof queueMicrotask ? queueMicrotask : "function" == typeof setTimeout && setTimeout
    }
    ,
    9167: (e, t, n) => {
        "use strict";
        n.d(t, {
            f: () => i
        });
        var i = function() {
            var e = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 3, 2, 0, 0, 5, 3, 1, 0, 1, 12, 1, 0, 10, 22, 2, 12, 0, 65, 0, 65, 0, 65, 0, 252, 10, 0, 0, 11, 7, 0, 65, 0, 253, 15, 26, 11])
              , t = new Uint8Array([32, 0, 65, 2, 1, 106, 34, 33, 3, 128, 11, 4, 13, 64, 6, 253, 10, 7, 15, 116, 127, 5, 8, 12, 40, 16, 19, 54, 20, 9, 27, 255, 113, 17, 42, 67, 24, 23, 146, 148, 18, 14, 22, 45, 70, 69, 56, 114, 101, 21, 25, 63, 75, 136, 108, 28, 118, 29, 73, 115]);
            if ("object" != typeof WebAssembly)
                return {
                    supported: !1
                };
            var n, i = WebAssembly.validate(e) ? "b9H79TebbbeKl9Gbb9Gvuuuuueu9Giuuub9Geueuikqbbebeedddilve9Weeeviebeoweuec:q;Aekr;leDo9TW9T9VV95dbH9F9F939H79T9F9J9H229F9Jt9VV7bb8A9TW79O9V9Wt9F9KW9J9V9KW9wWVtW949c919M9MWVbdY9TW79O9V9Wt9F9KW9J9V9KW69U9KW949c919M9MWVblE9TW79O9V9Wt9F9KW9J9V9KW69U9KW949tWG91W9U9JWbvL9TW79O9V9Wt9F9KW9J9V9KWS9P2tWV9p9JtboK9TW79O9V9Wt9F9KW9J9V9KWS9P2tWV9r919HtbrL9TW79O9V9Wt9F9KW9J9V9KWS9P2tWVT949Wbwl79IV9RbDq;t9tqlbzik9:evu8Jjjjjbcz9Rhbcbheincbhdcbhiinabcwfadfaicjuaead4ceGglE86bbaialfhiadcefgdcw9hmbkaec:q:yjjbfai86bbaecitc:q1jjbfab8Piw83ibaecefgecjd9hmbkk;h8JlHud97euo978Jjjjjbcj;kb9Rgv8Kjjjjbc9:hodnadcefal0mbcuhoaiRbbc:Ge9hmbavaialfgrad9Rad;8qbbcj;abad9UhoaicefhldnadTmbaoc;WFbGgocjdaocjd6EhwcbhDinaDae9pmeawaeaD9RaDawfae6Egqcsfgoc9WGgkci2hxakcethmaocl4cifcd4hPabaDad2fhscbhzdnincehHalhOcbhAdninaraO9RaP6miavcj;cbfaAak2fhCaOaPfhlcbhidnakc;ab6mbaral9Rc;Gb6mbcbhoinaCaofhidndndndndnaOaoco4fRbbgXciGPlbedibkaipxbbbbbbbbbbbbbbbbpklbxikaialpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklbalclfaYpQbfaKc:q:yjjbfRbbfhlxdkaialpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklbalcwfaYpQbfaKc:q:yjjbfRbbfhlxekaialpbbbpklbalczfhlkdndndndndnaXcd4ciGPlbedibkaipxbbbbbbbbbbbbbbbbpklzxikaialpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklzalclfaYpQbfaKc:q:yjjbfRbbfhlxdkaialpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklzalcwfaYpQbfaKc:q:yjjbfRbbfhlxekaialpbbbpklzalczfhlkdndndndndnaXcl4ciGPlbedibkaipxbbbbbbbbbbbbbbbbpklaxikaialpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklaalclfaYpQbfaKc:q:yjjbfRbbfhlxdkaialpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklaalcwfaYpQbfaKc:q:yjjbfRbbfhlxekaialpbbbpklaalczfhlkdndndndndnaXco4Plbedibkaipxbbbbbbbbbbbbbbbbpkl8WxikaialpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgXcitc:q1jjbfpbibaXc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgXcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spkl8WalclfaYpQbfaXc:q:yjjbfRbbfhlxdkaialpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgXcitc:q1jjbfpbibaXc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgXcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spkl8WalcwfaYpQbfaXc:q:yjjbfRbbfhlxekaialpbbbpkl8Walczfhlkaoc;abfhiaocjefak0meaihoaral9Rc;Fb0mbkkdndnaiak9pmbaici4hoinaral9RcK6mdaCaifhXdndndndndnaOaico4fRbbaocoG4ciGPlbedibkaXpxbbbbbbbbbbbbbbbbpklbxikaXalpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklbalclfaYpQbfaKc:q:yjjbfRbbfhlxdkaXalpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklbalcwfaYpQbfaKc:q:yjjbfRbbfhlxekaXalpbbbpklbalczfhlkaocdfhoaiczfgiak6mbkkalTmbaAci6hHalhOaAcefgohAaoclSmdxekkcbhlaHceGmdkdnakTmbavcjdfazfhiavazfpbdbhYcbhXinaiavcj;cbfaXfgopblbgLcep9TaLpxeeeeeeeeeeeeeeeegQp9op9Hp9rgLaoakfpblbg8Acep9Ta8AaQp9op9Hp9rg8ApmbzeHdOiAlCvXoQrLgEaoamfpblbg3cep9Ta3aQp9op9Hp9rg3aoaxfpblbg5cep9Ta5aQp9op9Hp9rg5pmbzeHdOiAlCvXoQrLg8EpmbezHdiOAlvCXorQLgQaQpmbedibedibedibediaYp9UgYp9AdbbaiadfgoaYaQaQpmlvorlvorlvorlvorp9UgYp9AdbbaoadfgoaYaQaQpmwDqkwDqkwDqkwDqkp9UgYp9AdbbaoadfgoaYaQaQpmxmPsxmPsxmPsxmPsp9UgYp9AdbbaoadfgoaYaEa8EpmwDKYqk8AExm35Ps8E8FgQaQpmbedibedibedibedip9UgYp9AdbbaoadfgoaYaQaQpmlvorlvorlvorlvorp9UgYp9AdbbaoadfgoaYaQaQpmwDqkwDqkwDqkwDqkp9UgYp9AdbbaoadfgoaYaQaQpmxmPsxmPsxmPsxmPsp9UgYp9AdbbaoadfgoaYaLa8ApmwKDYq8AkEx3m5P8Es8FgLa3a5pmwKDYq8AkEx3m5P8Es8Fg8ApmbezHdiOAlvCXorQLgQaQpmbedibedibedibedip9UgYp9AdbbaoadfgoaYaQaQpmlvorlvorlvorlvorp9UgYp9AdbbaoadfgoaYaQaQpmwDqkwDqkwDqkwDqkp9UgYp9AdbbaoadfgoaYaQaQpmxmPsxmPsxmPsxmPsp9UgYp9AdbbaoadfgoaYaLa8ApmwDKYqk8AExm35Ps8E8FgQaQpmbedibedibedibedip9UgYp9AdbbaoadfgoaYaQaQpmlvorlvorlvorlvorp9UgYp9AdbbaoadfgoaYaQaQpmwDqkwDqkwDqkwDqkp9UgYp9AdbbaoadfgoaYaQaQpmxmPsxmPsxmPsxmPsp9UgYp9AdbbaoadfhiaXczfgXak6mbkkazclfgzad6mbkasavcjdfaqad2;8qbbavavcjdfaqcufad2fad;8qbbaqaDfhDc9:hoalmexikkc9:hoxekcbc99aral9Radcaadca0ESEhokavcj;kbf8Kjjjjbaokwbz:bjjjbk;uzeHu8Jjjjjbc;ae9Rgv8Kjjjjbc9:hodnaeci9UgrcHfal0mbcuhoaiRbbgwc;WeGc;Ge9hmbawcsGgDce0mbavc;abfcFecje;8kbavcUf9cu83ibavc8Wf9cu83ibavcyf9cu83ibavcaf9cu83ibavcKf9cu83ibavczf9cu83ibav9cu83iwav9cu83ibaialfc9WfhqaicefgwarfhodnaeTmbcmcsaDceSEhkcbhxcbhmcbhDcbhicbhlindnaoaq9nmbc9:hoxikdndnawRbbgrc;Ve0mbavc;abfalarcl4cu7fcsGcitfgPydlhsaPydbhzdnarcsGgPak9pmbavaiarcu7fcsGcdtfydbaxaPEhraPThPdndnadcd9hmbabaDcetfgHaz87ebaHcdfas87ebaHclfar87ebxekabaDcdtfgHazBdbaHclfasBdbaHcwfarBdbkaxaPfhxavc;abfalcitfgHarBdbaHasBdlavaicdtfarBdbavc;abfalcefcsGglcitfgHazBdbaHarBdlaiaPfhialcefhlxdkdndnaPcsSmbamaPfaPc987fcefhmxekaocefhrao8SbbgPcFeGhHdndnaPcu9mmbarhoxekaocvfhoaHcFbGhHcrhPdninar8SbbgOcFbGaPtaHVhHaOcu9kmearcefhraPcrfgPc8J9hmbxdkkarcefhokaHce4cbaHceG9R7amfhmkdndnadcd9hmbabaDcetfgraz87ebarcdfas87ebarclfam87ebxekabaDcdtfgrazBdbarclfasBdbarcwfamBdbkavc;abfalcitfgramBdbarasBdlavaicdtfamBdbavc;abfalcefcsGglcitfgrazBdbaramBdlaicefhialcefhlxekdnarcpe0mbaxcefgOavaiaqarcsGfRbbgPcl49RcsGcdtfydbaPcz6gHEhravaiaP9RcsGcdtfydbaOaHfgsaPcsGgOEhPaOThOdndnadcd9hmbabaDcetfgzax87ebazcdfar87ebazclfaP87ebxekabaDcdtfgzaxBdbazclfarBdbazcwfaPBdbkavaicdtfaxBdbavc;abfalcitfgzarBdbazaxBdlavaicefgicsGcdtfarBdbavc;abfalcefcsGcitfgzaPBdbazarBdlavaiaHfcsGgicdtfaPBdbavc;abfalcdfcsGglcitfgraxBdbaraPBdlalcefhlaiaOfhiasaOfhxxekaxcbaoRbbgzEgAarc;:eSgrfhsazcsGhCazcl4hXdndnazcs0mbascefhOxekashOavaiaX9RcsGcdtfydbhskdndnaCmbaOcefhxxekaOhxavaiaz9RcsGcdtfydbhOkdndnarTmbaocefhrxekaocdfhrao8SbegHcFeGhPdnaHcu9kmbaocofhAaPcFbGhPcrhodninar8SbbgHcFbGaotaPVhPaHcu9kmearcefhraocrfgoc8J9hmbkaAhrxekarcefhrkaPce4cbaPceG9R7amfgmhAkdndnaXcsSmbarhPxekarcefhPar8SbbgocFeGhHdnaocu9kmbarcvfhsaHcFbGhHcrhodninaP8SbbgrcFbGaotaHVhHarcu9kmeaPcefhPaocrfgoc8J9hmbkashPxekaPcefhPkaHce4cbaHceG9R7amfgmhskdndnaCcsSmbaPhoxekaPcefhoaP8SbbgrcFeGhHdnarcu9kmbaPcvfhOaHcFbGhHcrhrdninao8SbbgPcFbGartaHVhHaPcu9kmeaocefhoarcrfgrc8J9hmbkaOhoxekaocefhokaHce4cbaHceG9R7amfgmhOkdndnadcd9hmbabaDcetfgraA87ebarcdfas87ebarclfaO87ebxekabaDcdtfgraABdbarclfasBdbarcwfaOBdbkavc;abfalcitfgrasBdbaraABdlavaicdtfaABdbavc;abfalcefcsGcitfgraOBdbarasBdlavaicefgicsGcdtfasBdbavc;abfalcdfcsGcitfgraABdbaraOBdlavaiazcz6aXcsSVfgicsGcdtfaOBdbaiaCTaCcsSVfhialcifhlkawcefhwalcsGhlaicsGhiaDcifgDae6mbkkcbc99aoaqSEhokavc;aef8Kjjjjbaok:llevu8Jjjjjbcz9Rhvc9:hodnaecvfal0mbcuhoaiRbbc;:eGc;qe9hmbav9cb83iwaicefhraialfc98fhwdnaeTmbdnadcdSmbcbhDindnaraw6mbc9:skarcefhoar8SbbglcFeGhidndnalcu9mmbaohrxekarcvfhraicFbGhicrhldninao8SbbgdcFbGaltaiVhiadcu9kmeaocefhoalcrfglc8J9hmbxdkkaocefhrkabaDcdtfaicd4cbaice4ceG9R7avcwfaiceGcdtVgoydbfglBdbaoalBdbaDcefgDae9hmbxdkkcbhDindnaraw6mbc9:skarcefhoar8SbbglcFeGhidndnalcu9mmbaohrxekarcvfhraicFbGhicrhldninao8SbbgdcFbGaltaiVhiadcu9kmeaocefhoalcrfglc8J9hmbxdkkaocefhrkabaDcetfaicd4cbaice4ceG9R7avcwfaiceGcdtVgoydbfgl87ebaoalBdbaDcefgDae9hmbkkcbc99arawSEhokaok:EPliuo97eue978Jjjjjbca9Rhidndnadcl9hmbdnaec98GglTmbcbhvabhdinadadpbbbgocKp:RecKp:Sep;6egraocwp:RecKp:Sep;6earp;Geaoczp:RecKp:Sep;6egwp;Gep;Kep;LegDpxbbbbbbbbbbbbbbbbp:2egqarpxbbbjbbbjbbbjbbbjgkp9op9rp;Kegrpxbb;:9cbb;:9cbb;:9cbb;:9cararp;MeaDaDp;Meawaqawakp9op9rp;Kegrarp;Mep;Kep;Kep;Jep;Negwp;Mepxbbn0bbn0bbn0bbn0gqp;KepxFbbbFbbbFbbbFbbbp9oaopxbbbFbbbFbbbFbbbFp9op9qarawp;Meaqp;Kecwp:RepxbFbbbFbbbFbbbFbbp9op9qaDawp;Meaqp;Keczp:RepxbbFbbbFbbbFbbbFbp9op9qpkbbadczfhdavclfgval6mbkkalae9pmeaiaeciGgvcdtgdVcbczad9R;8kbaiabalcdtfglad;8qbbdnavTmbaiaipblbgocKp:RecKp:Sep;6egraocwp:RecKp:Sep;6earp;Geaoczp:RecKp:Sep;6egwp;Gep;Kep;LegDpxbbbbbbbbbbbbbbbbp:2egqarpxbbbjbbbjbbbjbbbjgkp9op9rp;Kegrpxbb;:9cbb;:9cbb;:9cbb;:9cararp;MeaDaDp;Meawaqawakp9op9rp;Kegrarp;Mep;Kep;Kep;Jep;Negwp;Mepxbbn0bbn0bbn0bbn0gqp;KepxFbbbFbbbFbbbFbbbp9oaopxbbbFbbbFbbbFbbbFp9op9qarawp;Meaqp;Kecwp:RepxbFbbbFbbbFbbbFbbp9op9qaDawp;Meaqp;Keczp:RepxbbFbbbFbbbFbbbFbp9op9qpklbkalaiad;8qbbskdnaec98GgxTmbcbhvabhdinadczfglalpbbbgopxbbbbbbFFbbbbbbFFgkp9oadpbbbgDaopmlvorxmPsCXQL358E8FpxFubbFubbFubbFubbp9op;6eaDaopmbediwDqkzHOAKY8AEgoczp:Sep;6egrp;Geaoczp:Reczp:Sep;6egwp;Gep;Kep;Legopxb;:FSb;:FSb;:FSb;:FSawaopxbbbbbbbbbbbbbbbbp:2egqawpxbbbjbbbjbbbjbbbjgmp9op9rp;Kegwawp;Meaoaop;Mearaqaramp9op9rp;Kegoaop;Mep;Kep;Kep;Jep;Negrp;Mepxbbn0bbn0bbn0bbn0gqp;Keczp:Reawarp;Meaqp;KepxFFbbFFbbFFbbFFbbp9op9qgwaoarp;Meaqp;KepxFFbbFFbbFFbbFFbbp9ogopmwDKYqk8AExm35Ps8E8Fp9qpkbbadaDakp9oawaopmbezHdiOAlvCXorQLp9qpkbbadcafhdavclfgvax6mbkkaxae9pmbaiaeciGgvcitgdfcbcaad9R;8kbaiabaxcitfglad;8qbbdnavTmbaiaipblzgopxbbbbbbFFbbbbbbFFgkp9oaipblbgDaopmlvorxmPsCXQL358E8FpxFubbFubbFubbFubbp9op;6eaDaopmbediwDqkzHOAKY8AEgoczp:Sep;6egrp;Geaoczp:Reczp:Sep;6egwp;Gep;Kep;Legopxb;:FSb;:FSb;:FSb;:FSawaopxbbbbbbbbbbbbbbbbp:2egqawpxbbbjbbbjbbbjbbbjgmp9op9rp;Kegwawp;Meaoaop;Mearaqaramp9op9rp;Kegoaop;Mep;Kep;Kep;Jep;Negrp;Mepxbbn0bbn0bbn0bbn0gqp;Keczp:Reawarp;Meaqp;KepxFFbbFFbbFFbbFFbbp9op9qgwaoarp;Meaqp;KepxFFbbFFbbFFbbFFbbp9ogopmwDKYqk8AExm35Ps8E8Fp9qpklzaiaDakp9oawaopmbezHdiOAlvCXorQLp9qpklbkalaiad;8qbbkk;4wllue97euv978Jjjjjbc8W9Rhidnaec98GglTmbcbhvabhoinaiaopbbbgraoczfgwpbbbgDpmlvorxmPsCXQL358E8Fgqczp:Segkclp:RepklbaopxbbjZbbjZbbjZbbjZpx;Zl81Z;Zl81Z;Zl81Z;Zl81Zakpxibbbibbbibbbibbbp9qp;6ep;NegkaraDpmbediwDqkzHOAKY8AEgrczp:Reczp:Sep;6ep;MegDaDp;Meakarczp:Sep;6ep;Megxaxp;Meakaqczp:Reczp:Sep;6ep;Megqaqp;Mep;Kep;Kep;Lepxbbbbbbbbbbbbbbbbp:4ep;Jepxb;:FSb;:FSb;:FSb;:FSgkp;Mepxbbn0bbn0bbn0bbn0grp;KepxFFbbFFbbFFbbFFbbgmp9oaxakp;Mearp;Keczp:Rep9qgxaqakp;Mearp;Keczp:ReaDakp;Mearp;Keamp9op9qgkpmbezHdiOAlvCXorQLgrp5baipblbpEb:T:j83ibaocwfarp5eaipblbpEe:T:j83ibawaxakpmwDKYqk8AExm35Ps8E8Fgkp5baipblbpEd:T:j83ibaocKfakp5eaipblbpEi:T:j83ibaocafhoavclfgval6mbkkdnalae9pmbaiaeciGgvcitgofcbcaao9R;8kbaiabalcitfgwao;8qbbdnavTmbaiaipblbgraipblzgDpmlvorxmPsCXQL358E8Fgqczp:Segkclp:RepklaaipxbbjZbbjZbbjZbbjZpx;Zl81Z;Zl81Z;Zl81Z;Zl81Zakpxibbbibbbibbbibbbp9qp;6ep;NegkaraDpmbediwDqkzHOAKY8AEgrczp:Reczp:Sep;6ep;MegDaDp;Meakarczp:Sep;6ep;Megxaxp;Meakaqczp:Reczp:Sep;6ep;Megqaqp;Mep;Kep;Kep;Lepxbbbbbbbbbbbbbbbbp:4ep;Jepxb;:FSb;:FSb;:FSb;:FSgkp;Mepxbbn0bbn0bbn0bbn0grp;KepxFFbbFFbbFFbbFFbbgmp9oaxakp;Mearp;Keczp:Rep9qgxaqakp;Mearp;Keczp:ReaDakp;Mearp;Keamp9op9qgkpmbezHdiOAlvCXorQLgrp5baipblapEb:T:j83ibaiarp5eaipblapEe:T:j83iwaiaxakpmwDKYqk8AExm35Ps8E8Fgkp5baipblapEd:T:j83izaiakp5eaipblapEi:T:j83iKkawaiao;8qbbkk:Pddiue978Jjjjjbc;ab9Rhidnadcd4ae2glc98GgvTmbcbhdabheinaeaepbbbgocwp:Recwp:Sep;6eaocep:SepxbbjZbbjZbbjZbbjZp:UepxbbjFbbjFbbjFbbjFp9op;Mepkbbaeczfheadclfgdav6mbkkdnaval9pmbaialciGgdcdtgeVcbc;abae9R;8kbaiabavcdtfgvae;8qbbdnadTmbaiaipblbgocwp:Recwp:Sep;6eaocep:SepxbbjZbbjZbbjZbbjZp:UepxbbjFbbjFbbjFbbjFp9op;Mepklbkavaiae;8qbbkk9teiucbcbydj1jjbgeabcifc98GfgbBdj1jjbdndnabZbcztgd9nmbcuhiabad9RcFFifcz4nbcuSmekaehikaikkkebcjwklz9Tbb" : "b9H79Tebbbe8Fv9Gbb9Gvuuuuueu9Giuuub9Geueu9Giuuueuikqbeeedddillviebeoweuec:q;iekr;leDo9TW9T9VV95dbH9F9F939H79T9F9J9H229F9Jt9VV7bb8A9TW79O9V9Wt9F9KW9J9V9KW9wWVtW949c919M9MWVbeY9TW79O9V9Wt9F9KW9J9V9KW69U9KW949c919M9MWVbdE9TW79O9V9Wt9F9KW9J9V9KW69U9KW949tWG91W9U9JWbiL9TW79O9V9Wt9F9KW9J9V9KWS9P2tWV9p9JtblK9TW79O9V9Wt9F9KW9J9V9KWS9P2tWV9r919HtbvL9TW79O9V9Wt9F9KW9J9V9KWS9P2tWVT949Wbol79IV9Rbrq:P8Yqdbk;3sezu8Jjjjjbcj;eb9Rgv8Kjjjjbc9:hodnadcefal0mbcuhoaiRbbc:Ge9hmbavaialfgrad9Radz1jjjbhwcj;abad9UhoaicefhldnadTmbaoc;WFbGgocjdaocjd6EhDcbhqinaqae9pmeaDaeaq9RaqaDfae6Egkcsfgocl4cifcd4hxdndndndnaoc9WGgmTmbcbhPcehsawcjdfhzalhHinaraH9Rax6midnaraHaxfgl9RcK6mbczhoinawcj;cbfaogifgoc9WfhOdndndndndnaHaic9WfgAco4fRbbaAci4coG4ciGPlbedibkaO9cb83ibaOcwf9cb83ibxikaOalRblalRbbgAco4gCaCciSgCE86bbaocGfalclfaCfgORbbaAcl4ciGgCaCciSgCE86bbaocVfaOaCfgORbbaAcd4ciGgCaCciSgCE86bbaoc7faOaCfgORbbaAciGgAaAciSgAE86bbaoctfaOaAfgARbbalRbegOco4gCaCciSgCE86bbaoc91faAaCfgARbbaOcl4ciGgCaCciSgCE86bbaoc4faAaCfgARbbaOcd4ciGgCaCciSgCE86bbaoc93faAaCfgARbbaOciGgOaOciSgOE86bbaoc94faAaOfgARbbalRbdgOco4gCaCciSgCE86bbaoc95faAaCfgARbbaOcl4ciGgCaCciSgCE86bbaoc96faAaCfgARbbaOcd4ciGgCaCciSgCE86bbaoc97faAaCfgARbbaOciGgOaOciSgOE86bbaoc98faAaOfgORbbalRbiglco4gAaAciSgAE86bbaoc99faOaAfgORbbalcl4ciGgAaAciSgAE86bbaoc9:faOaAfgORbbalcd4ciGgAaAciSgAE86bbaocufaOaAfgoRbbalciGglalciSglE86bbaoalfhlxdkaOalRbwalRbbgAcl4gCaCcsSgCE86bbaocGfalcwfaCfgORbbaAcsGgAaAcsSgAE86bbaocVfaOaAfgORbbalRbegAcl4gCaCcsSgCE86bbaoc7faOaCfgORbbaAcsGgAaAcsSgAE86bbaoctfaOaAfgORbbalRbdgAcl4gCaCcsSgCE86bbaoc91faOaCfgORbbaAcsGgAaAcsSgAE86bbaoc4faOaAfgORbbalRbigAcl4gCaCcsSgCE86bbaoc93faOaCfgORbbaAcsGgAaAcsSgAE86bbaoc94faOaAfgORbbalRblgAcl4gCaCcsSgCE86bbaoc95faOaCfgORbbaAcsGgAaAcsSgAE86bbaoc96faOaAfgORbbalRbvgAcl4gCaCcsSgCE86bbaoc97faOaCfgORbbaAcsGgAaAcsSgAE86bbaoc98faOaAfgORbbalRbogAcl4gCaCcsSgCE86bbaoc99faOaCfgORbbaAcsGgAaAcsSgAE86bbaoc9:faOaAfgORbbalRbrglcl4gAaAcsSgAE86bbaocufaOaAfgoRbbalcsGglalcsSglE86bbaoalfhlxekaOal8Pbb83bbaOcwfalcwf8Pbb83bbalczfhlkdnaiam9pmbaiczfhoaral9RcL0mekkaiam6mialTmidnakTmbawaPfRbbhOcbhoazhiinaiawcj;cbfaofRbbgAce4cbaAceG9R7aOfgO86bbaiadfhiaocefgoak9hmbkkazcefhzaPcefgPad6hsalhHaPad9hmexvkkcbhlasceGmdxikalaxad2fhCdnakTmbcbhHcehsawcjdfhminaral9Rax6mialTmdalaxfhlawaHfRbbhOcbhoamhiinaiawcj;cbfaofRbbgAce4cbaAceG9R7aOfgO86bbaiadfhiaocefgoak9hmbkamcefhmaHcefgHad6hsaHad9hmbkaChlxikcbhocehsinaral9Rax6mdalTmealaxfhlaocefgoad6hsadao9hmbkaChlxdkcbhlasceGTmekc9:hoxikabaqad2fawcjdfakad2z1jjjb8Aawawcjdfakcufad2fadz1jjjb8Aakaqfhqalmbkc9:hoxekcbc99aral9Radcaadca0ESEhokavcj;ebf8Kjjjjbaok;yzeHu8Jjjjjbc;ae9Rgv8Kjjjjbc9:hodnaeci9UgrcHfal0mbcuhoaiRbbgwc;WeGc;Ge9hmbawcsGgDce0mbavc;abfcFecjez:jjjjb8AavcUf9cu83ibavc8Wf9cu83ibavcyf9cu83ibavcaf9cu83ibavcKf9cu83ibavczf9cu83ibav9cu83iwav9cu83ibaialfc9WfhqaicefgwarfhodnaeTmbcmcsaDceSEhkcbhxcbhmcbhDcbhicbhlindnaoaq9nmbc9:hoxikdndnawRbbgrc;Ve0mbavc;abfalarcl4cu7fcsGcitfgPydlhsaPydbhzdnarcsGgPak9pmbavaiarcu7fcsGcdtfydbaxaPEhraPThPdndnadcd9hmbabaDcetfgHaz87ebaHcdfas87ebaHclfar87ebxekabaDcdtfgHazBdbaHclfasBdbaHcwfarBdbkaxaPfhxavc;abfalcitfgHarBdbaHasBdlavaicdtfarBdbavc;abfalcefcsGglcitfgHazBdbaHarBdlaiaPfhialcefhlxdkdndnaPcsSmbamaPfaPc987fcefhmxekaocefhrao8SbbgPcFeGhHdndnaPcu9mmbarhoxekaocvfhoaHcFbGhHcrhPdninar8SbbgOcFbGaPtaHVhHaOcu9kmearcefhraPcrfgPc8J9hmbxdkkarcefhokaHce4cbaHceG9R7amfhmkdndnadcd9hmbabaDcetfgraz87ebarcdfas87ebarclfam87ebxekabaDcdtfgrazBdbarclfasBdbarcwfamBdbkavc;abfalcitfgramBdbarasBdlavaicdtfamBdbavc;abfalcefcsGglcitfgrazBdbaramBdlaicefhialcefhlxekdnarcpe0mbaxcefgOavaiaqarcsGfRbbgPcl49RcsGcdtfydbaPcz6gHEhravaiaP9RcsGcdtfydbaOaHfgsaPcsGgOEhPaOThOdndnadcd9hmbabaDcetfgzax87ebazcdfar87ebazclfaP87ebxekabaDcdtfgzaxBdbazclfarBdbazcwfaPBdbkavaicdtfaxBdbavc;abfalcitfgzarBdbazaxBdlavaicefgicsGcdtfarBdbavc;abfalcefcsGcitfgzaPBdbazarBdlavaiaHfcsGgicdtfaPBdbavc;abfalcdfcsGglcitfgraxBdbaraPBdlalcefhlaiaOfhiasaOfhxxekaxcbaoRbbgzEgAarc;:eSgrfhsazcsGhCazcl4hXdndnazcs0mbascefhOxekashOavaiaX9RcsGcdtfydbhskdndnaCmbaOcefhxxekaOhxavaiaz9RcsGcdtfydbhOkdndnarTmbaocefhrxekaocdfhrao8SbegHcFeGhPdnaHcu9kmbaocofhAaPcFbGhPcrhodninar8SbbgHcFbGaotaPVhPaHcu9kmearcefhraocrfgoc8J9hmbkaAhrxekarcefhrkaPce4cbaPceG9R7amfgmhAkdndnaXcsSmbarhPxekarcefhPar8SbbgocFeGhHdnaocu9kmbarcvfhsaHcFbGhHcrhodninaP8SbbgrcFbGaotaHVhHarcu9kmeaPcefhPaocrfgoc8J9hmbkashPxekaPcefhPkaHce4cbaHceG9R7amfgmhskdndnaCcsSmbaPhoxekaPcefhoaP8SbbgrcFeGhHdnarcu9kmbaPcvfhOaHcFbGhHcrhrdninao8SbbgPcFbGartaHVhHaPcu9kmeaocefhoarcrfgrc8J9hmbkaOhoxekaocefhokaHce4cbaHceG9R7amfgmhOkdndnadcd9hmbabaDcetfgraA87ebarcdfas87ebarclfaO87ebxekabaDcdtfgraABdbarclfasBdbarcwfaOBdbkavc;abfalcitfgrasBdbaraABdlavaicdtfaABdbavc;abfalcefcsGcitfgraOBdbarasBdlavaicefgicsGcdtfasBdbavc;abfalcdfcsGcitfgraABdbaraOBdlavaiazcz6aXcsSVfgicsGcdtfaOBdbaiaCTaCcsSVfhialcifhlkawcefhwalcsGhlaicsGhiaDcifgDae6mbkkcbc99aoaqSEhokavc;aef8Kjjjjbaok:llevu8Jjjjjbcz9Rhvc9:hodnaecvfal0mbcuhoaiRbbc;:eGc;qe9hmbav9cb83iwaicefhraialfc98fhwdnaeTmbdnadcdSmbcbhDindnaraw6mbc9:skarcefhoar8SbbglcFeGhidndnalcu9mmbaohrxekarcvfhraicFbGhicrhldninao8SbbgdcFbGaltaiVhiadcu9kmeaocefhoalcrfglc8J9hmbxdkkaocefhrkabaDcdtfaicd4cbaice4ceG9R7avcwfaiceGcdtVgoydbfglBdbaoalBdbaDcefgDae9hmbxdkkcbhDindnaraw6mbc9:skarcefhoar8SbbglcFeGhidndnalcu9mmbaohrxekarcvfhraicFbGhicrhldninao8SbbgdcFbGaltaiVhiadcu9kmeaocefhoalcrfglc8J9hmbxdkkaocefhrkabaDcetfaicd4cbaice4ceG9R7avcwfaiceGcdtVgoydbfgl87ebaoalBdbaDcefgDae9hmbkkcbc99arawSEhokaok:Lvoeue99dud99eud99dndnadcl9hmbaeTmeindndnabcdfgd8Sbb:Yab8Sbbgi:Ygl:l:tabcefgv8Sbbgo:Ygr:l:tgwJbb;:9cawawNJbbbbawawJbbbb9GgDEgq:mgkaqaicb9iEalMgwawNakaqaocb9iEarMgqaqNMM:r:vglNJbbbZJbbb:;aDEMgr:lJbbb9p9DTmbar:Ohixekcjjjj94hikadai86bbdndnaqalNJbbbZJbbb:;aqJbbbb9GEMgq:lJbbb9p9DTmbaq:Ohdxekcjjjj94hdkavad86bbdndnawalNJbbbZJbbb:;awJbbbb9GEMgw:lJbbb9p9DTmbaw:Ohdxekcjjjj94hdkabad86bbabclfhbaecufgembxdkkaeTmbindndnabclfgd8Ueb:Yab8Uebgi:Ygl:l:tabcdfgv8Uebgo:Ygr:l:tgwJb;:FSawawNJbbbbawawJbbbb9GgDEgq:mgkaqaicb9iEalMgwawNakaqaocb9iEarMgqaqNMM:r:vglNJbbbZJbbb:;aDEMgr:lJbbb9p9DTmbar:Ohixekcjjjj94hikadai87ebdndnaqalNJbbbZJbbb:;aqJbbbb9GEMgq:lJbbb9p9DTmbaq:Ohdxekcjjjj94hdkavad87ebdndnawalNJbbbZJbbb:;awJbbbb9GEMgw:lJbbb9p9DTmbaw:Ohdxekcjjjj94hdkabad87ebabcwfhbaecufgembkkk;siliui99iue99dnaeTmbcbhiabhlindndnJ;Zl81Zalcof8UebgvciV:Y:vgoal8Ueb:YNgrJb;:FSNJbbbZJbbb:;arJbbbb9GEMgw:lJbbb9p9DTmbaw:OhDxekcjjjj94hDkalclf8Uebhqalcdf8UebhkabavcefciGaiVcetfaD87ebdndnaoak:YNgwJb;:FSNJbbbZJbbb:;awJbbbb9GEMgx:lJbbb9p9DTmbax:Ohkxekcjjjj94hkkabavcdfciGaiVcetfak87ebdndnaoaq:YNgoJb;:FSNJbbbZJbbb:;aoJbbbb9GEMgx:lJbbb9p9DTmbax:Ohqxekcjjjj94hqkabavcufciGaiVcetfaq87ebdndnJbbjZararN:tawawN:taoaoN:tgrJbbbbarJbbbb9GE:rJb;:FSNJbbbZMgr:lJbbb9p9DTmbar:Ohqxekcjjjj94hqkabavciGaiVcetfaq87ebalcwfhlaiclfhiaecufgembkkk9mbdnadcd4ae2geTmbinababydbgdcwtcw91:Yadce91cjjj;8ifcjjj98G::NUdbabclfhbaecufgembkkk9teiucbcbydj1jjbgeabcifc98GfgbBdj1jjbdndnabZbcztgd9nmbcuhiabad9RcFFifcz4nbcuSmekaehikaik;LeeeudndnaeabVciGTmbabhixekdndnadcz9pmbabhixekabhiinaiaeydbBdbaiclfaeclfydbBdbaicwfaecwfydbBdbaicxfaecxfydbBdbaiczfhiaeczfheadc9Wfgdcs0mbkkadcl6mbinaiaeydbBdbaeclfheaiclfhiadc98fgdci0mbkkdnadTmbinaiaeRbb86bbaicefhiaecefheadcufgdmbkkabk;aeedudndnabciGTmbabhixekaecFeGc:b:c:ew2hldndnadcz9pmbabhixekabhiinaialBdbaicxfalBdbaicwfalBdbaiclfalBdbaiczfhiadc9Wfgdcs0mbkkadcl6mbinaialBdbaiclfhiadc98fgdci0mbkkdnadTmbinaiae86bbaicefhiadcufgdmbkkabkkkebcjwklz9Kbb", r = WebAssembly.instantiate(s(i), {}).then((function(e) {
                (n = e.instance).exports.__wasm_call_ctors()
            }
            ));
            function s(e) {
                for (var n = new Uint8Array(e.length), i = 0; i < e.length; ++i) {
                    var r = e.charCodeAt(i);
                    n[i] = r > 96 ? r - 97 : r > 64 ? r - 39 : r + 4
                }
                var s = 0;
                for (i = 0; i < e.length; ++i)
                    n[s++] = n[i] < 60 ? t[n[i]] : 64 * (n[i] - 60) + n[++i];
                return n.buffer.slice(0, s)
            }
            function a(e, t, i, r, s, a) {
                var o = n.exports.sbrk
                  , l = i + 3 & -4
                  , c = o(l * r)
                  , u = o(s.length)
                  , h = new Uint8Array(n.exports.memory.buffer);
                h.set(s, u);
                var d = e(c, i, r, u, s.length);
                if (0 == d && a && a(c, l, r),
                t.set(h.subarray(c, c + i * r)),
                o(c - o(0)),
                0 != d)
                    throw new Error("Malformed buffer data: " + d)
            }
            var o = {
                NONE: "",
                OCTAHEDRAL: "meshopt_decodeFilterOct",
                QUATERNION: "meshopt_decodeFilterQuat",
                EXPONENTIAL: "meshopt_decodeFilterExp"
            }
              , l = {
                ATTRIBUTES: "meshopt_decodeVertexBuffer",
                TRIANGLES: "meshopt_decodeIndexBuffer",
                INDICES: "meshopt_decodeIndexSequence"
            }
              , c = []
              , u = 0;
            function h(e) {
                var t = {
                    object: new Worker(e),
                    pending: 0,
                    requests: {}
                };
                return t.object.onmessage = function(e) {
                    var n = e.data;
                    t.pending -= n.count,
                    t.requests[n.id][n.action](n.value),
                    delete t.requests[n.id]
                }
                ,
                t
            }
            function d(e) {
                for (var t = "var instance; var ready = WebAssembly.instantiate(new Uint8Array([" + new Uint8Array(s(i)) + "]), {}).then(function(result) { instance = result.instance; instance.exports.__wasm_call_ctors(); });self.onmessage = workerProcess;" + a.toString() + p.toString(), n = new Blob([t],{
                    type: "text/javascript"
                }), r = URL.createObjectURL(n), o = 0; o < e; ++o)
                    c[o] = h(r);
                URL.revokeObjectURL(r)
            }
            function p(e) {
                r.then((function() {
                    var t = e.data;
                    try {
                        var i = new Uint8Array(t.count * t.size);
                        a(n.exports[t.mode], i, t.count, t.size, t.source, n.exports[t.filter]),
                        self.postMessage({
                            id: t.id,
                            count: t.count,
                            action: "resolve",
                            value: i
                        }, [i.buffer])
                    } catch (e) {
                        self.postMessage({
                            id: t.id,
                            count: t.count,
                            action: "reject",
                            value: e
                        })
                    }
                }
                ))
            }
            return {
                ready: r,
                supported: !0,
                useWorkers: function(e) {
                    d(e)
                },
                decodeVertexBuffer: function(e, t, i, r, s) {
                    a(n.exports.meshopt_decodeVertexBuffer, e, t, i, r, n.exports[o[s]])
                },
                decodeIndexBuffer: function(e, t, i, r) {
                    a(n.exports.meshopt_decodeIndexBuffer, e, t, i, r)
                },
                decodeIndexSequence: function(e, t, i, r) {
                    a(n.exports.meshopt_decodeIndexSequence, e, t, i, r)
                },
                decodeGltfBuffer: function(e, t, i, r, s, c) {
                    a(n.exports[l[s]], e, t, i, r, n.exports[o[c]])
                },
                decodeGltfBufferAsync: function(e, t, i, s, h) {
                    return c.length > 0 ? function(e, t, n, i, r) {
                        for (var s = c[0], a = 1; a < c.length; ++a)
                            c[a].pending < s.pending && (s = c[a]);
                        return new Promise((function(a, o) {
                            var l = new Uint8Array(n)
                              , c = u++;
                            s.pending += e,
                            s.requests[c] = {
                                resolve: a,
                                reject: o
                            },
                            s.object.postMessage({
                                id: c,
                                count: e,
                                size: t,
                                source: l,
                                mode: i,
                                filter: r
                            }, [l.buffer])
                        }
                        ))
                    }(e, t, i, l[s], o[h]) : r.then((function() {
                        var r = new Uint8Array(e * t);
                        return a(n.exports[l[s]], r, e, t, i, n.exports[o[h]]),
                        r
                    }
                    ))
                }
            }
        }()
    }
    ,
    8087: (e, t, n) => {
        "use strict";
        n.d(t, {
            Z: () => s
        });
        var i = n(5062);
        const r = new WeakMap;
        class s extends i.aHM {
            constructor(e) {
                super(e),
                this.decoderPath = "",
                this.decoderConfig = {},
                this.decoderBinary = null,
                this.decoderPending = null,
                this.workerLimit = 4,
                this.workerPool = [],
                this.workerNextTaskID = 1,
                this.workerSourceURL = "",
                this.defaultAttributeIDs = {
                    position: "POSITION",
                    normal: "NORMAL",
                    color: "COLOR",
                    uv: "TEX_COORD"
                },
                this.defaultAttributeTypes = {
                    position: "Float32Array",
                    normal: "Float32Array",
                    color: "Float32Array",
                    uv: "Float32Array"
                }
            }
            setDecoderPath(e) {
                return this.decoderPath = e,
                this
            }
            setDecoderConfig(e) {
                return this.decoderConfig = e,
                this
            }
            setWorkerLimit(e) {
                return this.workerLimit = e,
                this
            }
            load(e, t, n, r) {
                const s = new i.Y9S(this.manager);
                s.setPath(this.path),
                s.setResponseType("arraybuffer"),
                s.setRequestHeader(this.requestHeader),
                s.setWithCredentials(this.withCredentials),
                s.load(e, (e => {
                    this.parse(e, t, r)
                }
                ), n, r)
            }
            parse(e, t, n=( () => {}
            )) {
                this.decodeDracoFile(e, t, null, null, i.er$, n).catch(n)
            }
            decodeDracoFile(e, t, n, r, s=i.Zr2, a=( () => {}
            )) {
                const o = {
                    attributeIDs: n || this.defaultAttributeIDs,
                    attributeTypes: r || this.defaultAttributeTypes,
                    useUniqueIDs: !!n,
                    vertexColorSpace: s
                };
                return this.decodeGeometry(e, o).then(t).catch(a)
            }
            decodeGeometry(e, t) {
                const n = JSON.stringify(t);
                if (r.has(e)) {
                    const t = r.get(e);
                    if (t.key === n)
                        return t.promise;
                    if (0 === e.byteLength)
                        throw new Error("THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.")
                }
                let i;
                const s = this.workerNextTaskID++
                  , a = e.byteLength
                  , o = this._getWorker(s, a).then((n => (i = n,
                new Promise(( (n, r) => {
                    i._callbacks[s] = {
                        resolve: n,
                        reject: r
                    },
                    i.postMessage({
                        type: "decode",
                        id: s,
                        taskConfig: t,
                        buffer: e
                    }, [e])
                }
                ))))).then((e => this._createGeometry(e.geometry)));
                return o.catch(( () => !0)).then(( () => {
                    i && s && this._releaseTask(i, s)
                }
                )),
                r.set(e, {
                    key: n,
                    promise: o
                }),
                o
            }
            _createGeometry(e) {
                const t = new i.LoY;
                e.index && t.setIndex(new i.THS(e.index.array,1));
                for (let n = 0; n < e.attributes.length; n++) {
                    const r = e.attributes[n]
                      , s = r.name
                      , a = r.array
                      , o = r.itemSize
                      , l = new i.THS(a,o);
                    "color" === s && (this._assignVertexColorSpace(l, r.vertexColorSpace),
                    l.normalized = a instanceof Float32Array == !1),
                    t.setAttribute(s, l)
                }
                return t
            }
            _assignVertexColorSpace(e, t) {
                if (t !== i.er$)
                    return;
                const n = new i.Q1f;
                for (let t = 0, r = e.count; t < r; t++)
                    n.fromBufferAttribute(e, t),
                    i.ppV.toWorkingColorSpace(n, i.er$),
                    e.setXYZ(t, n.r, n.g, n.b)
            }
            _loadLibrary(e, t) {
                const n = new i.Y9S(this.manager);
                return n.setPath(this.decoderPath),
                n.setResponseType(t),
                n.setWithCredentials(this.withCredentials),
                new Promise(( (t, i) => {
                    n.load(e, t, void 0, i)
                }
                ))
            }
            preload() {
                return this._initDecoder(),
                this
            }
            _initDecoder() {
                if (this.decoderPending)
                    return this.decoderPending;
                const e = "object" != typeof WebAssembly || "js" === this.decoderConfig.type
                  , t = [];
                return e ? t.push(this._loadLibrary("draco_decoder.js", "text")) : (t.push(this._loadLibrary("draco_wasm_wrapper.js", "text")),
                t.push(this._loadLibrary("draco_decoder.wasm", "arraybuffer"))),
                this.decoderPending = Promise.all(t).then((t => {
                    const n = t[0];
                    e || (this.decoderConfig.wasmBinary = t[1]);
                    const i = a.toString()
                      , r = ["/* draco decoder */", n, "", "/* worker */", i.substring(i.indexOf("{") + 1, i.lastIndexOf("}"))].join("\n");
                    this.workerSourceURL = URL.createObjectURL(new Blob([r]))
                }
                )),
                this.decoderPending
            }
            _getWorker(e, t) {
                return this._initDecoder().then(( () => {
                    if (this.workerPool.length < this.workerLimit) {
                        const e = new Worker(this.workerSourceURL);
                        e._callbacks = {},
                        e._taskCosts = {},
                        e._taskLoad = 0,
                        e.postMessage({
                            type: "init",
                            decoderConfig: this.decoderConfig
                        }),
                        e.onmessage = function(t) {
                            const n = t.data;
                            switch (n.type) {
                            case "decode":
                                e._callbacks[n.id].resolve(n);
                                break;
                            case "error":
                                e._callbacks[n.id].reject(n);
                                break;
                            default:
                                console.error('THREE.DRACOLoader: Unexpected message, "' + n.type + '"')
                            }
                        }
                        ,
                        this.workerPool.push(e)
                    } else
                        this.workerPool.sort((function(e, t) {
                            return e._taskLoad > t._taskLoad ? -1 : 1
                        }
                        ));
                    const n = this.workerPool[this.workerPool.length - 1];
                    return n._taskCosts[e] = t,
                    n._taskLoad += t,
                    n
                }
                ))
            }
            _releaseTask(e, t) {
                e._taskLoad -= e._taskCosts[t],
                delete e._callbacks[t],
                delete e._taskCosts[t]
            }
            debug() {
                console.log("Task load: ", this.workerPool.map((e => e._taskLoad)))
            }
            dispose() {
                for (let e = 0; e < this.workerPool.length; ++e)
                    this.workerPool[e].terminate();
                return this.workerPool.length = 0,
                "" !== this.workerSourceURL && URL.revokeObjectURL(this.workerSourceURL),
                this
            }
        }
        function a() {
            let e, t;
            function n(e, t, n, i, r, s) {
                const a = s.num_components()
                  , o = n.num_points() * a
                  , l = o * r.BYTES_PER_ELEMENT
                  , c = function(e, t) {
                    switch (t) {
                    case Float32Array:
                        return e.DT_FLOAT32;
                    case Int8Array:
                        return e.DT_INT8;
                    case Int16Array:
                        return e.DT_INT16;
                    case Int32Array:
                        return e.DT_INT32;
                    case Uint8Array:
                        return e.DT_UINT8;
                    case Uint16Array:
                        return e.DT_UINT16;
                    case Uint32Array:
                        return e.DT_UINT32
                    }
                }(e, r)
                  , u = e._malloc(l);
                t.GetAttributeDataArrayForAllPoints(n, s, c, l, u);
                const h = new r(e.HEAPF32.buffer,u,o).slice();
                return e._free(u),
                {
                    name: i,
                    array: h,
                    itemSize: a
                }
            }
            onmessage = function(i) {
                const r = i.data;
                switch (r.type) {
                case "init":
                    e = r.decoderConfig,
                    t = new Promise((function(t) {
                        e.onModuleLoaded = function(e) {
                            t({
                                draco: e
                            })
                        }
                        ,
                        DracoDecoderModule(e)
                    }
                    ));
                    break;
                case "decode":
                    const i = r.buffer
                      , s = r.taskConfig;
                    t.then((e => {
                        const t = e.draco
                          , a = new t.Decoder;
                        try {
                            const e = function(e, t, i, r) {
                                const s = r.attributeIDs
                                  , a = r.attributeTypes;
                                let o, l;
                                const c = t.GetEncodedGeometryType(i);
                                if (c === e.TRIANGULAR_MESH)
                                    o = new e.Mesh,
                                    l = t.DecodeArrayToMesh(i, i.byteLength, o);
                                else {
                                    if (c !== e.POINT_CLOUD)
                                        throw new Error("THREE.DRACOLoader: Unexpected geometry type.");
                                    o = new e.PointCloud,
                                    l = t.DecodeArrayToPointCloud(i, i.byteLength, o)
                                }
                                if (!l.ok() || 0 === o.ptr)
                                    throw new Error("THREE.DRACOLoader: Decoding failed: " + l.error_msg());
                                const u = {
                                    index: null,
                                    attributes: []
                                };
                                for (const i in s) {
                                    const l = self[a[i]];
                                    let c, h;
                                    if (r.useUniqueIDs)
                                        h = s[i],
                                        c = t.GetAttributeByUniqueId(o, h);
                                    else {
                                        if (h = t.GetAttributeId(o, e[s[i]]),
                                        -1 === h)
                                            continue;
                                        c = t.GetAttribute(o, h)
                                    }
                                    const d = n(e, t, o, i, l, c);
                                    "color" === i && (d.vertexColorSpace = r.vertexColorSpace),
                                    u.attributes.push(d)
                                }
                                c === e.TRIANGULAR_MESH && (u.index = function(e, t, n) {
                                    const i = n.num_faces()
                                      , r = 3 * i
                                      , s = 4 * r
                                      , a = e._malloc(s);
                                    t.GetTrianglesUInt32Array(n, s, a);
                                    const o = new Uint32Array(e.HEAPF32.buffer,a,r).slice();
                                    return e._free(a),
                                    {
                                        array: o,
                                        itemSize: 1
                                    }
                                }(e, t, o));
                                return e.destroy(o),
                                u
                            }(t, a, new Int8Array(i), s)
                              , o = e.attributes.map((e => e.array.buffer));
                            e.index && o.push(e.index.array.buffer),
                            self.postMessage({
                                type: "decode",
                                id: r.id,
                                geometry: e
                            }, o)
                        } catch (e) {
                            console.error(e),
                            self.postMessage({
                                type: "error",
                                id: r.id,
                                error: e.message
                            })
                        } finally {
                            t.destroy(a)
                        }
                    }
                    ))
                }
            }
        }
    }
    ,
    2701: (e, t, n) => {
        "use strict";
        n.d(t, {
            H: () => s
        });
        var i = n(5062)
          , r = n(7971);
        class s extends i.BRH {
            constructor(e) {
                super(e),
                this.type = i.ix0
            }
            parse(e) {
                const t = 65536
                  , n = 14
                  , s = 65537
                  , a = 16384
                  , o = Math.pow(2.7182818, 2.2);
                const l = {
                    l: 0,
                    c: 0,
                    lc: 0
                };
                function c(e, t, n, i, r) {
                    for (; n < e; )
                        t = t << 8 | z(i, r),
                        n += 8;
                    n -= e,
                    l.l = t >> n & (1 << e) - 1,
                    l.c = t,
                    l.lc = n
                }
                const u = new Array(59);
                function h(e, t, n, i, r, a) {
                    const o = t;
                    let h = 0
                      , d = 0;
                    for (; i <= r; i++) {
                        if (o.value - t.value > n)
                            return !1;
                        c(6, h, d, e, o);
                        const s = l.l;
                        if (h = l.c,
                        d = l.lc,
                        a[i] = s,
                        63 == s) {
                            if (o.value - t.value > n)
                                throw new Error("Something wrong with hufUnpackEncTable");
                            c(8, h, d, e, o);
                            let s = l.l + 6;
                            if (h = l.c,
                            d = l.lc,
                            i + s > r + 1)
                                throw new Error("Something wrong with hufUnpackEncTable");
                            for (; s--; )
                                a[i++] = 0;
                            i--
                        } else if (s >= 59) {
                            let e = s - 59 + 2;
                            if (i + e > r + 1)
                                throw new Error("Something wrong with hufUnpackEncTable");
                            for (; e--; )
                                a[i++] = 0;
                            i--
                        }
                    }
                    !function(e) {
                        for (let e = 0; e <= 58; ++e)
                            u[e] = 0;
                        for (let t = 0; t < s; ++t)
                            u[e[t]] += 1;
                        let t = 0;
                        for (let e = 58; e > 0; --e) {
                            const n = t + u[e] >> 1;
                            u[e] = t,
                            t = n
                        }
                        for (let t = 0; t < s; ++t) {
                            const n = e[t];
                            n > 0 && (e[t] = n | u[n]++ << 6)
                        }
                    }(a)
                }
                function d(e) {
                    return 63 & e
                }
                function p(e) {
                    return e >> 6
                }
                const f = {
                    c: 0,
                    lc: 0
                };
                function A(e, t, n, i) {
                    e = e << 8 | z(n, i),
                    t += 8,
                    f.c = e,
                    f.lc = t
                }
                const g = {
                    c: 0,
                    lc: 0
                };
                function m(e, t, n, i, r, s, a, o, l) {
                    if (e == t) {
                        i < 8 && (A(n, i, r, s),
                        n = f.c,
                        i = f.lc);
                        let e = n >> (i -= 8);
                        if (e = new Uint8Array([e])[0],
                        o.value + e > l)
                            return !1;
                        const t = a[o.value - 1];
                        for (; e-- > 0; )
                            a[o.value++] = t
                    } else {
                        if (!(o.value < l))
                            return !1;
                        a[o.value++] = e
                    }
                    g.c = n,
                    g.lc = i
                }
                function v(e) {
                    return 65535 & e
                }
                function y(e) {
                    const t = v(e);
                    return t > 32767 ? t - 65536 : t
                }
                const x = {
                    a: 0,
                    b: 0
                };
                function _(e, t) {
                    const n = y(e)
                      , i = y(t)
                      , r = n + (1 & i) + (i >> 1)
                      , s = r
                      , a = r - i;
                    x.a = s,
                    x.b = a
                }
                function b(e, t) {
                    const n = v(e)
                      , i = v(t)
                      , r = n - (i >> 1) & 65535
                      , s = i + r - 32768 & 65535;
                    x.a = s,
                    x.b = r
                }
                function E(e, t, n, i, r, s, a) {
                    const o = a < 16384
                      , l = n > r ? r : n;
                    let c, u, h = 1;
                    for (; h <= l; )
                        h <<= 1;
                    for (h >>= 1,
                    c = h,
                    h >>= 1; h >= 1; ) {
                        u = 0;
                        const a = u + s * (r - c)
                          , l = s * h
                          , d = s * c
                          , p = i * h
                          , f = i * c;
                        let A, g, m, v;
                        for (; u <= a; u += d) {
                            let r = u;
                            const s = u + i * (n - c);
                            for (; r <= s; r += f) {
                                const n = r + p
                                  , i = r + l
                                  , s = i + p;
                                o ? (_(e[r + t], e[i + t]),
                                A = x.a,
                                m = x.b,
                                _(e[n + t], e[s + t]),
                                g = x.a,
                                v = x.b,
                                _(A, g),
                                e[r + t] = x.a,
                                e[n + t] = x.b,
                                _(m, v),
                                e[i + t] = x.a,
                                e[s + t] = x.b) : (b(e[r + t], e[i + t]),
                                A = x.a,
                                m = x.b,
                                b(e[n + t], e[s + t]),
                                g = x.a,
                                v = x.b,
                                b(A, g),
                                e[r + t] = x.a,
                                e[n + t] = x.b,
                                b(m, v),
                                e[i + t] = x.a,
                                e[s + t] = x.b)
                            }
                            if (n & h) {
                                const n = r + l;
                                o ? _(e[r + t], e[n + t]) : b(e[r + t], e[n + t]),
                                A = x.a,
                                e[n + t] = x.b,
                                e[r + t] = A
                            }
                        }
                        if (r & h) {
                            let r = u;
                            const s = u + i * (n - c);
                            for (; r <= s; r += f) {
                                const n = r + p;
                                o ? _(e[r + t], e[n + t]) : b(e[r + t], e[n + t]),
                                A = x.a,
                                e[n + t] = x.b,
                                e[r + t] = A
                            }
                        }
                        c = h,
                        h >>= 1
                    }
                    return u
                }
                function w(e, t, i, r, o, l) {
                    const c = i.value
                      , u = H(t, i)
                      , v = H(t, i);
                    i.value += 4;
                    const y = H(t, i);
                    if (i.value += 4,
                    u < 0 || u >= s || v < 0 || v >= s)
                        throw new Error("Something wrong with HUF_ENCSIZE");
                    const x = new Array(s)
                      , _ = new Array(a);
                    !function(e) {
                        for (let t = 0; t < a; t++)
                            e[t] = {},
                            e[t].len = 0,
                            e[t].lit = 0,
                            e[t].p = null
                    }(_);
                    if (h(e, i, r - (i.value - c), u, v, x),
                    y > 8 * (r - (i.value - c)))
                        throw new Error("Something wrong with hufUncompress");
                    !function(e, t, i, r) {
                        for (; t <= i; t++) {
                            const i = p(e[t])
                              , s = d(e[t]);
                            if (i >> s)
                                throw new Error("Invalid table entry");
                            if (s > n) {
                                const e = r[i >> s - n];
                                if (e.len)
                                    throw new Error("Invalid table entry");
                                if (e.lit++,
                                e.p) {
                                    const t = e.p;
                                    e.p = new Array(e.lit);
                                    for (let n = 0; n < e.lit - 1; ++n)
                                        e.p[n] = t[n]
                                } else
                                    e.p = new Array(1);
                                e.p[e.lit - 1] = t
                            } else if (s) {
                                let e = 0;
                                for (let a = 1 << n - s; a > 0; a--) {
                                    const a = r[(i << n - s) + e];
                                    if (a.len || a.p)
                                        throw new Error("Invalid table entry");
                                    a.len = s,
                                    a.lit = t,
                                    e++
                                }
                            }
                        }
                    }(x, u, v, _),
                    function(e, t, i, r, s, a, o, l, c) {
                        let u = 0
                          , h = 0;
                        const v = o
                          , y = Math.trunc(r.value + (s + 7) / 8);
                        for (; r.value < y; )
                            for (A(u, h, i, r),
                            u = f.c,
                            h = f.lc; h >= n; ) {
                                const s = t[u >> h - n & 16383];
                                if (s.len)
                                    h -= s.len,
                                    m(s.lit, a, u, h, i, r, l, c, v),
                                    u = g.c,
                                    h = g.lc;
                                else {
                                    if (!s.p)
                                        throw new Error("hufDecode issues");
                                    let t;
                                    for (t = 0; t < s.lit; t++) {
                                        const n = d(e[s.p[t]]);
                                        for (; h < n && r.value < y; )
                                            A(u, h, i, r),
                                            u = f.c,
                                            h = f.lc;
                                        if (h >= n && p(e[s.p[t]]) == (u >> h - n & (1 << n) - 1)) {
                                            h -= n,
                                            m(s.p[t], a, u, h, i, r, l, c, v),
                                            u = g.c,
                                            h = g.lc;
                                            break
                                        }
                                    }
                                    if (t == s.lit)
                                        throw new Error("hufDecode issues")
                                }
                            }
                        const x = 8 - s & 7;
                        for (u >>= x,
                        h -= x; h > 0; ) {
                            const e = t[u << n - h & 16383];
                            if (!e.len)
                                throw new Error("hufDecode issues");
                            h -= e.len,
                            m(e.lit, a, u, h, i, r, l, c, v),
                            u = g.c,
                            h = g.lc
                        }
                    }(x, _, e, i, y, v, l, o, {
                        value: 0
                    })
                }
                function C(e) {
                    for (let t = 1; t < e.length; t++) {
                        const n = e[t - 1] + e[t] - 128;
                        e[t] = n
                    }
                }
                function I(e, t) {
                    let n = 0
                      , i = Math.floor((e.length + 1) / 2)
                      , r = 0;
                    const s = e.length - 1;
                    for (; !(r > s || (t[r++] = e[n++],
                    r > s)); )
                        t[r++] = e[i++]
                }
                function S(e) {
                    let t = e.byteLength;
                    const n = new Array;
                    let i = 0;
                    const r = new DataView(e);
                    for (; t > 0; ) {
                        const e = r.getInt8(i++);
                        if (e < 0) {
                            const s = -e;
                            t -= s + 1;
                            for (let e = 0; e < s; e++)
                                n.push(r.getUint8(i++))
                        } else {
                            const s = e;
                            t -= 2;
                            const a = r.getUint8(i++);
                            for (let e = 0; e < s + 1; e++)
                                n.push(a)
                        }
                    }
                    return n
                }
                function M(e, t, n) {
                    let i, r = 1;
                    for (; r < 64; )
                        i = t[e.value],
                        65280 == i ? r = 64 : i >> 8 == 255 ? r += 255 & i : (n[r] = i,
                        r++),
                        e.value++
                }
                function T(e, t) {
                    t[0] = Y(e[0]),
                    t[1] = Y(e[1]),
                    t[2] = Y(e[5]),
                    t[3] = Y(e[6]),
                    t[4] = Y(e[14]),
                    t[5] = Y(e[15]),
                    t[6] = Y(e[27]),
                    t[7] = Y(e[28]),
                    t[8] = Y(e[2]),
                    t[9] = Y(e[4]),
                    t[10] = Y(e[7]),
                    t[11] = Y(e[13]),
                    t[12] = Y(e[16]),
                    t[13] = Y(e[26]),
                    t[14] = Y(e[29]),
                    t[15] = Y(e[42]),
                    t[16] = Y(e[3]),
                    t[17] = Y(e[8]),
                    t[18] = Y(e[12]),
                    t[19] = Y(e[17]),
                    t[20] = Y(e[25]),
                    t[21] = Y(e[30]),
                    t[22] = Y(e[41]),
                    t[23] = Y(e[43]),
                    t[24] = Y(e[9]),
                    t[25] = Y(e[11]),
                    t[26] = Y(e[18]),
                    t[27] = Y(e[24]),
                    t[28] = Y(e[31]),
                    t[29] = Y(e[40]),
                    t[30] = Y(e[44]),
                    t[31] = Y(e[53]),
                    t[32] = Y(e[10]),
                    t[33] = Y(e[19]),
                    t[34] = Y(e[23]),
                    t[35] = Y(e[32]),
                    t[36] = Y(e[39]),
                    t[37] = Y(e[45]),
                    t[38] = Y(e[52]),
                    t[39] = Y(e[54]),
                    t[40] = Y(e[20]),
                    t[41] = Y(e[22]),
                    t[42] = Y(e[33]),
                    t[43] = Y(e[38]),
                    t[44] = Y(e[46]),
                    t[45] = Y(e[51]),
                    t[46] = Y(e[55]),
                    t[47] = Y(e[60]),
                    t[48] = Y(e[21]),
                    t[49] = Y(e[34]),
                    t[50] = Y(e[37]),
                    t[51] = Y(e[47]),
                    t[52] = Y(e[50]),
                    t[53] = Y(e[56]),
                    t[54] = Y(e[59]),
                    t[55] = Y(e[61]),
                    t[56] = Y(e[35]),
                    t[57] = Y(e[36]),
                    t[58] = Y(e[48]),
                    t[59] = Y(e[49]),
                    t[60] = Y(e[57]),
                    t[61] = Y(e[58]),
                    t[62] = Y(e[62]),
                    t[63] = Y(e[63])
                }
                function B(e) {
                    const t = .5 * Math.cos(.7853975)
                      , n = .5 * Math.cos(3.14159 / 16)
                      , i = .5 * Math.cos(3.14159 / 8)
                      , r = .5 * Math.cos(3 * 3.14159 / 16)
                      , s = .5 * Math.cos(.981746875)
                      , a = .5 * Math.cos(3 * 3.14159 / 8)
                      , o = .5 * Math.cos(1.374445625)
                      , l = new Array(4)
                      , c = new Array(4)
                      , u = new Array(4)
                      , h = new Array(4);
                    for (let d = 0; d < 8; ++d) {
                        const p = 8 * d;
                        l[0] = i * e[p + 2],
                        l[1] = a * e[p + 2],
                        l[2] = i * e[p + 6],
                        l[3] = a * e[p + 6],
                        c[0] = n * e[p + 1] + r * e[p + 3] + s * e[p + 5] + o * e[p + 7],
                        c[1] = r * e[p + 1] - o * e[p + 3] - n * e[p + 5] - s * e[p + 7],
                        c[2] = s * e[p + 1] - n * e[p + 3] + o * e[p + 5] + r * e[p + 7],
                        c[3] = o * e[p + 1] - s * e[p + 3] + r * e[p + 5] - n * e[p + 7],
                        u[0] = t * (e[p + 0] + e[p + 4]),
                        u[3] = t * (e[p + 0] - e[p + 4]),
                        u[1] = l[0] + l[3],
                        u[2] = l[1] - l[2],
                        h[0] = u[0] + u[1],
                        h[1] = u[3] + u[2],
                        h[2] = u[3] - u[2],
                        h[3] = u[0] - u[1],
                        e[p + 0] = h[0] + c[0],
                        e[p + 1] = h[1] + c[1],
                        e[p + 2] = h[2] + c[2],
                        e[p + 3] = h[3] + c[3],
                        e[p + 4] = h[3] - c[3],
                        e[p + 5] = h[2] - c[2],
                        e[p + 6] = h[1] - c[1],
                        e[p + 7] = h[0] - c[0]
                    }
                    for (let d = 0; d < 8; ++d)
                        l[0] = i * e[16 + d],
                        l[1] = a * e[16 + d],
                        l[2] = i * e[48 + d],
                        l[3] = a * e[48 + d],
                        c[0] = n * e[8 + d] + r * e[24 + d] + s * e[40 + d] + o * e[56 + d],
                        c[1] = r * e[8 + d] - o * e[24 + d] - n * e[40 + d] - s * e[56 + d],
                        c[2] = s * e[8 + d] - n * e[24 + d] + o * e[40 + d] + r * e[56 + d],
                        c[3] = o * e[8 + d] - s * e[24 + d] + r * e[40 + d] - n * e[56 + d],
                        u[0] = t * (e[d] + e[32 + d]),
                        u[3] = t * (e[d] - e[32 + d]),
                        u[1] = l[0] + l[3],
                        u[2] = l[1] - l[2],
                        h[0] = u[0] + u[1],
                        h[1] = u[3] + u[2],
                        h[2] = u[3] - u[2],
                        h[3] = u[0] - u[1],
                        e[0 + d] = h[0] + c[0],
                        e[8 + d] = h[1] + c[1],
                        e[16 + d] = h[2] + c[2],
                        e[24 + d] = h[3] + c[3],
                        e[32 + d] = h[3] - c[3],
                        e[40 + d] = h[2] - c[2],
                        e[48 + d] = h[1] - c[1],
                        e[56 + d] = h[0] - c[0]
                }
                function R(e) {
                    for (let t = 0; t < 64; ++t) {
                        const n = e[0][t]
                          , i = e[1][t]
                          , r = e[2][t];
                        e[0][t] = n + 1.5747 * r,
                        e[1][t] = n - .1873 * i - .4682 * r,
                        e[2][t] = n + 1.8556 * i
                    }
                }
                function D(e, t, n) {
                    for (let r = 0; r < 64; ++r)
                        t[n + r] = i.GxU.toHalfFloat(P(e[r]))
                }
                function P(e) {
                    return e <= 1 ? Math.sign(e) * Math.pow(Math.abs(e), 2.2) : Math.sign(e) * Math.pow(o, Math.abs(e) - 1)
                }
                function L(e) {
                    return new DataView(e.array.buffer,e.offset.value,e.size)
                }
                function U(e) {
                    const t = e.viewer.buffer.slice(e.offset.value, e.offset.value + e.size)
                      , n = new Uint8Array(S(t))
                      , i = new Uint8Array(n.length);
                    return C(n),
                    I(n, i),
                    new DataView(i.buffer)
                }
                function F(e) {
                    const t = e.array.slice(e.offset.value, e.offset.value + e.size)
                      , n = r.a8(t)
                      , i = new Uint8Array(n.length);
                    return C(n),
                    I(n, i),
                    new DataView(i.buffer)
                }
                function N(e) {
                    const n = e.viewer
                      , i = {
                        value: e.offset.value
                    }
                      , r = new Uint16Array(e.columns * e.lines * (e.inputChannels.length * e.type))
                      , s = new Uint8Array(8192);
                    let a = 0;
                    const o = new Array(e.inputChannels.length);
                    for (let t = 0, n = e.inputChannels.length; t < n; t++)
                        o[t] = {},
                        o[t].start = a,
                        o[t].end = o[t].start,
                        o[t].nx = e.columns,
                        o[t].ny = e.lines,
                        o[t].size = e.type,
                        a += o[t].nx * o[t].ny * o[t].size;
                    const l = X(n, i)
                      , c = X(n, i);
                    if (c >= 8192)
                        throw new Error("Something is wrong with PIZ_COMPRESSION BITMAP_SIZE");
                    if (l <= c)
                        for (let e = 0; e < c - l + 1; e++)
                            s[e + l] = V(n, i);
                    const u = new Uint16Array(t)
                      , h = function(e, n) {
                        let i = 0;
                        for (let r = 0; r < t; ++r)
                            (0 == r || e[r >> 3] & 1 << (7 & r)) && (n[i++] = r);
                        const r = i - 1;
                        for (; i < t; )
                            n[i++] = 0;
                        return r
                    }(s, u)
                      , d = H(n, i);
                    w(e.array, n, i, d, r, a);
                    for (let t = 0; t < e.inputChannels.length; ++t) {
                        const e = o[t];
                        for (let n = 0; n < o[t].size; ++n)
                            E(r, e.start + n, e.nx, e.size, e.ny, e.nx * e.size, h)
                    }
                    !function(e, t, n) {
                        for (let i = 0; i < n; ++i)
                            t[i] = e[t[i]]
                    }(u, r, a);
                    let p = 0;
                    const f = new Uint8Array(r.buffer.byteLength);
                    for (let t = 0; t < e.lines; t++)
                        for (let t = 0; t < e.inputChannels.length; t++) {
                            const e = o[t]
                              , n = e.nx * e.size
                              , i = new Uint8Array(r.buffer,2 * e.end,2 * n);
                            f.set(i, p),
                            p += 2 * n,
                            e.end += n
                        }
                    return new DataView(f.buffer)
                }
                function O(e) {
                    const t = e.array.slice(e.offset.value, e.offset.value + e.size)
                      , n = r.a8(t)
                      , i = e.inputChannels.length * e.lines * e.columns * e.totalBytes
                      , s = new ArrayBuffer(i)
                      , a = new DataView(s);
                    let o = 0
                      , l = 0;
                    const c = new Array(4);
                    for (let t = 0; t < e.lines; t++)
                        for (let t = 0; t < e.inputChannels.length; t++) {
                            let i = 0;
                            switch (e.inputChannels[t].pixelType) {
                            case 1:
                                c[0] = o,
                                c[1] = c[0] + e.columns,
                                o = c[1] + e.columns;
                                for (let t = 0; t < e.columns; ++t) {
                                    i += n[c[0]++] << 8 | n[c[1]++],
                                    a.setUint16(l, i, !0),
                                    l += 2
                                }
                                break;
                            case 2:
                                c[0] = o,
                                c[1] = c[0] + e.columns,
                                c[2] = c[1] + e.columns,
                                o = c[2] + e.columns;
                                for (let t = 0; t < e.columns; ++t) {
                                    i += n[c[0]++] << 24 | n[c[1]++] << 16 | n[c[2]++] << 8,
                                    a.setUint32(l, i, !0),
                                    l += 4
                                }
                            }
                        }
                    return a
                }
                function Q(e) {
                    const t = e.viewer
                      , n = {
                        value: e.offset.value
                    }
                      , i = new Uint8Array(e.columns * e.lines * (e.inputChannels.length * e.type * 2))
                      , s = {
                        version: W(t, n),
                        unknownUncompressedSize: W(t, n),
                        unknownCompressedSize: W(t, n),
                        acCompressedSize: W(t, n),
                        dcCompressedSize: W(t, n),
                        rleCompressedSize: W(t, n),
                        rleUncompressedSize: W(t, n),
                        rleRawSize: W(t, n),
                        totalAcUncompressedCount: W(t, n),
                        totalDcUncompressedCount: W(t, n),
                        acCompression: W(t, n)
                    };
                    if (s.version < 2)
                        throw new Error("EXRLoader.parse: " + se.compression + " version " + s.version + " is unsupported");
                    const a = new Array;
                    let o = X(t, n) - 2;
                    for (; o > 0; ) {
                        const e = k(t.buffer, n)
                          , i = V(t, n)
                          , r = i >> 2 & 3
                          , s = new Int8Array([(i >> 4) - 1])[0]
                          , l = V(t, n);
                        a.push({
                            name: e,
                            index: s,
                            type: l,
                            compression: r
                        }),
                        o -= e.length + 3
                    }
                    const l = se.channels
                      , c = new Array(e.inputChannels.length);
                    for (let t = 0; t < e.inputChannels.length; ++t) {
                        const n = c[t] = {}
                          , i = l[t];
                        n.name = i.name,
                        n.compression = 0,
                        n.decoded = !1,
                        n.type = i.pixelType,
                        n.pLinear = i.pLinear,
                        n.width = e.columns,
                        n.height = e.lines
                    }
                    const u = {
                        idx: new Array(3)
                    };
                    for (let t = 0; t < e.inputChannels.length; ++t) {
                        const e = c[t];
                        for (let n = 0; n < a.length; ++n) {
                            const i = a[n];
                            e.name == i.name && (e.compression = i.compression,
                            i.index >= 0 && (u.idx[i.index] = t),
                            e.offset = t)
                        }
                    }
                    let h, d, p;
                    if (s.acCompressedSize > 0)
                        switch (s.acCompression) {
                        case 0:
                            h = new Uint16Array(s.totalAcUncompressedCount),
                            w(e.array, t, n, s.acCompressedSize, h, s.totalAcUncompressedCount);
                            break;
                        case 1:
                            const i = e.array.slice(n.value, n.value + s.totalAcUncompressedCount)
                              , a = r.a8(i);
                            h = new Uint16Array(a.buffer),
                            n.value += s.totalAcUncompressedCount
                        }
                    if (s.dcCompressedSize > 0) {
                        const t = {
                            array: e.array,
                            offset: n,
                            size: s.dcCompressedSize
                        };
                        d = new Uint16Array(F(t).buffer),
                        n.value += s.dcCompressedSize
                    }
                    if (s.rleRawSize > 0) {
                        const t = e.array.slice(n.value, n.value + s.rleCompressedSize);
                        p = S(r.a8(t).buffer),
                        n.value += s.rleCompressedSize
                    }
                    let f = 0;
                    const A = new Array(c.length);
                    for (let e = 0; e < A.length; ++e)
                        A[e] = new Array;
                    for (let t = 0; t < e.lines; ++t)
                        for (let t = 0; t < c.length; ++t)
                            A[t].push(f),
                            f += c[t].width * e.type * 2;
                    !function(e, t, n, i, r, s) {
                        let a = new DataView(s.buffer);
                        const o = n[e.idx[0]].width
                          , l = n[e.idx[0]].height
                          , c = Math.floor(o / 8)
                          , u = Math.ceil(o / 8)
                          , h = Math.ceil(l / 8)
                          , d = o - 8 * (u - 1)
                          , p = l - 8 * (h - 1)
                          , f = {
                            value: 0
                        }
                          , A = new Array(3)
                          , g = new Array(3)
                          , m = new Array(3)
                          , v = new Array(3)
                          , y = new Array(3);
                        for (let n = 0; n < 3; ++n)
                            y[n] = t[e.idx[n]],
                            A[n] = n < 1 ? 0 : A[n - 1] + u * h,
                            g[n] = new Float32Array(64),
                            m[n] = new Uint16Array(64),
                            v[n] = new Uint16Array(64 * u);
                        for (let t = 0; t < h; ++t) {
                            let s = 8;
                            t == h - 1 && (s = p);
                            let o = 8;
                            for (let e = 0; e < u; ++e) {
                                e == u - 1 && (o = d);
                                for (let e = 0; e < 3; ++e)
                                    m[e].fill(0),
                                    m[e][0] = r[A[e]++],
                                    M(f, i, m[e]),
                                    T(m[e], g[e]),
                                    B(g[e]);
                                R(g);
                                for (let t = 0; t < 3; ++t)
                                    D(g[t], v[t], 64 * e)
                            }
                            let l = 0;
                            for (let i = 0; i < 3; ++i) {
                                const r = n[e.idx[i]].type;
                                for (let e = 8 * t; e < 8 * t + s; ++e) {
                                    l = y[i][e];
                                    for (let t = 0; t < c; ++t) {
                                        const n = 64 * t + 8 * (7 & e);
                                        a.setUint16(l + 0 * r, v[i][n + 0], !0),
                                        a.setUint16(l + 2 * r, v[i][n + 1], !0),
                                        a.setUint16(l + 4 * r, v[i][n + 2], !0),
                                        a.setUint16(l + 6 * r, v[i][n + 3], !0),
                                        a.setUint16(l + 8 * r, v[i][n + 4], !0),
                                        a.setUint16(l + 10 * r, v[i][n + 5], !0),
                                        a.setUint16(l + 12 * r, v[i][n + 6], !0),
                                        a.setUint16(l + 14 * r, v[i][n + 7], !0),
                                        l += 16 * r
                                    }
                                }
                                if (c != u)
                                    for (let e = 8 * t; e < 8 * t + s; ++e) {
                                        const t = y[i][e] + 8 * c * 2 * r
                                          , n = 64 * c + 8 * (7 & e);
                                        for (let e = 0; e < o; ++e)
                                            a.setUint16(t + 2 * e * r, v[i][n + e], !0)
                                    }
                            }
                        }
                        const x = new Uint16Array(o);
                        a = new DataView(s.buffer);
                        for (let t = 0; t < 3; ++t) {
                            n[e.idx[t]].decoded = !0;
                            const i = n[e.idx[t]].type;
                            if (2 == n[t].type)
                                for (let e = 0; e < l; ++e) {
                                    const n = y[t][e];
                                    for (let e = 0; e < o; ++e)
                                        x[e] = a.getUint16(n + 2 * e * i, !0);
                                    for (let e = 0; e < o; ++e)
                                        a.setFloat32(n + 2 * e * i, Y(x[e]), !0)
                                }
                        }
                    }(u, A, c, h, d, i);
                    for (let t = 0; t < c.length; ++t) {
                        const n = c[t];
                        if (!n.decoded) {
                            if (2 !== n.compression)
                                throw new Error("EXRLoader.parse: unsupported channel compression");
                            {
                                let r = 0
                                  , s = 0;
                                for (let a = 0; a < e.lines; ++a) {
                                    let e = A[t][r];
                                    for (let t = 0; t < n.width; ++t) {
                                        for (let t = 0; t < 2 * n.type; ++t)
                                            i[e++] = p[s + t * n.width * n.height];
                                        s++
                                    }
                                    r++
                                }
                            }
                        }
                    }
                    return new DataView(i.buffer)
                }
                function k(e, t) {
                    const n = new Uint8Array(e);
                    let i = 0;
                    for (; 0 != n[t.value + i]; )
                        i += 1;
                    const r = (new TextDecoder).decode(n.slice(t.value, t.value + i));
                    return t.value = t.value + i + 1,
                    r
                }
                function G(e, t) {
                    const n = e.getInt32(t.value, !0);
                    return t.value = t.value + 4,
                    n
                }
                function H(e, t) {
                    const n = e.getUint32(t.value, !0);
                    return t.value = t.value + 4,
                    n
                }
                function z(e, t) {
                    const n = e[t.value];
                    return t.value = t.value + 1,
                    n
                }
                function V(e, t) {
                    const n = e.getUint8(t.value);
                    return t.value = t.value + 1,
                    n
                }
                const W = function(e, t) {
                    let n;
                    return n = "getBigInt64"in DataView.prototype ? Number(e.getBigInt64(t.value, !0)) : e.getUint32(t.value + 4, !0) + Number(e.getUint32(t.value, !0) << 32),
                    t.value += 8,
                    n
                };
                function j(e, t) {
                    const n = e.getFloat32(t.value, !0);
                    return t.value += 4,
                    n
                }
                function q(e, t) {
                    return i.GxU.toHalfFloat(j(e, t))
                }
                function Y(e) {
                    const t = (31744 & e) >> 10
                      , n = 1023 & e;
                    return (e >> 15 ? -1 : 1) * (t ? 31 === t ? n ? NaN : 1 / 0 : Math.pow(2, t - 15) * (1 + n / 1024) : n / 1024 * 6103515625e-14)
                }
                function X(e, t) {
                    const n = e.getUint16(t.value, !0);
                    return t.value += 2,
                    n
                }
                function K(e, t) {
                    return Y(X(e, t))
                }
                function J(e, t, n, i, r) {
                    return "string" === i || "stringvector" === i || "iccProfile" === i ? function(e, t, n) {
                        const i = (new TextDecoder).decode(new Uint8Array(e).slice(t.value, t.value + n));
                        return t.value = t.value + n,
                        i
                    }(t, n, r) : "chlist" === i ? function(e, t, n, i) {
                        const r = n.value
                          , s = [];
                        for (; n.value < r + i - 1; ) {
                            const i = k(t, n)
                              , r = G(e, n)
                              , a = V(e, n);
                            n.value += 3;
                            const o = G(e, n)
                              , l = G(e, n);
                            s.push({
                                name: i,
                                pixelType: r,
                                pLinear: a,
                                xSampling: o,
                                ySampling: l
                            })
                        }
                        return n.value += 1,
                        s
                    }(e, t, n, r) : "chromaticities" === i ? function(e, t) {
                        return {
                            redX: j(e, t),
                            redY: j(e, t),
                            greenX: j(e, t),
                            greenY: j(e, t),
                            blueX: j(e, t),
                            blueY: j(e, t),
                            whiteX: j(e, t),
                            whiteY: j(e, t)
                        }
                    }(e, n) : "compression" === i ? function(e, t) {
                        return ["NO_COMPRESSION", "RLE_COMPRESSION", "ZIPS_COMPRESSION", "ZIP_COMPRESSION", "PIZ_COMPRESSION", "PXR24_COMPRESSION", "B44_COMPRESSION", "B44A_COMPRESSION", "DWAA_COMPRESSION", "DWAB_COMPRESSION"][V(e, t)]
                    }(e, n) : "box2i" === i ? function(e, t) {
                        return {
                            xMin: G(e, t),
                            yMin: G(e, t),
                            xMax: G(e, t),
                            yMax: G(e, t)
                        }
                    }(e, n) : "envmap" === i ? function(e, t) {
                        return ["ENVMAP_LATLONG", "ENVMAP_CUBE"][V(e, t)]
                    }(e, n) : "tiledesc" === i ? function(e, t) {
                        const n = H(e, t)
                          , i = H(e, t)
                          , r = V(e, t);
                        return {
                            xSize: n,
                            ySize: i,
                            levelMode: ["ONE_LEVEL", "MIPMAP_LEVELS", "RIPMAP_LEVELS"][15 & r],
                            roundingMode: ["ROUND_DOWN", "ROUND_UP"][r >> 4]
                        }
                    }(e, n) : "lineOrder" === i ? function(e, t) {
                        return ["INCREASING_Y", "DECREASING_Y", "RANDOM_Y"][V(e, t)]
                    }(e, n) : "float" === i ? j(e, n) : "v2f" === i ? function(e, t) {
                        return [j(e, t), j(e, t)]
                    }(e, n) : "v3f" === i ? function(e, t) {
                        return [j(e, t), j(e, t), j(e, t)]
                    }(e, n) : "int" === i ? G(e, n) : "rational" === i ? function(e, t) {
                        return [G(e, t), H(e, t)]
                    }(e, n) : "timecode" === i ? function(e, t) {
                        return [H(e, t), H(e, t)]
                    }(e, n) : "preview" === i ? (n.value += r,
                    "skipped") : void (n.value += r)
                }
                function Z(e, t, n) {
                    let i = 0;
                    switch (e.levelMode) {
                    case "ONE_LEVEL":
                        i = 1;
                        break;
                    case "MIPMAP_LEVELS":
                        i = function(e, t) {
                            const n = Math.log2(e);
                            return "ROUND_DOWN" == t ? Math.floor(n) : Math.ceil(n)
                        }(Math.max(t, n), e.roundingMode) + 1;
                        break;
                    case "RIPMAP_LEVELS":
                        throw new Error("THREE.EXRLoader: RIPMAP_LEVELS tiles currently unsupported.")
                    }
                    return i
                }
                function $(e, t, n, i) {
                    const r = new Array(e);
                    for (let s = 0; s < e; s++) {
                        const e = 1 << s;
                        let a = t / e | 0;
                        "ROUND_UP" == i && a * e < t && (a += 1);
                        const o = Math.max(a, 1);
                        r[s] = (o + n - 1) / n | 0
                    }
                    return r
                }
                function ee() {
                    const e = this
                      , t = e.offset
                      , n = {
                        value: 0
                    };
                    for (let i = 0; i < e.tileCount; i++) {
                        const i = G(e.viewer, t)
                          , r = G(e.viewer, t);
                        t.value += 8,
                        e.size = H(e.viewer, t);
                        const s = i * e.blockWidth
                          , a = r * e.blockHeight;
                        e.columns = s + e.blockWidth > e.width ? e.width - s : e.blockWidth,
                        e.lines = a + e.blockHeight > e.height ? e.height - a : e.blockHeight;
                        const o = e.columns * e.totalBytes
                          , l = e.size < e.lines * o ? e.uncompress(e) : L(e);
                        t.value += e.size;
                        for (let t = 0; t < e.lines; t++) {
                            const i = t * e.columns * e.totalBytes;
                            for (let r = 0; r < e.inputChannels.length; r++) {
                                const o = se.channels[r].name
                                  , c = e.channelByteOffsets[o] * e.columns
                                  , u = e.decodeChannels[o];
                                if (void 0 === u)
                                    continue;
                                n.value = i + c;
                                const h = (e.height - (1 + a + t)) * e.outLineWidth;
                                for (let t = 0; t < e.columns; t++) {
                                    const i = h + (t + s) * e.outputChannels + u;
                                    e.byteArray[i] = e.getter(l, n)
                                }
                            }
                        }
                    }
                }
                function te() {
                    const e = this
                      , t = e.offset
                      , n = {
                        value: 0
                    };
                    for (let i = 0; i < e.height / e.blockHeight; i++) {
                        const r = G(e.viewer, t) - se.dataWindow.yMin;
                        e.size = H(e.viewer, t),
                        e.lines = r + e.blockHeight > e.height ? e.height - r : e.blockHeight;
                        const s = e.columns * e.totalBytes
                          , a = e.size < e.lines * s ? e.uncompress(e) : L(e);
                        t.value += e.size;
                        for (let t = 0; t < e.blockHeight; t++) {
                            const r = i * e.blockHeight
                              , o = t + e.scanOrder(r);
                            if (o >= e.height)
                                continue;
                            const l = t * s
                              , c = (e.height - 1 - o) * e.outLineWidth;
                            for (let t = 0; t < e.inputChannels.length; t++) {
                                const i = se.channels[t].name
                                  , r = e.channelByteOffsets[i] * e.columns
                                  , s = e.decodeChannels[i];
                                if (void 0 !== s) {
                                    n.value = l + r;
                                    for (let t = 0; t < e.columns; t++) {
                                        const i = c + t * e.outputChannels + s;
                                        e.byteArray[i] = e.getter(a, n)
                                    }
                                }
                            }
                        }
                    }
                }
                const ne = {
                    value: 0
                }
                  , ie = new DataView(e)
                  , re = new Uint8Array(e)
                  , se = function(e, t, n) {
                    const i = {};
                    if (20000630 != e.getUint32(0, !0))
                        throw new Error("THREE.EXRLoader: Provided file doesn't appear to be in OpenEXR format.");
                    i.version = e.getUint8(4);
                    const r = e.getUint8(5);
                    i.spec = {
                        singleTile: !!(2 & r),
                        longName: !!(4 & r),
                        deepFormat: !!(8 & r),
                        multiPart: !!(16 & r)
                    },
                    n.value = 8;
                    let s = !0;
                    for (; s; ) {
                        const r = k(t, n);
                        if (0 == r)
                            s = !1;
                        else {
                            const s = k(t, n)
                              , a = J(e, t, n, s, H(e, n));
                            void 0 === a ? console.warn(`THREE.EXRLoader: Skipped unknown header attribute type '${s}'.`) : i[r] = a
                        }
                    }
                    if (-7 & r)
                        throw console.error("THREE.EXRHeader:", i),
                        new Error("THREE.EXRLoader: Provided file is currently unsupported.");
                    return i
                }(ie, e, ne)
                  , ae = function(e, t, n, r, s) {
                    const a = {
                        size: 0,
                        viewer: t,
                        array: n,
                        offset: r,
                        width: e.dataWindow.xMax - e.dataWindow.xMin + 1,
                        height: e.dataWindow.yMax - e.dataWindow.yMin + 1,
                        inputChannels: e.channels,
                        channelByteOffsets: {},
                        scanOrder: null,
                        totalBytes: null,
                        columns: null,
                        lines: null,
                        type: null,
                        uncompress: null,
                        getter: null,
                        format: null,
                        colorSpace: i.Zr2
                    };
                    switch (e.compression) {
                    case "NO_COMPRESSION":
                        a.blockHeight = 1,
                        a.uncompress = L;
                        break;
                    case "RLE_COMPRESSION":
                        a.blockHeight = 1,
                        a.uncompress = U;
                        break;
                    case "ZIPS_COMPRESSION":
                        a.blockHeight = 1,
                        a.uncompress = F;
                        break;
                    case "ZIP_COMPRESSION":
                        a.blockHeight = 16,
                        a.uncompress = F;
                        break;
                    case "PIZ_COMPRESSION":
                        a.blockHeight = 32,
                        a.uncompress = N;
                        break;
                    case "PXR24_COMPRESSION":
                        a.blockHeight = 16,
                        a.uncompress = O;
                        break;
                    case "DWAA_COMPRESSION":
                        a.blockHeight = 32,
                        a.uncompress = Q;
                        break;
                    case "DWAB_COMPRESSION":
                        a.blockHeight = 256,
                        a.uncompress = Q;
                        break;
                    default:
                        throw new Error("EXRLoader.parse: " + e.compression + " is unsupported")
                    }
                    const o = {};
                    for (const t of e.channels)
                        switch (t.name) {
                        case "Y":
                        case "R":
                        case "G":
                        case "B":
                        case "A":
                            o[t.name] = !0,
                            a.type = t.pixelType
                        }
                    let l = !1;
                    if (o.R && o.G && o.B)
                        l = !o.A,
                        a.outputChannels = 4,
                        a.decodeChannels = {
                            R: 0,
                            G: 1,
                            B: 2,
                            A: 3
                        };
                    else {
                        if (!o.Y)
                            throw new Error("EXRLoader.parse: file contains unsupported data channels.");
                        a.outputChannels = 1,
                        a.decodeChannels = {
                            Y: 0
                        }
                    }
                    if (1 == a.type)
                        switch (s) {
                        case i.RQf:
                            a.getter = K;
                            break;
                        case i.ix0:
                            a.getter = X
                        }
                    else {
                        if (2 != a.type)
                            throw new Error("EXRLoader.parse: unsupported pixelType " + a.type + " for " + e.compression + ".");
                        switch (s) {
                        case i.RQf:
                            a.getter = j;
                            break;
                        case i.ix0:
                            a.getter = q
                        }
                    }
                    a.columns = a.width;
                    const c = a.width * a.height * a.outputChannels;
                    switch (s) {
                    case i.RQf:
                        a.byteArray = new Float32Array(c),
                        l && a.byteArray.fill(1, 0, c);
                        break;
                    case i.ix0:
                        a.byteArray = new Uint16Array(c),
                        l && a.byteArray.fill(15360, 0, c);
                        break;
                    default:
                        console.error("THREE.EXRLoader: unsupported type: ", s)
                    }
                    let u = 0;
                    for (const t of e.channels)
                        void 0 !== a.decodeChannels[t.name] && (a.channelByteOffsets[t.name] = u),
                        u += 2 * t.pixelType;
                    if (a.totalBytes = u,
                    a.outLineWidth = a.width * a.outputChannels,
                    "INCREASING_Y" === e.lineOrder ? a.scanOrder = e => e : a.scanOrder = e => a.height - 1 - e,
                    4 == a.outputChannels ? (a.format = i.GWd,
                    a.colorSpace = i.Zr2) : (a.format = i.VT0,
                    a.colorSpace = i.jf0),
                    e.spec.singleTile) {
                        a.blockHeight = e.tiles.ySize,
                        a.blockWidth = e.tiles.xSize;
                        const n = Z(e.tiles, a.width, a.height)
                          , i = $(n, a.width, e.tiles.xSize, e.tiles.roundingMode)
                          , s = $(n, a.height, e.tiles.ySize, e.tiles.roundingMode);
                        a.tileCount = i[0] * s[0];
                        for (let e = 0; e < n; e++)
                            for (let n = 0; n < s[e]; n++)
                                for (let n = 0; n < i[e]; n++)
                                    W(t, r);
                        a.decode = ee.bind(a)
                    } else {
                        a.blockWidth = a.width;
                        const e = Math.ceil(a.height / a.blockHeight);
                        for (let n = 0; n < e; n++)
                            W(t, r);
                        a.decode = te.bind(a)
                    }
                    return a
                }(se, ie, re, ne, this.type);
                return ae.decode(),
                {
                    header: se,
                    width: ae.width,
                    height: ae.height,
                    data: ae.byteArray,
                    format: ae.format,
                    colorSpace: ae.colorSpace,
                    type: this.type
                }
            }
            setDataType(e) {
                return this.type = e,
                this
            }
            load(e, t, n, r) {
                return super.load(e, (function(e, n) {
                    e.colorSpace = n.colorSpace,
                    e.minFilter = i.k6q,
                    e.magFilter = i.k6q,
                    e.generateMipmaps = !1,
                    e.flipY = !1,
                    t && t(e, n)
                }
                ), n, r)
            }
        }
    }
    ,
    8003: (e, t, n) => {
        "use strict";
        n.d(t, {
            w: () => p
        });
        var i = n(5062)
          , r = n(7971);
        function s(e, t, n) {
            const i = n.length - e - 1;
            if (t >= n[i])
                return i - 1;
            if (t <= n[e])
                return e;
            let r = e
              , s = i
              , a = Math.floor((r + s) / 2);
            for (; t < n[a] || t >= n[a + 1]; )
                t < n[a] ? s = a : r = a,
                a = Math.floor((r + s) / 2);
            return a
        }
        function a(e, t, n, i) {
            const r = []
              , s = []
              , a = [];
            r[0] = 1;
            for (let o = 1; o <= n; ++o) {
                s[o] = t - i[e + 1 - o],
                a[o] = i[e + o] - t;
                let n = 0;
                for (let e = 0; e < o; ++e) {
                    const t = a[e + 1]
                      , i = s[o - e]
                      , l = r[e] / (t + i);
                    r[e] = n + t * l,
                    n = i * l
                }
                r[o] = n
            }
            return r
        }
        function o(e, t) {
            let n = 1;
            for (let t = 2; t <= e; ++t)
                n *= t;
            let i = 1;
            for (let e = 2; e <= t; ++e)
                i *= e;
            for (let n = 2; n <= e - t; ++n)
                i *= n;
            return n / i
        }
        function l(e, t, n, r, a) {
            const l = function(e, t, n, r, a) {
                const o = a < e ? a : e
                  , l = []
                  , c = s(e, r, t)
                  , u = function(e, t, n, i, r) {
                    const s = [];
                    for (let e = 0; e <= n; ++e)
                        s[e] = 0;
                    const a = [];
                    for (let e = 0; e <= i; ++e)
                        a[e] = s.slice(0);
                    const o = [];
                    for (let e = 0; e <= n; ++e)
                        o[e] = s.slice(0);
                    o[0][0] = 1;
                    const l = s.slice(0)
                      , c = s.slice(0);
                    for (let i = 1; i <= n; ++i) {
                        l[i] = t - r[e + 1 - i],
                        c[i] = r[e + i] - t;
                        let n = 0;
                        for (let e = 0; e < i; ++e) {
                            const t = c[e + 1]
                              , r = l[i - e];
                            o[i][e] = t + r;
                            const s = o[e][i - 1] / o[i][e];
                            o[e][i] = n + t * s,
                            n = r * s
                        }
                        o[i][i] = n
                    }
                    for (let e = 0; e <= n; ++e)
                        a[0][e] = o[e][n];
                    for (let e = 0; e <= n; ++e) {
                        let t = 0
                          , r = 1;
                        const l = [];
                        for (let e = 0; e <= n; ++e)
                            l[e] = s.slice(0);
                        l[0][0] = 1;
                        for (let s = 1; s <= i; ++s) {
                            let i = 0;
                            const c = e - s
                              , u = n - s;
                            e >= s && (l[r][0] = l[t][0] / o[u + 1][c],
                            i = l[r][0] * o[c][u]);
                            const h = e - 1 <= u ? s - 1 : n - e;
                            for (let e = c >= -1 ? 1 : -c; e <= h; ++e)
                                l[r][e] = (l[t][e] - l[t][e - 1]) / o[u + 1][c + e],
                                i += l[r][e] * o[c + e][u];
                            e <= u && (l[r][s] = -l[t][s - 1] / o[u + 1][e],
                            i += l[r][s] * o[e][u]),
                            a[s][e] = i;
                            const d = t;
                            t = r,
                            r = d
                        }
                    }
                    let u = n;
                    for (let e = 1; e <= i; ++e) {
                        for (let t = 0; t <= n; ++t)
                            a[e][t] *= u;
                        u *= n - e
                    }
                    return a
                }(c, r, e, o, t)
                  , h = [];
                for (let e = 0; e < n.length; ++e) {
                    const t = n[e].clone()
                      , i = t.w;
                    t.x *= i,
                    t.y *= i,
                    t.z *= i,
                    h[e] = t
                }
                for (let t = 0; t <= o; ++t) {
                    const n = h[c - e].clone().multiplyScalar(u[t][0]);
                    for (let i = 1; i <= e; ++i)
                        n.add(h[c - e + i].clone().multiplyScalar(u[t][i]));
                    l[t] = n
                }
                for (let e = o + 1; e <= a + 1; ++e)
                    l[e] = new i.IUQ(0,0,0);
                return l
            }(e, t, n, r, a);
            return function(e) {
                const t = e.length
                  , n = []
                  , r = [];
                for (let s = 0; s < t; ++s) {
                    const t = e[s];
                    n[s] = new i.Pq0(t.x,t.y,t.z),
                    r[s] = t.w
                }
                const s = [];
                for (let e = 0; e < t; ++e) {
                    const t = n[e].clone();
                    for (let n = 1; n <= e; ++n)
                        t.sub(s[e - n].clone().multiplyScalar(o(e, n) * r[n]));
                    s[e] = t.divideScalar(r[0])
                }
                return s
            }(l)
        }
        class c extends i.Ipv {
            constructor(e, t, n, r, s) {
                super();
                const a = t ? t.length - 1 : 0
                  , o = n ? n.length : 0;
                this.degree = e,
                this.knots = t,
                this.controlPoints = [],
                this.startKnot = r || 0,
                this.endKnot = s || a;
                for (let e = 0; e < o; ++e) {
                    const t = n[e];
                    this.controlPoints[e] = new i.IUQ(t.x,t.y,t.z,t.w)
                }
            }
            getPoint(e, t=new i.Pq0) {
                const n = t
                  , r = this.knots[this.startKnot] + e * (this.knots[this.endKnot] - this.knots[this.startKnot])
                  , o = function(e, t, n, r) {
                    const o = s(e, r, t)
                      , l = a(o, r, e, t)
                      , c = new i.IUQ(0,0,0,0);
                    for (let t = 0; t <= e; ++t) {
                        const i = n[o - e + t]
                          , r = l[t]
                          , s = i.w * r;
                        c.x += i.x * s,
                        c.y += i.y * s,
                        c.z += i.z * s,
                        c.w += i.w * r
                    }
                    return c
                }(this.degree, this.knots, this.controlPoints, r);
                return 1 !== o.w && o.divideScalar(o.w),
                n.set(o.x, o.y, o.z)
            }
            getTangent(e, t=new i.Pq0) {
                const n = t
                  , r = this.knots[0] + e * (this.knots[this.knots.length - 1] - this.knots[0])
                  , s = l(this.degree, this.knots, this.controlPoints, r, 1);
                return n.copy(s[1]).normalize(),
                n
            }
            toJSON() {
                const e = super.toJSON();
                return e.degree = this.degree,
                e.knots = [...this.knots],
                e.controlPoints = this.controlPoints.map((e => e.toArray())),
                e.startKnot = this.startKnot,
                e.endKnot = this.endKnot,
                e
            }
            fromJSON(e) {
                return super.fromJSON(e),
                this.degree = e.degree,
                this.knots = [...e.knots],
                this.controlPoints = e.controlPoints.map((e => new i.IUQ(e[0],e[1],e[2],e[3]))),
                this.startKnot = e.startKnot,
                this.endKnot = e.endKnot,
                this
            }
        }
        let u, h, d;
        class p extends i.aHM {
            constructor(e) {
                super(e)
            }
            load(e, t, n, r) {
                const s = this
                  , a = "" === s.path ? i.r6x.extractUrlBase(e) : s.path
                  , o = new i.Y9S(this.manager);
                o.setPath(s.path),
                o.setResponseType("arraybuffer"),
                o.setRequestHeader(s.requestHeader),
                o.setWithCredentials(s.withCredentials),
                o.load(e, (function(n) {
                    try {
                        t(s.parse(n, a))
                    } catch (t) {
                        r ? r(t) : console.error(t),
                        s.manager.itemError(e)
                    }
                }
                ), n, r)
            }
            parse(e, t) {
                if (function(e) {
                    const t = "Kaydara FBX Binary  \0";
                    return e.byteLength >= t.length && t === B(e, 0, t.length)
                }(e))
                    u = (new v).parse(e);
                else {
                    const t = B(e);
                    if (!function(e) {
                        const t = ["K", "a", "y", "d", "a", "r", "a", "\\", "F", "B", "X", "\\", "B", "i", "n", "a", "r", "y", "\\", "\\"];
                        let n = 0;
                        function i(t) {
                            const i = e[t - 1];
                            return e = e.slice(n + t),
                            n++,
                            i
                        }
                        for (let e = 0; e < t.length; ++e) {
                            if (i(1) === t[e])
                                return !1
                        }
                        return !0
                    }(t))
                        throw new Error("THREE.FBXLoader: Unknown format.");
                    if (_(t) < 7e3)
                        throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: " + _(t));
                    u = (new m).parse(t)
                }
                const n = new i.Tap(this.manager).setPath(this.resourcePath || t).setCrossOrigin(this.crossOrigin);
                return new f(n,this.manager).parse(u)
            }
        }
        class f {
            constructor(e, t) {
                this.textureLoader = e,
                this.manager = t
            }
            parse() {
                h = this.parseConnections();
                const e = this.parseImages()
                  , t = this.parseTextures(e)
                  , n = this.parseMaterials(t)
                  , i = this.parseDeformers()
                  , r = (new A).parse(i);
                return this.parseScene(i, r, n),
                d
            }
            parseConnections() {
                const e = new Map;
                if ("Connections"in u) {
                    u.Connections.connections.forEach((function(t) {
                        const n = t[0]
                          , i = t[1]
                          , r = t[2];
                        e.has(n) || e.set(n, {
                            parents: [],
                            children: []
                        });
                        const s = {
                            ID: i,
                            relationship: r
                        };
                        e.get(n).parents.push(s),
                        e.has(i) || e.set(i, {
                            parents: [],
                            children: []
                        });
                        const a = {
                            ID: n,
                            relationship: r
                        };
                        e.get(i).children.push(a)
                    }
                    ))
                }
                return e
            }
            parseImages() {
                const e = {}
                  , t = {};
                if ("Video"in u.Objects) {
                    const n = u.Objects.Video;
                    for (const i in n) {
                        const r = n[i];
                        if (e[parseInt(i)] = r.RelativeFilename || r.Filename,
                        "Content"in r) {
                            const e = r.Content instanceof ArrayBuffer && r.Content.byteLength > 0
                              , s = "string" == typeof r.Content && "" !== r.Content;
                            if (e || s) {
                                const e = this.parseImage(n[i]);
                                t[r.RelativeFilename || r.Filename] = e
                            }
                        }
                    }
                }
                for (const n in e) {
                    const i = e[n];
                    void 0 !== t[i] ? e[n] = t[i] : e[n] = e[n].split("\\").pop()
                }
                return e
            }
            parseImage(e) {
                const t = e.Content
                  , n = e.RelativeFilename || e.Filename
                  , i = n.slice(n.lastIndexOf(".") + 1).toLowerCase();
                let r;
                switch (i) {
                case "bmp":
                    r = "image/bmp";
                    break;
                case "jpg":
                case "jpeg":
                    r = "image/jpeg";
                    break;
                case "png":
                    r = "image/png";
                    break;
                case "tif":
                    r = "image/tiff";
                    break;
                case "tga":
                    null === this.manager.getHandler(".tga") && console.warn("FBXLoader: TGA loader not found, skipping ", n),
                    r = "image/tga";
                    break;
                default:
                    return void console.warn('FBXLoader: Image type "' + i + '" is not supported.')
                }
                if ("string" == typeof t)
                    return "data:" + r + ";base64," + t;
                {
                    const e = new Uint8Array(t);
                    return window.URL.createObjectURL(new Blob([e],{
                        type: r
                    }))
                }
            }
            parseTextures(e) {
                const t = new Map;
                if ("Texture"in u.Objects) {
                    const n = u.Objects.Texture;
                    for (const i in n) {
                        const r = this.parseTexture(n[i], e);
                        t.set(parseInt(i), r)
                    }
                }
                return t
            }
            parseTexture(e, t) {
                const n = this.loadTexture(e, t);
                n.ID = e.id,
                n.name = e.attrName;
                const r = e.WrapModeU
                  , s = e.WrapModeV
                  , a = void 0 !== r ? r.value : 0
                  , o = void 0 !== s ? s.value : 0;
                if (n.wrapS = 0 === a ? i.GJx : i.ghU,
                n.wrapT = 0 === o ? i.GJx : i.ghU,
                "Scaling"in e) {
                    const t = e.Scaling.value;
                    n.repeat.x = t[0],
                    n.repeat.y = t[1]
                }
                if ("Translation"in e) {
                    const t = e.Translation.value;
                    n.offset.x = t[0],
                    n.offset.y = t[1]
                }
                return n
            }
            loadTexture(e, t) {
                const n = new Set(["tga", "tif", "tiff", "exr", "dds", "hdr", "ktx2"])
                  , r = e.FileName.split(".").pop().toLowerCase()
                  , s = n.has(r) ? this.manager.getHandler(`.${r}`) : this.textureLoader;
                if (!s)
                    return console.warn(`FBXLoader: ${r.toUpperCase()} loader not found, creating placeholder texture for`, e.RelativeFilename),
                    new i.gPd;
                const a = s.path;
                a || s.setPath(this.textureLoader.path);
                const o = h.get(e.id).children;
                let l;
                void 0 !== o && o.length > 0 && void 0 !== t[o[0].ID] && (l = t[o[0].ID],
                0 !== l.indexOf("blob:") && 0 !== l.indexOf("data:") || s.setPath(void 0));
                const c = s.load(l);
                return s.setPath(a),
                c
            }
            parseMaterials(e) {
                const t = new Map;
                if ("Material"in u.Objects) {
                    const n = u.Objects.Material;
                    for (const i in n) {
                        const r = this.parseMaterial(n[i], e);
                        null !== r && t.set(parseInt(i), r)
                    }
                }
                return t
            }
            parseMaterial(e, t) {
                const n = e.id
                  , r = e.attrName;
                let s = e.ShadingModel;
                if ("object" == typeof s && (s = s.value),
                !h.has(n))
                    return null;
                const a = this.parseParameters(e, t, n);
                let o;
                switch (s.toLowerCase()) {
                case "phong":
                    o = new i.tXL;
                    break;
                case "lambert":
                    o = new i.G_z;
                    break;
                default:
                    console.warn('THREE.FBXLoader: unknown material type "%s". Defaulting to MeshPhongMaterial.', s),
                    o = new i.tXL
                }
                return o.setValues(a),
                o.name = r,
                o
            }
            parseParameters(e, t, n) {
                const r = {};
                e.BumpFactor && (r.bumpScale = e.BumpFactor.value),
                e.Diffuse ? r.color = i.ppV.toWorkingColorSpace((new i.Q1f).fromArray(e.Diffuse.value), i.er$) : !e.DiffuseColor || "Color" !== e.DiffuseColor.type && "ColorRGB" !== e.DiffuseColor.type || (r.color = i.ppV.toWorkingColorSpace((new i.Q1f).fromArray(e.DiffuseColor.value), i.er$)),
                e.DisplacementFactor && (r.displacementScale = e.DisplacementFactor.value),
                e.Emissive ? r.emissive = i.ppV.toWorkingColorSpace((new i.Q1f).fromArray(e.Emissive.value), i.er$) : !e.EmissiveColor || "Color" !== e.EmissiveColor.type && "ColorRGB" !== e.EmissiveColor.type || (r.emissive = i.ppV.toWorkingColorSpace((new i.Q1f).fromArray(e.EmissiveColor.value), i.er$)),
                e.EmissiveFactor && (r.emissiveIntensity = parseFloat(e.EmissiveFactor.value)),
                r.opacity = 1 - (e.TransparencyFactor ? parseFloat(e.TransparencyFactor.value) : 0),
                1 !== r.opacity && 0 !== r.opacity || (r.opacity = e.Opacity ? parseFloat(e.Opacity.value) : null,
                null === r.opacity && (r.opacity = 1 - (e.TransparentColor ? parseFloat(e.TransparentColor.value[0]) : 0))),
                r.opacity < 1 && (r.transparent = !0),
                e.ReflectionFactor && (r.reflectivity = e.ReflectionFactor.value),
                e.Shininess && (r.shininess = e.Shininess.value),
                e.Specular ? r.specular = i.ppV.toWorkingColorSpace((new i.Q1f).fromArray(e.Specular.value), i.er$) : e.SpecularColor && "Color" === e.SpecularColor.type && (r.specular = i.ppV.toWorkingColorSpace((new i.Q1f).fromArray(e.SpecularColor.value), i.er$));
                const s = this;
                return h.get(n).children.forEach((function(e) {
                    const n = e.relationship;
                    switch (n) {
                    case "Bump":
                        r.bumpMap = s.getTexture(t, e.ID);
                        break;
                    case "Maya|TEX_ao_map":
                        r.aoMap = s.getTexture(t, e.ID);
                        break;
                    case "DiffuseColor":
                    case "Maya|TEX_color_map":
                        r.map = s.getTexture(t, e.ID),
                        void 0 !== r.map && (r.map.colorSpace = i.er$);
                        break;
                    case "DisplacementColor":
                        r.displacementMap = s.getTexture(t, e.ID);
                        break;
                    case "EmissiveColor":
                        r.emissiveMap = s.getTexture(t, e.ID),
                        void 0 !== r.emissiveMap && (r.emissiveMap.colorSpace = i.er$);
                        break;
                    case "NormalMap":
                    case "Maya|TEX_normal_map":
                        r.normalMap = s.getTexture(t, e.ID);
                        break;
                    case "ReflectionColor":
                        r.envMap = s.getTexture(t, e.ID),
                        void 0 !== r.envMap && (r.envMap.mapping = i.wfO,
                        r.envMap.colorSpace = i.er$);
                        break;
                    case "SpecularColor":
                        r.specularMap = s.getTexture(t, e.ID),
                        void 0 !== r.specularMap && (r.specularMap.colorSpace = i.er$);
                        break;
                    case "TransparentColor":
                    case "TransparencyFactor":
                        r.alphaMap = s.getTexture(t, e.ID),
                        r.transparent = !0;
                        break;
                    default:
                        console.warn("THREE.FBXLoader: %s map is not supported in three.js, skipping texture.", n)
                    }
                }
                )),
                r
            }
            getTexture(e, t) {
                return "LayeredTexture"in u.Objects && t in u.Objects.LayeredTexture && (console.warn("THREE.FBXLoader: layered textures are not supported in three.js. Discarding all but first layer."),
                t = h.get(t).children[0].ID),
                e.get(t)
            }
            parseDeformers() {
                const e = {}
                  , t = {};
                if ("Deformer"in u.Objects) {
                    const n = u.Objects.Deformer;
                    for (const i in n) {
                        const r = n[i]
                          , s = h.get(parseInt(i));
                        if ("Skin" === r.attrType) {
                            const t = this.parseSkeleton(s, n);
                            t.ID = i,
                            s.parents.length > 1 && console.warn("THREE.FBXLoader: skeleton attached to more than one geometry is not supported."),
                            t.geometryID = s.parents[0].ID,
                            e[i] = t
                        } else if ("BlendShape" === r.attrType) {
                            const e = {
                                id: i
                            };
                            e.rawTargets = this.parseMorphTargets(s, n),
                            e.id = i,
                            s.parents.length > 1 && console.warn("THREE.FBXLoader: morph target attached to more than one geometry is not supported."),
                            t[i] = e
                        }
                    }
                }
                return {
                    skeletons: e,
                    morphTargets: t
                }
            }
            parseSkeleton(e, t) {
                const n = [];
                return e.children.forEach((function(e) {
                    const r = t[e.ID];
                    if ("Cluster" !== r.attrType)
                        return;
                    const s = {
                        ID: e.ID,
                        indices: [],
                        weights: [],
                        transformLink: (new i.kn4).fromArray(r.TransformLink.a)
                    };
                    "Indexes"in r && (s.indices = r.Indexes.a,
                    s.weights = r.Weights.a),
                    n.push(s)
                }
                )),
                {
                    rawBones: n,
                    bones: []
                }
            }
            parseMorphTargets(e, t) {
                const n = [];
                for (let i = 0; i < e.children.length; i++) {
                    const r = e.children[i]
                      , s = t[r.ID]
                      , a = {
                        name: s.attrName,
                        initialWeight: s.DeformPercent,
                        id: s.id,
                        fullWeights: s.FullWeights.a
                    };
                    if ("BlendShapeChannel" !== s.attrType)
                        return;
                    a.geoID = h.get(parseInt(r.ID)).children.filter((function(e) {
                        return void 0 === e.relationship
                    }
                    ))[0].ID,
                    n.push(a)
                }
                return n
            }
            parseScene(e, t, n) {
                d = new i.YJl;
                const r = this.parseModels(e.skeletons, t, n)
                  , s = u.Objects.Model
                  , a = this;
                r.forEach((function(e) {
                    const t = s[e.ID];
                    a.setLookAtProperties(e, t);
                    h.get(e.ID).parents.forEach((function(t) {
                        const n = r.get(t.ID);
                        void 0 !== n && n.add(e)
                    }
                    )),
                    null === e.parent && d.add(e)
                }
                )),
                this.bindSkeleton(e.skeletons, t, r),
                this.addGlobalSceneSettings(),
                d.traverse((function(e) {
                    if (e.userData.transformData) {
                        e.parent && (e.userData.transformData.parentMatrix = e.parent.matrix,
                        e.userData.transformData.parentMatrixWorld = e.parent.matrixWorld);
                        const t = S(e.userData.transformData);
                        e.applyMatrix4(t),
                        e.updateWorldMatrix()
                    }
                }
                ));
                const o = (new g).parse();
                1 === d.children.length && d.children[0].isGroup && (d.children[0].animations = o,
                d = d.children[0]),
                d.animations = o
            }
            parseModels(e, t, n) {
                const r = new Map
                  , s = u.Objects.Model;
                for (const a in s) {
                    const o = parseInt(a)
                      , l = s[a]
                      , c = h.get(o);
                    let u = this.buildSkeleton(c, e, o, l.attrName);
                    if (!u) {
                        switch (l.attrType) {
                        case "Camera":
                            u = this.createCamera(c);
                            break;
                        case "Light":
                            u = this.createLight(c);
                            break;
                        case "Mesh":
                            u = this.createMesh(c, t, n);
                            break;
                        case "NurbsCurve":
                            u = this.createCurve(c, t);
                            break;
                        case "LimbNode":
                        case "Root":
                            u = new i.$Kf;
                            break;
                        default:
                            u = new i.YJl
                        }
                        u.name = l.attrName ? i.Nwf.sanitizeNodeName(l.attrName) : "",
                        u.userData.originalName = l.attrName,
                        u.ID = o
                    }
                    this.getTransformData(u, l),
                    r.set(o, u)
                }
                return r
            }
            buildSkeleton(e, t, n, r) {
                let s = null;
                return e.parents.forEach((function(e) {
                    for (const a in t) {
                        const o = t[a];
                        o.rawBones.forEach((function(t, a) {
                            if (t.ID === e.ID) {
                                const e = s;
                                s = new i.$Kf,
                                s.matrixWorld.copy(t.transformLink),
                                s.name = r ? i.Nwf.sanitizeNodeName(r) : "",
                                s.userData.originalName = r,
                                s.ID = n,
                                o.bones[a] = s,
                                null !== e && s.add(e)
                            }
                        }
                        ))
                    }
                }
                )),
                s
            }
            createCamera(e) {
                let t, n;
                if (e.children.forEach((function(e) {
                    const t = u.Objects.NodeAttribute[e.ID];
                    void 0 !== t && (n = t)
                }
                )),
                void 0 === n)
                    t = new i.B69;
                else {
                    let e = 0;
                    void 0 !== n.CameraProjectionType && 1 === n.CameraProjectionType.value && (e = 1);
                    let r = 1;
                    void 0 !== n.NearPlane && (r = n.NearPlane.value / 1e3);
                    let s = 1e3;
                    void 0 !== n.FarPlane && (s = n.FarPlane.value / 1e3);
                    let a = window.innerWidth
                      , o = window.innerHeight;
                    void 0 !== n.AspectWidth && void 0 !== n.AspectHeight && (a = n.AspectWidth.value,
                    o = n.AspectHeight.value);
                    const l = a / o;
                    let c = 45;
                    void 0 !== n.FieldOfView && (c = n.FieldOfView.value);
                    const u = n.FocalLength ? n.FocalLength.value : null;
                    switch (e) {
                    case 0:
                        t = new i.ubm(c,l,r,s),
                        null !== u && t.setFocalLength(u);
                        break;
                    case 1:
                        console.warn("THREE.FBXLoader: Orthographic cameras not supported yet."),
                        t = new i.B69;
                        break;
                    default:
                        console.warn("THREE.FBXLoader: Unknown camera type " + e + "."),
                        t = new i.B69
                    }
                }
                return t
            }
            createLight(e) {
                let t, n;
                if (e.children.forEach((function(e) {
                    const t = u.Objects.NodeAttribute[e.ID];
                    void 0 !== t && (n = t)
                }
                )),
                void 0 === n)
                    t = new i.B69;
                else {
                    let e;
                    e = void 0 === n.LightType ? 0 : n.LightType.value;
                    let r = 16777215;
                    void 0 !== n.Color && (r = i.ppV.toWorkingColorSpace((new i.Q1f).fromArray(n.Color.value), i.er$));
                    let s = void 0 === n.Intensity ? 1 : n.Intensity.value / 100;
                    void 0 !== n.CastLightOnObject && 0 === n.CastLightOnObject.value && (s = 0);
                    let a = 0;
                    void 0 !== n.FarAttenuationEnd && (a = void 0 !== n.EnableFarAttenuation && 0 === n.EnableFarAttenuation.value ? 0 : n.FarAttenuationEnd.value);
                    const o = 1;
                    switch (e) {
                    case 0:
                        t = new i.HiM(r,s,a,o);
                        break;
                    case 1:
                        t = new i.ZyN(r,s);
                        break;
                    case 2:
                        let e = Math.PI / 3;
                        void 0 !== n.InnerAngle && (e = i.cj9.degToRad(n.InnerAngle.value));
                        let l = 0;
                        void 0 !== n.OuterAngle && (l = i.cj9.degToRad(n.OuterAngle.value),
                        l = Math.max(l, 1)),
                        t = new i.nCl(r,s,a,e,l,o);
                        break;
                    default:
                        console.warn("THREE.FBXLoader: Unknown light type " + n.LightType.value + ", defaulting to a PointLight."),
                        t = new i.HiM(r,s)
                    }
                    void 0 !== n.CastShadows && 1 === n.CastShadows.value && (t.castShadow = !0)
                }
                return t
            }
            createMesh(e, t, n) {
                let r, s = null, a = null;
                const o = [];
                return e.children.forEach((function(e) {
                    t.has(e.ID) && (s = t.get(e.ID)),
                    n.has(e.ID) && o.push(n.get(e.ID))
                }
                )),
                o.length > 1 ? a = o : o.length > 0 ? a = o[0] : (a = new i.tXL({
                    name: i.aHM.DEFAULT_MATERIAL_NAME,
                    color: 13421772
                }),
                o.push(a)),
                "color"in s.attributes && o.forEach((function(e) {
                    e.vertexColors = !0
                }
                )),
                s.FBX_Deformer ? (r = new i.I46(s,a),
                r.normalizeSkinWeights()) : r = new i.eaF(s,a),
                r
            }
            createCurve(e, t) {
                const n = e.children.reduce((function(e, n) {
                    return t.has(n.ID) && (e = t.get(n.ID)),
                    e
                }
                ), null)
                  , r = new i.mrM({
                    name: i.aHM.DEFAULT_MATERIAL_NAME,
                    color: 3342591,
                    linewidth: 1
                });
                return new i.N1A(n,r)
            }
            getTransformData(e, t) {
                const n = {};
                "InheritType"in t && (n.inheritType = parseInt(t.InheritType.value)),
                n.eulerOrder = M("RotationOrder"in t ? t.RotationOrder.value : 0),
                "Lcl_Translation"in t && (n.translation = t.Lcl_Translation.value),
                "PreRotation"in t && (n.preRotation = t.PreRotation.value),
                "Lcl_Rotation"in t && (n.rotation = t.Lcl_Rotation.value),
                "PostRotation"in t && (n.postRotation = t.PostRotation.value),
                "Lcl_Scaling"in t && (n.scale = t.Lcl_Scaling.value),
                "ScalingOffset"in t && (n.scalingOffset = t.ScalingOffset.value),
                "ScalingPivot"in t && (n.scalingPivot = t.ScalingPivot.value),
                "RotationOffset"in t && (n.rotationOffset = t.RotationOffset.value),
                "RotationPivot"in t && (n.rotationPivot = t.RotationPivot.value),
                e.userData.transformData = n
            }
            setLookAtProperties(e, t) {
                if ("LookAtProperty"in t) {
                    h.get(e.ID).children.forEach((function(t) {
                        if ("LookAtProperty" === t.relationship) {
                            const n = u.Objects.Model[t.ID];
                            if ("Lcl_Translation"in n) {
                                const t = n.Lcl_Translation.value;
                                void 0 !== e.target ? (e.target.position.fromArray(t),
                                d.add(e.target)) : e.lookAt((new i.Pq0).fromArray(t))
                            }
                        }
                    }
                    ))
                }
            }
            bindSkeleton(e, t, n) {
                const r = this.parsePoseNodes();
                for (const s in e) {
                    const a = e[s];
                    h.get(parseInt(a.ID)).parents.forEach((function(e) {
                        if (t.has(e.ID)) {
                            const t = e.ID;
                            h.get(t).parents.forEach((function(e) {
                                if (n.has(e.ID)) {
                                    n.get(e.ID).bind(new i.EAD(a.bones), r[e.ID])
                                }
                            }
                            ))
                        }
                    }
                    ))
                }
            }
            parsePoseNodes() {
                const e = {};
                if ("Pose"in u.Objects) {
                    const t = u.Objects.Pose;
                    for (const n in t)
                        if ("BindPose" === t[n].attrType && t[n].NbPoseNodes > 0) {
                            const r = t[n].PoseNode;
                            Array.isArray(r) ? r.forEach((function(t) {
                                e[t.Node] = (new i.kn4).fromArray(t.Matrix.a)
                            }
                            )) : e[r.Node] = (new i.kn4).fromArray(r.Matrix.a)
                        }
                }
                return e
            }
            addGlobalSceneSettings() {
                if ("GlobalSettings"in u) {
                    if ("AmbientColor"in u.GlobalSettings) {
                        const e = u.GlobalSettings.AmbientColor.value
                          , t = e[0]
                          , n = e[1]
                          , r = e[2];
                        if (0 !== t || 0 !== n || 0 !== r) {
                            const e = (new i.Q1f).setRGB(t, n, r, i.er$);
                            d.add(new i.$p8(e,1))
                        }
                    }
                    "UnitScaleFactor"in u.GlobalSettings && (d.userData.unitScaleFactor = u.GlobalSettings.UnitScaleFactor.value)
                }
            }
        }
        class A {
            constructor() {
                this.negativeMaterialIndices = !1
            }
            parse(e) {
                const t = new Map;
                if ("Geometry"in u.Objects) {
                    const n = u.Objects.Geometry;
                    for (const i in n) {
                        const r = h.get(parseInt(i))
                          , s = this.parseGeometry(r, n[i], e);
                        t.set(parseInt(i), s)
                    }
                }
                return !0 === this.negativeMaterialIndices && console.warn("THREE.FBXLoader: The FBX file contains invalid (negative) material indices. The asset might not render as expected."),
                t
            }
            parseGeometry(e, t, n) {
                switch (t.attrType) {
                case "Mesh":
                    return this.parseMeshGeometry(e, t, n);
                case "NurbsCurve":
                    return this.parseNurbsGeometry(t)
                }
            }
            parseMeshGeometry(e, t, n) {
                const i = n.skeletons
                  , r = []
                  , s = e.parents.map((function(e) {
                    return u.Objects.Model[e.ID]
                }
                ));
                if (0 === s.length)
                    return;
                const a = e.children.reduce((function(e, t) {
                    return void 0 !== i[t.ID] && (e = i[t.ID]),
                    e
                }
                ), null);
                e.children.forEach((function(e) {
                    void 0 !== n.morphTargets[e.ID] && r.push(n.morphTargets[e.ID])
                }
                ));
                const o = s[0]
                  , l = {};
                "RotationOrder"in o && (l.eulerOrder = M(o.RotationOrder.value)),
                "InheritType"in o && (l.inheritType = parseInt(o.InheritType.value)),
                "GeometricTranslation"in o && (l.translation = o.GeometricTranslation.value),
                "GeometricRotation"in o && (l.rotation = o.GeometricRotation.value),
                "GeometricScaling"in o && (l.scale = o.GeometricScaling.value);
                const c = S(l);
                return this.genGeometry(t, a, r, c)
            }
            genGeometry(e, t, n, r) {
                const s = new i.LoY;
                e.attrName && (s.name = e.attrName);
                const a = this.parseGeoNode(e, t)
                  , o = this.genBuffers(a)
                  , l = new i.qtW(o.vertex,3);
                if (l.applyMatrix4(r),
                s.setAttribute("position", l),
                o.colors.length > 0 && s.setAttribute("color", new i.qtW(o.colors,3)),
                t && (s.setAttribute("skinIndex", new i.A$4(o.weightsIndices,4)),
                s.setAttribute("skinWeight", new i.qtW(o.vertexWeights,4)),
                s.FBX_Deformer = t),
                o.normal.length > 0) {
                    const e = (new i.dwI).getNormalMatrix(r)
                      , t = new i.qtW(o.normal,3);
                    t.applyNormalMatrix(e),
                    s.setAttribute("normal", t)
                }
                if (o.uvs.forEach((function(e, t) {
                    const n = 0 === t ? "uv" : `uv${t}`;
                    s.setAttribute(n, new i.qtW(o.uvs[t],2))
                }
                )),
                a.material && "AllSame" !== a.material.mappingType) {
                    let e = o.materialIndex[0]
                      , t = 0;
                    if (o.materialIndex.forEach((function(n, i) {
                        n !== e && (s.addGroup(t, i - t, e),
                        e = n,
                        t = i)
                    }
                    )),
                    s.groups.length > 0) {
                        const t = s.groups[s.groups.length - 1]
                          , n = t.start + t.count;
                        n !== o.materialIndex.length && s.addGroup(n, o.materialIndex.length - n, e)
                    }
                    0 === s.groups.length && s.addGroup(0, o.materialIndex.length, o.materialIndex[0])
                }
                return this.addMorphTargets(s, e, n, r),
                s
            }
            parseGeoNode(e, t) {
                const n = {};
                if (n.vertexPositions = void 0 !== e.Vertices ? e.Vertices.a : [],
                n.vertexIndices = void 0 !== e.PolygonVertexIndex ? e.PolygonVertexIndex.a : [],
                e.LayerElementColor && (n.color = this.parseVertexColors(e.LayerElementColor[0])),
                e.LayerElementMaterial && (n.material = this.parseMaterialIndices(e.LayerElementMaterial[0])),
                e.LayerElementNormal && (n.normal = this.parseNormals(e.LayerElementNormal[0])),
                e.LayerElementUV) {
                    n.uv = [];
                    let t = 0;
                    for (; e.LayerElementUV[t]; )
                        e.LayerElementUV[t].UV && n.uv.push(this.parseUVs(e.LayerElementUV[t])),
                        t++
                }
                return n.weightTable = {},
                null !== t && (n.skeleton = t,
                t.rawBones.forEach((function(e, t) {
                    e.indices.forEach((function(i, r) {
                        void 0 === n.weightTable[i] && (n.weightTable[i] = []),
                        n.weightTable[i].push({
                            id: t,
                            weight: e.weights[r]
                        })
                    }
                    ))
                }
                ))),
                n
            }
            genBuffers(e) {
                const t = {
                    vertex: [],
                    normal: [],
                    colors: [],
                    uvs: [],
                    materialIndex: [],
                    vertexWeights: [],
                    weightsIndices: []
                };
                let n = 0
                  , i = 0
                  , r = !1
                  , s = []
                  , a = []
                  , o = []
                  , l = []
                  , c = []
                  , u = [];
                const h = this;
                return e.vertexIndices.forEach((function(d, p) {
                    let f, A = !1;
                    d < 0 && (d = ~d,
                    A = !0);
                    let g = []
                      , m = [];
                    if (s.push(3 * d, 3 * d + 1, 3 * d + 2),
                    e.color) {
                        const t = w(p, n, d, e.color);
                        o.push(t[0], t[1], t[2])
                    }
                    if (e.skeleton) {
                        if (void 0 !== e.weightTable[d] && e.weightTable[d].forEach((function(e) {
                            m.push(e.weight),
                            g.push(e.id)
                        }
                        )),
                        m.length > 4) {
                            r || (console.warn("THREE.FBXLoader: Vertex has more than 4 skinning weights assigned to vertex. Deleting additional weights."),
                            r = !0);
                            const e = [0, 0, 0, 0]
                              , t = [0, 0, 0, 0];
                            m.forEach((function(n, i) {
                                let r = n
                                  , s = g[i];
                                t.forEach((function(t, n, i) {
                                    if (r > t) {
                                        i[n] = r,
                                        r = t;
                                        const a = e[n];
                                        e[n] = s,
                                        s = a
                                    }
                                }
                                ))
                            }
                            )),
                            g = e,
                            m = t
                        }
                        for (; m.length < 4; )
                            m.push(0),
                            g.push(0);
                        for (let e = 0; e < 4; ++e)
                            c.push(m[e]),
                            u.push(g[e])
                    }
                    if (e.normal) {
                        const t = w(p, n, d, e.normal);
                        a.push(t[0], t[1], t[2])
                    }
                    e.material && "AllSame" !== e.material.mappingType && (f = w(p, n, d, e.material)[0],
                    f < 0 && (h.negativeMaterialIndices = !0,
                    f = 0)),
                    e.uv && e.uv.forEach((function(e, t) {
                        const i = w(p, n, d, e);
                        void 0 === l[t] && (l[t] = []),
                        l[t].push(i[0]),
                        l[t].push(i[1])
                    }
                    )),
                    i++,
                    A && (h.genFace(t, e, s, f, a, o, l, c, u, i),
                    n++,
                    i = 0,
                    s = [],
                    a = [],
                    o = [],
                    l = [],
                    c = [],
                    u = [])
                }
                )),
                t
            }
            getNormalNewell(e) {
                const t = new i.Pq0(0,0,0);
                for (let n = 0; n < e.length; n++) {
                    const i = e[n]
                      , r = e[(n + 1) % e.length];
                    t.x += (i.y - r.y) * (i.z + r.z),
                    t.y += (i.z - r.z) * (i.x + r.x),
                    t.z += (i.x - r.x) * (i.y + r.y)
                }
                return t.normalize(),
                t
            }
            getNormalTangentAndBitangent(e) {
                const t = this.getNormalNewell(e)
                  , n = (Math.abs(t.z) > .5 ? new i.Pq0(0,1,0) : new i.Pq0(0,0,1)).cross(t).normalize()
                  , r = t.clone().cross(n).normalize();
                return {
                    normal: t,
                    tangent: n,
                    bitangent: r
                }
            }
            flattenVertex(e, t, n) {
                return new i.I9Y(e.dot(t),e.dot(n))
            }
            genFace(e, t, n, r, s, a, o, l, c, u) {
                let h;
                if (u > 3) {
                    const e = []
                      , r = t.baseVertexPositions || t.vertexPositions;
                    for (let t = 0; t < n.length; t += 3)
                        e.push(new i.Pq0(r[n[t]],r[n[t + 1]],r[n[t + 2]]));
                    const {tangent: s, bitangent: a} = this.getNormalTangentAndBitangent(e)
                      , o = [];
                    for (const t of e)
                        o.push(this.flattenVertex(t, s, a));
                    h = i.xJ6.triangulateShape(o, [])
                } else
                    h = [[0, 1, 2]];
                for (const [i,u,d] of h)
                    e.vertex.push(t.vertexPositions[n[3 * i]]),
                    e.vertex.push(t.vertexPositions[n[3 * i + 1]]),
                    e.vertex.push(t.vertexPositions[n[3 * i + 2]]),
                    e.vertex.push(t.vertexPositions[n[3 * u]]),
                    e.vertex.push(t.vertexPositions[n[3 * u + 1]]),
                    e.vertex.push(t.vertexPositions[n[3 * u + 2]]),
                    e.vertex.push(t.vertexPositions[n[3 * d]]),
                    e.vertex.push(t.vertexPositions[n[3 * d + 1]]),
                    e.vertex.push(t.vertexPositions[n[3 * d + 2]]),
                    t.skeleton && (e.vertexWeights.push(l[4 * i]),
                    e.vertexWeights.push(l[4 * i + 1]),
                    e.vertexWeights.push(l[4 * i + 2]),
                    e.vertexWeights.push(l[4 * i + 3]),
                    e.vertexWeights.push(l[4 * u]),
                    e.vertexWeights.push(l[4 * u + 1]),
                    e.vertexWeights.push(l[4 * u + 2]),
                    e.vertexWeights.push(l[4 * u + 3]),
                    e.vertexWeights.push(l[4 * d]),
                    e.vertexWeights.push(l[4 * d + 1]),
                    e.vertexWeights.push(l[4 * d + 2]),
                    e.vertexWeights.push(l[4 * d + 3]),
                    e.weightsIndices.push(c[4 * i]),
                    e.weightsIndices.push(c[4 * i + 1]),
                    e.weightsIndices.push(c[4 * i + 2]),
                    e.weightsIndices.push(c[4 * i + 3]),
                    e.weightsIndices.push(c[4 * u]),
                    e.weightsIndices.push(c[4 * u + 1]),
                    e.weightsIndices.push(c[4 * u + 2]),
                    e.weightsIndices.push(c[4 * u + 3]),
                    e.weightsIndices.push(c[4 * d]),
                    e.weightsIndices.push(c[4 * d + 1]),
                    e.weightsIndices.push(c[4 * d + 2]),
                    e.weightsIndices.push(c[4 * d + 3])),
                    t.color && (e.colors.push(a[3 * i]),
                    e.colors.push(a[3 * i + 1]),
                    e.colors.push(a[3 * i + 2]),
                    e.colors.push(a[3 * u]),
                    e.colors.push(a[3 * u + 1]),
                    e.colors.push(a[3 * u + 2]),
                    e.colors.push(a[3 * d]),
                    e.colors.push(a[3 * d + 1]),
                    e.colors.push(a[3 * d + 2])),
                    t.material && "AllSame" !== t.material.mappingType && (e.materialIndex.push(r),
                    e.materialIndex.push(r),
                    e.materialIndex.push(r)),
                    t.normal && (e.normal.push(s[3 * i]),
                    e.normal.push(s[3 * i + 1]),
                    e.normal.push(s[3 * i + 2]),
                    e.normal.push(s[3 * u]),
                    e.normal.push(s[3 * u + 1]),
                    e.normal.push(s[3 * u + 2]),
                    e.normal.push(s[3 * d]),
                    e.normal.push(s[3 * d + 1]),
                    e.normal.push(s[3 * d + 2])),
                    t.uv && t.uv.forEach((function(t, n) {
                        void 0 === e.uvs[n] && (e.uvs[n] = []),
                        e.uvs[n].push(o[n][2 * i]),
                        e.uvs[n].push(o[n][2 * i + 1]),
                        e.uvs[n].push(o[n][2 * u]),
                        e.uvs[n].push(o[n][2 * u + 1]),
                        e.uvs[n].push(o[n][2 * d]),
                        e.uvs[n].push(o[n][2 * d + 1])
                    }
                    ))
            }
            addMorphTargets(e, t, n, i) {
                if (0 === n.length)
                    return;
                e.morphTargetsRelative = !0,
                e.morphAttributes.position = [];
                const r = this;
                n.forEach((function(n) {
                    n.rawTargets.forEach((function(n) {
                        const s = u.Objects.Geometry[n.geoID];
                        void 0 !== s && r.genMorphGeometry(e, t, s, i, n.name)
                    }
                    ))
                }
                ))
            }
            genMorphGeometry(e, t, n, r, s) {
                const a = void 0 !== t.Vertices ? t.Vertices.a : []
                  , o = void 0 !== t.PolygonVertexIndex ? t.PolygonVertexIndex.a : []
                  , l = void 0 !== n.Vertices ? n.Vertices.a : []
                  , c = void 0 !== n.Indexes ? n.Indexes.a : []
                  , u = 3 * e.attributes.position.count
                  , h = new Float32Array(u);
                for (let e = 0; e < c.length; e++) {
                    const t = 3 * c[e];
                    h[t] = l[3 * e],
                    h[t + 1] = l[3 * e + 1],
                    h[t + 2] = l[3 * e + 2]
                }
                const d = {
                    vertexIndices: o,
                    vertexPositions: h,
                    baseVertexPositions: a
                }
                  , p = this.genBuffers(d)
                  , f = new i.qtW(p.vertex,3);
                f.name = s || n.attrName,
                f.applyMatrix4(r),
                e.morphAttributes.position.push(f)
            }
            parseNormals(e) {
                const t = e.MappingInformationType
                  , n = e.ReferenceInformationType
                  , i = e.Normals.a;
                let r = [];
                return "IndexToDirect" === n && ("NormalIndex"in e ? r = e.NormalIndex.a : "NormalsIndex"in e && (r = e.NormalsIndex.a)),
                {
                    dataSize: 3,
                    buffer: i,
                    indices: r,
                    mappingType: t,
                    referenceType: n
                }
            }
            parseUVs(e) {
                const t = e.MappingInformationType
                  , n = e.ReferenceInformationType
                  , i = e.UV.a;
                let r = [];
                return "IndexToDirect" === n && (r = e.UVIndex.a),
                {
                    dataSize: 2,
                    buffer: i,
                    indices: r,
                    mappingType: t,
                    referenceType: n
                }
            }
            parseVertexColors(e) {
                const t = e.MappingInformationType
                  , n = e.ReferenceInformationType
                  , r = e.Colors.a;
                let s = [];
                "IndexToDirect" === n && (s = e.ColorIndex.a);
                for (let e = 0, t = new i.Q1f; e < r.length; e += 4)
                    t.fromArray(r, e),
                    i.ppV.toWorkingColorSpace(t, i.er$),
                    t.toArray(r, e);
                return {
                    dataSize: 4,
                    buffer: r,
                    indices: s,
                    mappingType: t,
                    referenceType: n
                }
            }
            parseMaterialIndices(e) {
                const t = e.MappingInformationType
                  , n = e.ReferenceInformationType;
                if ("NoMappingInformation" === t)
                    return {
                        dataSize: 1,
                        buffer: [0],
                        indices: [0],
                        mappingType: "AllSame",
                        referenceType: n
                    };
                const i = e.Materials.a
                  , r = [];
                for (let e = 0; e < i.length; ++e)
                    r.push(e);
                return {
                    dataSize: 1,
                    buffer: i,
                    indices: r,
                    mappingType: t,
                    referenceType: n
                }
            }
            parseNurbsGeometry(e) {
                const t = parseInt(e.Order);
                if (isNaN(t))
                    return console.error("THREE.FBXLoader: Invalid Order %s given for geometry ID: %s", e.Order, e.id),
                    new i.LoY;
                const n = t - 1
                  , r = e.KnotVector.a
                  , s = []
                  , a = e.Points.a;
                for (let e = 0, t = a.length; e < t; e += 4)
                    s.push((new i.IUQ).fromArray(a, e));
                let o, l;
                if ("Closed" === e.Form)
                    s.push(s[0]);
                else if ("Periodic" === e.Form) {
                    o = n,
                    l = r.length - 1 - o;
                    for (let e = 0; e < n; ++e)
                        s.push(s[e])
                }
                const u = new c(n,r,s,o,l).getPoints(12 * s.length);
                return (new i.LoY).setFromPoints(u)
            }
        }
        class g {
            parse() {
                const e = []
                  , t = this.parseClips();
                if (void 0 !== t)
                    for (const n in t) {
                        const i = t[n]
                          , r = this.addClip(i);
                        e.push(r)
                    }
                return e
            }
            parseClips() {
                if (void 0 === u.Objects.AnimationCurve)
                    return;
                const e = this.parseAnimationCurveNodes();
                this.parseAnimationCurves(e);
                const t = this.parseAnimationLayers(e);
                return this.parseAnimStacks(t)
            }
            parseAnimationCurveNodes() {
                const e = u.Objects.AnimationCurveNode
                  , t = new Map;
                for (const n in e) {
                    const i = e[n];
                    if (null !== i.attrName.match(/S|R|T|DeformPercent/)) {
                        const e = {
                            id: i.id,
                            attr: i.attrName,
                            curves: {}
                        };
                        t.set(e.id, e)
                    }
                }
                return t
            }
            parseAnimationCurves(e) {
                const t = u.Objects.AnimationCurve;
                for (const n in t) {
                    const i = {
                        id: t[n].id,
                        times: t[n].KeyTime.a.map(b),
                        values: t[n].KeyValueFloat.a
                    }
                      , r = h.get(i.id);
                    if (void 0 !== r) {
                        const t = r.parents[0].ID
                          , n = r.parents[0].relationship;
                        n.match(/X/) ? e.get(t).curves.x = i : n.match(/Y/) ? e.get(t).curves.y = i : n.match(/Z/) ? e.get(t).curves.z = i : n.match(/DeformPercent/) && e.has(t) && (e.get(t).curves.morph = i)
                    }
                }
            }
            parseAnimationLayers(e) {
                const t = u.Objects.AnimationLayer
                  , n = new Map;
                for (const r in t) {
                    const t = []
                      , s = h.get(parseInt(r));
                    if (void 0 !== s) {
                        s.children.forEach((function(n, r) {
                            if (e.has(n.ID)) {
                                const s = e.get(n.ID);
                                if (void 0 !== s.curves.x || void 0 !== s.curves.y || void 0 !== s.curves.z) {
                                    if (void 0 === t[r]) {
                                        const e = h.get(n.ID).parents.filter((function(e) {
                                            return void 0 !== e.relationship
                                        }
                                        ))[0].ID;
                                        if (void 0 !== e) {
                                            const s = u.Objects.Model[e.toString()];
                                            if (void 0 === s)
                                                return void console.warn("THREE.FBXLoader: Encountered a unused curve.", n);
                                            const a = {
                                                modelName: s.attrName ? i.Nwf.sanitizeNodeName(s.attrName) : "",
                                                ID: s.id,
                                                initialPosition: [0, 0, 0],
                                                initialRotation: [0, 0, 0],
                                                initialScale: [1, 1, 1]
                                            };
                                            d.traverse((function(e) {
                                                e.ID === s.id && (a.transform = e.matrix,
                                                e.userData.transformData && (a.eulerOrder = e.userData.transformData.eulerOrder))
                                            }
                                            )),
                                            a.transform || (a.transform = new i.kn4),
                                            "PreRotation"in s && (a.preRotation = s.PreRotation.value),
                                            "PostRotation"in s && (a.postRotation = s.PostRotation.value),
                                            t[r] = a
                                        }
                                    }
                                    t[r] && (t[r][s.attr] = s)
                                } else if (void 0 !== s.curves.morph) {
                                    if (void 0 === t[r]) {
                                        const e = h.get(n.ID).parents.filter((function(e) {
                                            return void 0 !== e.relationship
                                        }
                                        ))[0].ID
                                          , s = h.get(e).parents[0].ID
                                          , a = h.get(s).parents[0].ID
                                          , o = h.get(a).parents[0].ID
                                          , l = u.Objects.Model[o]
                                          , c = {
                                            modelName: l.attrName ? i.Nwf.sanitizeNodeName(l.attrName) : "",
                                            morphName: u.Objects.Deformer[e].attrName
                                        };
                                        t[r] = c
                                    }
                                    t[r][s.attr] = s
                                }
                            }
                        }
                        )),
                        n.set(parseInt(r), t)
                    }
                }
                return n
            }
            parseAnimStacks(e) {
                const t = u.Objects.AnimationStack
                  , n = {};
                for (const i in t) {
                    const r = h.get(parseInt(i)).children;
                    r.length > 1 && console.warn("THREE.FBXLoader: Encountered an animation stack with multiple layers, this is currently not supported. Ignoring subsequent layers.");
                    const s = e.get(r[0].ID);
                    n[i] = {
                        name: t[i].attrName,
                        layer: s
                    }
                }
                return n
            }
            addClip(e) {
                let t = [];
                const n = this;
                return e.layer.forEach((function(e) {
                    t = t.concat(n.generateTracks(e))
                }
                )),
                new i.tz3(e.name,-1,t)
            }
            generateTracks(e) {
                const t = [];
                let n = new i.Pq0
                  , r = new i.Pq0;
                if (e.transform && e.transform.decompose(n, new i.PTz, r),
                n = n.toArray(),
                r = r.toArray(),
                void 0 !== e.T && Object.keys(e.T.curves).length > 0) {
                    const i = this.generateVectorTrack(e.modelName, e.T.curves, n, "position");
                    void 0 !== i && t.push(i)
                }
                if (void 0 !== e.R && Object.keys(e.R.curves).length > 0) {
                    const n = this.generateRotationTrack(e.modelName, e.R.curves, e.preRotation, e.postRotation, e.eulerOrder);
                    void 0 !== n && t.push(n)
                }
                if (void 0 !== e.S && Object.keys(e.S.curves).length > 0) {
                    const n = this.generateVectorTrack(e.modelName, e.S.curves, r, "scale");
                    void 0 !== n && t.push(n)
                }
                if (void 0 !== e.DeformPercent) {
                    const n = this.generateMorphTrack(e);
                    void 0 !== n && t.push(n)
                }
                return t
            }
            generateVectorTrack(e, t, n, r) {
                const s = this.getTimesForAllAxes(t)
                  , a = this.getKeyframeTrackValues(s, t, n);
                return new i.RiT(e + "." + r,s,a)
            }
            generateRotationTrack(e, t, n, r, s) {
                let a, o;
                if (void 0 !== t.x && void 0 !== t.y && void 0 !== t.z) {
                    const e = this.interpolateRotations(t.x, t.y, t.z, s);
                    a = e[0],
                    o = e[1]
                }
                const l = M(0);
                void 0 !== n && ((n = n.map(i.cj9.degToRad)).push(l),
                n = (new i.O9p).fromArray(n),
                n = (new i.PTz).setFromEuler(n)),
                void 0 !== r && ((r = r.map(i.cj9.degToRad)).push(l),
                r = (new i.O9p).fromArray(r),
                r = (new i.PTz).setFromEuler(r).invert());
                const c = new i.PTz
                  , u = new i.O9p
                  , h = [];
                if (!o || !a)
                    return new i.MBL(e + ".quaternion",[0],[0]);
                for (let e = 0; e < o.length; e += 3) {
                    if (u.set(o[e], o[e + 1], o[e + 2], s),
                    c.setFromEuler(u),
                    void 0 !== n && c.premultiply(n),
                    void 0 !== r && c.multiply(r),
                    e > 2) {
                        (new i.PTz).fromArray(h, (e - 3) / 3 * 4).dot(c) < 0 && c.set(-c.x, -c.y, -c.z, -c.w)
                    }
                    c.toArray(h, e / 3 * 4)
                }
                return new i.MBL(e + ".quaternion",a,h)
            }
            generateMorphTrack(e) {
                const t = e.DeformPercent.curves.morph
                  , n = t.values.map((function(e) {
                    return e / 100
                }
                ))
                  , r = d.getObjectByName(e.modelName).morphTargetDictionary[e.morphName];
                return new i.Hit(e.modelName + ".morphTargetInfluences[" + r + "]",t.times,n)
            }
            getTimesForAllAxes(e) {
                let t = [];
                if (void 0 !== e.x && (t = t.concat(e.x.times)),
                void 0 !== e.y && (t = t.concat(e.y.times)),
                void 0 !== e.z && (t = t.concat(e.z.times)),
                t = t.sort((function(e, t) {
                    return e - t
                }
                )),
                t.length > 1) {
                    let e = 1
                      , n = t[0];
                    for (let i = 1; i < t.length; i++) {
                        const r = t[i];
                        r !== n && (t[e] = r,
                        n = r,
                        e++)
                    }
                    t = t.slice(0, e)
                }
                return t
            }
            getKeyframeTrackValues(e, t, n) {
                const i = n
                  , r = [];
                let s = -1
                  , a = -1
                  , o = -1;
                return e.forEach((function(e) {
                    if (t.x && (s = t.x.times.indexOf(e)),
                    t.y && (a = t.y.times.indexOf(e)),
                    t.z && (o = t.z.times.indexOf(e)),
                    -1 !== s) {
                        const e = t.x.values[s];
                        r.push(e),
                        i[0] = e
                    } else
                        r.push(i[0]);
                    if (-1 !== a) {
                        const e = t.y.values[a];
                        r.push(e),
                        i[1] = e
                    } else
                        r.push(i[1]);
                    if (-1 !== o) {
                        const e = t.z.values[o];
                        r.push(e),
                        i[2] = e
                    } else
                        r.push(i[2])
                }
                )),
                r
            }
            interpolateRotations(e, t, n, r) {
                const s = []
                  , a = [];
                s.push(e.times[0]),
                a.push(i.cj9.degToRad(e.values[0])),
                a.push(i.cj9.degToRad(t.values[0])),
                a.push(i.cj9.degToRad(n.values[0]));
                for (let o = 1; o < e.values.length; o++) {
                    const l = [e.values[o - 1], t.values[o - 1], n.values[o - 1]];
                    if (isNaN(l[0]) || isNaN(l[1]) || isNaN(l[2]))
                        continue;
                    const c = l.map(i.cj9.degToRad)
                      , u = [e.values[o], t.values[o], n.values[o]];
                    if (isNaN(u[0]) || isNaN(u[1]) || isNaN(u[2]))
                        continue;
                    const h = u.map(i.cj9.degToRad)
                      , d = [u[0] - l[0], u[1] - l[1], u[2] - l[2]]
                      , p = [Math.abs(d[0]), Math.abs(d[1]), Math.abs(d[2])];
                    if (p[0] >= 180 || p[1] >= 180 || p[2] >= 180) {
                        const t = Math.max(...p) / 180
                          , n = new i.O9p(...c,r)
                          , l = new i.O9p(...h,r)
                          , u = (new i.PTz).setFromEuler(n)
                          , d = (new i.PTz).setFromEuler(l);
                        u.dot(d) && d.set(-d.x, -d.y, -d.z, -d.w);
                        const f = e.times[o - 1]
                          , A = e.times[o] - f
                          , g = new i.PTz
                          , m = new i.O9p;
                        for (let e = 0; e < 1; e += 1 / t)
                            g.copy(u.clone().slerp(d.clone(), e)),
                            s.push(f + e * A),
                            m.setFromQuaternion(g, r),
                            a.push(m.x),
                            a.push(m.y),
                            a.push(m.z)
                    } else
                        s.push(e.times[o]),
                        a.push(i.cj9.degToRad(e.values[o])),
                        a.push(i.cj9.degToRad(t.values[o])),
                        a.push(i.cj9.degToRad(n.values[o]))
                }
                return [s, a]
            }
        }
        class m {
            getPrevNode() {
                return this.nodeStack[this.currentIndent - 2]
            }
            getCurrentNode() {
                return this.nodeStack[this.currentIndent - 1]
            }
            getCurrentProp() {
                return this.currentProp
            }
            pushStack(e) {
                this.nodeStack.push(e),
                this.currentIndent += 1
            }
            popStack() {
                this.nodeStack.pop(),
                this.currentIndent -= 1
            }
            setCurrentProp(e, t) {
                this.currentProp = e,
                this.currentPropName = t
            }
            parse(e) {
                this.currentIndent = 0,
                this.allNodes = new x,
                this.nodeStack = [],
                this.currentProp = [],
                this.currentPropName = "";
                const t = this
                  , n = e.split(/[\r\n]+/);
                return n.forEach((function(e, i) {
                    const r = e.match(/^[\s\t]*;/)
                      , s = e.match(/^[\s\t]*$/);
                    if (r || s)
                        return;
                    const a = e.match("^\\t{" + t.currentIndent + "}(\\w+):(.*){", "")
                      , o = e.match("^\\t{" + t.currentIndent + "}(\\w+):[\\s\\t\\r\\n](.*)")
                      , l = e.match("^\\t{" + (t.currentIndent - 1) + "}}");
                    a ? t.parseNodeBegin(e, a) : o ? t.parseNodeProperty(e, o, n[++i]) : l ? t.popStack() : e.match(/^[^\s\t}]/) && t.parseNodePropertyContinued(e)
                }
                )),
                this.allNodes
            }
            parseNodeBegin(e, t) {
                const n = t[1].trim().replace(/^"/, "").replace(/"$/, "")
                  , i = t[2].split(",").map((function(e) {
                    return e.trim().replace(/^"/, "").replace(/"$/, "")
                }
                ))
                  , r = {
                    name: n
                }
                  , s = this.parseNodeAttr(i)
                  , a = this.getCurrentNode();
                0 === this.currentIndent ? this.allNodes.add(n, r) : n in a ? ("PoseNode" === n ? a.PoseNode.push(r) : void 0 !== a[n].id && (a[n] = {},
                a[n][a[n].id] = a[n]),
                "" !== s.id && (a[n][s.id] = r)) : "number" == typeof s.id ? (a[n] = {},
                a[n][s.id] = r) : "Properties70" !== n && (a[n] = "PoseNode" === n ? [r] : r),
                "number" == typeof s.id && (r.id = s.id),
                "" !== s.name && (r.attrName = s.name),
                "" !== s.type && (r.attrType = s.type),
                this.pushStack(r)
            }
            parseNodeAttr(e) {
                let t = e[0];
                "" !== e[0] && (t = parseInt(e[0]),
                isNaN(t) && (t = e[0]));
                let n = ""
                  , i = "";
                return e.length > 1 && (n = e[1].replace(/^(\w+)::/, ""),
                i = e[2]),
                {
                    id: t,
                    name: n,
                    type: i
                }
            }
            parseNodeProperty(e, t, n) {
                let i = t[1].replace(/^"/, "").replace(/"$/, "").trim()
                  , r = t[2].replace(/^"/, "").replace(/"$/, "").trim();
                "Content" === i && "," === r && (r = n.replace(/"/g, "").replace(/,$/, "").trim());
                const s = this.getCurrentNode();
                if ("Properties70" !== s.name) {
                    if ("C" === i) {
                        const e = r.split(",").slice(1)
                          , t = parseInt(e[0])
                          , n = parseInt(e[1]);
                        let a = r.split(",").slice(3);
                        a = a.map((function(e) {
                            return e.trim().replace(/^"/, "")
                        }
                        )),
                        i = "connections",
                        r = [t, n],
                        function(e, t) {
                            for (let n = 0, i = e.length, r = t.length; n < r; n++,
                            i++)
                                e[i] = t[n]
                        }(r, a),
                        void 0 === s[i] && (s[i] = [])
                    }
                    "Node" === i && (s.id = r),
                    i in s && Array.isArray(s[i]) ? s[i].push(r) : "a" !== i ? s[i] = r : s.a = r,
                    this.setCurrentProp(s, i),
                    "a" === i && "," !== r.slice(-1) && (s.a = T(r))
                } else
                    this.parseNodeSpecialProperty(e, i, r)
            }
            parseNodePropertyContinued(e) {
                const t = this.getCurrentNode();
                t.a += e,
                "," !== e.slice(-1) && (t.a = T(t.a))
            }
            parseNodeSpecialProperty(e, t, n) {
                const i = n.split('",').map((function(e) {
                    return e.trim().replace(/^\"/, "").replace(/\s/, "_")
                }
                ))
                  , r = i[0]
                  , s = i[1]
                  , a = i[2]
                  , o = i[3];
                let l = i[4];
                switch (s) {
                case "int":
                case "enum":
                case "bool":
                case "ULongLong":
                case "double":
                case "Number":
                case "FieldOfView":
                    l = parseFloat(l);
                    break;
                case "Color":
                case "ColorRGB":
                case "Vector3D":
                case "Lcl_Translation":
                case "Lcl_Rotation":
                case "Lcl_Scaling":
                    l = T(l)
                }
                this.getPrevNode()[r] = {
                    type: s,
                    type2: a,
                    flag: o,
                    value: l
                },
                this.setCurrentProp(this.getPrevNode(), r)
            }
        }
        class v {
            parse(e) {
                const t = new y(e);
                t.skip(23);
                const n = t.getUint32();
                if (n < 6400)
                    throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: " + n);
                const i = new x;
                for (; !this.endOfContent(t); ) {
                    const e = this.parseNode(t, n);
                    null !== e && i.add(e.name, e)
                }
                return i
            }
            endOfContent(e) {
                return e.size() % 16 == 0 ? (e.getOffset() + 160 + 16 & -16) >= e.size() : e.getOffset() + 160 + 16 >= e.size()
            }
            parseNode(e, t) {
                const n = {}
                  , i = t >= 7500 ? e.getUint64() : e.getUint32()
                  , r = t >= 7500 ? e.getUint64() : e.getUint32();
                t >= 7500 ? e.getUint64() : e.getUint32();
                const s = e.getUint8()
                  , a = e.getString(s);
                if (0 === i)
                    return null;
                const o = [];
                for (let t = 0; t < r; t++)
                    o.push(this.parseProperty(e));
                const l = o.length > 0 ? o[0] : ""
                  , c = o.length > 1 ? o[1] : ""
                  , u = o.length > 2 ? o[2] : "";
                for (n.singleProperty = 1 === r && e.getOffset() === i; i > e.getOffset(); ) {
                    const i = this.parseNode(e, t);
                    null !== i && this.parseSubNode(a, n, i)
                }
                return n.propertyList = o,
                "number" == typeof l && (n.id = l),
                "" !== c && (n.attrName = c),
                "" !== u && (n.attrType = u),
                "" !== a && (n.name = a),
                n
            }
            parseSubNode(e, t, n) {
                if (!0 === n.singleProperty) {
                    const e = n.propertyList[0];
                    Array.isArray(e) ? (t[n.name] = n,
                    n.a = e) : t[n.name] = e
                } else if ("Connections" === e && "C" === n.name) {
                    const e = [];
                    n.propertyList.forEach((function(t, n) {
                        0 !== n && e.push(t)
                    }
                    )),
                    void 0 === t.connections && (t.connections = []),
                    t.connections.push(e)
                } else if ("Properties70" === n.name) {
                    Object.keys(n).forEach((function(e) {
                        t[e] = n[e]
                    }
                    ))
                } else if ("Properties70" === e && "P" === n.name) {
                    let e = n.propertyList[0]
                      , i = n.propertyList[1];
                    const r = n.propertyList[2]
                      , s = n.propertyList[3];
                    let a;
                    0 === e.indexOf("Lcl ") && (e = e.replace("Lcl ", "Lcl_")),
                    0 === i.indexOf("Lcl ") && (i = i.replace("Lcl ", "Lcl_")),
                    a = "Color" === i || "ColorRGB" === i || "Vector" === i || "Vector3D" === i || 0 === i.indexOf("Lcl_") ? [n.propertyList[4], n.propertyList[5], n.propertyList[6]] : n.propertyList[4],
                    t[e] = {
                        type: i,
                        type2: r,
                        flag: s,
                        value: a
                    }
                } else
                    void 0 === t[n.name] ? "number" == typeof n.id ? (t[n.name] = {},
                    t[n.name][n.id] = n) : t[n.name] = n : "PoseNode" === n.name ? (Array.isArray(t[n.name]) || (t[n.name] = [t[n.name]]),
                    t[n.name].push(n)) : void 0 === t[n.name][n.id] && (t[n.name][n.id] = n)
            }
            parseProperty(e) {
                const t = e.getString(1);
                let n;
                switch (t) {
                case "C":
                    return e.getBoolean();
                case "D":
                    return e.getFloat64();
                case "F":
                    return e.getFloat32();
                case "I":
                    return e.getInt32();
                case "L":
                    return e.getInt64();
                case "R":
                    return n = e.getUint32(),
                    e.getArrayBuffer(n);
                case "S":
                    return n = e.getUint32(),
                    e.getString(n);
                case "Y":
                    return e.getInt16();
                case "b":
                case "c":
                case "d":
                case "f":
                case "i":
                case "l":
                    const i = e.getUint32()
                      , s = e.getUint32()
                      , a = e.getUint32();
                    if (0 === s)
                        switch (t) {
                        case "b":
                        case "c":
                            return e.getBooleanArray(i);
                        case "d":
                            return e.getFloat64Array(i);
                        case "f":
                            return e.getFloat32Array(i);
                        case "i":
                            return e.getInt32Array(i);
                        case "l":
                            return e.getInt64Array(i)
                        }
                    const o = r.a8(new Uint8Array(e.getArrayBuffer(a)))
                      , l = new y(o.buffer);
                    switch (t) {
                    case "b":
                    case "c":
                        return l.getBooleanArray(i);
                    case "d":
                        return l.getFloat64Array(i);
                    case "f":
                        return l.getFloat32Array(i);
                    case "i":
                        return l.getInt32Array(i);
                    case "l":
                        return l.getInt64Array(i)
                    }
                    break;
                default:
                    throw new Error("THREE.FBXLoader: Unknown property type " + t)
                }
            }
        }
        class y {
            constructor(e, t) {
                this.dv = new DataView(e),
                this.offset = 0,
                this.littleEndian = void 0 === t || t,
                this._textDecoder = new TextDecoder
            }
            getOffset() {
                return this.offset
            }
            size() {
                return this.dv.buffer.byteLength
            }
            skip(e) {
                this.offset += e
            }
            getBoolean() {
                return !(1 & ~this.getUint8())
            }
            getBooleanArray(e) {
                const t = [];
                for (let n = 0; n < e; n++)
                    t.push(this.getBoolean());
                return t
            }
            getUint8() {
                const e = this.dv.getUint8(this.offset);
                return this.offset += 1,
                e
            }
            getInt16() {
                const e = this.dv.getInt16(this.offset, this.littleEndian);
                return this.offset += 2,
                e
            }
            getInt32() {
                const e = this.dv.getInt32(this.offset, this.littleEndian);
                return this.offset += 4,
                e
            }
            getInt32Array(e) {
                const t = [];
                for (let n = 0; n < e; n++)
                    t.push(this.getInt32());
                return t
            }
            getUint32() {
                const e = this.dv.getUint32(this.offset, this.littleEndian);
                return this.offset += 4,
                e
            }
            getInt64() {
                let e, t;
                return this.littleEndian ? (e = this.getUint32(),
                t = this.getUint32()) : (t = this.getUint32(),
                e = this.getUint32()),
                2147483648 & t ? (t = 4294967295 & ~t,
                e = 4294967295 & ~e,
                4294967295 === e && (t = t + 1 & 4294967295),
                e = e + 1 & 4294967295,
                -(4294967296 * t + e)) : 4294967296 * t + e
            }
            getInt64Array(e) {
                const t = [];
                for (let n = 0; n < e; n++)
                    t.push(this.getInt64());
                return t
            }
            getUint64() {
                let e, t;
                return this.littleEndian ? (e = this.getUint32(),
                t = this.getUint32()) : (t = this.getUint32(),
                e = this.getUint32()),
                4294967296 * t + e
            }
            getFloat32() {
                const e = this.dv.getFloat32(this.offset, this.littleEndian);
                return this.offset += 4,
                e
            }
            getFloat32Array(e) {
                const t = [];
                for (let n = 0; n < e; n++)
                    t.push(this.getFloat32());
                return t
            }
            getFloat64() {
                const e = this.dv.getFloat64(this.offset, this.littleEndian);
                return this.offset += 8,
                e
            }
            getFloat64Array(e) {
                const t = [];
                for (let n = 0; n < e; n++)
                    t.push(this.getFloat64());
                return t
            }
            getArrayBuffer(e) {
                const t = this.dv.buffer.slice(this.offset, this.offset + e);
                return this.offset += e,
                t
            }
            getString(e) {
                const t = this.offset;
                let n = new Uint8Array(this.dv.buffer,t,e);
                this.skip(e);
                const i = n.indexOf(0);
                return i >= 0 && (n = new Uint8Array(this.dv.buffer,t,i)),
                this._textDecoder.decode(n)
            }
        }
        class x {
            add(e, t) {
                this[e] = t
            }
        }
        function _(e) {
            const t = e.match(/FBXVersion: (\d+)/);
            if (t) {
                return parseInt(t[1])
            }
            throw new Error("THREE.FBXLoader: Cannot find the version number for the file given.")
        }
        function b(e) {
            return e / 46186158e3
        }
        const E = [];
        function w(e, t, n, i) {
            let r;
            switch (i.mappingType) {
            case "ByPolygonVertex":
                r = e;
                break;
            case "ByPolygon":
                r = t;
                break;
            case "ByVertice":
                r = n;
                break;
            case "AllSame":
                r = i.indices[0];
                break;
            default:
                console.warn("THREE.FBXLoader: unknown attribute mapping type " + i.mappingType)
            }
            "IndexToDirect" === i.referenceType && (r = i.indices[r]);
            const s = r * i.dataSize
              , a = s + i.dataSize;
            return function(e, t, n, i) {
                for (let r = n, s = 0; r < i; r++,
                s++)
                    e[s] = t[r];
                return e
            }(E, i.buffer, s, a)
        }
        const C = new i.O9p
          , I = new i.Pq0;
        function S(e) {
            const t = new i.kn4
              , n = new i.kn4
              , r = new i.kn4
              , s = new i.kn4
              , a = new i.kn4
              , o = new i.kn4
              , l = new i.kn4
              , c = new i.kn4
              , u = new i.kn4
              , h = new i.kn4
              , d = new i.kn4
              , p = new i.kn4
              , f = e.inheritType ? e.inheritType : 0;
            e.translation && t.setPosition(I.fromArray(e.translation));
            const A = M(0);
            if (e.preRotation) {
                const t = e.preRotation.map(i.cj9.degToRad);
                t.push(A),
                n.makeRotationFromEuler(C.fromArray(t))
            }
            if (e.rotation) {
                const t = e.rotation.map(i.cj9.degToRad);
                t.push(e.eulerOrder || A),
                r.makeRotationFromEuler(C.fromArray(t))
            }
            if (e.postRotation) {
                const t = e.postRotation.map(i.cj9.degToRad);
                t.push(A),
                s.makeRotationFromEuler(C.fromArray(t)),
                s.invert()
            }
            e.scale && a.scale(I.fromArray(e.scale)),
            e.scalingOffset && l.setPosition(I.fromArray(e.scalingOffset)),
            e.scalingPivot && o.setPosition(I.fromArray(e.scalingPivot)),
            e.rotationOffset && c.setPosition(I.fromArray(e.rotationOffset)),
            e.rotationPivot && u.setPosition(I.fromArray(e.rotationPivot)),
            e.parentMatrixWorld && (d.copy(e.parentMatrix),
            h.copy(e.parentMatrixWorld));
            const g = n.clone().multiply(r).multiply(s)
              , m = new i.kn4;
            m.extractRotation(h);
            const v = new i.kn4;
            v.copyPosition(h);
            const y = v.clone().invert().multiply(h)
              , x = m.clone().invert().multiply(y)
              , _ = a
              , b = new i.kn4;
            if (0 === f)
                b.copy(m).multiply(g).multiply(x).multiply(_);
            else if (1 === f)
                b.copy(m).multiply(x).multiply(g).multiply(_);
            else {
                const e = (new i.kn4).scale((new i.Pq0).setFromMatrixScale(d)).clone().invert()
                  , t = x.clone().multiply(e);
                b.copy(m).multiply(g).multiply(t).multiply(_)
            }
            const E = u.clone().invert()
              , w = o.clone().invert();
            let S = t.clone().multiply(c).multiply(u).multiply(n).multiply(r).multiply(s).multiply(E).multiply(l).multiply(o).multiply(a).multiply(w);
            const T = (new i.kn4).copyPosition(S)
              , B = h.clone().multiply(T);
            return p.copyPosition(B),
            S = p.clone().multiply(b),
            S.premultiply(h.invert()),
            S
        }
        function M(e) {
            const t = ["ZYX", "YZX", "XZY", "ZXY", "YXZ", "XYZ"];
            return 6 === (e = e || 0) ? (console.warn("THREE.FBXLoader: unsupported Euler Order: Spherical XYZ. Animations and rotations may be incorrect."),
            t[0]) : t[e]
        }
        function T(e) {
            return e.split(",").map((function(e) {
                return parseFloat(e)
            }
            ))
        }
        function B(e, t, n) {
            return void 0 === t && (t = 0),
            void 0 === n && (n = e.byteLength),
            (new TextDecoder).decode(new Uint8Array(e,t,n))
        }
    }
    ,
    9511: (e, t, n) => {
        "use strict";
        n.d(t, {
            B: () => s
        });
        var i = n(5062);
        function r(e, t) {
            if (t === i.RJ4)
                return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."),
                e;
            if (t === i.rYR || t === i.O49) {
                let n = e.getIndex();
                if (null === n) {
                    const t = []
                      , i = e.getAttribute("position");
                    if (void 0 === i)
                        return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),
                        e;
                    for (let e = 0; e < i.count; e++)
                        t.push(e);
                    e.setIndex(t),
                    n = e.getIndex()
                }
                const r = n.count - 2
                  , s = [];
                if (t === i.rYR)
                    for (let e = 1; e <= r; e++)
                        s.push(n.getX(0)),
                        s.push(n.getX(e)),
                        s.push(n.getX(e + 1));
                else
                    for (let e = 0; e < r; e++)
                        e % 2 == 0 ? (s.push(n.getX(e)),
                        s.push(n.getX(e + 1)),
                        s.push(n.getX(e + 2))) : (s.push(n.getX(e + 2)),
                        s.push(n.getX(e + 1)),
                        s.push(n.getX(e)));
                s.length / 3 !== r && console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
                const a = e.clone();
                return a.setIndex(s),
                a.clearGroups(),
                a
            }
            return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:", t),
            e
        }
        class s extends i.aHM {
            constructor(e) {
                super(e),
                this.dracoLoader = null,
                this.ktx2Loader = null,
                this.meshoptDecoder = null,
                this.pluginCallbacks = [],
                this.register((function(e) {
                    return new h(e)
                }
                )),
                this.register((function(e) {
                    return new d(e)
                }
                )),
                this.register((function(e) {
                    return new _(e)
                }
                )),
                this.register((function(e) {
                    return new b(e)
                }
                )),
                this.register((function(e) {
                    return new E(e)
                }
                )),
                this.register((function(e) {
                    return new f(e)
                }
                )),
                this.register((function(e) {
                    return new A(e)
                }
                )),
                this.register((function(e) {
                    return new g(e)
                }
                )),
                this.register((function(e) {
                    return new m(e)
                }
                )),
                this.register((function(e) {
                    return new u(e)
                }
                )),
                this.register((function(e) {
                    return new v(e)
                }
                )),
                this.register((function(e) {
                    return new p(e)
                }
                )),
                this.register((function(e) {
                    return new x(e)
                }
                )),
                this.register((function(e) {
                    return new y(e)
                }
                )),
                this.register((function(e) {
                    return new l(e)
                }
                )),
                this.register((function(e) {
                    return new w(e)
                }
                )),
                this.register((function(e) {
                    return new C(e)
                }
                ))
            }
            load(e, t, n, r) {
                const s = this;
                let a;
                if ("" !== this.resourcePath)
                    a = this.resourcePath;
                else if ("" !== this.path) {
                    const t = i.r6x.extractUrlBase(e);
                    a = i.r6x.resolveURL(t, this.path)
                } else
                    a = i.r6x.extractUrlBase(e);
                this.manager.itemStart(e);
                const o = function(t) {
                    r ? r(t) : console.error(t),
                    s.manager.itemError(e),
                    s.manager.itemEnd(e)
                }
                  , l = new i.Y9S(this.manager);
                l.setPath(this.path),
                l.setResponseType("arraybuffer"),
                l.setRequestHeader(this.requestHeader),
                l.setWithCredentials(this.withCredentials),
                l.load(e, (function(n) {
                    try {
                        s.parse(n, a, (function(n) {
                            t(n),
                            s.manager.itemEnd(e)
                        }
                        ), o)
                    } catch (e) {
                        o(e)
                    }
                }
                ), n, o)
            }
            setDRACOLoader(e) {
                return this.dracoLoader = e,
                this
            }
            setKTX2Loader(e) {
                return this.ktx2Loader = e,
                this
            }
            setMeshoptDecoder(e) {
                return this.meshoptDecoder = e,
                this
            }
            register(e) {
                return -1 === this.pluginCallbacks.indexOf(e) && this.pluginCallbacks.push(e),
                this
            }
            unregister(e) {
                return -1 !== this.pluginCallbacks.indexOf(e) && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1),
                this
            }
            parse(e, t, n, i) {
                let r;
                const s = {}
                  , a = {}
                  , l = new TextDecoder;
                if ("string" == typeof e)
                    r = JSON.parse(e);
                else if (e instanceof ArrayBuffer) {
                    if (l.decode(new Uint8Array(e,0,4)) === I) {
                        try {
                            s[o.KHR_BINARY_GLTF] = new T(e)
                        } catch (e) {
                            return void (i && i(e))
                        }
                        r = JSON.parse(s[o.KHR_BINARY_GLTF].content)
                    } else
                        r = JSON.parse(l.decode(e))
                } else
                    r = e;
                if (void 0 === r.asset || r.asset.version[0] < 2)
                    return void (i && i(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.")));
                const u = new ee(r,{
                    path: t || this.resourcePath || "",
                    crossOrigin: this.crossOrigin,
                    requestHeader: this.requestHeader,
                    manager: this.manager,
                    ktx2Loader: this.ktx2Loader,
                    meshoptDecoder: this.meshoptDecoder
                });
                u.fileLoader.setRequestHeader(this.requestHeader);
                for (let e = 0; e < this.pluginCallbacks.length; e++) {
                    const t = this.pluginCallbacks[e](u);
                    t.name || console.error("THREE.GLTFLoader: Invalid plugin found: missing name"),
                    a[t.name] = t,
                    s[t.name] = !0
                }
                if (r.extensionsUsed)
                    for (let e = 0; e < r.extensionsUsed.length; ++e) {
                        const t = r.extensionsUsed[e]
                          , n = r.extensionsRequired || [];
                        switch (t) {
                        case o.KHR_MATERIALS_UNLIT:
                            s[t] = new c;
                            break;
                        case o.KHR_DRACO_MESH_COMPRESSION:
                            s[t] = new B(r,this.dracoLoader);
                            break;
                        case o.KHR_TEXTURE_TRANSFORM:
                            s[t] = new R;
                            break;
                        case o.KHR_MESH_QUANTIZATION:
                            s[t] = new D;
                            break;
                        default:
                            n.indexOf(t) >= 0 && void 0 === a[t] && console.warn('THREE.GLTFLoader: Unknown extension "' + t + '".')
                        }
                    }
                u.setExtensions(s),
                u.setPlugins(a),
                u.parse(n, i)
            }
            parseAsync(e, t) {
                const n = this;
                return new Promise((function(i, r) {
                    n.parse(e, t, i, r)
                }
                ))
            }
        }
        function a() {
            let e = {};
            return {
                get: function(t) {
                    return e[t]
                },
                add: function(t, n) {
                    e[t] = n
                },
                remove: function(t) {
                    delete e[t]
                },
                removeAll: function() {
                    e = {}
                }
            }
        }
        const o = {
            KHR_BINARY_GLTF: "KHR_binary_glTF",
            KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
            KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
            KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
            KHR_MATERIALS_DISPERSION: "KHR_materials_dispersion",
            KHR_MATERIALS_IOR: "KHR_materials_ior",
            KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
            KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
            KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
            KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence",
            KHR_MATERIALS_ANISOTROPY: "KHR_materials_anisotropy",
            KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
            KHR_MATERIALS_VOLUME: "KHR_materials_volume",
            KHR_TEXTURE_BASISU: "KHR_texture_basisu",
            KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
            KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
            KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength",
            EXT_MATERIALS_BUMP: "EXT_materials_bump",
            EXT_TEXTURE_WEBP: "EXT_texture_webp",
            EXT_TEXTURE_AVIF: "EXT_texture_avif",
            EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
            EXT_MESH_GPU_INSTANCING: "EXT_mesh_gpu_instancing"
        };
        class l {
            constructor(e) {
                this.parser = e,
                this.name = o.KHR_LIGHTS_PUNCTUAL,
                this.cache = {
                    refs: {},
                    uses: {}
                }
            }
            _markDefs() {
                const e = this.parser
                  , t = this.parser.json.nodes || [];
                for (let n = 0, i = t.length; n < i; n++) {
                    const i = t[n];
                    i.extensions && i.extensions[this.name] && void 0 !== i.extensions[this.name].light && e._addNodeRef(this.cache, i.extensions[this.name].light)
                }
            }
            _loadLight(e) {
                const t = this.parser
                  , n = "light:" + e;
                let r = t.cache.get(n);
                if (r)
                    return r;
                const s = t.json
                  , a = ((s.extensions && s.extensions[this.name] || {}).lights || [])[e];
                let o;
                const l = new i.Q1f(16777215);
                void 0 !== a.color && l.setRGB(a.color[0], a.color[1], a.color[2], i.Zr2);
                const c = void 0 !== a.range ? a.range : 0;
                switch (a.type) {
                case "directional":
                    o = new i.ZyN(l),
                    o.target.position.set(0, 0, -1),
                    o.add(o.target);
                    break;
                case "point":
                    o = new i.HiM(l),
                    o.distance = c;
                    break;
                case "spot":
                    o = new i.nCl(l),
                    o.distance = c,
                    a.spot = a.spot || {},
                    a.spot.innerConeAngle = void 0 !== a.spot.innerConeAngle ? a.spot.innerConeAngle : 0,
                    a.spot.outerConeAngle = void 0 !== a.spot.outerConeAngle ? a.spot.outerConeAngle : Math.PI / 4,
                    o.angle = a.spot.outerConeAngle,
                    o.penumbra = 1 - a.spot.innerConeAngle / a.spot.outerConeAngle,
                    o.target.position.set(0, 0, -1),
                    o.add(o.target);
                    break;
                default:
                    throw new Error("THREE.GLTFLoader: Unexpected light type: " + a.type)
                }
                return o.position.set(0, 0, 0),
                o.decay = 2,
                Y(o, a),
                void 0 !== a.intensity && (o.intensity = a.intensity),
                o.name = t.createUniqueName(a.name || "light_" + e),
                r = Promise.resolve(o),
                t.cache.add(n, r),
                r
            }
            getDependency(e, t) {
                if ("light" === e)
                    return this._loadLight(t)
            }
            createNodeAttachment(e) {
                const t = this
                  , n = this.parser
                  , i = n.json.nodes[e]
                  , r = (i.extensions && i.extensions[this.name] || {}).light;
                return void 0 === r ? null : this._loadLight(r).then((function(e) {
                    return n._getNodeRef(t.cache, r, e)
                }
                ))
            }
        }
        class c {
            constructor() {
                this.name = o.KHR_MATERIALS_UNLIT
            }
            getMaterialType() {
                return i.V9B
            }
            extendParams(e, t, n) {
                const r = [];
                e.color = new i.Q1f(1,1,1),
                e.opacity = 1;
                const s = t.pbrMetallicRoughness;
                if (s) {
                    if (Array.isArray(s.baseColorFactor)) {
                        const t = s.baseColorFactor;
                        e.color.setRGB(t[0], t[1], t[2], i.Zr2),
                        e.opacity = t[3]
                    }
                    void 0 !== s.baseColorTexture && r.push(n.assignTexture(e, "map", s.baseColorTexture, i.er$))
                }
                return Promise.all(r)
            }
        }
        class u {
            constructor(e) {
                this.parser = e,
                this.name = o.KHR_MATERIALS_EMISSIVE_STRENGTH
            }
            extendMaterialParams(e, t) {
                const n = this.parser.json.materials[e];
                if (!n.extensions || !n.extensions[this.name])
                    return Promise.resolve();
                const i = n.extensions[this.name].emissiveStrength;
                return void 0 !== i && (t.emissiveIntensity = i),
                Promise.resolve()
            }
        }
        class h {
            constructor(e) {
                this.parser = e,
                this.name = o.KHR_MATERIALS_CLEARCOAT
            }
            getMaterialType(e) {
                const t = this.parser.json.materials[e];
                return t.extensions && t.extensions[this.name] ? i.uSd : null
            }
            extendMaterialParams(e, t) {
                const n = this.parser
                  , r = n.json.materials[e];
                if (!r.extensions || !r.extensions[this.name])
                    return Promise.resolve();
                const s = []
                  , a = r.extensions[this.name];
                if (void 0 !== a.clearcoatFactor && (t.clearcoat = a.clearcoatFactor),
                void 0 !== a.clearcoatTexture && s.push(n.assignTexture(t, "clearcoatMap", a.clearcoatTexture)),
                void 0 !== a.clearcoatRoughnessFactor && (t.clearcoatRoughness = a.clearcoatRoughnessFactor),
                void 0 !== a.clearcoatRoughnessTexture && s.push(n.assignTexture(t, "clearcoatRoughnessMap", a.clearcoatRoughnessTexture)),
                void 0 !== a.clearcoatNormalTexture && (s.push(n.assignTexture(t, "clearcoatNormalMap", a.clearcoatNormalTexture)),
                void 0 !== a.clearcoatNormalTexture.scale)) {
                    const e = a.clearcoatNormalTexture.scale;
                    t.clearcoatNormalScale = new i.I9Y(e,e)
                }
                return Promise.all(s)
            }
        }
        class d {
            constructor(e) {
                this.parser = e,
                this.name = o.KHR_MATERIALS_DISPERSION
            }
            getMaterialType(e) {
                const t = this.parser.json.materials[e];
                return t.extensions && t.extensions[this.name] ? i.uSd : null
            }
            extendMaterialParams(e, t) {
                const n = this.parser.json.materials[e];
                if (!n.extensions || !n.extensions[this.name])
                    return Promise.resolve();
                const i = n.extensions[this.name];
                return t.dispersion = void 0 !== i.dispersion ? i.dispersion : 0,
                Promise.resolve()
            }
        }
        class p {
            constructor(e) {
                this.parser = e,
                this.name = o.KHR_MATERIALS_IRIDESCENCE
            }
            getMaterialType(e) {
                const t = this.parser.json.materials[e];
                return t.extensions && t.extensions[this.name] ? i.uSd : null
            }
            extendMaterialParams(e, t) {
                const n = this.parser
                  , i = n.json.materials[e];
                if (!i.extensions || !i.extensions[this.name])
                    return Promise.resolve();
                const r = []
                  , s = i.extensions[this.name];
                return void 0 !== s.iridescenceFactor && (t.iridescence = s.iridescenceFactor),
                void 0 !== s.iridescenceTexture && r.push(n.assignTexture(t, "iridescenceMap", s.iridescenceTexture)),
                void 0 !== s.iridescenceIor && (t.iridescenceIOR = s.iridescenceIor),
                void 0 === t.iridescenceThicknessRange && (t.iridescenceThicknessRange = [100, 400]),
                void 0 !== s.iridescenceThicknessMinimum && (t.iridescenceThicknessRange[0] = s.iridescenceThicknessMinimum),
                void 0 !== s.iridescenceThicknessMaximum && (t.iridescenceThicknessRange[1] = s.iridescenceThicknessMaximum),
                void 0 !== s.iridescenceThicknessTexture && r.push(n.assignTexture(t, "iridescenceThicknessMap", s.iridescenceThicknessTexture)),
                Promise.all(r)
            }
        }
        class f {
            constructor(e) {
                this.parser = e,
                this.name = o.KHR_MATERIALS_SHEEN
            }
            getMaterialType(e) {
                const t = this.parser.json.materials[e];
                return t.extensions && t.extensions[this.name] ? i.uSd : null
            }
            extendMaterialParams(e, t) {
                const n = this.parser
                  , r = n.json.materials[e];
                if (!r.extensions || !r.extensions[this.name])
                    return Promise.resolve();
                const s = [];
                t.sheenColor = new i.Q1f(0,0,0),
                t.sheenRoughness = 0,
                t.sheen = 1;
                const a = r.extensions[this.name];
                if (void 0 !== a.sheenColorFactor) {
                    const e = a.sheenColorFactor;
                    t.sheenColor.setRGB(e[0], e[1], e[2], i.Zr2)
                }
                return void 0 !== a.sheenRoughnessFactor && (t.sheenRoughness = a.sheenRoughnessFactor),
                void 0 !== a.sheenColorTexture && s.push(n.assignTexture(t, "sheenColorMap", a.sheenColorTexture, i.er$)),
                void 0 !== a.sheenRoughnessTexture && s.push(n.assignTexture(t, "sheenRoughnessMap", a.sheenRoughnessTexture)),
                Promise.all(s)
            }
        }
        class A {
            constructor(e) {
                this.parser = e,
                this.name = o.KHR_MATERIALS_TRANSMISSION
            }
            getMaterialType(e) {
                const t = this.parser.json.materials[e];
                return t.extensions && t.extensions[this.name] ? i.uSd : null
            }
            extendMaterialParams(e, t) {
                const n = this.parser
                  , i = n.json.materials[e];
                if (!i.extensions || !i.extensions[this.name])
                    return Promise.resolve();
                const r = []
                  , s = i.extensions[this.name];
                return void 0 !== s.transmissionFactor && (t.transmission = s.transmissionFactor),
                void 0 !== s.transmissionTexture && r.push(n.assignTexture(t, "transmissionMap", s.transmissionTexture)),
                Promise.all(r)
            }
        }
        class g {
            constructor(e) {
                this.parser = e,
                this.name = o.KHR_MATERIALS_VOLUME
            }
            getMaterialType(e) {
                const t = this.parser.json.materials[e];
                return t.extensions && t.extensions[this.name] ? i.uSd : null
            }
            extendMaterialParams(e, t) {
                const n = this.parser
                  , r = n.json.materials[e];
                if (!r.extensions || !r.extensions[this.name])
                    return Promise.resolve();
                const s = []
                  , a = r.extensions[this.name];
                t.thickness = void 0 !== a.thicknessFactor ? a.thicknessFactor : 0,
                void 0 !== a.thicknessTexture && s.push(n.assignTexture(t, "thicknessMap", a.thicknessTexture)),
                t.attenuationDistance = a.attenuationDistance || 1 / 0;
                const o = a.attenuationColor || [1, 1, 1];
                return t.attenuationColor = (new i.Q1f).setRGB(o[0], o[1], o[2], i.Zr2),
                Promise.all(s)
            }
        }
        class m {
            constructor(e) {
                this.parser = e,
                this.name = o.KHR_MATERIALS_IOR
            }
            getMaterialType(e) {
                const t = this.parser.json.materials[e];
                return t.extensions && t.extensions[this.name] ? i.uSd : null
            }
            extendMaterialParams(e, t) {
                const n = this.parser.json.materials[e];
                if (!n.extensions || !n.extensions[this.name])
                    return Promise.resolve();
                const i = n.extensions[this.name];
                return t.ior = void 0 !== i.ior ? i.ior : 1.5,
                Promise.resolve()
            }
        }
        class v {
            constructor(e) {
                this.parser = e,
                this.name = o.KHR_MATERIALS_SPECULAR
            }
            getMaterialType(e) {
                const t = this.parser.json.materials[e];
                return t.extensions && t.extensions[this.name] ? i.uSd : null
            }
            extendMaterialParams(e, t) {
                const n = this.parser
                  , r = n.json.materials[e];
                if (!r.extensions || !r.extensions[this.name])
                    return Promise.resolve();
                const s = []
                  , a = r.extensions[this.name];
                t.specularIntensity = void 0 !== a.specularFactor ? a.specularFactor : 1,
                void 0 !== a.specularTexture && s.push(n.assignTexture(t, "specularIntensityMap", a.specularTexture));
                const o = a.specularColorFactor || [1, 1, 1];
                return t.specularColor = (new i.Q1f).setRGB(o[0], o[1], o[2], i.Zr2),
                void 0 !== a.specularColorTexture && s.push(n.assignTexture(t, "specularColorMap", a.specularColorTexture, i.er$)),
                Promise.all(s)
            }
        }
        class y {
            constructor(e) {
                this.parser = e,
                this.name = o.EXT_MATERIALS_BUMP
            }
            getMaterialType(e) {
                const t = this.parser.json.materials[e];
                return t.extensions && t.extensions[this.name] ? i.uSd : null
            }
            extendMaterialParams(e, t) {
                const n = this.parser
                  , i = n.json.materials[e];
                if (!i.extensions || !i.extensions[this.name])
                    return Promise.resolve();
                const r = []
                  , s = i.extensions[this.name];
                return t.bumpScale = void 0 !== s.bumpFactor ? s.bumpFactor : 1,
                void 0 !== s.bumpTexture && r.push(n.assignTexture(t, "bumpMap", s.bumpTexture)),
                Promise.all(r)
            }
        }
        class x {
            constructor(e) {
                this.parser = e,
                this.name = o.KHR_MATERIALS_ANISOTROPY
            }
            getMaterialType(e) {
                const t = this.parser.json.materials[e];
                return t.extensions && t.extensions[this.name] ? i.uSd : null
            }
            extendMaterialParams(e, t) {
                const n = this.parser
                  , i = n.json.materials[e];
                if (!i.extensions || !i.extensions[this.name])
                    return Promise.resolve();
                const r = []
                  , s = i.extensions[this.name];
                return void 0 !== s.anisotropyStrength && (t.anisotropy = s.anisotropyStrength),
                void 0 !== s.anisotropyRotation && (t.anisotropyRotation = s.anisotropyRotation),
                void 0 !== s.anisotropyTexture && r.push(n.assignTexture(t, "anisotropyMap", s.anisotropyTexture)),
                Promise.all(r)
            }
        }
        class _ {
            constructor(e) {
                this.parser = e,
                this.name = o.KHR_TEXTURE_BASISU
            }
            loadTexture(e) {
                const t = this.parser
                  , n = t.json
                  , i = n.textures[e];
                if (!i.extensions || !i.extensions[this.name])
                    return null;
                const r = i.extensions[this.name]
                  , s = t.options.ktx2Loader;
                if (!s) {
                    if (n.extensionsRequired && n.extensionsRequired.indexOf(this.name) >= 0)
                        throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
                    return null
                }
                return t.loadTextureImage(e, r.source, s)
            }
        }
        class b {
            constructor(e) {
                this.parser = e,
                this.name = o.EXT_TEXTURE_WEBP,
                this.isSupported = null
            }
            loadTexture(e) {
                const t = this.name
                  , n = this.parser
                  , i = n.json
                  , r = i.textures[e];
                if (!r.extensions || !r.extensions[t])
                    return null;
                const s = r.extensions[t]
                  , a = i.images[s.source];
                let o = n.textureLoader;
                if (a.uri) {
                    const e = n.options.manager.getHandler(a.uri);
                    null !== e && (o = e)
                }
                return this.detectSupport().then((function(r) {
                    if (r)
                        return n.loadTextureImage(e, s.source, o);
                    if (i.extensionsRequired && i.extensionsRequired.indexOf(t) >= 0)
                        throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
                    return n.loadTexture(e)
                }
                ))
            }
            detectSupport() {
                return this.isSupported || (this.isSupported = new Promise((function(e) {
                    const t = new Image;
                    t.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA",
                    t.onload = t.onerror = function() {
                        e(1 === t.height)
                    }
                }
                ))),
                this.isSupported
            }
        }
        class E {
            constructor(e) {
                this.parser = e,
                this.name = o.EXT_TEXTURE_AVIF,
                this.isSupported = null
            }
            loadTexture(e) {
                const t = this.name
                  , n = this.parser
                  , i = n.json
                  , r = i.textures[e];
                if (!r.extensions || !r.extensions[t])
                    return null;
                const s = r.extensions[t]
                  , a = i.images[s.source];
                let o = n.textureLoader;
                if (a.uri) {
                    const e = n.options.manager.getHandler(a.uri);
                    null !== e && (o = e)
                }
                return this.detectSupport().then((function(r) {
                    if (r)
                        return n.loadTextureImage(e, s.source, o);
                    if (i.extensionsRequired && i.extensionsRequired.indexOf(t) >= 0)
                        throw new Error("THREE.GLTFLoader: AVIF required by asset but unsupported.");
                    return n.loadTexture(e)
                }
                ))
            }
            detectSupport() {
                return this.isSupported || (this.isSupported = new Promise((function(e) {
                    const t = new Image;
                    t.src = "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=",
                    t.onload = t.onerror = function() {
                        e(1 === t.height)
                    }
                }
                ))),
                this.isSupported
            }
        }
        class w {
            constructor(e) {
                this.name = o.EXT_MESHOPT_COMPRESSION,
                this.parser = e
            }
            loadBufferView(e) {
                const t = this.parser.json
                  , n = t.bufferViews[e];
                if (n.extensions && n.extensions[this.name]) {
                    const e = n.extensions[this.name]
                      , i = this.parser.getDependency("buffer", e.buffer)
                      , r = this.parser.options.meshoptDecoder;
                    if (!r || !r.supported) {
                        if (t.extensionsRequired && t.extensionsRequired.indexOf(this.name) >= 0)
                            throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
                        return null
                    }
                    return i.then((function(t) {
                        const n = e.byteOffset || 0
                          , i = e.byteLength || 0
                          , s = e.count
                          , a = e.byteStride
                          , o = new Uint8Array(t,n,i);
                        return r.decodeGltfBufferAsync ? r.decodeGltfBufferAsync(s, a, o, e.mode, e.filter).then((function(e) {
                            return e.buffer
                        }
                        )) : r.ready.then((function() {
                            const t = new ArrayBuffer(s * a);
                            return r.decodeGltfBuffer(new Uint8Array(t), s, a, o, e.mode, e.filter),
                            t
                        }
                        ))
                    }
                    ))
                }
                return null
            }
        }
        class C {
            constructor(e) {
                this.name = o.EXT_MESH_GPU_INSTANCING,
                this.parser = e
            }
            createNodeMesh(e) {
                const t = this.parser.json
                  , n = t.nodes[e];
                if (!n.extensions || !n.extensions[this.name] || void 0 === n.mesh)
                    return null;
                const r = t.meshes[n.mesh];
                for (const e of r.primitives)
                    if (e.mode !== F.TRIANGLES && e.mode !== F.TRIANGLE_STRIP && e.mode !== F.TRIANGLE_FAN && void 0 !== e.mode)
                        return null;
                const s = n.extensions[this.name].attributes
                  , a = []
                  , o = {};
                for (const e in s)
                    a.push(this.parser.getDependency("accessor", s[e]).then((t => (o[e] = t,
                    o[e]))));
                return a.length < 1 ? null : (a.push(this.parser.createNodeMesh(e)),
                Promise.all(a).then((e => {
                    const t = e.pop()
                      , n = t.isGroup ? t.children : [t]
                      , r = e[0].count
                      , s = [];
                    for (const e of n) {
                        const t = new i.kn4
                          , n = new i.Pq0
                          , a = new i.PTz
                          , l = new i.Pq0(1,1,1)
                          , c = new i.ZLX(e.geometry,e.material,r);
                        for (let e = 0; e < r; e++)
                            o.TRANSLATION && n.fromBufferAttribute(o.TRANSLATION, e),
                            o.ROTATION && a.fromBufferAttribute(o.ROTATION, e),
                            o.SCALE && l.fromBufferAttribute(o.SCALE, e),
                            c.setMatrixAt(e, t.compose(n, a, l));
                        for (const t in o)
                            if ("_COLOR_0" === t) {
                                const e = o[t];
                                c.instanceColor = new i.uWO(e.array,e.itemSize,e.normalized)
                            } else
                                "TRANSLATION" !== t && "ROTATION" !== t && "SCALE" !== t && e.geometry.setAttribute(t, o[t]);
                        i.B69.prototype.copy.call(c, e),
                        this.parser.assignFinalMaterial(c),
                        s.push(c)
                    }
                    return t.isGroup ? (t.clear(),
                    t.add(...s),
                    t) : s[0]
                }
                )))
            }
        }
        const I = "glTF"
          , S = 1313821514
          , M = 5130562;
        class T {
            constructor(e) {
                this.name = o.KHR_BINARY_GLTF,
                this.content = null,
                this.body = null;
                const t = new DataView(e,0,12)
                  , n = new TextDecoder;
                if (this.header = {
                    magic: n.decode(new Uint8Array(e.slice(0, 4))),
                    version: t.getUint32(4, !0),
                    length: t.getUint32(8, !0)
                },
                this.header.magic !== I)
                    throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
                if (this.header.version < 2)
                    throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
                const i = this.header.length - 12
                  , r = new DataView(e,12);
                let s = 0;
                for (; s < i; ) {
                    const t = r.getUint32(s, !0);
                    s += 4;
                    const i = r.getUint32(s, !0);
                    if (s += 4,
                    i === S) {
                        const i = new Uint8Array(e,12 + s,t);
                        this.content = n.decode(i)
                    } else if (i === M) {
                        const n = 12 + s;
                        this.body = e.slice(n, n + t)
                    }
                    s += t
                }
                if (null === this.content)
                    throw new Error("THREE.GLTFLoader: JSON content not found.")
            }
        }
        class B {
            constructor(e, t) {
                if (!t)
                    throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
                this.name = o.KHR_DRACO_MESH_COMPRESSION,
                this.json = e,
                this.dracoLoader = t,
                this.dracoLoader.preload()
            }
            decodePrimitive(e, t) {
                const n = this.json
                  , r = this.dracoLoader
                  , s = e.extensions[this.name].bufferView
                  , a = e.extensions[this.name].attributes
                  , o = {}
                  , l = {}
                  , c = {};
                for (const e in a) {
                    const t = G[e] || e.toLowerCase();
                    o[t] = a[e]
                }
                for (const t in e.attributes) {
                    const i = G[t] || t.toLowerCase();
                    if (void 0 !== a[t]) {
                        const r = n.accessors[e.attributes[t]]
                          , s = N[r.componentType];
                        c[i] = s.name,
                        l[i] = !0 === r.normalized
                    }
                }
                return t.getDependency("bufferView", s).then((function(e) {
                    return new Promise((function(t, n) {
                        r.decodeDracoFile(e, (function(e) {
                            for (const t in e.attributes) {
                                const n = e.attributes[t]
                                  , i = l[t];
                                void 0 !== i && (n.normalized = i)
                            }
                            t(e)
                        }
                        ), o, c, i.Zr2, n)
                    }
                    ))
                }
                ))
            }
        }
        class R {
            constructor() {
                this.name = o.KHR_TEXTURE_TRANSFORM
            }
            extendTexture(e, t) {
                return void 0 !== t.texCoord && t.texCoord !== e.channel || void 0 !== t.offset || void 0 !== t.rotation || void 0 !== t.scale ? (e = e.clone(),
                void 0 !== t.texCoord && (e.channel = t.texCoord),
                void 0 !== t.offset && e.offset.fromArray(t.offset),
                void 0 !== t.rotation && (e.rotation = t.rotation),
                void 0 !== t.scale && e.repeat.fromArray(t.scale),
                e.needsUpdate = !0,
                e) : e
            }
        }
        class D {
            constructor() {
                this.name = o.KHR_MESH_QUANTIZATION
            }
        }
        class P extends i.lGw {
            constructor(e, t, n, i) {
                super(e, t, n, i)
            }
            copySampleValue_(e) {
                const t = this.resultBuffer
                  , n = this.sampleValues
                  , i = this.valueSize
                  , r = e * i * 3 + i;
                for (let e = 0; e !== i; e++)
                    t[e] = n[r + e];
                return t
            }
            interpolate_(e, t, n, i) {
                const r = this.resultBuffer
                  , s = this.sampleValues
                  , a = this.valueSize
                  , o = 2 * a
                  , l = 3 * a
                  , c = i - t
                  , u = (n - t) / c
                  , h = u * u
                  , d = h * u
                  , p = e * l
                  , f = p - l
                  , A = -2 * d + 3 * h
                  , g = d - h
                  , m = 1 - A
                  , v = g - h + u;
                for (let e = 0; e !== a; e++) {
                    const t = s[f + e + a]
                      , n = s[f + e + o] * c
                      , i = s[p + e + a]
                      , l = s[p + e] * c;
                    r[e] = m * t + v * n + A * i + g * l
                }
                return r
            }
        }
        const L = new i.PTz;
        class U extends P {
            interpolate_(e, t, n, i) {
                const r = super.interpolate_(e, t, n, i);
                return L.fromArray(r).normalize().toArray(r),
                r
            }
        }
        const F = {
            FLOAT: 5126,
            FLOAT_MAT3: 35675,
            FLOAT_MAT4: 35676,
            FLOAT_VEC2: 35664,
            FLOAT_VEC3: 35665,
            FLOAT_VEC4: 35666,
            LINEAR: 9729,
            REPEAT: 10497,
            SAMPLER_2D: 35678,
            POINTS: 0,
            LINES: 1,
            LINE_LOOP: 2,
            LINE_STRIP: 3,
            TRIANGLES: 4,
            TRIANGLE_STRIP: 5,
            TRIANGLE_FAN: 6,
            UNSIGNED_BYTE: 5121,
            UNSIGNED_SHORT: 5123
        }
          , N = {
            5120: Int8Array,
            5121: Uint8Array,
            5122: Int16Array,
            5123: Uint16Array,
            5125: Uint32Array,
            5126: Float32Array
        }
          , O = {
            9728: i.hxR,
            9729: i.k6q,
            9984: i.pHI,
            9985: i.kRr,
            9986: i.Cfg,
            9987: i.$_I
        }
          , Q = {
            33071: i.ghU,
            33648: i.kTW,
            10497: i.GJx
        }
          , k = {
            SCALAR: 1,
            VEC2: 2,
            VEC3: 3,
            VEC4: 4,
            MAT2: 4,
            MAT3: 9,
            MAT4: 16
        }
          , G = {
            POSITION: "position",
            NORMAL: "normal",
            TANGENT: "tangent",
            TEXCOORD_0: "uv",
            TEXCOORD_1: "uv1",
            TEXCOORD_2: "uv2",
            TEXCOORD_3: "uv3",
            COLOR_0: "color",
            WEIGHTS_0: "skinWeight",
            JOINTS_0: "skinIndex"
        }
          , H = {
            scale: "scale",
            translation: "position",
            rotation: "quaternion",
            weights: "morphTargetInfluences"
        }
          , z = {
            CUBICSPLINE: void 0,
            LINEAR: i.PJ3,
            STEP: i.ljd
        }
          , V = "OPAQUE"
          , W = "MASK"
          , j = "BLEND";
        function q(e, t, n) {
            for (const i in n.extensions)
                void 0 === e[i] && (t.userData.gltfExtensions = t.userData.gltfExtensions || {},
                t.userData.gltfExtensions[i] = n.extensions[i])
        }
        function Y(e, t) {
            void 0 !== t.extras && ("object" == typeof t.extras ? Object.assign(e.userData, t.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + t.extras))
        }
        function X(e, t) {
            if (e.updateMorphTargets(),
            void 0 !== t.weights)
                for (let n = 0, i = t.weights.length; n < i; n++)
                    e.morphTargetInfluences[n] = t.weights[n];
            if (t.extras && Array.isArray(t.extras.targetNames)) {
                const n = t.extras.targetNames;
                if (e.morphTargetInfluences.length === n.length) {
                    e.morphTargetDictionary = {};
                    for (let t = 0, i = n.length; t < i; t++)
                        e.morphTargetDictionary[n[t]] = t
                } else
                    console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")
            }
        }
        function K(e) {
            let t;
            const n = e.extensions && e.extensions[o.KHR_DRACO_MESH_COMPRESSION];
            if (t = n ? "draco:" + n.bufferView + ":" + n.indices + ":" + J(n.attributes) : e.indices + ":" + J(e.attributes) + ":" + e.mode,
            void 0 !== e.targets)
                for (let n = 0, i = e.targets.length; n < i; n++)
                    t += ":" + J(e.targets[n]);
            return t
        }
        function J(e) {
            let t = "";
            const n = Object.keys(e).sort();
            for (let i = 0, r = n.length; i < r; i++)
                t += n[i] + ":" + e[n[i]] + ";";
            return t
        }
        function Z(e) {
            switch (e) {
            case Int8Array:
                return 1 / 127;
            case Uint8Array:
                return 1 / 255;
            case Int16Array:
                return 1 / 32767;
            case Uint16Array:
                return 1 / 65535;
            default:
                throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")
            }
        }
        const $ = new i.kn4;
        class ee {
            constructor(e={}, t={}) {
                this.json = e,
                this.extensions = {},
                this.plugins = {},
                this.options = t,
                this.cache = new a,
                this.associations = new Map,
                this.primitiveCache = {},
                this.nodeCache = {},
                this.meshCache = {
                    refs: {},
                    uses: {}
                },
                this.cameraCache = {
                    refs: {},
                    uses: {}
                },
                this.lightCache = {
                    refs: {},
                    uses: {}
                },
                this.sourceCache = {},
                this.textureCache = {},
                this.nodeNamesUsed = {};
                let n = !1
                  , r = -1
                  , s = !1
                  , o = -1;
                if ("undefined" != typeof navigator) {
                    const e = navigator.userAgent;
                    n = !0 === /^((?!chrome|android).)*safari/i.test(e);
                    const t = e.match(/Version\/(\d+)/);
                    r = n && t ? parseInt(t[1], 10) : -1,
                    s = e.indexOf("Firefox") > -1,
                    o = s ? e.match(/Firefox\/([0-9]+)\./)[1] : -1
                }
                "undefined" == typeof createImageBitmap || n && r < 17 || s && o < 98 ? this.textureLoader = new i.Tap(this.options.manager) : this.textureLoader = new i.Kzg(this.options.manager),
                this.textureLoader.setCrossOrigin(this.options.crossOrigin),
                this.textureLoader.setRequestHeader(this.options.requestHeader),
                this.fileLoader = new i.Y9S(this.options.manager),
                this.fileLoader.setResponseType("arraybuffer"),
                "use-credentials" === this.options.crossOrigin && this.fileLoader.setWithCredentials(!0)
            }
            setExtensions(e) {
                this.extensions = e
            }
            setPlugins(e) {
                this.plugins = e
            }
            parse(e, t) {
                const n = this
                  , i = this.json
                  , r = this.extensions;
                this.cache.removeAll(),
                this.nodeCache = {},
                this._invokeAll((function(e) {
                    return e._markDefs && e._markDefs()
                }
                )),
                Promise.all(this._invokeAll((function(e) {
                    return e.beforeRoot && e.beforeRoot()
                }
                ))).then((function() {
                    return Promise.all([n.getDependencies("scene"), n.getDependencies("animation"), n.getDependencies("camera")])
                }
                )).then((function(t) {
                    const s = {
                        scene: t[0][i.scene || 0],
                        scenes: t[0],
                        animations: t[1],
                        cameras: t[2],
                        asset: i.asset,
                        parser: n,
                        userData: {}
                    };
                    return q(r, s, i),
                    Y(s, i),
                    Promise.all(n._invokeAll((function(e) {
                        return e.afterRoot && e.afterRoot(s)
                    }
                    ))).then((function() {
                        for (const e of s.scenes)
                            e.updateMatrixWorld();
                        e(s)
                    }
                    ))
                }
                )).catch(t)
            }
            _markDefs() {
                const e = this.json.nodes || []
                  , t = this.json.skins || []
                  , n = this.json.meshes || [];
                for (let n = 0, i = t.length; n < i; n++) {
                    const i = t[n].joints;
                    for (let t = 0, n = i.length; t < n; t++)
                        e[i[t]].isBone = !0
                }
                for (let t = 0, i = e.length; t < i; t++) {
                    const i = e[t];
                    void 0 !== i.mesh && (this._addNodeRef(this.meshCache, i.mesh),
                    void 0 !== i.skin && (n[i.mesh].isSkinnedMesh = !0)),
                    void 0 !== i.camera && this._addNodeRef(this.cameraCache, i.camera)
                }
            }
            _addNodeRef(e, t) {
                void 0 !== t && (void 0 === e.refs[t] && (e.refs[t] = e.uses[t] = 0),
                e.refs[t]++)
            }
            _getNodeRef(e, t, n) {
                if (e.refs[t] <= 1)
                    return n;
                const i = n.clone()
                  , r = (e, t) => {
                    const n = this.associations.get(e);
                    null != n && this.associations.set(t, n);
                    for (const [n,i] of e.children.entries())
                        r(i, t.children[n])
                }
                ;
                return r(n, i),
                i.name += "_instance_" + e.uses[t]++,
                i
            }
            _invokeOne(e) {
                const t = Object.values(this.plugins);
                t.push(this);
                for (let n = 0; n < t.length; n++) {
                    const i = e(t[n]);
                    if (i)
                        return i
                }
                return null
            }
            _invokeAll(e) {
                const t = Object.values(this.plugins);
                t.unshift(this);
                const n = [];
                for (let i = 0; i < t.length; i++) {
                    const r = e(t[i]);
                    r && n.push(r)
                }
                return n
            }
            getDependency(e, t) {
                const n = e + ":" + t;
                let i = this.cache.get(n);
                if (!i) {
                    switch (e) {
                    case "scene":
                        i = this.loadScene(t);
                        break;
                    case "node":
                        i = this._invokeOne((function(e) {
                            return e.loadNode && e.loadNode(t)
                        }
                        ));
                        break;
                    case "mesh":
                        i = this._invokeOne((function(e) {
                            return e.loadMesh && e.loadMesh(t)
                        }
                        ));
                        break;
                    case "accessor":
                        i = this.loadAccessor(t);
                        break;
                    case "bufferView":
                        i = this._invokeOne((function(e) {
                            return e.loadBufferView && e.loadBufferView(t)
                        }
                        ));
                        break;
                    case "buffer":
                        i = this.loadBuffer(t);
                        break;
                    case "material":
                        i = this._invokeOne((function(e) {
                            return e.loadMaterial && e.loadMaterial(t)
                        }
                        ));
                        break;
                    case "texture":
                        i = this._invokeOne((function(e) {
                            return e.loadTexture && e.loadTexture(t)
                        }
                        ));
                        break;
                    case "skin":
                        i = this.loadSkin(t);
                        break;
                    case "animation":
                        i = this._invokeOne((function(e) {
                            return e.loadAnimation && e.loadAnimation(t)
                        }
                        ));
                        break;
                    case "camera":
                        i = this.loadCamera(t);
                        break;
                    default:
                        if (i = this._invokeOne((function(n) {
                            return n != this && n.getDependency && n.getDependency(e, t)
                        }
                        )),
                        !i)
                            throw new Error("Unknown type: " + e)
                    }
                    this.cache.add(n, i)
                }
                return i
            }
            getDependencies(e) {
                let t = this.cache.get(e);
                if (!t) {
                    const n = this
                      , i = this.json[e + ("mesh" === e ? "es" : "s")] || [];
                    t = Promise.all(i.map((function(t, i) {
                        return n.getDependency(e, i)
                    }
                    ))),
                    this.cache.add(e, t)
                }
                return t
            }
            loadBuffer(e) {
                const t = this.json.buffers[e]
                  , n = this.fileLoader;
                if (t.type && "arraybuffer" !== t.type)
                    throw new Error("THREE.GLTFLoader: " + t.type + " buffer type is not supported.");
                if (void 0 === t.uri && 0 === e)
                    return Promise.resolve(this.extensions[o.KHR_BINARY_GLTF].body);
                const r = this.options;
                return new Promise((function(e, s) {
                    n.load(i.r6x.resolveURL(t.uri, r.path), e, void 0, (function() {
                        s(new Error('THREE.GLTFLoader: Failed to load buffer "' + t.uri + '".'))
                    }
                    ))
                }
                ))
            }
            loadBufferView(e) {
                const t = this.json.bufferViews[e];
                return this.getDependency("buffer", t.buffer).then((function(e) {
                    const n = t.byteLength || 0
                      , i = t.byteOffset || 0;
                    return e.slice(i, i + n)
                }
                ))
            }
            loadAccessor(e) {
                const t = this
                  , n = this.json
                  , r = this.json.accessors[e];
                if (void 0 === r.bufferView && void 0 === r.sparse) {
                    const e = k[r.type]
                      , t = N[r.componentType]
                      , n = !0 === r.normalized
                      , s = new t(r.count * e);
                    return Promise.resolve(new i.THS(s,e,n))
                }
                const s = [];
                return void 0 !== r.bufferView ? s.push(this.getDependency("bufferView", r.bufferView)) : s.push(null),
                void 0 !== r.sparse && (s.push(this.getDependency("bufferView", r.sparse.indices.bufferView)),
                s.push(this.getDependency("bufferView", r.sparse.values.bufferView))),
                Promise.all(s).then((function(e) {
                    const s = e[0]
                      , a = k[r.type]
                      , o = N[r.componentType]
                      , l = o.BYTES_PER_ELEMENT
                      , c = l * a
                      , u = r.byteOffset || 0
                      , h = void 0 !== r.bufferView ? n.bufferViews[r.bufferView].byteStride : void 0
                      , d = !0 === r.normalized;
                    let p, f;
                    if (h && h !== c) {
                        const e = Math.floor(u / h)
                          , n = "InterleavedBuffer:" + r.bufferView + ":" + r.componentType + ":" + e + ":" + r.count;
                        let c = t.cache.get(n);
                        c || (p = new o(s,e * h,r.count * h / l),
                        c = new i.eB$(p,h / l),
                        t.cache.add(n, c)),
                        f = new i.eHs(c,a,u % h / l,d)
                    } else
                        p = null === s ? new o(r.count * a) : new o(s,u,r.count * a),
                        f = new i.THS(p,a,d);
                    if (void 0 !== r.sparse) {
                        const t = k.SCALAR
                          , n = N[r.sparse.indices.componentType]
                          , l = r.sparse.indices.byteOffset || 0
                          , c = r.sparse.values.byteOffset || 0
                          , u = new n(e[1],l,r.sparse.count * t)
                          , h = new o(e[2],c,r.sparse.count * a);
                        null !== s && (f = new i.THS(f.array.slice(),f.itemSize,f.normalized)),
                        f.normalized = !1;
                        for (let e = 0, t = u.length; e < t; e++) {
                            const t = u[e];
                            if (f.setX(t, h[e * a]),
                            a >= 2 && f.setY(t, h[e * a + 1]),
                            a >= 3 && f.setZ(t, h[e * a + 2]),
                            a >= 4 && f.setW(t, h[e * a + 3]),
                            a >= 5)
                                throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")
                        }
                        f.normalized = d
                    }
                    return f
                }
                ))
            }
            loadTexture(e) {
                const t = this.json
                  , n = this.options
                  , i = t.textures[e].source
                  , r = t.images[i];
                let s = this.textureLoader;
                if (r.uri) {
                    const e = n.manager.getHandler(r.uri);
                    null !== e && (s = e)
                }
                return this.loadTextureImage(e, i, s)
            }
            loadTextureImage(e, t, n) {
                const r = this
                  , s = this.json
                  , a = s.textures[e]
                  , o = s.images[t]
                  , l = (o.uri || o.bufferView) + ":" + a.sampler;
                if (this.textureCache[l])
                    return this.textureCache[l];
                const c = this.loadImageSource(t, n).then((function(t) {
                    t.flipY = !1,
                    t.name = a.name || o.name || "",
                    "" === t.name && "string" == typeof o.uri && !1 === o.uri.startsWith("data:image/") && (t.name = o.uri);
                    const n = (s.samplers || {})[a.sampler] || {};
                    return t.magFilter = O[n.magFilter] || i.k6q,
                    t.minFilter = O[n.minFilter] || i.$_I,
                    t.wrapS = Q[n.wrapS] || i.GJx,
                    t.wrapT = Q[n.wrapT] || i.GJx,
                    t.generateMipmaps = !t.isCompressedTexture && t.minFilter !== i.hxR && t.minFilter !== i.k6q,
                    r.associations.set(t, {
                        textures: e
                    }),
                    t
                }
                )).catch((function() {
                    return null
                }
                ));
                return this.textureCache[l] = c,
                c
            }
            loadImageSource(e, t) {
                const n = this
                  , r = this.json
                  , s = this.options;
                if (void 0 !== this.sourceCache[e])
                    return this.sourceCache[e].then((e => e.clone()));
                const a = r.images[e]
                  , o = self.URL || self.webkitURL;
                let l = a.uri || ""
                  , c = !1;
                if (void 0 !== a.bufferView)
                    l = n.getDependency("bufferView", a.bufferView).then((function(e) {
                        c = !0;
                        const t = new Blob([e],{
                            type: a.mimeType
                        });
                        return l = o.createObjectURL(t),
                        l
                    }
                    ));
                else if (void 0 === a.uri)
                    throw new Error("THREE.GLTFLoader: Image " + e + " is missing URI and bufferView");
                const u = Promise.resolve(l).then((function(e) {
                    return new Promise((function(n, r) {
                        let a = n;
                        !0 === t.isImageBitmapLoader && (a = function(e) {
                            const t = new i.gPd(e);
                            t.needsUpdate = !0,
                            n(t)
                        }
                        ),
                        t.load(i.r6x.resolveURL(e, s.path), a, void 0, r)
                    }
                    ))
                }
                )).then((function(e) {
                    var t;
                    return !0 === c && o.revokeObjectURL(l),
                    Y(e, a),
                    e.userData.mimeType = a.mimeType || ((t = a.uri).search(/\.jpe?g($|\?)/i) > 0 || 0 === t.search(/^data\:image\/jpeg/) ? "image/jpeg" : t.search(/\.webp($|\?)/i) > 0 || 0 === t.search(/^data\:image\/webp/) ? "image/webp" : t.search(/\.ktx2($|\?)/i) > 0 || 0 === t.search(/^data\:image\/ktx2/) ? "image/ktx2" : "image/png"),
                    e
                }
                )).catch((function(e) {
                    throw console.error("THREE.GLTFLoader: Couldn't load texture", l),
                    e
                }
                ));
                return this.sourceCache[e] = u,
                u
            }
            assignTexture(e, t, n, i) {
                const r = this;
                return this.getDependency("texture", n.index).then((function(s) {
                    if (!s)
                        return null;
                    if (void 0 !== n.texCoord && n.texCoord > 0 && ((s = s.clone()).channel = n.texCoord),
                    r.extensions[o.KHR_TEXTURE_TRANSFORM]) {
                        const e = void 0 !== n.extensions ? n.extensions[o.KHR_TEXTURE_TRANSFORM] : void 0;
                        if (e) {
                            const t = r.associations.get(s);
                            s = r.extensions[o.KHR_TEXTURE_TRANSFORM].extendTexture(s, e),
                            r.associations.set(s, t)
                        }
                    }
                    return void 0 !== i && (s.colorSpace = i),
                    e[t] = s,
                    s
                }
                ))
            }
            assignFinalMaterial(e) {
                const t = e.geometry;
                let n = e.material;
                const r = void 0 === t.attributes.tangent
                  , s = void 0 !== t.attributes.color
                  , a = void 0 === t.attributes.normal;
                if (e.isPoints) {
                    const e = "PointsMaterial:" + n.uuid;
                    let t = this.cache.get(e);
                    t || (t = new i.BH$,
                    i.imn.prototype.copy.call(t, n),
                    t.color.copy(n.color),
                    t.map = n.map,
                    t.sizeAttenuation = !1,
                    this.cache.add(e, t)),
                    n = t
                } else if (e.isLine) {
                    const e = "LineBasicMaterial:" + n.uuid;
                    let t = this.cache.get(e);
                    t || (t = new i.mrM,
                    i.imn.prototype.copy.call(t, n),
                    t.color.copy(n.color),
                    t.map = n.map,
                    this.cache.add(e, t)),
                    n = t
                }
                if (r || s || a) {
                    let e = "ClonedMaterial:" + n.uuid + ":";
                    r && (e += "derivative-tangents:"),
                    s && (e += "vertex-colors:"),
                    a && (e += "flat-shading:");
                    let t = this.cache.get(e);
                    t || (t = n.clone(),
                    s && (t.vertexColors = !0),
                    a && (t.flatShading = !0),
                    r && (t.normalScale && (t.normalScale.y *= -1),
                    t.clearcoatNormalScale && (t.clearcoatNormalScale.y *= -1)),
                    this.cache.add(e, t),
                    this.associations.set(t, this.associations.get(n))),
                    n = t
                }
                e.material = n
            }
            getMaterialType() {
                return i._4j
            }
            loadMaterial(e) {
                const t = this
                  , n = this.json
                  , r = this.extensions
                  , s = n.materials[e];
                let a;
                const l = {}
                  , c = [];
                if ((s.extensions || {})[o.KHR_MATERIALS_UNLIT]) {
                    const e = r[o.KHR_MATERIALS_UNLIT];
                    a = e.getMaterialType(),
                    c.push(e.extendParams(l, s, t))
                } else {
                    const n = s.pbrMetallicRoughness || {};
                    if (l.color = new i.Q1f(1,1,1),
                    l.opacity = 1,
                    Array.isArray(n.baseColorFactor)) {
                        const e = n.baseColorFactor;
                        l.color.setRGB(e[0], e[1], e[2], i.Zr2),
                        l.opacity = e[3]
                    }
                    void 0 !== n.baseColorTexture && c.push(t.assignTexture(l, "map", n.baseColorTexture, i.er$)),
                    l.metalness = void 0 !== n.metallicFactor ? n.metallicFactor : 1,
                    l.roughness = void 0 !== n.roughnessFactor ? n.roughnessFactor : 1,
                    void 0 !== n.metallicRoughnessTexture && (c.push(t.assignTexture(l, "metalnessMap", n.metallicRoughnessTexture)),
                    c.push(t.assignTexture(l, "roughnessMap", n.metallicRoughnessTexture))),
                    a = this._invokeOne((function(t) {
                        return t.getMaterialType && t.getMaterialType(e)
                    }
                    )),
                    c.push(Promise.all(this._invokeAll((function(t) {
                        return t.extendMaterialParams && t.extendMaterialParams(e, l)
                    }
                    ))))
                }
                !0 === s.doubleSided && (l.side = i.$EB);
                const u = s.alphaMode || V;
                if (u === j ? (l.transparent = !0,
                l.depthWrite = !1) : (l.transparent = !1,
                u === W && (l.alphaTest = void 0 !== s.alphaCutoff ? s.alphaCutoff : .5)),
                void 0 !== s.normalTexture && a !== i.V9B && (c.push(t.assignTexture(l, "normalMap", s.normalTexture)),
                l.normalScale = new i.I9Y(1,1),
                void 0 !== s.normalTexture.scale)) {
                    const e = s.normalTexture.scale;
                    l.normalScale.set(e, e)
                }
                if (void 0 !== s.occlusionTexture && a !== i.V9B && (c.push(t.assignTexture(l, "aoMap", s.occlusionTexture)),
                void 0 !== s.occlusionTexture.strength && (l.aoMapIntensity = s.occlusionTexture.strength)),
                void 0 !== s.emissiveFactor && a !== i.V9B) {
                    const e = s.emissiveFactor;
                    l.emissive = (new i.Q1f).setRGB(e[0], e[1], e[2], i.Zr2)
                }
                return void 0 !== s.emissiveTexture && a !== i.V9B && c.push(t.assignTexture(l, "emissiveMap", s.emissiveTexture, i.er$)),
                Promise.all(c).then((function() {
                    const n = new a(l);
                    return s.name && (n.name = s.name),
                    Y(n, s),
                    t.associations.set(n, {
                        materials: e
                    }),
                    s.extensions && q(r, n, s),
                    n
                }
                ))
            }
            createUniqueName(e) {
                const t = i.Nwf.sanitizeNodeName(e || "");
                return t in this.nodeNamesUsed ? t + "_" + ++this.nodeNamesUsed[t] : (this.nodeNamesUsed[t] = 0,
                t)
            }
            loadGeometries(e) {
                const t = this
                  , n = this.extensions
                  , r = this.primitiveCache;
                function s(e) {
                    return n[o.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(e, t).then((function(n) {
                        return te(n, e, t)
                    }
                    ))
                }
                const a = [];
                for (let n = 0, l = e.length; n < l; n++) {
                    const l = e[n]
                      , c = K(l)
                      , u = r[c];
                    if (u)
                        a.push(u.promise);
                    else {
                        let e;
                        e = l.extensions && l.extensions[o.KHR_DRACO_MESH_COMPRESSION] ? s(l) : te(new i.LoY, l, t),
                        r[c] = {
                            primitive: l,
                            promise: e
                        },
                        a.push(e)
                    }
                }
                return Promise.all(a)
            }
            loadMesh(e) {
                const t = this
                  , n = this.json
                  , s = this.extensions
                  , a = n.meshes[e]
                  , o = a.primitives
                  , l = [];
                for (let e = 0, t = o.length; e < t; e++) {
                    const t = void 0 === o[e].material ? (void 0 === (c = this.cache).DefaultMaterial && (c.DefaultMaterial = new i._4j({
                        color: 16777215,
                        emissive: 0,
                        metalness: 1,
                        roughness: 1,
                        transparent: !1,
                        depthTest: !0,
                        side: i.hB5
                    })),
                    c.DefaultMaterial) : this.getDependency("material", o[e].material);
                    l.push(t)
                }
                var c;
                return l.push(t.loadGeometries(o)),
                Promise.all(l).then((function(n) {
                    const l = n.slice(0, n.length - 1)
                      , c = n[n.length - 1]
                      , u = [];
                    for (let n = 0, h = c.length; n < h; n++) {
                        const h = c[n]
                          , d = o[n];
                        let p;
                        const f = l[n];
                        if (d.mode === F.TRIANGLES || d.mode === F.TRIANGLE_STRIP || d.mode === F.TRIANGLE_FAN || void 0 === d.mode)
                            p = !0 === a.isSkinnedMesh ? new i.I46(h,f) : new i.eaF(h,f),
                            !0 === p.isSkinnedMesh && p.normalizeSkinWeights(),
                            d.mode === F.TRIANGLE_STRIP ? p.geometry = r(p.geometry, i.O49) : d.mode === F.TRIANGLE_FAN && (p.geometry = r(p.geometry, i.rYR));
                        else if (d.mode === F.LINES)
                            p = new i.DXC(h,f);
                        else if (d.mode === F.LINE_STRIP)
                            p = new i.N1A(h,f);
                        else if (d.mode === F.LINE_LOOP)
                            p = new i.FCc(h,f);
                        else {
                            if (d.mode !== F.POINTS)
                                throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + d.mode);
                            p = new i.ONl(h,f)
                        }
                        Object.keys(p.geometry.morphAttributes).length > 0 && X(p, a),
                        p.name = t.createUniqueName(a.name || "mesh_" + e),
                        Y(p, a),
                        d.extensions && q(s, p, d),
                        t.assignFinalMaterial(p),
                        u.push(p)
                    }
                    for (let n = 0, i = u.length; n < i; n++)
                        t.associations.set(u[n], {
                            meshes: e,
                            primitives: n
                        });
                    if (1 === u.length)
                        return a.extensions && q(s, u[0], a),
                        u[0];
                    const h = new i.YJl;
                    a.extensions && q(s, h, a),
                    t.associations.set(h, {
                        meshes: e
                    });
                    for (let e = 0, t = u.length; e < t; e++)
                        h.add(u[e]);
                    return h
                }
                ))
            }
            loadCamera(e) {
                let t;
                const n = this.json.cameras[e]
                  , r = n[n.type];
                if (r)
                    return "perspective" === n.type ? t = new i.ubm(i.cj9.radToDeg(r.yfov),r.aspectRatio || 1,r.znear || 1,r.zfar || 2e6) : "orthographic" === n.type && (t = new i.qUd(-r.xmag,r.xmag,r.ymag,-r.ymag,r.znear,r.zfar)),
                    n.name && (t.name = this.createUniqueName(n.name)),
                    Y(t, n),
                    Promise.resolve(t);
                console.warn("THREE.GLTFLoader: Missing camera parameters.")
            }
            loadSkin(e) {
                const t = this.json.skins[e]
                  , n = [];
                for (let e = 0, i = t.joints.length; e < i; e++)
                    n.push(this._loadNodeShallow(t.joints[e]));
                return void 0 !== t.inverseBindMatrices ? n.push(this.getDependency("accessor", t.inverseBindMatrices)) : n.push(null),
                Promise.all(n).then((function(e) {
                    const n = e.pop()
                      , r = e
                      , s = []
                      , a = [];
                    for (let e = 0, o = r.length; e < o; e++) {
                        const o = r[e];
                        if (o) {
                            s.push(o);
                            const t = new i.kn4;
                            null !== n && t.fromArray(n.array, 16 * e),
                            a.push(t)
                        } else
                            console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', t.joints[e])
                    }
                    return new i.EAD(s,a)
                }
                ))
            }
            loadAnimation(e) {
                const t = this.json
                  , n = this
                  , r = t.animations[e]
                  , s = r.name ? r.name : "animation_" + e
                  , a = []
                  , o = []
                  , l = []
                  , c = []
                  , u = [];
                for (let e = 0, t = r.channels.length; e < t; e++) {
                    const t = r.channels[e]
                      , n = r.samplers[t.sampler]
                      , i = t.target
                      , s = i.node
                      , h = void 0 !== r.parameters ? r.parameters[n.input] : n.input
                      , d = void 0 !== r.parameters ? r.parameters[n.output] : n.output;
                    void 0 !== i.node && (a.push(this.getDependency("node", s)),
                    o.push(this.getDependency("accessor", h)),
                    l.push(this.getDependency("accessor", d)),
                    c.push(n),
                    u.push(i))
                }
                return Promise.all([Promise.all(a), Promise.all(o), Promise.all(l), Promise.all(c), Promise.all(u)]).then((function(e) {
                    const t = e[0]
                      , r = e[1]
                      , a = e[2]
                      , o = e[3]
                      , l = e[4]
                      , c = [];
                    for (let e = 0, i = t.length; e < i; e++) {
                        const i = t[e]
                          , s = r[e]
                          , u = a[e]
                          , h = o[e]
                          , d = l[e];
                        if (void 0 === i)
                            continue;
                        i.updateMatrix && i.updateMatrix();
                        const p = n._createAnimationTracks(i, s, u, h, d);
                        if (p)
                            for (let e = 0; e < p.length; e++)
                                c.push(p[e])
                    }
                    return new i.tz3(s,void 0,c)
                }
                ))
            }
            createNodeMesh(e) {
                const t = this.json
                  , n = this
                  , i = t.nodes[e];
                return void 0 === i.mesh ? null : n.getDependency("mesh", i.mesh).then((function(e) {
                    const t = n._getNodeRef(n.meshCache, i.mesh, e);
                    return void 0 !== i.weights && t.traverse((function(e) {
                        if (e.isMesh)
                            for (let t = 0, n = i.weights.length; t < n; t++)
                                e.morphTargetInfluences[t] = i.weights[t]
                    }
                    )),
                    t
                }
                ))
            }
            loadNode(e) {
                const t = this
                  , n = this.json.nodes[e]
                  , i = t._loadNodeShallow(e)
                  , r = []
                  , s = n.children || [];
                for (let e = 0, n = s.length; e < n; e++)
                    r.push(t.getDependency("node", s[e]));
                const a = void 0 === n.skin ? Promise.resolve(null) : t.getDependency("skin", n.skin);
                return Promise.all([i, Promise.all(r), a]).then((function(e) {
                    const t = e[0]
                      , n = e[1]
                      , i = e[2];
                    null !== i && t.traverse((function(e) {
                        e.isSkinnedMesh && e.bind(i, $)
                    }
                    ));
                    for (let e = 0, i = n.length; e < i; e++)
                        t.add(n[e]);
                    return t
                }
                ))
            }
            _loadNodeShallow(e) {
                const t = this.json
                  , n = this.extensions
                  , r = this;
                if (void 0 !== this.nodeCache[e])
                    return this.nodeCache[e];
                const s = t.nodes[e]
                  , a = s.name ? r.createUniqueName(s.name) : ""
                  , o = []
                  , l = r._invokeOne((function(t) {
                    return t.createNodeMesh && t.createNodeMesh(e)
                }
                ));
                return l && o.push(l),
                void 0 !== s.camera && o.push(r.getDependency("camera", s.camera).then((function(e) {
                    return r._getNodeRef(r.cameraCache, s.camera, e)
                }
                ))),
                r._invokeAll((function(t) {
                    return t.createNodeAttachment && t.createNodeAttachment(e)
                }
                )).forEach((function(e) {
                    o.push(e)
                }
                )),
                this.nodeCache[e] = Promise.all(o).then((function(t) {
                    let o;
                    if (o = !0 === s.isBone ? new i.$Kf : t.length > 1 ? new i.YJl : 1 === t.length ? t[0] : new i.B69,
                    o !== t[0])
                        for (let e = 0, n = t.length; e < n; e++)
                            o.add(t[e]);
                    if (s.name && (o.userData.name = s.name,
                    o.name = a),
                    Y(o, s),
                    s.extensions && q(n, o, s),
                    void 0 !== s.matrix) {
                        const e = new i.kn4;
                        e.fromArray(s.matrix),
                        o.applyMatrix4(e)
                    } else
                        void 0 !== s.translation && o.position.fromArray(s.translation),
                        void 0 !== s.rotation && o.quaternion.fromArray(s.rotation),
                        void 0 !== s.scale && o.scale.fromArray(s.scale);
                    return r.associations.has(o) || r.associations.set(o, {}),
                    r.associations.get(o).nodes = e,
                    o
                }
                )),
                this.nodeCache[e]
            }
            loadScene(e) {
                const t = this.extensions
                  , n = this.json.scenes[e]
                  , r = this
                  , s = new i.YJl;
                n.name && (s.name = r.createUniqueName(n.name)),
                Y(s, n),
                n.extensions && q(t, s, n);
                const a = n.nodes || []
                  , o = [];
                for (let e = 0, t = a.length; e < t; e++)
                    o.push(r.getDependency("node", a[e]));
                return Promise.all(o).then((function(e) {
                    for (let t = 0, n = e.length; t < n; t++)
                        s.add(e[t]);
                    return r.associations = (e => {
                        const t = new Map;
                        for (const [e,n] of r.associations)
                            (e instanceof i.imn || e instanceof i.gPd) && t.set(e, n);
                        return e.traverse((e => {
                            const n = r.associations.get(e);
                            null != n && t.set(e, n)
                        }
                        )),
                        t
                    }
                    )(s),
                    s
                }
                ))
            }
            _createAnimationTracks(e, t, n, r, s) {
                const a = []
                  , o = e.name ? e.name : e.uuid
                  , l = [];
                let c;
                switch (H[s.path] === H.weights ? e.traverse((function(e) {
                    e.morphTargetInfluences && l.push(e.name ? e.name : e.uuid)
                }
                )) : l.push(o),
                H[s.path]) {
                case H.weights:
                    c = i.Hit;
                    break;
                case H.rotation:
                    c = i.MBL;
                    break;
                case H.position:
                case H.scale:
                    c = i.RiT;
                    break;
                default:
                    if (1 === n.itemSize)
                        c = i.Hit;
                    else
                        c = i.RiT
                }
                const u = void 0 !== r.interpolation ? z[r.interpolation] : i.PJ3
                  , h = this._getArrayFromAccessor(n);
                for (let e = 0, n = l.length; e < n; e++) {
                    const n = new c(l[e] + "." + H[s.path],t.array,h,u);
                    "CUBICSPLINE" === r.interpolation && this._createCubicSplineTrackInterpolant(n),
                    a.push(n)
                }
                return a
            }
            _getArrayFromAccessor(e) {
                let t = e.array;
                if (e.normalized) {
                    const e = Z(t.constructor)
                      , n = new Float32Array(t.length);
                    for (let i = 0, r = t.length; i < r; i++)
                        n[i] = t[i] * e;
                    t = n
                }
                return t
            }
            _createCubicSplineTrackInterpolant(e) {
                e.createInterpolant = function(e) {
                    return new (this instanceof i.MBL ? U : P)(this.times,this.values,this.getValueSize() / 3,e)
                }
                ,
                e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0
            }
        }
        function te(e, t, n) {
            const r = t.attributes
              , s = [];
            function a(t, i) {
                return n.getDependency("accessor", t).then((function(t) {
                    e.setAttribute(i, t)
                }
                ))
            }
            for (const t in r) {
                const n = G[t] || t.toLowerCase();
                n in e.attributes || s.push(a(r[t], n))
            }
            if (void 0 !== t.indices && !e.index) {
                const i = n.getDependency("accessor", t.indices).then((function(t) {
                    e.setIndex(t)
                }
                ));
                s.push(i)
            }
            return i.ppV.workingColorSpace !== i.Zr2 && "COLOR_0"in r && console.warn(`THREE.GLTFLoader: Converting vertex colors from "srgb-linear" to "${i.ppV.workingColorSpace}" not supported.`),
            Y(e, t),
            function(e, t, n) {
                const r = t.attributes
                  , s = new i.NRn;
                if (void 0 === r.POSITION)
                    return;
                {
                    const e = n.json.accessors[r.POSITION]
                      , t = e.min
                      , a = e.max;
                    if (void 0 === t || void 0 === a)
                        return void console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
                    if (s.set(new i.Pq0(t[0],t[1],t[2]), new i.Pq0(a[0],a[1],a[2])),
                    e.normalized) {
                        const t = Z(N[e.componentType]);
                        s.min.multiplyScalar(t),
                        s.max.multiplyScalar(t)
                    }
                }
                const a = t.targets;
                if (void 0 !== a) {
                    const e = new i.Pq0
                      , t = new i.Pq0;
                    for (let i = 0, r = a.length; i < r; i++) {
                        const r = a[i];
                        if (void 0 !== r.POSITION) {
                            const i = n.json.accessors[r.POSITION]
                              , s = i.min
                              , a = i.max;
                            if (void 0 !== s && void 0 !== a) {
                                if (t.setX(Math.max(Math.abs(s[0]), Math.abs(a[0]))),
                                t.setY(Math.max(Math.abs(s[1]), Math.abs(a[1]))),
                                t.setZ(Math.max(Math.abs(s[2]), Math.abs(a[2]))),
                                i.normalized) {
                                    const e = Z(N[i.componentType]);
                                    t.multiplyScalar(e)
                                }
                                e.max(t)
                            } else
                                console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")
                        }
                    }
                    s.expandByVector(e)
                }
                e.boundingBox = s;
                const o = new i.iyt;
                s.getCenter(o.center),
                o.radius = s.min.distanceTo(s.max) / 2,
                e.boundingSphere = o
            }(e, t, n),
            Promise.all(s).then((function() {
                return void 0 !== t.targets ? function(e, t, n) {
                    let i = !1
                      , r = !1
                      , s = !1;
                    for (let e = 0, n = t.length; e < n; e++) {
                        const n = t[e];
                        if (void 0 !== n.POSITION && (i = !0),
                        void 0 !== n.NORMAL && (r = !0),
                        void 0 !== n.COLOR_0 && (s = !0),
                        i && r && s)
                            break
                    }
                    if (!i && !r && !s)
                        return Promise.resolve(e);
                    const a = []
                      , o = []
                      , l = [];
                    for (let c = 0, u = t.length; c < u; c++) {
                        const u = t[c];
                        if (i) {
                            const t = void 0 !== u.POSITION ? n.getDependency("accessor", u.POSITION) : e.attributes.position;
                            a.push(t)
                        }
                        if (r) {
                            const t = void 0 !== u.NORMAL ? n.getDependency("accessor", u.NORMAL) : e.attributes.normal;
                            o.push(t)
                        }
                        if (s) {
                            const t = void 0 !== u.COLOR_0 ? n.getDependency("accessor", u.COLOR_0) : e.attributes.color;
                            l.push(t)
                        }
                    }
                    return Promise.all([Promise.all(a), Promise.all(o), Promise.all(l)]).then((function(t) {
                        const n = t[0]
                          , a = t[1]
                          , o = t[2];
                        return i && (e.morphAttributes.position = n),
                        r && (e.morphAttributes.normal = a),
                        s && (e.morphAttributes.color = o),
                        e.morphTargetsRelative = !0,
                        e
                    }
                    ))
                }(e, t.targets, n) : e
            }
            ))
        }
    }
    ,
    9174: (e, t, n) => {
        "use strict";
        n.d(t, {
            p: () => C
        });
        var i = n(5062);
        class r {
            constructor(e=4) {
                this.pool = e,
                this.queue = [],
                this.workers = [],
                this.workersResolve = [],
                this.workerStatus = 0
            }
            _initWorker(e) {
                if (!this.workers[e]) {
                    const t = this.workerCreator();
                    t.addEventListener("message", this._onMessage.bind(this, e)),
                    this.workers[e] = t
                }
            }
            _getIdleWorker() {
                for (let e = 0; e < this.pool; e++)
                    if (!(this.workerStatus & 1 << e))
                        return e;
                return -1
            }
            _onMessage(e, t) {
                const n = this.workersResolve[e];
                if (n && n(t),
                this.queue.length) {
                    const {resolve: t, msg: n, transfer: i} = this.queue.shift();
                    this.workersResolve[e] = t,
                    this.workers[e].postMessage(n, i)
                } else
                    this.workerStatus ^= 1 << e
            }
            setWorkerCreator(e) {
                this.workerCreator = e
            }
            setWorkerLimit(e) {
                this.pool = e
            }
            postMessage(e, t) {
                return new Promise((n => {
                    const i = this._getIdleWorker();
                    -1 !== i ? (this._initWorker(i),
                    this.workerStatus |= 1 << i,
                    this.workersResolve[i] = n,
                    this.workers[i].postMessage(e, t)) : this.queue.push({
                        resolve: n,
                        msg: e,
                        transfer: t
                    })
                }
                ))
            }
            dispose() {
                this.workers.forEach((e => e.terminate())),
                this.workersResolve.length = 0,
                this.workers.length = 0,
                this.queue.length = 0,
                this.workerStatus = 0
            }
        }
        const s = 2
          , a = 0
          , o = 1
          , l = 10
          , c = 1000066e3;
        class u {
            constructor() {
                this.vkFormat = 0,
                this.typeSize = 1,
                this.pixelWidth = 0,
                this.pixelHeight = 0,
                this.pixelDepth = 0,
                this.layerCount = 0,
                this.faceCount = 1,
                this.supercompressionScheme = 0,
                this.levels = [],
                this.dataFormatDescriptor = [{
                    vendorId: 0,
                    descriptorType: 0,
                    descriptorBlockSize: 0,
                    versionNumber: 2,
                    colorModel: 0,
                    colorPrimaries: 1,
                    transferFunction: 2,
                    flags: 0,
                    texelBlockDimension: [0, 0, 0, 0],
                    bytesPlane: [0, 0, 0, 0, 0, 0, 0, 0],
                    samples: []
                }],
                this.keyValue = {},
                this.globalData = null
            }
        }
        class h {
            constructor(e, t, n, i) {
                this._dataView = void 0,
                this._littleEndian = void 0,
                this._offset = void 0,
                this._dataView = new DataView(e.buffer,e.byteOffset + t,n),
                this._littleEndian = i,
                this._offset = 0
            }
            _nextUint8() {
                const e = this._dataView.getUint8(this._offset);
                return this._offset += 1,
                e
            }
            _nextUint16() {
                const e = this._dataView.getUint16(this._offset, this._littleEndian);
                return this._offset += 2,
                e
            }
            _nextUint32() {
                const e = this._dataView.getUint32(this._offset, this._littleEndian);
                return this._offset += 4,
                e
            }
            _nextUint64() {
                const e = this._dataView.getUint32(this._offset, this._littleEndian) + 2 ** 32 * this._dataView.getUint32(this._offset + 4, this._littleEndian);
                return this._offset += 8,
                e
            }
            _nextInt32() {
                const e = this._dataView.getInt32(this._offset, this._littleEndian);
                return this._offset += 4,
                e
            }
            _nextUint8Array(e) {
                const t = new Uint8Array(this._dataView.buffer,this._dataView.byteOffset + this._offset,e);
                return this._offset += e,
                t
            }
            _skip(e) {
                return this._offset += e,
                this
            }
            _scan(e, t) {
                void 0 === t && (t = 0);
                const n = this._offset;
                let i = 0;
                for (; this._dataView.getUint8(this._offset) !== t && i < e; )
                    i++,
                    this._offset++;
                return i < e && this._offset++,
                new Uint8Array(this._dataView.buffer,this._dataView.byteOffset + n,i)
            }
        }
        new Uint8Array([0]);
        const d = [171, 75, 84, 88, 32, 50, 48, 187, 13, 10, 26, 10];
        function p(e) {
            return (new TextDecoder).decode(e)
        }
        let f, A, g;
        const m = {
            env: {
                emscripten_notify_memory_growth: function(e) {
                    g = new Uint8Array(A.exports.memory.buffer)
                }
            }
        };
        class v {
            init() {
                return f || (f = "undefined" != typeof fetch ? fetch("data:application/wasm;base64," + y).then((e => e.arrayBuffer())).then((e => WebAssembly.instantiate(e, m))).then(this._init) : WebAssembly.instantiate(Buffer.from(y, "base64"), m).then(this._init),
                f)
            }
            _init(e) {
                A = e.instance,
                m.env.emscripten_notify_memory_growth(0)
            }
            decode(e, t=0) {
                if (!A)
                    throw new Error("ZSTDDecoder: Await .init() before decoding.");
                const n = e.byteLength
                  , i = A.exports.malloc(n);
                g.set(e, i),
                t = t || Number(A.exports.ZSTD_findDecompressedSize(i, n));
                const r = A.exports.malloc(t)
                  , s = A.exports.ZSTD_decompress(r, t, i, n)
                  , a = g.slice(r, r + s);
                return A.exports.free(i),
                A.exports.free(r),
                a
            }
        }
        const y = "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IAMNACAEQQNxBEADQCACRQ0FIAAgAkF/aiICaiIDIAEgAmotAAA6AAAgA0EDcQ0ACwsgAkEDTQ0AA0AgACACQXxqIgJqIAEgAmooAgA2AgAgAkEDSw0ACwsgAkUNAgNAIAAgAkF/aiICaiABIAJqLQAAOgAAIAINAAsMAgsgAkEDTQ0AIAIhBANAIAMgASgCADYCACABQQRqIQEgA0EEaiEDIARBfGoiBEEDSw0ACyACQQNxIQILIAJFDQADQCADIAEtAAA6AAAgA0EBaiEDIAFBAWohASACQX9qIgINAAsLIAAL8wICAn8BfgJAIAJFDQAgACACaiIDQX9qIAE6AAAgACABOgAAIAJBA0kNACADQX5qIAE6AAAgACABOgABIANBfWogAToAACAAIAE6AAIgAkEHSQ0AIANBfGogAToAACAAIAE6AAMgAkEJSQ0AIABBACAAa0EDcSIEaiIDIAFB/wFxQYGChAhsIgE2AgAgAyACIARrQXxxIgRqIgJBfGogATYCACAEQQlJDQAgAyABNgIIIAMgATYCBCACQXhqIAE2AgAgAkF0aiABNgIAIARBGUkNACADIAE2AhggAyABNgIUIAMgATYCECADIAE2AgwgAkFwaiABNgIAIAJBbGogATYCACACQWhqIAE2AgAgAkFkaiABNgIAIAQgA0EEcUEYciIEayICQSBJDQAgAa0iBUIghiAFhCEFIAMgBGohAQNAIAEgBTcDGCABIAU3AxAgASAFNwMIIAEgBTcDACABQSBqIQEgAkFgaiICQR9LDQALCyAACy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAIajYCACADCy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAFajYCACADCx8AIAAgASACKAIEEAg2AgAgARAEGiAAIAJBCGo2AgQLCAAgAGdBH3MLugUBDX8jAEEQayIKJAACfyAEQQNNBEAgCkEANgIMIApBDGogAyAEEAsaIAAgASACIApBDGpBBBAVIgBBbCAAEAMbIAAgACAESxsMAQsgAEEAIAEoAgBBAXRBAmoQECENQVQgAygAACIGQQ9xIgBBCksNABogAiAAQQVqNgIAIAMgBGoiAkF8aiEMIAJBeWohDiACQXtqIRAgAEEGaiELQQQh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ASIDNgLE4AEgACgCvOABIQQgACABNgK84AEgACABIAJqNgK44AEgACABIAQgA2tqNgLA4AELpgEBAX8gACAAKALs4QEQFjYCyOABIABCADcD+OABIABCADcDuOABIABBwOABakIANwMAIABBqNAAaiIBQYyAgOAANgIAIABBADYCmOIBIABCADcDiOEBIABCAzcDgOEBIABBrNABakHgEikCADcCACAAQbTQAWpB6BIoAgA2AgAgACABNgIMIAAgAEGYIGo2AgggACAAQaAwajYCBCAAIABBEGo2AgALYQEBf0G4fyEDAkAgAUEDSQ0AIAIgABAhIgFBA3YiADYCCCACIAFBAXE2AgQgAiABQQF2QQNxIgM2AgACQCADQX9qIgFBAksNAAJAIAFBAWsOAgEAAgtBbA8LIAAhAwsgAwsMACAAIAEgAkEAEC4LiAQCA38CfiADEBYhBCAAQQBBKBAQIQAgBCACSwRAIAQPCyABRQRAQX8PCwJAAkAgA0EBRg0AIAEoAAAiBkGo6r5pRg0AQXYhAyAGQXBxQdDUtMIBRw0BQQghAyACQQhJDQEgAEEAQSgQECEAIAEoAAQhASAAQQE2AhQgACABrTcDAEEADwsgASACIAMQLyIDIAJLDQAgACADNgIYQXIhAyABIARqIgVBf2otAAAiAkEIcQ0AIAJBIHEiBkUEQEFwIQMgBS0AACIFQacBSw0BIAVBB3GtQgEgBUEDdkEKaq2GIgdCA4h+IAd8IQggBEEBaiEECyACQQZ2IQMgAkECdiEFAkAgAkEDcUF/aiICQQJLBEBBACECDAELAkACQAJAIAJBAWsOAgECAAsgASAEai0AACECIARBAWohBAwCCyABIARqLwAAIQIgBEECaiEEDAELIAEgBGooAAAhAiAEQQRqIQQLIAVBAXEhBQJ+AkACQAJAIANBf2oiA0ECTQRAIANBAWsOAgIDAQtCfyAGRQ0DGiABIARqMQAADAMLIAEgBGovAACtQoACfAwCCyABIARqKAAArQwBCyABIARqKQAACyEHIAAgBTYCICAAIAI2AhwgACAHNwMAQQAhAyAAQQA2AhQgACAHIAggBhsiBzcDCCAAIAdCgIAIIAdCgIAIVBs+AhALIAMLWwEBf0G4fyEDIAIQFiICIAFNBH8gACACakF/ai0AACIAQQNxQQJ0QaAeaigC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C0Egak8NAQsgByAHKQNoNwMQIAcgBykDYDcDCCAEIA0gB0EIaiAHQdwAaiAPIA4gESAQEB4hCwwBCyACIARqIQggBCAKEAcgAkERTwRAIARBEGohAgNAIAIgCkEQaiIKEAcgAkEQaiICIAhJDQALCyAIIAlrIQIgByATNgJcIAkgCCAOa0sEQCAJIAggEWtLBEBBbCELDAILIBAgAiAOayICaiIKIANqIBBNBEAgCCAKIAMQDxoMAgsgCCAKQQAgAmsQDyEIIAcgAiADaiIDNgJkIAggAmshCCAOIQILIAlBEE8EQCADIAhqIQMDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALDAELAkAgCUEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgCUECdCIDQcAeaigCAGoiAhAXIAIgA0HgHmooAgBrIQIgBygCZCEDDAELIAggAhAMCyADQQlJDQAgAyAIaiEDIAhBCGoiCCACQQhqIgJrQQ9MBEADQCAIIAIQDCACQQhqIQIgCEEIaiIIIANJDQAMAgALAAsDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALCyAHQRhqEAQaIAsgDCALEAMiAhshDCAEIAQgC2ogAhshBCAFQX9qIgUNAAsgDBADDQFBbCEMIAdBGGoQBEECSQ0BQQAhCANAIAhBA0cEQCAAIAhBAnQiAmpBrNABaiACIAdqKAJENgIAIAhBAWohCAwBCwsgBygCXCEIC0G6fyEMIA8gCGsiACANIARrSw0AIAQEfyAEIAggABALIABqBUEACyABayEMCyAHQfAAaiQAIAwLkRcCFn8FfiMAQdABayIHJAAgByAAKALw4QEiCDYCvAEgASACaiESIAggACgCgOIBaiETAkACQCAFRQRAIAEhAwwBCyAAKALE4AEhESAAKALA4AEhFSAAKAK84AEhDyAAQQE2AozhAUEAIQgDQCAIQQNHBEAgByAIQQJ0IgJqIAAgAmpBrNABaigCADYCVCAIQQFqIQgMAQsLIAcgETYCZCAHIA82AmAgByABIA9rNgJoQWwhECAHQShqIAMgBBAGEAMNASAFQQQgBUEESBshFyAHQTxqIAdBKGogACgCABATIAdBxABqIAdBKGogACgCCBATIAdBzABqIAdB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IAdB0AFqJAAgEAslACAAQgA3AgAgAEEAOwEIIABBADoACyAAIAE2AgwgACACOgAKC7QFAQN/IwBBMGsiBCQAIABB/wFqIgVBfWohBgJAIAMvAQIEQCAEQRhqIAEgAhAGIgIQAw0BIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahASOgAAIAMgBEEIaiAEQRhqEBI6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0FIAEgBEEQaiAEQRhqEBI6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBSABIARBCGogBEEYahASOgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEjoAACABIAJqIABrIQIMAwsgAyAEQRBqIARBGGoQEjoAAiADIARBCGogBEEYahASOgADIANBBGohAwwAAAsACyAEQRhqIAEgAhAGIgIQAw0AIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahAROgAAIAMgBEEIaiAEQRhqEBE6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0EIAEgBEEQaiAEQRhqEBE6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBCABIARBCGogBEEYahAROgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEToAACABIAJqIABrIQIMAgsgAyAEQRBqIARBGGoQEToAAiADIARBCGogBEEYahAROgADIANBBGohAwwAAAsACyAEQTBqJAAgAgtpAQF/An8CQAJAIAJBB00NACABKAAAQbfIwuF+Rw0AIAAgASgABDYCmOIBQWIgAEEQaiABIAIQPiIDEAMNAhogAEKBgICAEDcDiOEBIAAgASADaiACIANrECoMAQsgACABIAIQKgtBAAsLrQMBBn8jAEGAAWsiAyQAQWIhCAJAIAJBCUkNACAAQZjQAGogAUEIaiIEIAJBeGogAEGY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wOABCwutAgIEfwF+IwBBQGoiBCQAAkACQCACQQhJDQAgASgAAEFwcUHQ1LTCAUcNACABIAIQIiEBIABCADcDCCAAQQA2AgQgACABNgIADAELIARBGGogASACEC0iAxADBEAgACADEBoMAQsgAwRAIABBuH8QGgwBCyACIAQoAjAiA2shAiABIANqIQMDQAJAIAAgAyACIARBCGoQLCIFEAMEfyAFBSACIAVBA2oiBU8NAUG4fwsQGgwCCyAGQQFqIQYgAiAFayECIAMgBWohAyAEKAIMRQ0ACyAEKAI4BEAgAkEDTQRAIABBuH8QGgwCCyADQQRqIQMLIAQoAighAiAEKQMYIQcgAEEANgIEIAAgAyABazYCACAAIAIgBmytIAcgB0J/URs3AwgLIARBQGskAAslAQF/IwBBEGsiAiQAIAIgACABEFEgAigCACEAIAJBEGokACAAC30BBH8jAEGQBGsiBCQAIARB/wE2AggCQCAEQRBqIARBCGogBEEMaiABIAIQFSIGEAMEQCAGIQUMAQtBVCEFIAQoAgwiB0EGSw0AIAMgBEEQaiAEKAIIIAcQQSIFEAMNACAAIAEgBmogAiAGayADEDwhBQsgBEGQBGokACAFC4cBAgJ/An5BABAWIQMCQANAIAEgA08EQAJAIAAoAABBcHFB0NS0wgFGBEAgACABECIiAhADRQ0BQn4PCyAAIAEQVSIEQn1WDQMgBCAFfCIFIARUIQJCfiEEIAINAyAAIAEQUiICEAMNAwsgASACayEBIAAgAmohAAwBCwtCfiAFIAEbIQQLIAQLPwIBfwF+IwBBMGsiAiQAAn5CfiACQQhqIAAgARAtDQAaQgAgAigCHEEBRg0AGiACKQMICyEDIAJBMGokACADC40BAQJ/IwBBMGsiASQAAkAgAEUNACAAKAKI4gENACABIABB/OEBaigCADYCKCABIAApAvThATcDICAAEDAgACgCqOIBIQIgASABKAIoNgIYIAEgASkDIDcDECACIAFBEGoQGyAAQQA2AqjiASABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALKgECfyMAQRBrIgAkACAAQQA2AgggAEIANwMAIAAQWCEBIABBEGokACABC4cBAQN/IwBBEGsiAiQAAkAgACgCAEUgACgCBEVzDQAgAiAAKAIINgIIIAIgACkCADcDAAJ/IAIoAgAiAQRAIAIoAghBqOMJIAERBQAMAQtBqOMJECgLIgFFDQAgASAAKQIANwL04QEgAUH84QFqIAAoAgg2AgAgARBZIAEhAwsgAkEQaiQAIAMLywEBAn8jAEEgayIBJAAgAEGBgIDAADYCtOIBIABBADYCiOIBIABBADYC7OEBIABCADcDkOIBIABBADYCpOMJIABBADYC3OIBIABCADcCzOIBIABBADYCvOIBIABBADYCxOABIABCADcCnOIBIABBpOIBakIANwIAIABBrOIBakEANgIAIAFCADcCECABQgA3AhggASABKQMYNwMIIAEgASkDEDcDACABKAIIQQh2QQFxIQIgAEEANgLg4gEgACACNgKM4gEgAUEgaiQAC3YBA38jAEEwayIBJAAgAARAIAEgAEHE0AFqIgIoAgA2AiggASAAKQK80AE3AyAgACgCACEDIAEgAigCADYCGCABIAApArzQATcDECADIAFBEGoQGyABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALzAEBAX8gACABKAK00AE2ApjiASAAIAEoAgQiAjYCwOABIAAgAjYCvOABIAAgAiABKAIIaiICNgK44AEgACACNgLE4AEgASgCuNABBEAgAEKBgICAEDcDiOEBIAAgAUGk0ABqNgIMIAAgAUGUIGo2AgggACABQZwwajYCBCAAIAFBDGo2AgAgAEGs0AFqIAFBqNABaigCADYCACAAQbDQAWogAUGs0AFqKAIANgIAIABBtNABaiABQbDQAWooAgA2AgAPCyAAQgA3A4jhAQs7ACACRQRAQbp/DwsgBEUEQEFsDwsgAiAEEGAEQCAAIAEgAiADIAQgBRBhDwsgACABIAIgAyAEIAUQZQtGAQF/IwBBEGsiBSQAIAVBCGogBBAOAn8gBS0ACQRAIAAgASACIAMgBBAyDAELIAAgASACIAMgBBA0CyEAIAVBEGokACAACzQAIAAgAyAEIAUQNiIFEAMEQCAFDwsgBSAESQR/IAEgAiADIAVqIAQgBWsgABA1BUG4fwsLRgEBfyMAQRBrIgUkACAFQQhqIAQQDgJ/IAUtAAkEQCAAIAEgAiADIAQQYgwBCyAAIAEgAiADIAQQNQshACAFQRBqJAAgAAtZAQF/QQ8hAiABIABJBEAgAUEE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"
          , x = "display-p3"
          , _ = "display-p3-linear"
          , b = (i.KLL,
        i.VxR,
        i.VxR,
        new WeakMap);
        let E, w = 0;
        class C extends i.aHM {
            constructor(e) {
                super(e),
                this.transcoderPath = "",
                this.transcoderBinary = null,
                this.transcoderPending = null,
                this.workerPool = new r,
                this.workerSourceURL = "",
                this.workerConfig = null,
                "undefined" != typeof MSC_TRANSCODER && console.warn('THREE.KTX2Loader: Please update to latest "basis_transcoder". "msc_basis_transcoder" is no longer supported in three.js r125+.')
            }
            setTranscoderPath(e) {
                return this.transcoderPath = e,
                this
            }
            setWorkerLimit(e) {
                return this.workerPool.setWorkerLimit(e),
                this
            }
            async detectSupportAsync(e) {
                return this.workerConfig = {
                    astcSupported: await e.hasFeatureAsync("texture-compression-astc"),
                    astcHDRSupported: !1,
                    etc1Supported: await e.hasFeatureAsync("texture-compression-etc1"),
                    etc2Supported: await e.hasFeatureAsync("texture-compression-etc2"),
                    dxtSupported: await e.hasFeatureAsync("texture-compression-bc"),
                    bptcSupported: await e.hasFeatureAsync("texture-compression-bptc"),
                    pvrtcSupported: await e.hasFeatureAsync("texture-compression-pvrtc")
                },
                this
            }
            detectSupport(e) {
                return !0 === e.isWebGPURenderer ? this.workerConfig = {
                    astcSupported: e.hasFeature("texture-compression-astc"),
                    astcHDRSupported: !1,
                    etc1Supported: e.hasFeature("texture-compression-etc1"),
                    etc2Supported: e.hasFeature("texture-compression-etc2"),
                    dxtSupported: e.hasFeature("texture-compression-bc"),
                    bptcSupported: e.hasFeature("texture-compression-bptc"),
                    pvrtcSupported: e.hasFeature("texture-compression-pvrtc")
                } : this.workerConfig = {
                    astcSupported: e.extensions.has("WEBGL_compressed_texture_astc"),
                    astcHDRSupported: e.extensions.has("WEBGL_compressed_texture_astc") && e.extensions.get("WEBGL_compressed_texture_astc").getSupportedProfiles().includes("hdr"),
                    etc1Supported: e.extensions.has("WEBGL_compressed_texture_etc1"),
                    etc2Supported: e.extensions.has("WEBGL_compressed_texture_etc"),
                    dxtSupported: e.extensions.has("WEBGL_compressed_texture_s3tc"),
                    bptcSupported: e.extensions.has("EXT_texture_compression_bptc"),
                    pvrtcSupported: e.extensions.has("WEBGL_compressed_texture_pvrtc") || e.extensions.has("WEBKIT_WEBGL_compressed_texture_pvrtc")
                },
                this
            }
            init() {
                if (!this.transcoderPending) {
                    const e = new i.Y9S(this.manager);
                    e.setPath(this.transcoderPath),
                    e.setWithCredentials(this.withCredentials);
                    const t = e.loadAsync("basis_transcoder.js")
                      , n = new i.Y9S(this.manager);
                    n.setPath(this.transcoderPath),
                    n.setResponseType("arraybuffer"),
                    n.setWithCredentials(this.withCredentials);
                    const r = n.loadAsync("basis_transcoder.wasm");
                    this.transcoderPending = Promise.all([t, r]).then(( ([e,t]) => {
                        const n = C.BasisWorker.toString()
                          , i = ["/* constants */", "let _EngineFormat = " + JSON.stringify(C.EngineFormat), "let _EngineType = " + JSON.stringify(C.EngineType), "let _TranscoderFormat = " + JSON.stringify(C.TranscoderFormat), "let _BasisFormat = " + JSON.stringify(C.BasisFormat), "/* basis_transcoder.js */", e, "/* worker */", n.substring(n.indexOf("{") + 1, n.lastIndexOf("}"))].join("\n");
                        this.workerSourceURL = URL.createObjectURL(new Blob([i])),
                        this.transcoderBinary = t,
                        this.workerPool.setWorkerCreator(( () => {
                            const e = new Worker(this.workerSourceURL)
                              , t = this.transcoderBinary.slice(0);
                            return e.postMessage({
                                type: "init",
                                config: this.workerConfig,
                                transcoderBinary: t
                            }, [t]),
                            e
                        }
                        ))
                    }
                    )),
                    w > 0 && console.warn("THREE.KTX2Loader: Multiple active KTX2 loaders may cause performance issues. Use a single KTX2Loader instance, or call .dispose() on old instances."),
                    w++
                }
                return this.transcoderPending
            }
            load(e, t, n, r) {
                if (null === this.workerConfig)
                    throw new Error("THREE.KTX2Loader: Missing initialization with `.detectSupport( renderer )`.");
                const s = new i.Y9S(this.manager);
                s.setResponseType("arraybuffer"),
                s.setWithCredentials(this.withCredentials),
                s.load(e, (e => {
                    this.parse(e, t, r)
                }
                ), n, r)
            }
            parse(e, t, n) {
                if (null === this.workerConfig)
                    throw new Error("THREE.KTX2Loader: Missing initialization with `.detectSupport( renderer )`.");
                if (b.has(e)) {
                    return b.get(e).promise.then(t).catch(n)
                }
                this._createTexture(e).then((e => t ? t(e) : null)).catch(n)
            }
            _createTextureFrom(e, t) {
                const {type: n, error: r, data: {faces: s, width: a, height: o, format: l, type: c, dfdFlags: u}} = e;
                if ("error" === n)
                    return Promise.reject(r);
                let h;
                if (6 === t.faceCount)
                    h = new i.c5h(s,l,c);
                else {
                    const e = s[0].mipmaps;
                    h = t.layerCount > 1 ? new i.iOZ(e,a,o,t.layerCount,l,c) : new i.FvD(e,a,o,l,c)
                }
                return h.minFilter = 1 === s[0].mipmaps.length ? i.k6q : i.$_I,
                h.magFilter = i.k6q,
                h.generateMipmaps = !1,
                h.needsUpdate = !0,
                h.colorSpace = T(t),
                h.premultiplyAlpha = !!(1 & u),
                h
            }
            async _createTexture(e, t={}) {
                const n = function(e) {
                    const t = new Uint8Array(e.buffer,e.byteOffset,d.length);
                    if (t[0] !== d[0] || t[1] !== d[1] || t[2] !== d[2] || t[3] !== d[3] || t[4] !== d[4] || t[5] !== d[5] || t[6] !== d[6] || t[7] !== d[7] || t[8] !== d[8] || t[9] !== d[9] || t[10] !== d[10] || t[11] !== d[11])
                        throw new Error("Missing KTX 2.0 identifier.");
                    const n = new u
                      , i = 17 * Uint32Array.BYTES_PER_ELEMENT
                      , r = new h(e,d.length,i,!0);
                    n.vkFormat = r._nextUint32(),
                    n.typeSize = r._nextUint32(),
                    n.pixelWidth = r._nextUint32(),
                    n.pixelHeight = r._nextUint32(),
                    n.pixelDepth = r._nextUint32(),
                    n.layerCount = r._nextUint32(),
                    n.faceCount = r._nextUint32();
                    const s = r._nextUint32();
                    n.supercompressionScheme = r._nextUint32();
                    const a = r._nextUint32()
                      , o = r._nextUint32()
                      , l = r._nextUint32()
                      , c = r._nextUint32()
                      , f = r._nextUint64()
                      , A = r._nextUint64()
                      , g = new h(e,d.length + i,3 * s * 8,!0);
                    for (let t = 0; t < s; t++)
                        n.levels.push({
                            levelData: new Uint8Array(e.buffer,e.byteOffset + g._nextUint64(),g._nextUint64()),
                            uncompressedByteLength: g._nextUint64()
                        });
                    const m = new h(e,a,o,!0)
                      , v = {
                        vendorId: m._skip(4)._nextUint16(),
                        descriptorType: m._nextUint16(),
                        versionNumber: m._nextUint16(),
                        descriptorBlockSize: m._nextUint16(),
                        colorModel: m._nextUint8(),
                        colorPrimaries: m._nextUint8(),
                        transferFunction: m._nextUint8(),
                        flags: m._nextUint8(),
                        texelBlockDimension: [m._nextUint8(), m._nextUint8(), m._nextUint8(), m._nextUint8()],
                        bytesPlane: [m._nextUint8(), m._nextUint8(), m._nextUint8(), m._nextUint8(), m._nextUint8(), m._nextUint8(), m._nextUint8(), m._nextUint8()],
                        samples: []
                    }
                      , y = (v.descriptorBlockSize / 4 - 6) / 4;
                    for (let e = 0; e < y; e++) {
                        const t = {
                            bitOffset: m._nextUint16(),
                            bitLength: m._nextUint8(),
                            channelType: m._nextUint8(),
                            samplePosition: [m._nextUint8(), m._nextUint8(), m._nextUint8(), m._nextUint8()],
                            sampleLower: -1 / 0,
                            sampleUpper: 1 / 0
                        };
                        64 & t.channelType ? (t.sampleLower = m._nextInt32(),
                        t.sampleUpper = m._nextInt32()) : (t.sampleLower = m._nextUint32(),
                        t.sampleUpper = m._nextUint32()),
                        v.samples[e] = t
                    }
                    n.dataFormatDescriptor.length = 0,
                    n.dataFormatDescriptor.push(v);
                    const x = new h(e,l,c,!0);
                    for (; x._offset < c; ) {
                        const e = x._nextUint32()
                          , t = x._scan(e)
                          , i = p(t);
                        if (n.keyValue[i] = x._nextUint8Array(e - t.byteLength - 1),
                        i.match(/^ktx/i)) {
                            const e = p(n.keyValue[i]);
                            n.keyValue[i] = e.substring(0, e.lastIndexOf("\0"))
                        }
                        x._skip(e % 4 ? 4 - e % 4 : 0)
                    }
                    if (A <= 0)
                        return n;
                    const _ = new h(e,f,A,!0)
                      , b = _._nextUint16()
                      , E = _._nextUint16()
                      , w = _._nextUint32()
                      , C = _._nextUint32()
                      , I = _._nextUint32()
                      , S = _._nextUint32()
                      , M = [];
                    for (let e = 0; e < s; e++)
                        M.push({
                            imageFlags: _._nextUint32(),
                            rgbSliceByteOffset: _._nextUint32(),
                            rgbSliceByteLength: _._nextUint32(),
                            alphaSliceByteOffset: _._nextUint32(),
                            alphaSliceByteLength: _._nextUint32()
                        });
                    const T = f + _._offset
                      , B = T + w
                      , R = B + C
                      , D = R + I
                      , P = new Uint8Array(e.buffer,e.byteOffset + T,w)
                      , L = new Uint8Array(e.buffer,e.byteOffset + B,C)
                      , U = new Uint8Array(e.buffer,e.byteOffset + R,I)
                      , F = new Uint8Array(e.buffer,e.byteOffset + D,S);
                    return n.globalData = {
                        endpointCount: b,
                        selectorCount: E,
                        imageDescs: M,
                        endpointsData: P,
                        selectorsData: L,
                        tablesData: U,
                        extendedData: F
                    },
                    n
                }(new Uint8Array(e))
                  , r = n.vkFormat === c && 167 === n.dataFormatDescriptor[0].colorModel;
                if (!(0 === n.vkFormat || r && !this.workerConfig.astcHDRSupported))
                    return async function(e) {
                        const {vkFormat: t} = e;
                        if (void 0 === S[t])
                            throw new Error("THREE.KTX2Loader: Unsupported vkFormat.");
                        let n;
                        2 === e.supercompressionScheme && (E || (E = new Promise((async e => {
                            const t = new v;
                            await t.init(),
                            e(t)
                        }
                        ))),
                        n = await E);
                        const r = [];
                        for (let s = 0; s < e.levels.length; s++) {
                            const a = Math.max(1, e.pixelWidth >> s)
                              , o = Math.max(1, e.pixelHeight >> s)
                              , l = e.pixelDepth ? Math.max(1, e.pixelDepth >> s) : 0
                              , c = e.levels[s];
                            let u, h;
                            if (0 === e.supercompressionScheme)
                                u = c.levelData;
                            else {
                                if (2 !== e.supercompressionScheme)
                                    throw new Error("THREE.KTX2Loader: Unsupported supercompressionScheme.");
                                u = n.decode(c.levelData, c.uncompressedByteLength)
                            }
                            h = M[t] === i.RQf ? new Float32Array(u.buffer,u.byteOffset,u.byteLength / Float32Array.BYTES_PER_ELEMENT) : M[t] === i.ix0 ? new Uint16Array(u.buffer,u.byteOffset,u.byteLength / Uint16Array.BYTES_PER_ELEMENT) : u,
                            r.push({
                                data: h,
                                width: a,
                                height: o,
                                depth: l
                            })
                        }
                        let s;
                        if (I.has(S[t]))
                            s = 0 === e.pixelDepth ? new i.GYF(r[0].data,e.pixelWidth,e.pixelHeight) : new i.dYF(r[0].data,e.pixelWidth,e.pixelHeight,e.pixelDepth);
                        else {
                            if (e.pixelDepth > 0)
                                throw new Error("THREE.KTX2Loader: Unsupported pixelDepth.");
                            s = new i.FvD(r,e.pixelWidth,e.pixelHeight)
                        }
                        return s.mipmaps = r,
                        s.type = M[t],
                        s.format = S[t],
                        s.colorSpace = T(e),
                        s.needsUpdate = !0,
                        Promise.resolve(s)
                    }(n);
                const s = t
                  , a = this.init().then(( () => this.workerPool.postMessage({
                    type: "transcode",
                    buffer: e,
                    taskConfig: s
                }, [e]))).then((e => this._createTextureFrom(e.data, n)));
                return b.set(e, {
                    promise: a
                }),
                a
            }
            dispose() {
                return this.workerPool.dispose(),
                this.workerSourceURL && URL.revokeObjectURL(this.workerSourceURL),
                w--,
                this
            }
        }
        C.BasisFormat = {
            ETC1S: 0,
            UASTC: 1,
            UASTC_HDR: 2
        },
        C.TranscoderFormat = {
            ETC1: 0,
            ETC2: 1,
            BC1: 2,
            BC3: 3,
            BC4: 4,
            BC5: 5,
            BC7_M6_OPAQUE_ONLY: 6,
            BC7_M5: 7,
            PVRTC1_4_RGB: 8,
            PVRTC1_4_RGBA: 9,
            ASTC_4x4: 10,
            ATC_RGB: 11,
            ATC_RGBA_INTERPOLATED_ALPHA: 12,
            RGBA32: 13,
            RGB565: 14,
            BGR565: 15,
            RGBA4444: 16,
            BC6H: 22,
            RGB_HALF: 24,
            RGBA_HALF: 25
        },
        C.EngineFormat = {
            RGBAFormat: i.GWd,
            RGBA_ASTC_4x4_Format: i.qa3,
            RGB_BPTC_UNSIGNED_Format: i.W9U,
            RGBA_BPTC_Format: i.Fn,
            RGBA_ETC2_EAC_Format: i.KDk,
            RGBA_PVRTC_4BPPV1_Format: i.HXV,
            RGBA_S3TC_DXT5_Format: i.BXX,
            RGB_ETC1_Format: i.CVz,
            RGB_ETC2_Format: i.Riy,
            RGB_PVRTC_4BPPV1_Format: i.k6Q,
            RGBA_S3TC_DXT1_Format: i.Nz6
        },
        C.EngineType = {
            UnsignedByteType: i.OUM,
            HalfFloatType: i.ix0,
            FloatType: i.RQf
        },
        C.BasisWorker = function() {
            let e, t, n;
            const i = _EngineFormat
              , r = _EngineType
              , s = _TranscoderFormat
              , a = _BasisFormat;
            self.addEventListener("message", (function(i) {
                const s = i.data;
                switch (s.type) {
                case "init":
                    e = s.config,
                    o = s.transcoderBinary,
                    t = new Promise((e => {
                        n = {
                            wasmBinary: o,
                            onRuntimeInitialized: e
                        },
                        BASIS(n)
                    }
                    )).then(( () => {
                        n.initializeBasis(),
                        void 0 === n.KTX2File && console.warn("THREE.KTX2Loader: Please update Basis Universal transcoder.")
                    }
                    ));
                    break;
                case "transcode":
                    t.then(( () => {
                        try {
                            const {faces: t, buffers: i, width: o, height: h, hasAlpha: d, format: p, type: f, dfdFlags: A} = function(t) {
                                const i = new n.KTX2File(new Uint8Array(t));
                                function s() {
                                    i.close(),
                                    i.delete()
                                }
                                if (!i.isValid())
                                    throw s(),
                                    new Error("THREE.KTX2Loader:\tInvalid or unsupported .ktx2 file");
                                let o;
                                if (i.isUASTC())
                                    o = a.UASTC;
                                else if (i.isETC1S())
                                    o = a.ETC1S;
                                else {
                                    if (!i.isHDR())
                                        throw new Error("THREE.KTX2Loader: Unknown Basis encoding");
                                    o = a.UASTC_HDR
                                }
                                const h = i.getWidth()
                                  , d = i.getHeight()
                                  , p = i.getLayers() || 1
                                  , f = i.getLevels()
                                  , A = i.getFaces()
                                  , g = i.getHasAlpha()
                                  , m = i.getDFDFlags()
                                  , {transcoderFormat: v, engineFormat: y, engineType: x} = function(t, n, i, r) {
                                    const s = l[t];
                                    for (let a = 0; a < s.length; a++) {
                                        const o = s[a];
                                        if (o.if && !e[o.if])
                                            continue;
                                        if (!o.basisFormat.includes(t))
                                            continue;
                                        if (r && o.transcoderFormat.length < 2)
                                            continue;
                                        if (o.needsPowerOfTwo && (!c(n) || !c(i)))
                                            continue;
                                        return {
                                            transcoderFormat: o.transcoderFormat[r ? 1 : 0],
                                            engineFormat: o.engineFormat[r ? 1 : 0],
                                            engineType: o.engineType[0]
                                        }
                                    }
                                    throw new Error("THREE.KTX2Loader: Failed to identify transcoding target.")
                                }(o, h, d, g);
                                if (!h || !d || !f)
                                    throw s(),
                                    new Error("THREE.KTX2Loader:\tInvalid texture");
                                if (!i.startTranscoding())
                                    throw s(),
                                    new Error("THREE.KTX2Loader: .startTranscoding failed");
                                const _ = []
                                  , b = [];
                                for (let e = 0; e < A; e++) {
                                    const t = [];
                                    for (let n = 0; n < f; n++) {
                                        const a = [];
                                        let o, l;
                                        for (let t = 0; t < p; t++) {
                                            const c = i.getImageLevelInfo(n, t, e);
                                            0 !== e || 0 !== n || 0 !== t || c.origWidth % 4 == 0 && c.origHeight % 4 == 0 || console.warn("THREE.KTX2Loader: ETC1S and UASTC textures should use multiple-of-four dimensions."),
                                            f > 1 ? (o = c.origWidth,
                                            l = c.origHeight) : (o = c.width,
                                            l = c.height);
                                            let u = new Uint8Array(i.getImageTranscodedSizeInBytes(n, t, 0, v));
                                            const h = i.transcodeImage(u, n, t, e, v, 0, -1, -1);
                                            if (x === r.HalfFloatType && (u = new Uint16Array(u.buffer,u.byteOffset,u.byteLength / Uint16Array.BYTES_PER_ELEMENT)),
                                            !h)
                                                throw s(),
                                                new Error("THREE.KTX2Loader: .transcodeImage failed.");
                                            a.push(u)
                                        }
                                        const c = u(a);
                                        t.push({
                                            data: c,
                                            width: o,
                                            height: l
                                        }),
                                        b.push(c.buffer)
                                    }
                                    _.push({
                                        mipmaps: t,
                                        width: h,
                                        height: d,
                                        format: y,
                                        type: x
                                    })
                                }
                                return s(),
                                {
                                    faces: _,
                                    buffers: b,
                                    width: h,
                                    height: d,
                                    hasAlpha: g,
                                    dfdFlags: m,
                                    format: y,
                                    type: x
                                }
                            }(s.buffer);
                            self.postMessage({
                                type: "transcode",
                                id: s.id,
                                data: {
                                    faces: t,
                                    width: o,
                                    height: h,
                                    hasAlpha: d,
                                    format: p,
                                    type: f,
                                    dfdFlags: A
                                }
                            }, i)
                        } catch (e) {
                            console.error(e),
                            self.postMessage({
                                type: "error",
                                id: s.id,
                                error: e.message
                            })
                        }
                    }
                    ))
                }
                var o
            }
            ));
            const o = [{
                if: "astcSupported",
                basisFormat: [a.UASTC],
                transcoderFormat: [s.ASTC_4x4, s.ASTC_4x4],
                engineFormat: [i.RGBA_ASTC_4x4_Format, i.RGBA_ASTC_4x4_Format],
                engineType: [r.UnsignedByteType],
                priorityETC1S: 1 / 0,
                priorityUASTC: 1,
                needsPowerOfTwo: !1
            }, {
                if: "bptcSupported",
                basisFormat: [a.ETC1S, a.UASTC],
                transcoderFormat: [s.BC7_M5, s.BC7_M5],
                engineFormat: [i.RGBA_BPTC_Format, i.RGBA_BPTC_Format],
                engineType: [r.UnsignedByteType],
                priorityETC1S: 3,
                priorityUASTC: 2,
                needsPowerOfTwo: !1
            }, {
                if: "dxtSupported",
                basisFormat: [a.ETC1S, a.UASTC],
                transcoderFormat: [s.BC1, s.BC3],
                engineFormat: [i.RGBA_S3TC_DXT1_Format, i.RGBA_S3TC_DXT5_Format],
                engineType: [r.UnsignedByteType],
                priorityETC1S: 4,
                priorityUASTC: 5,
                needsPowerOfTwo: !1
            }, {
                if: "etc2Supported",
                basisFormat: [a.ETC1S, a.UASTC],
                transcoderFormat: [s.ETC1, s.ETC2],
                engineFormat: [i.RGB_ETC2_Format, i.RGBA_ETC2_EAC_Format],
                engineType: [r.UnsignedByteType],
                priorityETC1S: 1,
                priorityUASTC: 3,
                needsPowerOfTwo: !1
            }, {
                if: "etc1Supported",
                basisFormat: [a.ETC1S, a.UASTC],
                transcoderFormat: [s.ETC1],
                engineFormat: [i.RGB_ETC1_Format],
                engineType: [r.UnsignedByteType],
                priorityETC1S: 2,
                priorityUASTC: 4,
                needsPowerOfTwo: !1
            }, {
                if: "pvrtcSupported",
                basisFormat: [a.ETC1S, a.UASTC],
                transcoderFormat: [s.PVRTC1_4_RGB, s.PVRTC1_4_RGBA],
                engineFormat: [i.RGB_PVRTC_4BPPV1_Format, i.RGBA_PVRTC_4BPPV1_Format],
                engineType: [r.UnsignedByteType],
                priorityETC1S: 5,
                priorityUASTC: 6,
                needsPowerOfTwo: !0
            }, {
                if: "bptcSupported",
                basisFormat: [a.UASTC_HDR],
                transcoderFormat: [s.BC6H],
                engineFormat: [i.RGB_BPTC_UNSIGNED_Format],
                engineType: [r.HalfFloatType],
                priorityHDR: 1,
                needsPowerOfTwo: !1
            }, {
                basisFormat: [a.ETC1S, a.UASTC],
                transcoderFormat: [s.RGBA32, s.RGBA32],
                engineFormat: [i.RGBAFormat, i.RGBAFormat],
                engineType: [r.UnsignedByteType, r.UnsignedByteType],
                priorityETC1S: 100,
                priorityUASTC: 100,
                needsPowerOfTwo: !1
            }, {
                basisFormat: [a.UASTC_HDR],
                transcoderFormat: [s.RGBA_HALF],
                engineFormat: [i.RGBAFormat],
                engineType: [r.HalfFloatType],
                priorityHDR: 100,
                needsPowerOfTwo: !1
            }]
              , l = {
                [a.ETC1S]: o.filter((e => e.basisFormat.includes(a.ETC1S))).sort(( (e, t) => e.priorityUASTC - t.priorityUASTC)),
                [a.UASTC]: o.filter((e => e.basisFormat.includes(a.UASTC))).sort(( (e, t) => e.priorityUASTC - t.priorityUASTC)),
                [a.UASTC_HDR]: o.filter((e => e.basisFormat.includes(a.UASTC_HDR))).sort(( (e, t) => e.priorityHDR - t.priorityHDR))
            };
            function c(e) {
                return e <= 2 || !(e & e - 1) && 0 !== e
            }
            function u(e) {
                if (1 === e.length)
                    return e[0];
                let t = 0;
                for (let n = 0; n < e.length; n++) {
                    t += e[n].byteLength
                }
                const n = new Uint8Array(t);
                let i = 0;
                for (let t = 0; t < e.length; t++) {
                    const r = e[t];
                    n.set(r, i),
                    i += r.byteLength
                }
                return n
            }
        }
        ;
        const I = new Set([i.GWd, i.paN, i.VT0])
          , S = {
            109: i.GWd,
            97: i.GWd,
            37: i.GWd,
            43: i.GWd,
            103: i.paN,
            83: i.paN,
            16: i.paN,
            22: i.paN,
            100: i.VT0,
            76: i.VT0,
            15: i.VT0,
            9: i.VT0,
            [c]: i.qa3,
            166: i.Qrf,
            165: i.Qrf
        }
          , M = {
            109: i.RQf,
            97: i.ix0,
            37: i.OUM,
            43: i.OUM,
            103: i.RQf,
            83: i.ix0,
            16: i.OUM,
            22: i.OUM,
            100: i.RQf,
            76: i.ix0,
            15: i.OUM,
            9: i.OUM,
            [c]: i.ix0,
            166: i.OUM,
            165: i.OUM
        };
        function T(e) {
            const t = e.dataFormatDescriptor[0];
            return t.colorPrimaries === o ? t.transferFunction === s ? i.er$ : i.Zr2 : t.colorPrimaries === l ? t.transferFunction === s ? x : _ : (t.colorPrimaries === a || console.warn(`THREE.KTX2Loader: Unsupported color primaries, "${t.colorPrimaries}"`),
            i.jf0)
        }
    }
    ,
    5837: (e, t, n) => {
        "use strict";
        n.d(t, {
            L: () => g
        });
        var i = n(5062);
        const r = /^[og]\s*(.+)?/
          , s = /^mtllib /
          , a = /^usemtl /
          , o = /^usemap /
          , l = /\s+/
          , c = new i.Pq0
          , u = new i.Pq0
          , h = new i.Pq0
          , d = new i.Pq0
          , p = new i.Pq0
          , f = new i.Q1f;
        function A() {
            const e = {
                objects: [],
                object: {},
                vertices: [],
                normals: [],
                colors: [],
                uvs: [],
                materials: {},
                materialLibraries: [],
                startObject: function(e, t) {
                    if (this.object && !1 === this.object.fromDeclaration)
                        return this.object.name = e,
                        void (this.object.fromDeclaration = !1 !== t);
                    const n = this.object && "function" == typeof this.object.currentMaterial ? this.object.currentMaterial() : void 0;
                    if (this.object && "function" == typeof this.object._finalize && this.object._finalize(!0),
                    this.object = {
                        name: e || "",
                        fromDeclaration: !1 !== t,
                        geometry: {
                            vertices: [],
                            normals: [],
                            colors: [],
                            uvs: [],
                            hasUVIndices: !1
                        },
                        materials: [],
                        smooth: !0,
                        startMaterial: function(e, t) {
                            const n = this._finalize(!1);
                            n && (n.inherited || n.groupCount <= 0) && this.materials.splice(n.index, 1);
                            const i = {
                                index: this.materials.length,
                                name: e || "",
                                mtllib: Array.isArray(t) && t.length > 0 ? t[t.length - 1] : "",
                                smooth: void 0 !== n ? n.smooth : this.smooth,
                                groupStart: void 0 !== n ? n.groupEnd : 0,
                                groupEnd: -1,
                                groupCount: -1,
                                inherited: !1,
                                clone: function(e) {
                                    const t = {
                                        index: "number" == typeof e ? e : this.index,
                                        name: this.name,
                                        mtllib: this.mtllib,
                                        smooth: this.smooth,
                                        groupStart: 0,
                                        groupEnd: -1,
                                        groupCount: -1,
                                        inherited: !1
                                    };
                                    return t.clone = this.clone.bind(t),
                                    t
                                }
                            };
                            return this.materials.push(i),
                            i
                        },
                        currentMaterial: function() {
                            if (this.materials.length > 0)
                                return this.materials[this.materials.length - 1]
                        },
                        _finalize: function(e) {
                            const t = this.currentMaterial();
                            if (t && -1 === t.groupEnd && (t.groupEnd = this.geometry.vertices.length / 3,
                            t.groupCount = t.groupEnd - t.groupStart,
                            t.inherited = !1),
                            e && this.materials.length > 1)
                                for (let e = this.materials.length - 1; e >= 0; e--)
                                    this.materials[e].groupCount <= 0 && this.materials.splice(e, 1);
                            return e && 0 === this.materials.length && this.materials.push({
                                name: "",
                                smooth: this.smooth
                            }),
                            t
                        }
                    },
                    n && n.name && "function" == typeof n.clone) {
                        const e = n.clone(0);
                        e.inherited = !0,
                        this.object.materials.push(e)
                    }
                    this.objects.push(this.object)
                },
                finalize: function() {
                    this.object && "function" == typeof this.object._finalize && this.object._finalize(!0)
                },
                parseVertexIndex: function(e, t) {
                    const n = parseInt(e, 10);
                    return 3 * (n >= 0 ? n - 1 : n + t / 3)
                },
                parseNormalIndex: function(e, t) {
                    const n = parseInt(e, 10);
                    return 3 * (n >= 0 ? n - 1 : n + t / 3)
                },
                parseUVIndex: function(e, t) {
                    const n = parseInt(e, 10);
                    return 2 * (n >= 0 ? n - 1 : n + t / 2)
                },
                addVertex: function(e, t, n) {
                    const i = this.vertices
                      , r = this.object.geometry.vertices;
                    r.push(i[e + 0], i[e + 1], i[e + 2]),
                    r.push(i[t + 0], i[t + 1], i[t + 2]),
                    r.push(i[n + 0], i[n + 1], i[n + 2])
                },
                addVertexPoint: function(e) {
                    const t = this.vertices;
                    this.object.geometry.vertices.push(t[e + 0], t[e + 1], t[e + 2])
                },
                addVertexLine: function(e) {
                    const t = this.vertices;
                    this.object.geometry.vertices.push(t[e + 0], t[e + 1], t[e + 2])
                },
                addNormal: function(e, t, n) {
                    const i = this.normals
                      , r = this.object.geometry.normals;
                    r.push(i[e + 0], i[e + 1], i[e + 2]),
                    r.push(i[t + 0], i[t + 1], i[t + 2]),
                    r.push(i[n + 0], i[n + 1], i[n + 2])
                },
                addFaceNormal: function(e, t, n) {
                    const i = this.vertices
                      , r = this.object.geometry.normals;
                    c.fromArray(i, e),
                    u.fromArray(i, t),
                    h.fromArray(i, n),
                    p.subVectors(h, u),
                    d.subVectors(c, u),
                    p.cross(d),
                    p.normalize(),
                    r.push(p.x, p.y, p.z),
                    r.push(p.x, p.y, p.z),
                    r.push(p.x, p.y, p.z)
                },
                addColor: function(e, t, n) {
                    const i = this.colors
                      , r = this.object.geometry.colors;
                    void 0 !== i[e] && r.push(i[e + 0], i[e + 1], i[e + 2]),
                    void 0 !== i[t] && r.push(i[t + 0], i[t + 1], i[t + 2]),
                    void 0 !== i[n] && r.push(i[n + 0], i[n + 1], i[n + 2])
                },
                addUV: function(e, t, n) {
                    const i = this.uvs
                      , r = this.object.geometry.uvs;
                    r.push(i[e + 0], i[e + 1]),
                    r.push(i[t + 0], i[t + 1]),
                    r.push(i[n + 0], i[n + 1])
                },
                addDefaultUV: function() {
                    const e = this.object.geometry.uvs;
                    e.push(0, 0),
                    e.push(0, 0),
                    e.push(0, 0)
                },
                addUVLine: function(e) {
                    const t = this.uvs;
                    this.object.geometry.uvs.push(t[e + 0], t[e + 1])
                },
                addFace: function(e, t, n, i, r, s, a, o, l) {
                    const c = this.vertices.length;
                    let u = this.parseVertexIndex(e, c)
                      , h = this.parseVertexIndex(t, c)
                      , d = this.parseVertexIndex(n, c);
                    if (this.addVertex(u, h, d),
                    this.addColor(u, h, d),
                    void 0 !== a && "" !== a) {
                        const e = this.normals.length;
                        u = this.parseNormalIndex(a, e),
                        h = this.parseNormalIndex(o, e),
                        d = this.parseNormalIndex(l, e),
                        this.addNormal(u, h, d)
                    } else
                        this.addFaceNormal(u, h, d);
                    if (void 0 !== i && "" !== i) {
                        const e = this.uvs.length;
                        u = this.parseUVIndex(i, e),
                        h = this.parseUVIndex(r, e),
                        d = this.parseUVIndex(s, e),
                        this.addUV(u, h, d),
                        this.object.geometry.hasUVIndices = !0
                    } else
                        this.addDefaultUV()
                },
                addPointGeometry: function(e) {
                    this.object.geometry.type = "Points";
                    const t = this.vertices.length;
                    for (let n = 0, i = e.length; n < i; n++) {
                        const i = this.parseVertexIndex(e[n], t);
                        this.addVertexPoint(i),
                        this.addColor(i)
                    }
                },
                addLineGeometry: function(e, t) {
                    this.object.geometry.type = "Line";
                    const n = this.vertices.length
                      , i = this.uvs.length;
                    for (let t = 0, i = e.length; t < i; t++)
                        this.addVertexLine(this.parseVertexIndex(e[t], n));
                    for (let e = 0, n = t.length; e < n; e++)
                        this.addUVLine(this.parseUVIndex(t[e], i))
                }
            };
            return e.startObject("", !1),
            e
        }
        class g extends i.aHM {
            constructor(e) {
                super(e),
                this.materials = null
            }
            load(e, t, n, r) {
                const s = this
                  , a = new i.Y9S(this.manager);
                a.setPath(this.path),
                a.setRequestHeader(this.requestHeader),
                a.setWithCredentials(this.withCredentials),
                a.load(e, (function(n) {
                    try {
                        t(s.parse(n))
                    } catch (t) {
                        r ? r(t) : console.error(t),
                        s.manager.itemError(e)
                    }
                }
                ), n, r)
            }
            setMaterials(e) {
                return this.materials = e,
                this
            }
            parse(e) {
                const t = new A;
                -1 !== e.indexOf("\r\n") && (e = e.replace(/\r\n/g, "\n")),
                -1 !== e.indexOf("\\\n") && (e = e.replace(/\\\n/g, ""));
                const n = e.split("\n");
                let c = [];
                for (let e = 0, u = n.length; e < u; e++) {
                    const u = n[e].trimStart();
                    if (0 === u.length)
                        continue;
                    const h = u.charAt(0);
                    if ("#" !== h)
                        if ("v" === h) {
                            const e = u.split(l);
                            switch (e[0]) {
                            case "v":
                                t.vertices.push(parseFloat(e[1]), parseFloat(e[2]), parseFloat(e[3])),
                                e.length >= 7 ? (f.setRGB(parseFloat(e[4]), parseFloat(e[5]), parseFloat(e[6]), i.er$),
                                t.colors.push(f.r, f.g, f.b)) : t.colors.push(void 0, void 0, void 0);
                                break;
                            case "vn":
                                t.normals.push(parseFloat(e[1]), parseFloat(e[2]), parseFloat(e[3]));
                                break;
                            case "vt":
                                t.uvs.push(parseFloat(e[1]), parseFloat(e[2]))
                            }
                        } else if ("f" === h) {
                            const e = u.slice(1).trim().split(l)
                              , n = [];
                            for (let t = 0, i = e.length; t < i; t++) {
                                const i = e[t];
                                if (i.length > 0) {
                                    const e = i.split("/");
                                    n.push(e)
                                }
                            }
                            const i = n[0];
                            for (let e = 1, r = n.length - 1; e < r; e++) {
                                const r = n[e]
                                  , s = n[e + 1];
                                t.addFace(i[0], r[0], s[0], i[1], r[1], s[1], i[2], r[2], s[2])
                            }
                        } else if ("l" === h) {
                            const e = u.substring(1).trim().split(" ");
                            let n = [];
                            const i = [];
                            if (-1 === u.indexOf("/"))
                                n = e;
                            else
                                for (let t = 0, r = e.length; t < r; t++) {
                                    const r = e[t].split("/");
                                    "" !== r[0] && n.push(r[0]),
                                    "" !== r[1] && i.push(r[1])
                                }
                            t.addLineGeometry(n, i)
                        } else if ("p" === h) {
                            const e = u.slice(1).trim().split(" ");
                            t.addPointGeometry(e)
                        } else if (null !== (c = r.exec(u))) {
                            const e = (" " + c[0].slice(1).trim()).slice(1);
                            t.startObject(e)
                        } else if (a.test(u))
                            t.object.startMaterial(u.substring(7).trim(), t.materialLibraries);
                        else if (s.test(u))
                            t.materialLibraries.push(u.substring(7).trim());
                        else if (o.test(u))
                            console.warn('THREE.OBJLoader: Rendering identifier "usemap" not supported. Textures must be defined in MTL files.');
                        else if ("s" === h) {
                            if (c = u.split(" "),
                            c.length > 1) {
                                const e = c[1].trim().toLowerCase();
                                t.object.smooth = "0" !== e && "off" !== e
                            } else
                                t.object.smooth = !0;
                            const e = t.object.currentMaterial();
                            e && (e.smooth = t.object.smooth)
                        } else {
                            if ("\0" === u)
                                continue;
                            console.warn('THREE.OBJLoader: Unexpected line: "' + u + '"')
                        }
                }
                t.finalize();
                const u = new i.YJl;
                u.materialLibraries = [].concat(t.materialLibraries);
                if (!0 === !(1 === t.objects.length && 0 === t.objects[0].geometry.vertices.length))
                    for (let e = 0, n = t.objects.length; e < n; e++) {
                        const n = t.objects[e]
                          , r = n.geometry
                          , s = n.materials
                          , a = "Line" === r.type
                          , o = "Points" === r.type;
                        let l = !1;
                        if (0 === r.vertices.length)
                            continue;
                        const c = new i.LoY;
                        c.setAttribute("position", new i.qtW(r.vertices,3)),
                        r.normals.length > 0 && c.setAttribute("normal", new i.qtW(r.normals,3)),
                        r.colors.length > 0 && (l = !0,
                        c.setAttribute("color", new i.qtW(r.colors,3))),
                        !0 === r.hasUVIndices && c.setAttribute("uv", new i.qtW(r.uvs,2));
                        const h = [];
                        for (let e = 0, n = s.length; e < n; e++) {
                            const n = s[e]
                              , r = n.name + "_" + n.smooth + "_" + l;
                            let c = t.materials[r];
                            if (null !== this.materials)
                                if (c = this.materials.create(n.name),
                                !a || !c || c instanceof i.mrM) {
                                    if (o && c && !(c instanceof i.BH$)) {
                                        const e = new i.BH$({
                                            size: 10,
                                            sizeAttenuation: !1
                                        });
                                        i.imn.prototype.copy.call(e, c),
                                        e.color.copy(c.color),
                                        e.map = c.map,
                                        c = e
                                    }
                                } else {
                                    const e = new i.mrM;
                                    i.imn.prototype.copy.call(e, c),
                                    e.color.copy(c.color),
                                    c = e
                                }
                            void 0 === c && (c = a ? new i.mrM : o ? new i.BH$({
                                size: 1,
                                sizeAttenuation: !1
                            }) : new i.tXL,
                            c.name = n.name,
                            c.flatShading = !n.smooth,
                            c.vertexColors = l,
                            t.materials[r] = c),
                            h.push(c)
                        }
                        let d;
                        if (h.length > 1) {
                            for (let e = 0, t = s.length; e < t; e++) {
                                const t = s[e];
                                c.addGroup(t.groupStart, t.groupCount, e)
                            }
                            d = a ? new i.DXC(c,h) : o ? new i.ONl(c,h) : new i.eaF(c,h)
                        } else
                            d = a ? new i.DXC(c,h[0]) : o ? new i.ONl(c,h[0]) : new i.eaF(c,h[0]);
                        d.name = n.name,
                        u.add(d)
                    }
                else if (t.vertices.length > 0) {
                    const e = new i.BH$({
                        size: 1,
                        sizeAttenuation: !1
                    })
                      , n = new i.LoY;
                    n.setAttribute("position", new i.qtW(t.vertices,3)),
                    t.colors.length > 0 && void 0 !== t.colors[0] && (n.setAttribute("color", new i.qtW(t.colors,3)),
                    e.vertexColors = !0);
                    const r = new i.ONl(n,e);
                    u.add(r)
                }
                return u
            }
        }
    }
    ,
    3206: (e, t, n) => {
        "use strict";
        n.d(t, {
            Y: () => r
        });
        var i = n(5062);
        class r extends i.BRH {
            constructor(e) {
                super(e),
                this.type = i.ix0
            }
            parse(e) {
                const t = function(e, t) {
                    switch (e) {
                    case 1:
                        throw new Error("THREE.RGBELoader: Read Error: " + (t || ""));
                    case 2:
                        throw new Error("THREE.RGBELoader: Write Error: " + (t || ""));
                    case 3:
                        throw new Error("THREE.RGBELoader: Bad File Format: " + (t || ""));
                    default:
                        throw new Error("THREE.RGBELoader: Memory Error: " + (t || ""))
                    }
                }
                  , n = function(e, t, n) {
                    t = t || 1024;
                    let i = e.pos
                      , r = -1
                      , s = 0
                      , a = ""
                      , o = String.fromCharCode.apply(null, new Uint16Array(e.subarray(i, i + 128)));
                    for (; 0 > (r = o.indexOf("\n")) && s < t && i < e.byteLength; )
                        a += o,
                        s += o.length,
                        i += 128,
                        o += String.fromCharCode.apply(null, new Uint16Array(e.subarray(i, i + 128)));
                    return -1 < r && (!1 !== n && (e.pos += s + r + 1),
                    a + o.slice(0, r))
                }
                  , r = function(e, t, n, i) {
                    const r = e[t + 3]
                      , s = Math.pow(2, r - 128) / 255;
                    n[i + 0] = e[t + 0] * s,
                    n[i + 1] = e[t + 1] * s,
                    n[i + 2] = e[t + 2] * s,
                    n[i + 3] = 1
                }
                  , s = function(e, t, n, r) {
                    const s = e[t + 3]
                      , a = Math.pow(2, s - 128) / 255;
                    n[r + 0] = i.GxU.toHalfFloat(Math.min(e[t + 0] * a, 65504)),
                    n[r + 1] = i.GxU.toHalfFloat(Math.min(e[t + 1] * a, 65504)),
                    n[r + 2] = i.GxU.toHalfFloat(Math.min(e[t + 2] * a, 65504)),
                    n[r + 3] = i.GxU.toHalfFloat(1)
                }
                  , a = new Uint8Array(e);
                a.pos = 0;
                const o = function(e) {
                    const i = /^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/
                      , r = /^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/
                      , s = /^\s*FORMAT=(\S+)\s*$/
                      , a = /^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/
                      , o = {
                        valid: 0,
                        string: "",
                        comments: "",
                        programtype: "RGBE",
                        format: "",
                        gamma: 1,
                        exposure: 1,
                        width: 0,
                        height: 0
                    };
                    let l, c;
                    for ((e.pos >= e.byteLength || !(l = n(e))) && t(1, "no header found"),
                    (c = l.match(/^#\?(\S+)/)) || t(3, "bad initial token"),
                    o.valid |= 1,
                    o.programtype = c[1],
                    o.string += l + "\n"; l = n(e),
                    !1 !== l; )
                        if (o.string += l + "\n",
                        "#" !== l.charAt(0)) {
                            if ((c = l.match(i)) && (o.gamma = parseFloat(c[1])),
                            (c = l.match(r)) && (o.exposure = parseFloat(c[1])),
                            (c = l.match(s)) && (o.valid |= 2,
                            o.format = c[1]),
                            (c = l.match(a)) && (o.valid |= 4,
                            o.height = parseInt(c[1], 10),
                            o.width = parseInt(c[2], 10)),
                            2 & o.valid && 4 & o.valid)
                                break
                        } else
                            o.comments += l + "\n";
                    return 2 & o.valid || t(3, "missing format specifier"),
                    4 & o.valid || t(3, "missing image size specifier"),
                    o
                }(a)
                  , l = o.width
                  , c = o.height
                  , u = function(e, n, i) {
                    const r = n;
                    if (r < 8 || r > 32767 || 2 !== e[0] || 2 !== e[1] || 128 & e[2])
                        return new Uint8Array(e);
                    r !== (e[2] << 8 | e[3]) && t(3, "wrong scanline width");
                    const s = new Uint8Array(4 * n * i);
                    s.length || t(4, "unable to allocate buffer space");
                    let a = 0
                      , o = 0;
                    const l = 4 * r
                      , c = new Uint8Array(4)
                      , u = new Uint8Array(l);
                    let h = i;
                    for (; h > 0 && o < e.byteLength; ) {
                        o + 4 > e.byteLength && t(1),
                        c[0] = e[o++],
                        c[1] = e[o++],
                        c[2] = e[o++],
                        c[3] = e[o++],
                        2 == c[0] && 2 == c[1] && (c[2] << 8 | c[3]) == r || t(3, "bad rgbe scanline format");
                        let n, i = 0;
                        for (; i < l && o < e.byteLength; ) {
                            n = e[o++];
                            const r = n > 128;
                            if (r && (n -= 128),
                            (0 === n || i + n > l) && t(3, "bad scanline data"),
                            r) {
                                const t = e[o++];
                                for (let e = 0; e < n; e++)
                                    u[i++] = t
                            } else
                                u.set(e.subarray(o, o + n), i),
                                i += n,
                                o += n
                        }
                        const d = r;
                        for (let e = 0; e < d; e++) {
                            let t = 0;
                            s[a] = u[e + t],
                            t += r,
                            s[a + 1] = u[e + t],
                            t += r,
                            s[a + 2] = u[e + t],
                            t += r,
                            s[a + 3] = u[e + t],
                            a += 4
                        }
                        h--
                    }
                    return s
                }(a.subarray(a.pos), l, c);
                let h, d, p;
                switch (this.type) {
                case i.RQf:
                    p = u.length / 4;
                    const e = new Float32Array(4 * p);
                    for (let t = 0; t < p; t++)
                        r(u, 4 * t, e, 4 * t);
                    h = e,
                    d = i.RQf;
                    break;
                case i.ix0:
                    p = u.length / 4;
                    const t = new Uint16Array(4 * p);
                    for (let e = 0; e < p; e++)
                        s(u, 4 * e, t, 4 * e);
                    h = t,
                    d = i.ix0;
                    break;
                default:
                    throw new Error("THREE.RGBELoader: Unsupported type: " + this.type)
                }
                return {
                    width: l,
                    height: c,
                    data: h,
                    header: o.string,
                    gamma: o.gamma,
                    exposure: o.exposure,
                    type: d
                }
            }
            setDataType(e) {
                return this.type = e,
                this
            }
            load(e, t, n, r) {
                return super.load(e, (function(e, n) {
                    switch (e.type) {
                    case i.RQf:
                    case i.ix0:
                        e.colorSpace = i.Zr2,
                        e.minFilter = i.k6q,
                        e.magFilter = i.k6q,
                        e.generateMipmaps = !1,
                        e.flipY = !0
                    }
                    t && t(e, n)
                }
                ), n, r)
            }
        }
    }
    ,
    739: (e, t, n) => {
        "use strict";
        n.d(t, {
            J: () => r
        });
        var i = n(5062);
        class r extends i.eaF {
            constructor(e, t={}) {
                super(e),
                this.isReflector = !0,
                this.type = "Reflector",
                this.camera = new i.ubm;
                const n = this
                  , s = void 0 !== t.color ? new i.Q1f(t.color) : new i.Q1f(8355711)
                  , a = t.textureWidth || 512
                  , o = t.textureHeight || 512
                  , l = t.clipBias || 0
                  , c = t.shader || r.ReflectorShader
                  , u = void 0 !== t.multisample ? t.multisample : 4
                  , h = new i.Zcv
                  , d = new i.Pq0
                  , p = new i.Pq0
                  , f = new i.Pq0
                  , A = new i.kn4
                  , g = new i.Pq0(0,0,-1)
                  , m = new i.IUQ
                  , v = new i.Pq0
                  , y = new i.Pq0
                  , x = new i.IUQ
                  , _ = new i.kn4
                  , b = this.camera
                  , E = new i.nWS(a,o,{
                    samples: u,
                    type: i.ix0
                })
                  , w = new i.BKk({
                    name: void 0 !== c.name ? c.name : "unspecified",
                    uniforms: i.LlO.clone(c.uniforms),
                    fragmentShader: c.fragmentShader,
                    vertexShader: c.vertexShader
                });
                w.uniforms.tDiffuse.value = E.texture,
                w.uniforms.color.value = s,
                w.uniforms.textureMatrix.value = _,
                this.material = w,
                this.onBeforeRender = function(e, t, i) {
                    if (p.setFromMatrixPosition(n.matrixWorld),
                    f.setFromMatrixPosition(i.matrixWorld),
                    A.extractRotation(n.matrixWorld),
                    d.set(0, 0, 1),
                    d.applyMatrix4(A),
                    v.subVectors(p, f),
                    v.dot(d) > 0)
                        return;
                    v.reflect(d).negate(),
                    v.add(p),
                    A.extractRotation(i.matrixWorld),
                    g.set(0, 0, -1),
                    g.applyMatrix4(A),
                    g.add(f),
                    y.subVectors(p, g),
                    y.reflect(d).negate(),
                    y.add(p),
                    b.position.copy(v),
                    b.up.set(0, 1, 0),
                    b.up.applyMatrix4(A),
                    b.up.reflect(d),
                    b.lookAt(y),
                    b.far = i.far,
                    b.updateMatrixWorld(),
                    b.projectionMatrix.copy(i.projectionMatrix),
                    _.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1),
                    _.multiply(b.projectionMatrix),
                    _.multiply(b.matrixWorldInverse),
                    _.multiply(n.matrixWorld),
                    h.setFromNormalAndCoplanarPoint(d, p),
                    h.applyMatrix4(b.matrixWorldInverse),
                    m.set(h.normal.x, h.normal.y, h.normal.z, h.constant);
                    const r = b.projectionMatrix;
                    x.x = (Math.sign(m.x) + r.elements[8]) / r.elements[0],
                    x.y = (Math.sign(m.y) + r.elements[9]) / r.elements[5],
                    x.z = -1,
                    x.w = (1 + r.elements[10]) / r.elements[14],
                    m.multiplyScalar(2 / m.dot(x)),
                    r.elements[2] = m.x,
                    r.elements[6] = m.y,
                    r.elements[10] = m.z + 1 - l,
                    r.elements[14] = m.w,
                    n.visible = !1;
                    const s = e.getRenderTarget()
                      , a = e.xr.enabled
                      , o = e.shadowMap.autoUpdate;
                    e.xr.enabled = !1,
                    e.shadowMap.autoUpdate = !1,
                    e.setRenderTarget(E),
                    e.state.buffers.depth.setMask(!0),
                    !1 === e.autoClear && e.clear(),
                    e.render(t, b),
                    e.xr.enabled = a,
                    e.shadowMap.autoUpdate = o,
                    e.setRenderTarget(s);
                    const c = i.viewport;
                    void 0 !== c && e.state.viewport(c),
                    n.visible = !0
                }
                ,
                this.getRenderTarget = function() {
                    return E
                }
                ,
                this.dispose = function() {
                    E.dispose(),
                    n.material.dispose()
                }
            }
        }
        r.ReflectorShader = {
            name: "ReflectorShader",
            uniforms: {
                color: {
                    value: null
                },
                tDiffuse: {
                    value: null
                },
                textureMatrix: {
                    value: null
                }
            },
            vertexShader: "\n\t\tuniform mat4 textureMatrix;\n\t\tvarying vec4 vUv;\n\n\t\t#include <common>\n\t\t#include <logdepthbuf_pars_vertex>\n\n\t\tvoid main() {\n\n\t\t\tvUv = textureMatrix * vec4( position, 1.0 );\n\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t\t#include <logdepthbuf_vertex>\n\n\t\t}",
            fragmentShader: "\n\t\tuniform vec3 color;\n\t\tuniform sampler2D tDiffuse;\n\t\tvarying vec4 vUv;\n\n\t\t#include <logdepthbuf_pars_fragment>\n\n\t\tfloat blendOverlay( float base, float blend ) {\n\n\t\t\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );\n\n\t\t}\n\n\t\tvec3 blendOverlay( vec3 base, vec3 blend ) {\n\n\t\t\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\t#include <logdepthbuf_fragment>\n\n\t\t\tvec4 base = texture2DProj( tDiffuse, vUv );\n\t\t\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );\n\n\t\t\t#include <tonemapping_fragment>\n\t\t\t#include <colorspace_fragment>\n\n\t\t}"
        }
    }
    ,
    2445: (e, t, n) => {
        "use strict";
        n.d(t, {
            N: () => r
        });
        var i = n(5062);
        class r extends i.eaF {
            constructor(e, t={}) {
                super(e),
                this.isRefractor = !0,
                this.type = "Refractor",
                this.camera = new i.ubm;
                const n = this
                  , s = void 0 !== t.color ? new i.Q1f(t.color) : new i.Q1f(8355711)
                  , a = t.textureWidth || 512
                  , o = t.textureHeight || 512
                  , l = t.clipBias || 0
                  , c = t.shader || r.RefractorShader
                  , u = void 0 !== t.multisample ? t.multisample : 4
                  , h = this.camera;
                h.matrixAutoUpdate = !1,
                h.userData.refractor = !0;
                const d = new i.Zcv
                  , p = new i.kn4
                  , f = new i.nWS(a,o,{
                    samples: u,
                    type: i.ix0
                });
                this.material = new i.BKk({
                    name: void 0 !== c.name ? c.name : "unspecified",
                    uniforms: i.LlO.clone(c.uniforms),
                    vertexShader: c.vertexShader,
                    fragmentShader: c.fragmentShader,
                    transparent: !0
                }),
                this.material.uniforms.color.value = s,
                this.material.uniforms.tDiffuse.value = f.texture,
                this.material.uniforms.textureMatrix.value = p;
                const A = function() {
                    const e = new i.Pq0
                      , t = new i.Pq0
                      , r = new i.kn4
                      , s = new i.Pq0
                      , a = new i.Pq0;
                    return function(i) {
                        return e.setFromMatrixPosition(n.matrixWorld),
                        t.setFromMatrixPosition(i.matrixWorld),
                        s.subVectors(e, t),
                        r.extractRotation(n.matrixWorld),
                        a.set(0, 0, 1),
                        a.applyMatrix4(r),
                        s.dot(a) < 0
                    }
                }()
                  , g = function() {
                    const e = new i.Pq0
                      , t = new i.Pq0
                      , r = new i.PTz
                      , s = new i.Pq0;
                    return function() {
                        n.matrixWorld.decompose(t, r, s),
                        e.set(0, 0, 1).applyQuaternion(r).normalize(),
                        e.negate(),
                        d.setFromNormalAndCoplanarPoint(e, t)
                    }
                }()
                  , m = function() {
                    const e = new i.Zcv
                      , t = new i.IUQ
                      , n = new i.IUQ;
                    return function(i) {
                        h.matrixWorld.copy(i.matrixWorld),
                        h.matrixWorldInverse.copy(h.matrixWorld).invert(),
                        h.projectionMatrix.copy(i.projectionMatrix),
                        h.far = i.far,
                        e.copy(d),
                        e.applyMatrix4(h.matrixWorldInverse),
                        t.set(e.normal.x, e.normal.y, e.normal.z, e.constant);
                        const r = h.projectionMatrix;
                        n.x = (Math.sign(t.x) + r.elements[8]) / r.elements[0],
                        n.y = (Math.sign(t.y) + r.elements[9]) / r.elements[5],
                        n.z = -1,
                        n.w = (1 + r.elements[10]) / r.elements[14],
                        t.multiplyScalar(2 / t.dot(n)),
                        r.elements[2] = t.x,
                        r.elements[6] = t.y,
                        r.elements[10] = t.z + 1 - l,
                        r.elements[14] = t.w
                    }
                }();
                this.onBeforeRender = function(e, t, i) {
                    !0 !== i.userData.refractor && !0 != !A(i) && (g(),
                    function(e) {
                        p.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1),
                        p.multiply(e.projectionMatrix),
                        p.multiply(e.matrixWorldInverse),
                        p.multiply(n.matrixWorld)
                    }(i),
                    m(i),
                    function(e, t, i) {
                        n.visible = !1;
                        const r = e.getRenderTarget()
                          , s = e.xr.enabled
                          , a = e.shadowMap.autoUpdate;
                        e.xr.enabled = !1,
                        e.shadowMap.autoUpdate = !1,
                        e.setRenderTarget(f),
                        !1 === e.autoClear && e.clear(),
                        e.render(t, h),
                        e.xr.enabled = s,
                        e.shadowMap.autoUpdate = a,
                        e.setRenderTarget(r);
                        const o = i.viewport;
                        void 0 !== o && e.state.viewport(o),
                        n.visible = !0
                    }(e, t, i))
                }
                ,
                this.getRenderTarget = function() {
                    return f
                }
                ,
                this.dispose = function() {
                    f.dispose(),
                    n.material.dispose()
                }
            }
        }
        r.RefractorShader = {
            name: "RefractorShader",
            uniforms: {
                color: {
                    value: null
                },
                tDiffuse: {
                    value: null
                },
                textureMatrix: {
                    value: null
                }
            },
            vertexShader: "\n\n\t\tuniform mat4 textureMatrix;\n\n\t\tvarying vec4 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = textureMatrix * vec4( position, 1.0 );\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",
            fragmentShader: "\n\n\t\tuniform vec3 color;\n\t\tuniform sampler2D tDiffuse;\n\n\t\tvarying vec4 vUv;\n\n\t\tfloat blendOverlay( float base, float blend ) {\n\n\t\t\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );\n\n\t\t}\n\n\t\tvec3 blendOverlay( vec3 base, vec3 blend ) {\n\n\t\t\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvec4 base = texture2DProj( tDiffuse, vUv );\n\t\t\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );\n\n\t\t\t#include <tonemapping_fragment>\n\t\t\t#include <colorspace_fragment>\n\n\t\t}"
        }
    }
    ,
    1358: (e, t, n) => {
        "use strict";
        function i(e) {
            const t = new Map
              , n = new Map
              , i = e.clone();
            return r(e, i, (function(e, i) {
                t.set(i, e),
                n.set(e, i)
            }
            )),
            i.traverse((function(e) {
                if (!e.isSkinnedMesh)
                    return;
                const i = e
                  , r = t.get(e)
                  , s = r.skeleton.bones;
                i.skeleton = r.skeleton.clone(),
                i.bindMatrix.copy(r.bindMatrix),
                i.skeleton.bones = s.map((function(e) {
                    return n.get(e)
                }
                )),
                i.bind(i.skeleton, i.bindMatrix)
            }
            )),
            i
        }
        function r(e, t, n) {
            n(e, t);
            for (let i = 0; i < e.children.length; i++)
                r(e.children[i], t.children[i], n)
        }
        n.d(t, {
            o8: () => i
        })
    }
    ,
    20: (e, t, n) => {
        "use strict";
        n.d(t, {
            qE: () => i
        });
        Math.PI,
        Math.PI;
        function i(e, t, n) {
            return Math.max(t, Math.min(n, e))
        }
    }
}]);
